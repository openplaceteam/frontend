var Gx = Object.defineProperty;
var $x = Object.getPrototypeOf;
var Hx = Reflect.get;
var Cv = (_) => {
  throw TypeError(_);
};
var Wx = (_, o, f) =>
  o in _
    ? Gx(_, o, { enumerable: !0, configurable: !0, writable: !0, value: f })
    : (_[o] = f);
var Ir = (_, o, f) => Wx(_, typeof o != "symbol" ? o + "" : o, f),
  lm = (_, o, f) => o.has(_) || Cv("Cannot " + f);
var He = (_, o, f) => (
    lm(_, o, "read from private field"), f ? f.call(_) : o.get(_)
  ),
  Er = (_, o, f) =>
    o.has(_)
      ? Cv("Cannot add the same private member more than once")
      : o instanceof WeakSet
      ? o.add(_)
      : o.set(_, f),
  $i = (_, o, f, x) => (
    lm(_, o, "write to private field"), x ? x.call(_, f) : o.set(_, f), f
  ),
  Or = (_, o, f) => (lm(_, o, "access private method"), f);
var Pv = (_, o, f) => Hx($x(_), f, o);
import "../chunks/ClL9a_Zs.js";
import { o as Fn, s as si } from "../chunks/Ba2x20r8.js";
import {
  ac as Xx,
  bm as Yx,
  bB as Kx,
  bo as Jx,
  bC as Qx,
  aY as eb,
  bD as tb,
  l as Je,
  bE as Iv,
  aa as rb,
  g as y,
  o as te,
  a_ as $u,
  m as Si,
  k as Bn,
  p as Dr,
  f as me,
  d as M,
  r as P,
  s as q,
  u as ut,
  n as yn,
  t as Ne,
  v as Zn,
  b as G,
  c as Rr,
  D as $r,
  z as Lr,
  bz as eh,
  C as s_,
  F as yl,
  w as Jt,
  a as _t,
  q as ji,
  aF as nb,
  aE as Mv,
  aG as ib,
  M as g0,
  bF as _o,
  x as sa,
  bG as v0,
  by as l_,
  e as ab,
  $ as ob,
} from "../chunks/iK5FT0Sa.js";
import { s as le, c as y0 } from "../chunks/BHnQYZx5.js";
import { i as Me } from "../chunks/6Mc7KQD2.js";
import { h as sb } from "../chunks/DDOVU0Bm.js";
import {
  r as Oa,
  e as yi,
  a as Br,
  g as x0,
  d as dr,
  s as gr,
  f as Oc,
  h as Qu,
  c as hs,
  i as Av,
} from "../chunks/Cw1VVyw7.js";
import { a as _l, t as oa } from "../chunks/D4MEaonn.js";
import { g as Ep, b as lb } from "../chunks/E8vEVpET.js";
import { p as di } from "../chunks/D_G6cexA.js";
import { g as da, P as cb, b as ub } from "../chunks/B3m8Ax5i.js";
import {
  S as pa,
  a as Jr,
  t as xr,
  u as kt,
  p as ko,
  q as hb,
  v as db,
  w as pb,
  y as fb,
  x as mb,
  e as _b,
  z as gb,
  c as vb,
  A as yb,
  C as kv,
  P as cm,
  B as xb,
} from "../chunks/BcevhAVP.js";
import {
  A as Oi,
  c as Tm,
  g as um,
  p as bb,
  a as b0,
} from "../chunks/BJyid7P1.js";
import { f as gl, h as ba, R as w0 } from "../chunks/D1YbojwT.js";
import { p as Et, r as lr, s as Bs, u as Ev } from "../chunks/ClBgBzqC.js";
import { h as Gp } from "../chunks/D_F-xNOc.js";
import { b as Eo } from "../chunks/DnZ5W6UV.js";
import { L as T0 } from "../chunks/6G5adFH1.js";
import { g as ze, l as wb } from "../chunks/DQcFTXWv.js";
import { c as Gh } from "../chunks/BRvsRNeX.js";
import { d as Tb, L as $p, p as c_ } from "../chunks/CbE2L3A6.js";
import {
  c as Sm,
  b as u_,
  D as S0,
  W as Sb,
  s as Cb,
  d as Pb,
  l as C0,
  a as Ib,
  p as Mb,
  r as Ab,
  t as kb,
  e as Eb,
  R as zb,
  f as zv,
} from "../chunks/DKIm2qqY.js";
import { e as oi, i as Hp } from "../chunks/DcUGKLlr.js";
import { c as h_, b as $h, a as Lb } from "../chunks/yt7z1efG.js";
import { P as mo, t as P0 } from "../chunks/DUpX1e05.js";
import {
  l as Db,
  p as d_,
  m as I0,
  v as Rb,
  s as Fb,
} from "../chunks/DsSnzxUe.js";
import { g as Ni, a as Wp, c as M0, b as Bb } from "../chunks/UjG3PxiF.js";
import { k as th } from "../chunks/COcZhybn.js";
import { A as A0, c as ds } from "../chunks/DpS0PshJ.js";
import {
  A as k0,
  d as E0,
  D as z0,
  a as Xp,
  r as Ob,
  I as Cm,
  e as Nb,
  c as jb,
  P as L0,
  b as Vb,
} from "../chunks/BptsAMEP.js";
import { f as Ha, s as bp } from "../chunks/DG5z7AC6.js";
import { C as p_, c as qb } from "../chunks/2xVnDudW.js";
import "../chunks/CqEpAPi0.js";
import { i as D0 } from "../chunks/AXHr-fF2.js";
import { L as f_ } from "../chunks/qHbcPXTE.js";
import { c as Ti } from "../chunks/CZQHObn-.js";
import { L as Ub } from "../chunks/CgP_-eBe.js";
import { _ as Zb } from "../chunks/CD6G4wKE.js";
import { c as R0 } from "../chunks/y2OiVH5z.js";
import { s as F0 } from "../chunks/BQsyJ3Sw.js";
import { T as rh, G as zp, t as B0 } from "../chunks/DnpWy_rL.js";
import { C as Gb } from "../chunks/D-ki6Nha.js";
import { R as $b } from "../chunks/DIrPyiFz.js";
import { W as Hb } from "../chunks/CnpP4qa_.js";
import { r as Wb } from "../chunks/C4amkYCn.js";
(function () {
  try {
    var _ =
      typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : typeof globalThis < "u"
        ? globalThis
        : typeof self < "u"
        ? self
        : {};
    _.SENTRY_RELEASE = { id: "0fdca126ca32380ac4e95a0011d2b66881dfb9e6" };
  } catch {}
})();
try {
  (function () {
    var _ =
        typeof window < "u"
          ? window
          : typeof global < "u"
          ? global
          : typeof globalThis < "u"
          ? globalThis
          : typeof self < "u"
          ? self
          : {},
      o = new _.Error().stack;
    o &&
      ((_._sentryDebugIds = _._sentryDebugIds || {}),
      (_._sentryDebugIds[o] = "a47e4a76-2504-4a14-8b88-37ae8a679de3"),
      (_._sentryDebugIdIdentifier =
        "sentry-dbid-a47e4a76-2504-4a14-8b88-37ae8a679de3"));
  })();
} catch {}
const Xb = [];
function Yb(_, o = !1, f = !1) {
  return wp(_, new Map(), "", Xb, null, f);
}
function wp(_, o, f, x, A = null, L = !1) {
  if (typeof _ == "object" && _ !== null) {
    var T = o.get(_);
    if (T !== void 0) return T;
    if (_ instanceof Map) return new Map(_);
    if (_ instanceof Set) return new Set(_);
    if (Xx(_)) {
      var s = Array(_.length);
      o.set(_, s), A !== null && o.set(A, s);
      for (var B = 0; B < _.length; B += 1) {
        var N = _[B];
        B in _ && (s[B] = wp(N, o, f, x, null, L));
      }
      return s;
    }
    if (Yx(_) === Kx) {
      (s = {}), o.set(_, s), A !== null && o.set(A, s);
      for (var K in _) s[K] = wp(_[K], o, f, x, null, L);
      return s;
    }
    if (_ instanceof Date) return structuredClone(_);
    if (typeof _.toJSON == "function" && !L) return wp(_.toJSON(), o, f, x, _);
  }
  if (_ instanceof EventTarget) return _;
  try {
    return structuredClone(_);
  } catch {
    return _;
  }
}
function Kb() {
  return Symbol(Jx);
}
function Yp(_, o) {
  Qx(window, ["resize"], () => eb(() => o(window[_])));
}
const Jb = tb;
var Io, Mo, ss, Bp, fo, Wu, Tp;
const D_ = class D_ extends Map {
  constructor(f) {
    super();
    Er(this, fo);
    Er(this, Io, new Map());
    Er(this, Mo, Je(0));
    Er(this, ss, Je(0));
    Er(this, Bp, Iv || -1);
    if (f) {
      for (var [x, A] of f) super.set(x, A);
      He(this, ss).v = super.size;
    }
  }
  has(f) {
    var x = He(this, Io),
      A = x.get(f);
    if (A === void 0) {
      var L = super.get(f);
      if (L !== void 0) (A = Or(this, fo, Wu).call(this, 0)), x.set(f, A);
      else return y(He(this, Mo)), !1;
    }
    return y(A), !0;
  }
  forEach(f, x) {
    Or(this, fo, Tp).call(this), super.forEach(f, x);
  }
  get(f) {
    var x = He(this, Io),
      A = x.get(f);
    if (A === void 0) {
      var L = super.get(f);
      if (L !== void 0) (A = Or(this, fo, Wu).call(this, 0)), x.set(f, A);
      else {
        y(He(this, Mo));
        return;
      }
    }
    return y(A), super.get(f);
  }
  set(f, x) {
    var ee;
    var A = He(this, Io),
      L = A.get(f),
      T = super.get(f),
      s = super.set(f, x),
      B = He(this, Mo);
    if (L === void 0)
      (L = Or(this, fo, Wu).call(this, 0)),
        A.set(f, L),
        te(He(this, ss), super.size),
        $u(B);
    else if (T !== x) {
      $u(L);
      var N = B.reactions === null ? null : new Set(B.reactions),
        K =
          N === null ||
          !((ee = L.reactions) != null && ee.every((re) => N.has(re)));
      K && $u(B);
    }
    return s;
  }
  delete(f) {
    var x = He(this, Io),
      A = x.get(f),
      L = super.delete(f);
    return (
      A !== void 0 &&
        (x.delete(f),
        te(He(this, ss), super.size),
        te(A, -1),
        $u(He(this, Mo))),
      L
    );
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var f = He(this, Io);
      te(He(this, ss), 0);
      for (var x of f.values()) te(x, -1);
      $u(He(this, Mo)), f.clear();
    }
  }
  keys() {
    return y(He(this, Mo)), super.keys();
  }
  values() {
    return Or(this, fo, Tp).call(this), super.values();
  }
  entries() {
    return Or(this, fo, Tp).call(this), super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return y(He(this, ss)), super.size;
  }
};
(Io = new WeakMap()),
  (Mo = new WeakMap()),
  (ss = new WeakMap()),
  (Bp = new WeakMap()),
  (fo = new WeakSet()),
  (Wu = function (f) {
    return Iv === He(this, Bp) ? Je(f) : rb(f);
  }),
  (Tp = function () {
    y(He(this, Mo));
    var f = He(this, Io);
    if (He(this, ss).v !== f.size) {
      for (var x of Pv(D_.prototype, this, "keys").call(this))
        if (!f.has(x)) {
          var A = Or(this, fo, Wu).call(this, 0);
          f.set(x, A);
        }
    }
    for ([, A] of He(this, Io)) y(A);
  });
let Pm = D_;
const Qb = () => "Log in",
  e2 = () => "Entrar",
  t2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Qb() : e2()),
  r2 = () => "Store",
  n2 = () => "Loja",
  O0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? r2() : n2()),
  i2 = () => "Alliance",
  a2 = () => "Alian√ßa",
  Kp = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? i2() : a2()),
  o2 = () => "Leaderboard",
  s2 = () => "Ranking",
  m_ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? o2() : s2()),
  l2 = () => "Unlock",
  c2 = () => "Destravar",
  u2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? l2() : c2()),
  h2 = () => "Lock",
  d2 = () => "Travar",
  p2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? h2() : d2()),
  f2 = () => "Info",
  m2 = () => "Informa√ß√µes",
  _2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? f2() : m2()),
  g2 = () => "Zoom in",
  v2 = () => "Aumentar zoom",
  y2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? g2() : v2()),
  x2 = () => "Zoom out",
  b2 = () => "Diminuir zoom",
  w2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? x2() : b2()),
  T2 = () => "Offline",
  S2 = () => "Offline",
  C2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? T2() : S2()),
  P2 = () => "Zoom in to see the pixels",
  I2 = () => "Amplie para ver os pixels",
  M2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? P2() : I2()),
  A2 = () => "Phone verification required",
  k2 = () => "Verifica√ß√£o de telefone necess√°ria",
  Lv = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? A2() : k2()),
  E2 = () => "My location",
  z2 = () => "Minha localiza√ß√£o",
  L2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? E2() : z2()),
  D2 = () => "You don't have charges to paint. Wait to recharge.",
  R2 = () => "Voc√™ n√£o possui tinta para pintar. Aguarde para carrega-las.",
  F2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? D2() : R2()),
  B2 = () => "Map powered by:",
  O2 = () => "Mapa fornecido por:",
  N2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? B2() : O2()),
  j2 = () => "OpenMapTiles Data from",
  V2 = () => "OpenMapTiles com dados do",
  q2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? j2() : V2()),
  U2 = () => "Overview",
  Z2 = () => "Vis√£o Geral",
  G2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? U2() : Z2()),
  $2 = () => "How to paint faster",
  H2 = () => "Como pintar mais r√°pido",
  W2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $2() : H2()),
  X2 = () => "When painting, click on the button",
  Y2 = () => "Quando pintar clique no bot√£o",
  K2 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? X2() : Y2()),
  J2 = () =>
    "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  Q2 = () =>
    "no canto superior direito da tela. Isso bloquear√° a tela, mas tamb√©m permitir√° pintar movendo o dedo sobre o mapa.",
  ew = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? J2() : Q2()),
  tw = () => "Hold",
  rw = () => "Segure",
  nw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? tw() : rw()),
  iw = () => "SPACE",
  aw = () => "Espa√ßo",
  ow = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? iw() : aw()),
  sw = () => "and move your cursor over the map.",
  lw = () => "e mova seu cursor sobre o mapa.",
  cw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? sw() : lw()),
  uw = () => "Recharge paint charges",
  hw = () => "Recarga de tinta",
  dw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? uw() : hw()),
  pw = () => "Items",
  fw = () => "Itens",
  mw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? pw() : fw()),
  _w = () => "Get more charges",
  gw = () => "Recarregue tinta para pintar",
  vw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? _w() : gw()),
  yw = (_) => `+${_.amount} Max. Charges`,
  xw = (_) => `+${_.amount} Tinta m√°xima`,
  bw = (_, o = {}) => ((o.locale ?? ze()) === "en" ? yw(_) : xw(_)),
  ww = () => "Increase your maximum paint charges capacity",
  Tw = () => "Aumente sua capacidade m√°xima de tinta",
  Sw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? ww() : Tw()),
  Cw = () => "Profile picture",
  Pw = () => "Imagem de perfil",
  Iw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Cw() : Pw()),
  Mw = () => "Add a new 16x16 profile picture",
  Aw = () => "Adicionar uma nova imagem de perfil 16x16",
  kw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Mw() : Aw()),
  Ew = () => "Not enough droplets",
  zw = () => "Droplets insuficientes",
  Jp = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Ew() : zw()),
  Lw = () => "Show profile",
  Dw = () => "Exibir perfil",
  Rw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Lw() : Dw()),
  Fw = () => "Menu",
  Bw = () => "Menu",
  Ow = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Fw() : Bw()),
  Nw = (_) => `Could not install the app: ${_.error}`,
  jw = (_) => `N√£o pode instalar o app: ${_.error}`,
  Vw = (_, o = {}) => ((o.locale ?? ze()) === "en" ? Nw(_) : jw(_)),
  qw = () => "Install App",
  Uw = () => "Instalar App",
  Zw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? qw() : Uw()),
  Gw = () => "Livestreams",
  $w = () => "Livestreams",
  Hw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Gw() : $w()),
  Ww = () => "Hide UI",
  Xw = () => "Esconder UI",
  Yw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Ww() : Xw()),
  Kw = () => "Change picture:",
  Jw = () => "Change picture:",
  Qw = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Kw() : Jw()),
  e5 = () => "Show last painted pixel on alliance",
  t5 = () => "Mostrar √∫ltimo pixel pintado na alian√ßa",
  r5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? e5() : t5()),
  n5 = () => "Delete Account",
  i5 = () => "Deletar Conta",
  Im = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? n5() : i5()),
  a5 = () => "Are you absolutely sure?",
  o5 = () => "Voc√™ tem certeza absoluta?",
  s5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? a5() : o5()),
  l5 = () =>
    "This will permanently delete your account and all associated data. This action cannot be undone.",
  c5 = () =>
    "Isso excluir√° permanentemente sua conta e todos os dados associados. Esta a√ß√£o n√£o pode ser desfeita.",
  u5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? l5() : c5()),
  h5 = () => "Profile",
  d5 = () => "Perfil",
  p5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? h5() : d5()),
  f5 = () =>
    "Display your country‚Äôs flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  m5 = () =>
    "Exiba a bandeira do seu pa√≠s ao lado do seu nome de usu√°rio. Al√©m disso, ao pintar em regi√µes onde voc√™ possui a bandeira correspondente, voc√™ recupera 10% das tintas gastas.",
  _5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? f5() : m5()),
  g5 = () => "Does not need to be equipped to provide the bonus",
  v5 = () => "N√£o precisa estar equipada para obter o b√¥nus",
  y5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? g5() : v5()),
  x5 = () => "Equipped",
  b5 = () => "Equipado",
  w5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? x5() : b5()),
  T5 = () => "Equip",
  S5 = () => "Equipar",
  C5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? T5() : S5()),
  P5 = () => "Country",
  I5 = () => "Pa√≠s",
  __ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? P5() : I5()),
  M5 = () => "No country found.",
  A5 = () => "Pa√≠s n√£o encontrado.",
  k5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? M5() : A5()),
  E5 = () => "Welcome to",
  z5 = () => "Bem vindo ao",
  L5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? E5() : z5()),
  D5 = () => "Rules",
  R5 = () => "Regras",
  F5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? D5() : R5()),
  B5 = () => "Important",
  O5 = () => "Importante",
  N5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? B5() : O5()),
  j5 = () =>
    "üö´ No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  V5 = () =>
    "üö´ Conte√∫do inapropriado n√£o permitido (+18, discurso de √≥dio, links inapropriados, conte√∫do altamente sugestivo, ...)",
  q5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? j5() : V5()),
  U5 = () =>
    "üòà Do not paint over other artworks using random colors or patterns just to mess things up",
  Z5 = () =>
    "üòà N√£o desenhe por cima de outras artes usando cores ou padr√µes aleat√≥rios s√≥ para bagun√ßar",
  G5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? U5() : Z5()),
  $5 = () => "üßë‚Äçü§ù‚Äçüßë Do not paint with more than one account",
  H5 = () => "üßë‚Äçü§ù‚Äçüßë N√£o desenhe com mais de uma conta",
  W5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $5() : H5()),
  X5 = () => "ü§ñ Use of bots is not allowed",
  Y5 = () => "ü§ñ Usar bots n√£o √© permitido",
  K5 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? X5() : Y5()),
  J5 = () => "üôÖ Disclosing other's personal information is not allowed",
  Q5 = () => "üôÖ Divulgar informa√ß√µes pessoais dos outros n√£o √© permitido",
  e3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? J5() : Q5()),
  t3 = () =>
    "‚úÖ Painting over other artworks to complement them or create a new drawing is allowed",
  r3 = () =>
    "‚úÖ Desenhar sobre outras artes para complementar ou criar novas artes √© permitido",
  n3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? t3() : r3()),
  i3 = () =>
    "‚úÖ Griefing political party flags or portraits of politicians is allowed",
  a3 = () =>
    "‚úÖ Desenhar sobre bandeiras de partidos e retratos de pol√≠ticos √© permitido",
  o3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? i3() : a3()),
  s3 = () =>
    "Violations of these rules may lead to suspension of your account or removal of drawings.",
  l3 = () =>
    "A viola√ß√£o destas regras pode levar √† suspens√£o da conta ou √† remo√ß√£o de desenhos.",
  c3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? s3() : l3()),
  u3 = () => "Understood",
  h3 = () => "Entendido",
  d3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? u3() : h3()),
  p3 = () => "Toggle art opacity",
  f3 = () => "Alterar opacidade",
  N0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? p3() : f3()),
  m3 = () => "Paint",
  _3 = () => "Pintar",
  j0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? m3() : _3()),
  g3 = () => "Select a color",
  v3 = () => "Selecione uma color",
  y3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? g3() : v3()),
  x3 = () => "Select a pixel to erase",
  b3 = () => "Selecione um pixel para apagar",
  w3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? x3() : b3()),
  T3 = () => "Pick a color from the map",
  S3 = () => "Escolha uma cor do mapa",
  C3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? T3() : S3()),
  P3 = () => "Click",
  I3 = () => "Clique",
  M3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? P3() : I3()),
  A3 = () => "SPACE",
  k3 = () => "ESPA√áO",
  E3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? A3() : k3()),
  z3 = () => "or hold",
  L3 = () => "ou segure",
  D3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? z3() : L3()),
  R3 = () => "to paint,",
  F3 = () => "para pintar",
  B3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? R3() : F3()),
  O3 = () => "You can paint more than 1 pixel",
  N3 = () => "Voc√™ pode pintar mais de 1 pixel",
  j3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? O3() : N3()),
  V3 = () => "Paint pixel",
  q3 = () => "Pintar pixel",
  U3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? V3() : q3()),
  Z3 = () => "Color Picker",
  G3 = () => "Conta Gotas",
  $3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Z3() : G3()),
  H3 = () => "+2 max. charge/level",
  W3 = () => "+2 tinta m√°xima/level",
  X3 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? H3() : W3()),
  Y3 = () => "Name",
  K3 = () => "Nome",
  Mm = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Y3() : K3()),
  J3 = () => "Discord Username",
  Q3 = () => "Usu√°rio do Discord",
  eT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? J3() : Q3()),
  tT = () => "Max. Charges",
  rT = () => "Tinta m√°xima",
  Dv = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? tT() : rT()),
  nT = () => "Paint Charges",
  iT = () => "Tintas",
  aT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? nT() : iT()),
  oT = (_) => `+${_.amount} Paint Charges`,
  sT = (_) => `+${_.amount} Tintas`,
  lT = (_, o = {}) => ((o.locale ?? ze()) === "en" ? oT(_) : sT(_)),
  cT = () => "Leave alliance",
  uT = () => "Sair da alian√ßa",
  hT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? cT() : uT()),
  dT = () => "Headquarters",
  pT = () => "Quartel General",
  fT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? dT() : pT()),
  mT = () => "Not set",
  _T = () => "N√£o configurado",
  gT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? mT() : _T()),
  vT = () => "You are not in an alliance",
  yT = () => "Voc√™ n√£o est√° em uma alian√ßa",
  xT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? vT() : yT()),
  bT = () => "Get invited to an alliance",
  wT = () => "Seja convidado para uma alian√ßa",
  TT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? bT() : wT()),
  ST = () => "OR",
  CT = () => "OU",
  PT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? ST() : CT()),
  IT = () => "Create an alliance",
  MT = () => "Crie uma alian√ßa",
  AT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? IT() : MT()),
  kT = () => "Invite link",
  ET = () => "Link de convite",
  zT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? kT() : ET()),
  LT = () =>
    "Send the link below to everybody you want to invite to the alliance",
  DT = () =>
    "Envie o link abaixo para quem voc√™ deseja convidar para a alian√ßa",
  RT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? LT() : DT()),
  FT = () => "Copied",
  BT = () => "Copiado",
  g_ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? FT() : BT()),
  OT = () => "No description",
  NT = () => "Sem descri√ß√£o",
  V0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? OT() : NT()),
  jT = () => "Invite",
  VT = () => "Convite",
  qT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? jT() : VT()),
  UT = () => "No pixels painted",
  ZT = () => "Nenhum pixel pintado",
  v_ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? UT() : ZT()),
  GT = () => "Today",
  $T = () => "Hoje",
  Qp = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? GT() : $T()),
  HT = () => "Week",
  WT = () => "Semana",
  XT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? HT() : WT()),
  YT = () => "Month",
  KT = () => "M√™s",
  JT = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? YT() : KT()),
  QT = () => "All time",
  eS = () => "Geral",
  tS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? QT() : eS()),
  rS = () => "this week",
  nS = () => "nesta semana",
  y_ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? rS() : nS()),
  iS = () => "this month",
  aS = () => "neste m√™s",
  x_ = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? iS() : aS()),
  oS = () => "Create alliance",
  sS = () => "Criar alian√ßa",
  lS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? oS() : sS()),
  cS = () => "Alliance Name",
  uS = () => "Nome da alian√ßa",
  hS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? cS() : uS()),
  dS = () => "Create",
  pS = () => "Criar",
  fS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? dS() : pS()),
  mS = () => "Give admin",
  _S = () => "Tornar admin",
  gS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? mS() : _S()),
  vS = () => "Ban from alliance",
  yS = () => "Banir da alian√ßa",
  q0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? vS() : yS()),
  xS = () => "No action",
  bS = () => "Sem op√ß√£o",
  wS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? xS() : bS()),
  TS = () => "Unban",
  SS = () => "Desbanir",
  CS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? TS() : SS()),
  PS = () => "No banned users",
  IS = () => "Sem usu√°rios banidos",
  MS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? PS() : IS()),
  AS = () => "Update",
  kS = () => "Atualizar",
  ES = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? AS() : kS()),
  zS = () => "Error giving admin to user",
  LS = () => "Erro ao tornar usu√°rio admin",
  DS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? zS() : LS()),
  RS = () => "Users",
  FS = () => "Usu√°rios",
  BS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? RS() : FS()),
  OS = () => "Regions",
  NS = () => "Regi√µes",
  jS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? OS() : NS()),
  VS = () => "Countries",
  qS = () => "Pa√≠ses",
  US = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? VS() : qS()),
  ZS = () => "Players",
  GS = () => "Jogadores",
  U0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? ZS() : GS()),
  $S = () => "Alliances",
  HS = () => "Alian√ßas",
  Z0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $S() : HS()),
  WS = () => "Region",
  XS = () => "Regi√£o",
  YS = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? WS() : XS()),
  KS = () => "Pixels",
  JS = () => "Pixels",
  Mc = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? KS() : JS()),
  QS = () => "Painted",
  eC = () => "Pintados",
  Ac = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? QS() : eC()),
  tC = () => "Pixels painted inside the region",
  rC = () => "Pixels pintados dentro da regi√£o",
  nC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? tC() : rC()),
  iC = () => "Not painted",
  aC = () => "N√£o pintado",
  oC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? iC() : aC()),
  sC = () => "Painted by",
  lC = () => "Pintado por",
  cC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? sC() : lC()),
  uC = () => "Limit reached",
  hC = () => "Limite atingido",
  dC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? uC() : hC()),
  pC = () => "Favorite",
  fC = () => "Favoritar",
  mC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? pC() : fC()),
  _C = () => "Share",
  gC = () => "Compartilhar",
  vC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? _C() : gC()),
  yC = () => "Share place",
  xC = () => "Compartilhar local",
  bC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? yC() : xC()),
  wC = () => "Mute",
  TC = () => "Mutar",
  SC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? wC() : TC()),
  CC = () => "Unmute",
  PC = () => "Desmutar",
  IC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? CC() : PC()),
  MC = () => "Select the headquarters location",
  AC = () => "Selecione a localiza√ß√£o do quartel general",
  kC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? MC() : AC()),
  EC = () => "Pixels painted inside the country",
  zC = () => "Pixels pintados dentro do pa√≠s",
  LC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? EC() : zC()),
  DC = () => "Username copied to clipboard",
  RC = () => "Usu√°rio copiado",
  FC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? DC() : RC()),
  BC = () => "No more charges",
  OC = () => "Acabou a tinta",
  NC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? BC() : OC()),
  jC = () =>
    "You are not allowed to use multiple accounts. Use your main account to paint.",
  VC = () =>
    "N√£o √© permitido usar v√°rias contas. Use sua conta principal para pintar.",
  qC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? jC() : VC()),
  UC = () => "SMS sent to",
  ZC = () => "SMS enviado para",
  GC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? UC() : ZC()),
  $C = () => "Phone successfully verified",
  HC = () => "Telefone verificado com sucesso",
  WC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $C() : HC()),
  XC = () => "Not a valid phone number",
  YC = () => "N√£o √© um n√∫mero v√°lido",
  KC = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? XC() : YC()),
  JC = () => "Location unfavorited",
  QC = () => "Localiza√ß√£o desfavoritada",
  eP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? JC() : QC()),
  tP = () => "Location favorited",
  rP = () => "Localiza√ß√£o favoritada",
  nP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? tP() : rP()),
  iP = () => "Giving admin to user",
  aP = () => "Tornar usu√°rio um admin",
  oP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? iP() : aP()),
  sP = () => "Profile updated",
  lP = () => "Perfil atualizado",
  cP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? sP() : lP()),
  uP = () => "Successfully linked your Discord account.",
  hP = () => "A sua conta Discord foi conectada com sucesso.",
  dP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? uP() : hP()),
  pP = () => "Discord unlinked",
  fP = () => "Discord desconectado",
  mP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? pP() : fP()),
  _P = () => "Link your Discord",
  gP = () => "Conectar Discord",
  vP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? _P() : gP()),
  yP = (_) => `Unlink Discord (${_.username})`,
  xP = (_) => `Desconectar Discord (${_.username})`,
  bP = (_, o = {}) => ((o.locale ?? ze()) === "en" ? yP(_) : xP(_)),
  wP = () => "Account successfully deleted",
  TP = () => "Conta deletada com sucesso",
  SP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? wP() : TP()),
  CP = () => "Logged out",
  PP = () => "Logout feito",
  IP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? CP() : PP()),
  MP = () => "Could not logout. Try refreshing the page.",
  AP = () => "N√£o foi poss√≠vel sair da conta. Tente recarregar a p√°gina.",
  kP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? MP() : AP()),
  EP = () => "You need to zoom in to select a pixel",
  zP = () => "D√™ zoom para selecionar um pixel",
  LP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? EP() : zP()),
  DP = () => "Phone verification",
  RP = () => "Verifica√ß√£o de telefone",
  FP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? DP() : RP()),
  BP = () =>
    "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  OP = () =>
    "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experi√™ncia segura e criativa para todos.",
  NP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? BP() : OP()),
  jP = () => "Send Code",
  VP = () => "Enviar o c√≥digo",
  qP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? jP() : VP()),
  UP = () => "Input the code",
  ZP = () => "Insira o c√≥digo",
  GP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? UP() : ZP()),
  $P = () => "Sent to",
  HP = () => "Enviar para",
  WP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $P() : HP()),
  XP = () => "Resend Code",
  YP = () => "Reenviar C√≥digo",
  KP = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? XP() : YP()),
  JP = () => "Try another number",
  QP = () => "Tentar outro n√∫mero",
  eI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? JP() : QP()),
  tI = () => "Edit profile",
  rI = () => "Editar perfil",
  nI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? tI() : rI()),
  iI = () => "Image",
  aI = () => "Imagem",
  oI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? iI() : aI()),
  sI = () => "Download",
  lI = () => "Download",
  cI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? sI() : lI()),
  uI = () => "Image copied to clipboard",
  hI = () => "Imagem copiada para a √°rea de transfer√™ncia",
  dI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? uI() : hI()),
  pI = () => "My map is lagging",
  fI = () => "Meu mapa est√° travando",
  mI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? pI() : fI()),
  _I = () => "Verify if",
  gI = () => "Verifique se",
  vI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? _I() : gI()),
  yI = () => "Use hardware acceleration when available",
  xI = () => "Usar acelera√ß√£o gr√°fica quando dispon√≠vel",
  bI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? yI() : xI()),
  wI = () => "is enabled on",
  TI = () => "est√° habilitado em",
  SI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? wI() : TI()),
  CI = () => "Follow the instructions to enable hardware acceleration",
  PI = () => "Siga a instru√ß√£o para habilitar a acelera√ß√£o de hardware",
  II = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? CI() : PI()),
  MI = () => "Moderation",
  AI = () => "Modera√ß√£o",
  kI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? MI() : AI()),
  EI = () => "Terms",
  zI = () => "Termos",
  LI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? EI() : zI()),
  DI = () => "Privacy",
  RI = () => "Privacidade",
  FI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? DI() : RI()),
  BI = () => "Refund",
  OI = () => "Reembolso",
  G0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? BI() : OI()),
  NI = () => "Clear area",
  jI = () => "Limpar √°rea",
  VI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? NI() : jI()),
  qI = () => "Select the area's first corner",
  UI = () => "Selecione o primeiro canto da √°rea",
  $0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? qI() : UI()),
  ZI = () => "Select the area's opposite corner",
  GI = () => "Selecione o canto oposto da √°rea",
  H0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? ZI() : GI()),
  $I = () => "Admin",
  HI = () => "Administra√ß√£o",
  WI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? $I() : HI()),
  XI = (_) => `Reason: ${_.reason}`,
  YI = (_) => `Motivo: ${_.reason}`,
  Rv = (_, o = {}) => ((o.locale ?? ze()) === "en" ? XI(_) : YI(_)),
  KI = () => "No corresponding region on the map (cosmetic effect only)",
  JI = () => "N√£o possui regi√£o no mapa (apenas efeito cosm√©tico)",
  QI = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? KI() : JI()),
  e4 = () => "Flag without region on the map",
  t4 = () => "Bandeira sem regi√£o no mapa",
  r4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? e4() : t4()),
  n4 = (_) =>
    `The flag of <b>${_.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  i4 = (_) =>
    `A bandeira <b>${_.country}</b> n√£o possui regi√µes correspondente no mapa e s√≥ ter√° efeito cosm√©tico.`,
  a4 = (_, o = {}) => ((o.locale ?? ze()) === "en" ? n4(_) : i4(_)),
  o4 = () => "Dark mode",
  s4 = () => "Modo escuro",
  l4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? o4() : s4()),
  c4 = () => "Light mode",
  u4 = () => "Modo claro",
  h4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? c4() : u4()),
  d4 = () => "This action will log your account out from all devices.",
  p4 = () => "Essa a√ß√£o ira desconectar sua conta de todos os dispositivos.",
  f4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? d4() : p4()),
  m4 = () => "More",
  _4 = () => "Mais",
  g4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? m4() : _4()),
  v4 = () => "This action is irreversible, do you want to proceed?",
  y4 = () => "Esta a√ß√£o √© irrevers√≠vel, voc√™ deseja prosseguir?",
  x4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? v4() : y4()),
  b4 = () => "Please confirm by entering your username:",
  w4 = () => "Por favor, confirme digitando seu nome de usu√°rio:",
  T4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? b4() : w4()),
  S4 = () => "Type your username",
  C4 = () => "Digite seu nome de usu√°rio",
  P4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? S4() : C4()),
  I4 = () => "This action may take some time to be completed.",
  M4 = () => "Essa a√ß√£o pode levar algum tempo para ser realizada.",
  A4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? I4() : M4()),
  k4 = () => "Ban appeal",
  E4 = () => "Revis√£o de banimento",
  W0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? k4() : E4()),
  z4 = () => "Suggestions",
  L4 = () => "Sugest√µes",
  D4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? z4() : L4()),
  R4 = () => "Bug report",
  F4 = () => "Reportar bug",
  B4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? R4() : F4()),
  O4 = () => "For more details, see our",
  N4 = () => "Para mais detalhes, veja nossa",
  j4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? O4() : N4()),
  V4 = () => "Account Enforcement Policy and Code of Conduct",
  q4 = () => "Pol√≠tica de Aplica√ß√£o da Conta e C√≥digo de Conduta",
  U4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? V4() : q4()),
  Z4 = () => "Community Leader",
  G4 = () => "L√≠der de Comunidade",
  $4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Z4() : G4()),
  H4 = () =>
    "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  W4 = () =>
    "Seu nome √© como outros usu√°rios o ver√£o no Wplace. Voc√™ pode alter√°-lo a cada 60 dias.",
  X4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? H4() : W4()),
  Y4 = () => "Twitch account migrated successfully.",
  K4 = () => "Conta da Twitch migrada com sucesso.",
  J4 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Y4() : K4()),
  Q4 = () => "Timeout appeal",
  eM = () => "Revis√£o de suspens√£o",
  tM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? Q4() : eM()),
  rM =
    () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  nM =
    () => `Se voc√™ acredita que sua suspens√£o foi um erro, voc√™ pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>n√£o garante que sua suspens√£o ser√° removida</b>; no entanto, nossa equipe analisar√° a sua situa√ß√£o novamente.

As revis√µes geralmente levam at√© <b>uma semana</b>.`,
  iM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? rM() : nM()),
  aM = () => "Why your suspension should be lifted?",
  oM = () => "Por que sua suspens√£o deve ser reconsiderada?",
  sM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? aM() : oM()),
  lM = () => "Tell us why you think your suspension should be reconsidered",
  cM = () =>
    "Explique por que voc√™ acha que sua suspens√£o deve ser reconsiderada",
  uM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? lM() : cM()),
  hM = () => "Submit",
  dM = () => "Enviar",
  pM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? hM() : dM()),
  fM = () => "Appeal sent successfully",
  mM = () => "Apelo enviado com sucesso",
  _M = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? fM() : mM()),
  gM = () => "User appeal",
  vM = () => "Apelo do usu√°rio",
  yM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? gM() : vM()),
  xM = (_) => `You can send another appeal in ${_.days} days`,
  bM = (_) => `Voc√™ pode enviar outro apelo em ${_.days} dias`,
  wM = (_, o = {}) => ((o.locale ?? ze()) === "en" ? xM(_) : bM(_)),
  TM = () => "Appeal",
  SM = () => "Apelar",
  CM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? TM() : SM()),
  PM = () => "Notifications",
  IM = () => "Notifica√ß√µes",
  X0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? PM() : IM()),
  MM = () => "No notifications",
  AM = () => "Nenhuma notifica√ß√£o",
  kM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? MM() : AM()),
  EM = () => "Report feedback",
  zM = () => "Feedback de report",
  Fv = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? EM() : zM()),
  LM = () =>
    "Your report has been reviewed, and a penalty has been applied to the reported player.",
  DM = () =>
    "Sua den√∫ncia foi analisada e uma penalidade foi aplicada ao jogador denunciado.",
  Bv = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? LM() : DM()),
  RM = () => "Thank you for helping keep the community fair and safe.",
  FM = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  BM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? RM() : FM()),
  OM = () => "Mark all as read",
  NM = () => "Marcar tudo como lido",
  jM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? OM() : NM()),
  VM = () => "Recent",
  qM = () => "Recente",
  UM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? VM() : qM()),
  ZM = () => "Random place",
  GM = () => "Local aleat√≥rio",
  $M = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? ZM() : GM()),
  HM = () => "No place found",
  WM = () => "Nenhum local encontrado",
  XM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? HM() : WM()),
  YM = () => "No recent locations",
  KM = () => "Nenhum local recente",
  JM = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? YM() : KM()),
  QM = () => "Coordinates",
  e6 = () => "Coordenadas",
  Y0 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? QM() : e6()),
  t6 = () => "Pumpkin",
  r6 = () => "Ab√≥bora",
  n6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? t6() : r6()),
  i6 = () => "Claim",
  a6 = () => "Resgatar",
  o6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? i6() : a6()),
  s6 = () => "Claimed",
  l6 = () => "Resgatado",
  c6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? s6() : l6()),
  u6 = (_) => `You received ${_.droplets} droplets!`,
  h6 = (_) => `Voc√™ recebeu ${_.droplets} droplets!`,
  d6 = (_, o = {}) => ((o.locale ?? ze()) === "en" ? u6(_) : h6(_)),
  p6 = () => "Event",
  f6 = () => "Evento",
  m6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? p6() : f6()),
  _6 = () =>
    "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  g6 = () =>
    "Service Workers n√£o s√£o suportados ou est√£o desativados em seu navegador. Alguns recursos podem n√£o funcionar corretamente.",
  v6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? _6() : g6()),
  y6 = () => "Change language",
  x6 = () => "Mudar idioma",
  b6 = (_ = {}, o = {}) => ((o.locale ?? ze()) === "en" ? y6() : x6()),
  is = (2 * Math.PI * 6378137) / 2;
class ps {
  constructor(o = 256) {
    Ir(this, "initialResolution");
    (this.tileSize = o), (this.initialResolution = (2 * is) / this.tileSize);
  }
  latLonToMeters(o, f) {
    const x = (f / 180) * is,
      A =
        ((Math.log(Math.tan(((90 + o) * Math.PI) / 360)) / (Math.PI / 180)) *
          is) /
        180;
    return [x, A];
  }
  metersToLatLon(o, f) {
    const x = (o / is) * 180;
    let A = (f / is) * 180;
    return (
      (A =
        (180 / Math.PI) *
        (2 * Math.atan(Math.exp((A * Math.PI) / 180)) - Math.PI / 2)),
      [A, x]
    );
  }
  pixelsToMeters(o, f, x) {
    const A = this.resolution(x),
      L = o * A - is,
      T = is - f * A;
    return [L, T];
  }
  pixelsToLatLon(o, f, x) {
    const [A, L] = this.pixelsToMeters(o, f, x);
    return this.metersToLatLon(A, L);
  }
  latLonToPixels(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f);
    return this.metersToPixels(A, L, x);
  }
  latLonToPixelsFloor(o, f, x) {
    const [A, L] = this.latLonToPixels(o, f, x);
    return [Math.floor(A), Math.floor(L)];
  }
  metersToPixels(o, f, x) {
    const A = this.resolution(x),
      L = (o + is) / A,
      T = (is - f) / A;
    return [L, T];
  }
  latLonToTile(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f);
    return this.metersToTile(A, L, x);
  }
  metersToTile(o, f, x) {
    const [A, L] = this.metersToPixels(o, f, x);
    return this.pixelsToTile(A, L);
  }
  pixelsToTile(o, f) {
    const x = Math.ceil(o / this.tileSize) - 1,
      A = Math.ceil(f / this.tileSize) - 1;
    return [x, A];
  }
  pixelsToTileLocal(o, f) {
    return {
      tile: this.pixelsToTile(o, f),
      pixel: [Math.floor(o) % this.tileSize, Math.floor(f) % this.tileSize],
    };
  }
  tileBounds(o, f, x) {
    const [A, L] = this.pixelsToMeters(o * this.tileSize, f * this.tileSize, x),
      [T, s] = this.pixelsToMeters(
        (o + 1) * this.tileSize,
        (f + 1) * this.tileSize,
        x
      );
    return { min: [A, L], max: [T, s] };
  }
  tileBoundsLatLon(o, f, x) {
    const A = this.tileBounds(o, f, x);
    return {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1]),
    };
  }
  resolution(o) {
    return this.initialResolution / 2 ** o;
  }
  latLonToTileAndPixel(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f),
      [T, s] = this.metersToTile(A, L, x),
      [B, N] = this.metersToPixels(A, L, x);
    return {
      tile: [T, s],
      pixel: [Math.floor(B) % this.tileSize, Math.floor(N) % this.tileSize],
    };
  }
  pixelBounds(o, f, x) {
    return {
      min: this.pixelsToMeters(o, f, x),
      max: this.pixelsToMeters(o + 1, f + 1, x),
    };
  }
  pixelToBoundsLatLon(o, f, x) {
    const A = this.pixelBounds(o, f, x),
      L = 0.001885,
      T = (A.max[0] - A.min[0]) * L,
      s = (A.max[1] - A.min[1]) * L;
    return (
      (A.min[0] -= T),
      (A.max[0] -= T),
      (A.min[1] -= s),
      (A.max[1] -= s),
      {
        min: this.metersToLatLon(A.min[0], A.min[1]),
        max: this.metersToLatLon(A.max[0], A.max[1]),
      }
    );
  }
  latLonToTileBoundsLatLon(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f),
      [T, s] = this.metersToTile(A, L, x);
    return this.tileBoundsLatLon(T, s, x);
  }
  latLonToPixelBoundsLatLon(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f),
      [T, s] = this.metersToPixels(A, L, x);
    return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(s), x);
  }
  latLonToRegionAndPixel(o, f, x, A = pa.regionSize) {
    const [L, T] = this.latLonToPixelsFloor(o, f, x),
      s = this.tileSize * A;
    return {
      region: [Math.floor(L / s), Math.floor(T / s)],
      pixel: [L % s, T % s],
    };
  }
}
function b_(_, o = !0) {
  const { min: f, max: x } = _;
  return o
    ? [
        [f[1], x[0]],
        [x[1], x[0]],
        [x[1], f[0]],
        [f[1], f[0]],
      ]
    : [
        [f[0], x[1]],
        [x[0], x[1]],
        [x[0], f[1]],
        [f[0], f[1]],
      ];
}
function w_(_) {
  return [(_.min[0] + _.max[0]) / 2, (_.min[1] + _.max[1]) / 2];
}
const w6 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  Ov =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";
function T6(_) {
  return Math.floor(Math.random() * _);
}
const Am = 14.5;
async function S6() {
  const _ = I6();
  if (_) return _;
  try {
    if (
      (await navigator.permissions.query({ name: "geolocation" })).state ===
      "granted"
    ) {
      const f = await new Promise((x, A) =>
        navigator.geolocation.getCurrentPosition(
          (L) => x(L),
          (L) => A(L)
        )
      );
      return { lat: f.coords.latitude, lng: f.coords.longitude, zoom: Am };
    }
  } catch (o) {
    console.error(o);
  }
  return { ...C6().pos, zoom: Am };
}
function C6() {
  const _ = Object.entries(P6),
    o = T6(_.length),
    [f, x] = _[o];
  return { city: f, pos: x };
}
const P6 = {
    tokyo: { lat: 35.677545560719665, lng: 139.76394445809638 },
    paris: { lat: 48.8537151734952, lng: 2.3484026030630787 },
    newYork: { lat: 40.71283173786517, lng: -74.00599771376795 },
    saoPaulo: { lat: -23.550584064565356, lng: -46.63339720713918 },
    sydney: { lat: -33.86943325619071, lng: 151.2083447239608 },
  },
  K0 = "location";
function as(_, o) {
  localStorage.setItem(K0, JSON.stringify({ ..._, zoom: o }));
}
function I6() {
  const _ = localStorage.getItem(K0);
  if (!_) return;
  const o = JSON.parse(_);
  return o.zoom ?? (o.zoom = Am), o;
}
var lh, ch;
class M6 {
  constructor() {
    Er(this, lh, Je(-1));
    Er(this, ch, Je([]));
  }
  get idx() {
    return y(He(this, lh));
  }
  set idx(o) {
    te(He(this, lh), o, !0);
  }
  get entries() {
    return y(He(this, ch));
  }
  set entries(o) {
    te(He(this, ch), o);
  }
  hasNext() {
    return this.idx < this.entries.length - 1;
  }
  goToNext(o) {
    const f = this.idx + 1,
      x = this.entries[f];
    x && ((this.idx = f), o.flyTo({ center: x.pos, zoom: x.zoom }));
  }
  hasPrev() {
    return this.idx > 0;
  }
  goToPrev(o) {
    const f = this.idx - 1,
      x = this.entries[f];
    x && ((this.idx = f), o.flyTo({ center: x.pos, zoom: x.zoom }));
  }
  isEmpty() {
    return this.entries.length === 0;
  }
  push(o) {
    (this.idx = this.idx + 1),
      (this.entries = [...this.entries.slice(0, this.idx), o]);
  }
}
(lh = new WeakMap()), (ch = new WeakMap());
const A6 = new M6();
function J0(_) {
  return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default")
    ? _.default
    : _;
}
var Sp = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */ var k6 = Sp.exports,
  Nv;
function E6() {
  return (
    Nv ||
      ((Nv = 1),
      (function (_, o) {
        (function (f, x) {
          _.exports = x();
        })(k6, function () {
          var f = {},
            x = {};
          function A(T, s, B) {
            if (((x[T] = B), T === "index")) {
              var N =
                  "var sharedModule = {}; (" +
                  x.shared +
                  ")(sharedModule); (" +
                  x.worker +
                  ")(sharedModule);",
                K = {};
              return (
                x.shared(K),
                x.index(f, K),
                typeof window < "u" &&
                  f.setWorkerUrl(
                    window.URL.createObjectURL(
                      new Blob([N], { type: "text/javascript" })
                    )
                  ),
                f
              );
            }
          }
          A("shared", ["exports"], function (T) {
            function s(n, t, r, a) {
              return new (r || (r = Promise))(function (c, p) {
                function m(C) {
                  try {
                    b(a.next(C));
                  } catch (I) {
                    p(I);
                  }
                }
                function v(C) {
                  try {
                    b(a.throw(C));
                  } catch (I) {
                    p(I);
                  }
                }
                function b(C) {
                  var I;
                  C.done
                    ? c(C.value)
                    : ((I = C.value),
                      I instanceof r
                        ? I
                        : new r(function (R) {
                            R(I);
                          })).then(m, v);
                }
                b((a = a.apply(n, t || [])).next());
              });
            }
            function B(n, t) {
              (this.x = n), (this.y = t);
            }
            function N(n) {
              return n &&
                n.__esModule &&
                Object.prototype.hasOwnProperty.call(n, "default")
                ? n.default
                : n;
            }
            var K, ee;
            typeof SuppressedError == "function" && SuppressedError,
              (B.prototype = {
                clone() {
                  return new B(this.x, this.y);
                },
                add(n) {
                  return this.clone()._add(n);
                },
                sub(n) {
                  return this.clone()._sub(n);
                },
                multByPoint(n) {
                  return this.clone()._multByPoint(n);
                },
                divByPoint(n) {
                  return this.clone()._divByPoint(n);
                },
                mult(n) {
                  return this.clone()._mult(n);
                },
                div(n) {
                  return this.clone()._div(n);
                },
                rotate(n) {
                  return this.clone()._rotate(n);
                },
                rotateAround(n, t) {
                  return this.clone()._rotateAround(n, t);
                },
                matMult(n) {
                  return this.clone()._matMult(n);
                },
                unit() {
                  return this.clone()._unit();
                },
                perp() {
                  return this.clone()._perp();
                },
                round() {
                  return this.clone()._round();
                },
                mag() {
                  return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                equals(n) {
                  return this.x === n.x && this.y === n.y;
                },
                dist(n) {
                  return Math.sqrt(this.distSqr(n));
                },
                distSqr(n) {
                  const t = n.x - this.x,
                    r = n.y - this.y;
                  return t * t + r * r;
                },
                angle() {
                  return Math.atan2(this.y, this.x);
                },
                angleTo(n) {
                  return Math.atan2(this.y - n.y, this.x - n.x);
                },
                angleWith(n) {
                  return this.angleWithSep(n.x, n.y);
                },
                angleWithSep(n, t) {
                  return Math.atan2(
                    this.x * t - this.y * n,
                    this.x * n + this.y * t
                  );
                },
                _matMult(n) {
                  const t = n[2] * this.x + n[3] * this.y;
                  return (
                    (this.x = n[0] * this.x + n[1] * this.y), (this.y = t), this
                  );
                },
                _add(n) {
                  return (this.x += n.x), (this.y += n.y), this;
                },
                _sub(n) {
                  return (this.x -= n.x), (this.y -= n.y), this;
                },
                _mult(n) {
                  return (this.x *= n), (this.y *= n), this;
                },
                _div(n) {
                  return (this.x /= n), (this.y /= n), this;
                },
                _multByPoint(n) {
                  return (this.x *= n.x), (this.y *= n.y), this;
                },
                _divByPoint(n) {
                  return (this.x /= n.x), (this.y /= n.y), this;
                },
                _unit() {
                  return this._div(this.mag()), this;
                },
                _perp() {
                  const n = this.y;
                  return (this.y = this.x), (this.x = -n), this;
                },
                _rotate(n) {
                  const t = Math.cos(n),
                    r = Math.sin(n),
                    a = r * this.x + t * this.y;
                  return (this.x = t * this.x - r * this.y), (this.y = a), this;
                },
                _rotateAround(n, t) {
                  const r = Math.cos(n),
                    a = Math.sin(n),
                    c = t.y + a * (this.x - t.x) + r * (this.y - t.y);
                  return (
                    (this.x = t.x + r * (this.x - t.x) - a * (this.y - t.y)),
                    (this.y = c),
                    this
                  );
                },
                _round() {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    this
                  );
                },
                constructor: B,
              }),
              (B.convert = function (n) {
                if (n instanceof B) return n;
                if (Array.isArray(n)) return new B(+n[0], +n[1]);
                if (n.x !== void 0 && n.y !== void 0) return new B(+n.x, +n.y);
                throw new Error("Expected [x, y] or {x, y} point format");
              });
            var re = (function () {
                if (ee) return K;
                function n(t, r, a, c) {
                  (this.cx = 3 * t),
                    (this.bx = 3 * (a - t) - this.cx),
                    (this.ax = 1 - this.cx - this.bx),
                    (this.cy = 3 * r),
                    (this.by = 3 * (c - r) - this.cy),
                    (this.ay = 1 - this.cy - this.by),
                    (this.p1x = t),
                    (this.p1y = r),
                    (this.p2x = a),
                    (this.p2y = c);
                }
                return (
                  (ee = 1),
                  (K = n),
                  (n.prototype = {
                    sampleCurveX: function (t) {
                      return ((this.ax * t + this.bx) * t + this.cx) * t;
                    },
                    sampleCurveY: function (t) {
                      return ((this.ay * t + this.by) * t + this.cy) * t;
                    },
                    sampleCurveDerivativeX: function (t) {
                      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
                    },
                    solveCurveX: function (t, r) {
                      if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
                      if (t > 1) return 1;
                      for (var a = t, c = 0; c < 8; c++) {
                        var p = this.sampleCurveX(a) - t;
                        if (Math.abs(p) < r) return a;
                        var m = this.sampleCurveDerivativeX(a);
                        if (Math.abs(m) < 1e-6) break;
                        a -= p / m;
                      }
                      var v = 0,
                        b = 1;
                      for (
                        a = t, c = 0;
                        c < 20 &&
                        ((p = this.sampleCurveX(a)), !(Math.abs(p - t) < r));
                        c++
                      )
                        t > p ? (v = a) : (b = a), (a = 0.5 * (b - v) + v);
                      return a;
                    },
                    solve: function (t, r) {
                      return this.sampleCurveY(this.solveCurveX(t, r));
                    },
                  }),
                  K
                );
              })(),
              ue = N(re);
            let ne, Y;
            function xe() {
              return (
                ne == null &&
                  (ne =
                    typeof OffscreenCanvas < "u" &&
                    new OffscreenCanvas(1, 1).getContext("2d") &&
                    typeof createImageBitmap == "function"),
                ne
              );
            }
            function Ie() {
              if (Y == null && ((Y = !1), xe())) {
                const t = new OffscreenCanvas(5, 5).getContext("2d", {
                  willReadFrequently: !0,
                });
                if (t) {
                  for (let a = 0; a < 25; a++) {
                    const c = 4 * a;
                    (t.fillStyle = `rgb(${c},${c + 1},${c + 2})`),
                      t.fillRect(a % 5, Math.floor(a / 5), 1, 1);
                  }
                  const r = t.getImageData(0, 0, 5, 5).data;
                  for (let a = 0; a < 100; a++)
                    if (a % 4 != 3 && r[a] !== a) {
                      Y = !0;
                      break;
                    }
                }
              }
              return Y || !1;
            }
            var Ee = 1e-6,
              De = typeof Float32Array < "u" ? Float32Array : Array;
            function Ae() {
              var n = new De(9);
              return (
                De != Float32Array &&
                  ((n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[5] = 0),
                  (n[6] = 0),
                  (n[7] = 0)),
                (n[0] = 1),
                (n[4] = 1),
                (n[8] = 1),
                n
              );
            }
            function qe(n) {
              return (
                (n[0] = 1),
                (n[1] = 0),
                (n[2] = 0),
                (n[3] = 0),
                (n[4] = 0),
                (n[5] = 1),
                (n[6] = 0),
                (n[7] = 0),
                (n[8] = 0),
                (n[9] = 0),
                (n[10] = 1),
                (n[11] = 0),
                (n[12] = 0),
                (n[13] = 0),
                (n[14] = 0),
                (n[15] = 1),
                n
              );
            }
            function Ue() {
              var n = new De(3);
              return (
                De != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)), n
              );
            }
            function Be(n) {
              var t = n[0],
                r = n[1],
                a = n[2];
              return Math.sqrt(t * t + r * r + a * a);
            }
            function ke(n, t, r) {
              var a = new De(3);
              return (a[0] = n), (a[1] = t), (a[2] = r), a;
            }
            function $e(n, t, r) {
              return (
                (n[0] = t[0] + r[0]),
                (n[1] = t[1] + r[1]),
                (n[2] = t[2] + r[2]),
                n
              );
            }
            function Le(n, t, r) {
              return (n[0] = t[0] * r), (n[1] = t[1] * r), (n[2] = t[2] * r), n;
            }
            function nt(n, t, r) {
              var a = t[0],
                c = t[1],
                p = t[2],
                m = r[0],
                v = r[1],
                b = r[2];
              return (
                (n[0] = c * b - p * v),
                (n[1] = p * m - a * b),
                (n[2] = a * v - c * m),
                n
              );
            }
            var dt,
              je = Be;
            function Ge(n, t, r) {
              var a = t[0],
                c = t[1],
                p = t[2],
                m = t[3];
              return (
                (n[0] = r[0] * a + r[4] * c + r[8] * p + r[12] * m),
                (n[1] = r[1] * a + r[5] * c + r[9] * p + r[13] * m),
                (n[2] = r[2] * a + r[6] * c + r[10] * p + r[14] * m),
                (n[3] = r[3] * a + r[7] * c + r[11] * p + r[15] * m),
                n
              );
            }
            function bt() {
              var n = new De(4);
              return (
                De != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
                (n[3] = 1),
                n
              );
            }
            function Xe(n, t, r, a) {
              var c =
                  arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : "zyx",
                p = Math.PI / 360;
              (t *= p), (a *= p), (r *= p);
              var m = Math.sin(t),
                v = Math.cos(t),
                b = Math.sin(r),
                C = Math.cos(r),
                I = Math.sin(a),
                R = Math.cos(a);
              switch (c) {
                case "xyz":
                  (n[0] = m * C * R + v * b * I),
                    (n[1] = v * b * R - m * C * I),
                    (n[2] = v * C * I + m * b * R),
                    (n[3] = v * C * R - m * b * I);
                  break;
                case "xzy":
                  (n[0] = m * C * R - v * b * I),
                    (n[1] = v * b * R - m * C * I),
                    (n[2] = v * C * I + m * b * R),
                    (n[3] = v * C * R + m * b * I);
                  break;
                case "yxz":
                  (n[0] = m * C * R + v * b * I),
                    (n[1] = v * b * R - m * C * I),
                    (n[2] = v * C * I - m * b * R),
                    (n[3] = v * C * R + m * b * I);
                  break;
                case "yzx":
                  (n[0] = m * C * R + v * b * I),
                    (n[1] = v * b * R + m * C * I),
                    (n[2] = v * C * I - m * b * R),
                    (n[3] = v * C * R - m * b * I);
                  break;
                case "zxy":
                  (n[0] = m * C * R - v * b * I),
                    (n[1] = v * b * R + m * C * I),
                    (n[2] = v * C * I + m * b * R),
                    (n[3] = v * C * R - m * b * I);
                  break;
                case "zyx":
                  (n[0] = m * C * R - v * b * I),
                    (n[1] = v * b * R + m * C * I),
                    (n[2] = v * C * I - m * b * R),
                    (n[3] = v * C * R + m * b * I);
                  break;
                default:
                  throw new Error("Unknown angle order " + c);
              }
              return n;
            }
            function Ve() {
              var n = new De(2);
              return De != Float32Array && ((n[0] = 0), (n[1] = 0)), n;
            }
            function Ke(n, t) {
              var r = new De(2);
              return (r[0] = n), (r[1] = t), r;
            }
            Ue(),
              (dt = new De(4)),
              De != Float32Array &&
                ((dt[0] = 0), (dt[1] = 0), (dt[2] = 0), (dt[3] = 0)),
              Ue(),
              ke(1, 0, 0),
              ke(0, 1, 0),
              bt(),
              bt(),
              Ae(),
              Ve();
            const Fe = 8192;
            function ft(n, t, r) {
              return (
                t * (Fe / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
              );
            }
            function lt(n, t) {
              return ((n % t) + t) % t;
            }
            function yt(n, t, r) {
              return n * (1 - r) + t * r;
            }
            function mt(n) {
              if (n <= 0) return 0;
              if (n >= 1) return 1;
              const t = n * n,
                r = t * n;
              return 4 * (n < 0.5 ? r : 3 * (n - t) + r - 0.75);
            }
            function ct(n, t, r, a) {
              const c = new ue(n, t, r, a);
              return (p) => c.solve(p);
            }
            const qt = ct(0.25, 0.1, 0.25, 1);
            function Ft(n, t, r) {
              return Math.min(r, Math.max(t, n));
            }
            function Ye(n, t, r) {
              const a = r - t,
                c = ((((n - t) % a) + a) % a) + t;
              return c === t ? r : c;
            }
            function at(n, ...t) {
              for (const r of t) for (const a in r) n[a] = r[a];
              return n;
            }
            let xt = 1;
            function It(n, t, r) {
              const a = {};
              for (const c in n) a[c] = t.call(this, n[c], c, n);
              return a;
            }
            function Tt(n, t, r) {
              const a = {};
              for (const c in n) t.call(this, n[c], c, n) && (a[c] = n[c]);
              return a;
            }
            function Mt(n) {
              return Array.isArray(n)
                ? n.map(Mt)
                : typeof n == "object" && n
                ? It(n, Mt)
                : n;
            }
            const Wt = {};
            function Bt(n) {
              Wt[n] || (typeof console < "u" && console.warn(n), (Wt[n] = !0));
            }
            function Gt(n, t, r) {
              return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x);
            }
            function At(n) {
              return (
                typeof WorkerGlobalScope < "u" &&
                n !== void 0 &&
                n instanceof WorkerGlobalScope
              );
            }
            let Xt = null;
            function Lt(n) {
              if (Xt == null) {
                const t = n.navigator ? n.navigator.userAgent : null;
                Xt =
                  !!n.safari ||
                  !(
                    !t ||
                    !(
                      /\b(iPad|iPhone|iPod)\b/.test(t) ||
                      (t.match("Safari") && !t.match("Chrome"))
                    )
                  );
              }
              return Xt;
            }
            function Nt(n) {
              return typeof ImageBitmap < "u" && n instanceof ImageBitmap;
            }
            const jt =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            function mr(n, t, r, a, c) {
              return s(this, void 0, void 0, function* () {
                if (typeof VideoFrame > "u")
                  throw new Error("VideoFrame not supported");
                const p = new VideoFrame(n, { timestamp: 0 });
                try {
                  const m = p == null ? void 0 : p.format;
                  if (!m || (!m.startsWith("BGR") && !m.startsWith("RGB")))
                    throw new Error(`Unrecognized format ${m}`);
                  const v = m.startsWith("BGR"),
                    b = new Uint8ClampedArray(a * c * 4);
                  if (
                    (yield p.copyTo(
                      b,
                      (function (C, I, R, U, Z) {
                        const X = 4 * Math.max(-I, 0),
                          Q = (Math.max(0, R) - R) * U * 4 + X,
                          ie = 4 * U,
                          he = Math.max(0, I),
                          Oe = Math.max(0, R);
                        return {
                          rect: {
                            x: he,
                            y: Oe,
                            width: Math.min(C.width, I + U) - he,
                            height: Math.min(C.height, R + Z) - Oe,
                          },
                          layout: [{ offset: Q, stride: ie }],
                        };
                      })(n, t, r, a, c)
                    ),
                    v)
                  )
                    for (let C = 0; C < b.length; C += 4) {
                      const I = b[C];
                      (b[C] = b[C + 2]), (b[C + 2] = I);
                    }
                  return b;
                } finally {
                  p.close();
                }
              });
            }
            let ir, vr;
            function ar(n, t, r, a) {
              return (
                n.addEventListener(t, r, a),
                {
                  unsubscribe: () => {
                    n.removeEventListener(t, r, a);
                  },
                }
              );
            }
            function pr(n) {
              return (n * Math.PI) / 180;
            }
            function tr(n) {
              return (n / Math.PI) * 180;
            }
            const Dt = {
                touchstart: !0,
                touchmove: !0,
                touchmoveWindow: !0,
                touchend: !0,
                touchcancel: !0,
              },
              Sr = {
                dblclick: !0,
                click: !0,
                mouseover: !0,
                mouseout: !0,
                mousedown: !0,
                mousemove: !0,
                mousemoveWindow: !0,
                mouseup: !0,
                mouseupWindow: !0,
                contextmenu: !0,
                wheel: !0,
              },
              Te = "AbortError";
            function O() {
              return new Error(Te);
            }
            const E = {
              MAX_PARALLEL_IMAGE_REQUESTS: 16,
              MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
              MAX_TILE_CACHE_ZOOM_LEVELS: 5,
              REGISTERED_PROTOCOLS: {},
              WORKER_URL: "",
            };
            function D(n) {
              return E.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))];
            }
            const j = "global-dispatcher";
            class H extends Error {
              constructor(t, r, a, c) {
                super(`AJAXError: ${r} (${t}): ${a}`),
                  (this.status = t),
                  (this.statusText = r),
                  (this.url = a),
                  (this.body = c);
              }
            }
            const W = () =>
                At(self)
                  ? self.worker && self.worker.referrer
                  : (window.location.protocol === "blob:"
                      ? window.parent
                      : window
                    ).location.href,
              ce = function (n, t) {
                if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
                  const a = D(n.url);
                  if (a) return a(n, t);
                  if (At(self) && self.worker && self.worker.actor)
                    return self.worker.actor.sendAsync(
                      { type: "GR", data: n, targetMapId: j },
                      t
                    );
                }
                if (
                  !(
                    /^file:/.test((r = n.url)) ||
                    (/^file:/.test(W()) && !/^\w+:/.test(r))
                  )
                ) {
                  if (
                    fetch &&
                    Request &&
                    AbortController &&
                    Object.prototype.hasOwnProperty.call(
                      Request.prototype,
                      "signal"
                    )
                  )
                    return (function (a, c) {
                      return s(this, void 0, void 0, function* () {
                        const p = new Request(a.url, {
                          method: a.method || "GET",
                          body: a.body,
                          credentials: a.credentials,
                          headers: a.headers,
                          cache: a.cache,
                          referrer: W(),
                          signal: c.signal,
                        });
                        let m, v;
                        a.type !== "json" ||
                          p.headers.has("Accept") ||
                          p.headers.set("Accept", "application/json");
                        try {
                          m = yield fetch(p);
                        } catch (C) {
                          throw new H(0, C.message, a.url, new Blob());
                        }
                        if (!m.ok) {
                          const C = yield m.blob();
                          throw new H(m.status, m.statusText, a.url, C);
                        }
                        v =
                          a.type === "arrayBuffer" || a.type === "image"
                            ? m.arrayBuffer()
                            : a.type === "json"
                            ? m.json()
                            : m.text();
                        const b = yield v;
                        if (c.signal.aborted) throw O();
                        return {
                          data: b,
                          cacheControl: m.headers.get("Cache-Control"),
                          expires: m.headers.get("Expires"),
                        };
                      });
                    })(n, t);
                  if (At(self) && self.worker && self.worker.actor)
                    return self.worker.actor.sendAsync(
                      { type: "GR", data: n, mustQueue: !0, targetMapId: j },
                      t
                    );
                }
                var r;
                return (function (a, c) {
                  return new Promise((p, m) => {
                    var v;
                    const b = new XMLHttpRequest();
                    b.open(a.method || "GET", a.url, !0),
                      (a.type !== "arrayBuffer" && a.type !== "image") ||
                        (b.responseType = "arraybuffer");
                    for (const C in a.headers)
                      b.setRequestHeader(C, a.headers[C]);
                    a.type === "json" &&
                      ((b.responseType = "text"),
                      (!((v = a.headers) === null || v === void 0) &&
                        v.Accept) ||
                        b.setRequestHeader("Accept", "application/json")),
                      (b.withCredentials = a.credentials === "include"),
                      (b.onerror = () => {
                        m(new Error(b.statusText));
                      }),
                      (b.onload = () => {
                        if (!c.signal.aborted)
                          if (
                            ((b.status >= 200 && b.status < 300) ||
                              b.status === 0) &&
                            b.response !== null
                          ) {
                            let C = b.response;
                            if (a.type === "json")
                              try {
                                C = JSON.parse(b.response);
                              } catch (I) {
                                return void m(I);
                              }
                            p({
                              data: C,
                              cacheControl:
                                b.getResponseHeader("Cache-Control"),
                              expires: b.getResponseHeader("Expires"),
                            });
                          } else {
                            const C = new Blob([b.response], {
                              type: b.getResponseHeader("Content-Type"),
                            });
                            m(new H(b.status, b.statusText, a.url, C));
                          }
                      }),
                      c.signal.addEventListener("abort", () => {
                        b.abort(), m(O());
                      }),
                      b.send(a.body);
                  });
                })(n, t);
              };
            function ge(n) {
              if (
                !n ||
                n.indexOf("://") <= 0 ||
                n.indexOf("data:image/") === 0 ||
                n.indexOf("blob:") === 0
              )
                return !0;
              const t = new URL(n),
                r = window.location;
              return t.protocol === r.protocol && t.host === r.host;
            }
            function de(n, t, r) {
              (r[n] && r[n].indexOf(t) !== -1) ||
                ((r[n] = r[n] || []), r[n].push(t));
            }
            function Se(n, t, r) {
              if (r && r[n]) {
                const a = r[n].indexOf(t);
                a !== -1 && r[n].splice(a, 1);
              }
            }
            class We {
              constructor(t, r = {}) {
                at(this, r), (this.type = t);
              }
            }
            class Ze extends We {
              constructor(t, r = {}) {
                super("error", at({ error: t }, r));
              }
            }
            class Ct {
              on(t, r) {
                return (
                  (this._listeners = this._listeners || {}),
                  de(t, r, this._listeners),
                  {
                    unsubscribe: () => {
                      this.off(t, r);
                    },
                  }
                );
              }
              off(t, r) {
                return (
                  Se(t, r, this._listeners),
                  Se(t, r, this._oneTimeListeners),
                  this
                );
              }
              once(t, r) {
                return r
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    de(t, r, this._oneTimeListeners),
                    this)
                  : new Promise((a) => this.once(t, a));
              }
              fire(t, r) {
                typeof t == "string" && (t = new We(t, r || {}));
                const a = t.type;
                if (this.listens(a)) {
                  t.target = this;
                  const c =
                    this._listeners && this._listeners[a]
                      ? this._listeners[a].slice()
                      : [];
                  for (const v of c) v.call(this, t);
                  const p =
                    this._oneTimeListeners && this._oneTimeListeners[a]
                      ? this._oneTimeListeners[a].slice()
                      : [];
                  for (const v of p)
                    Se(a, v, this._oneTimeListeners), v.call(this, t);
                  const m = this._eventedParent;
                  m &&
                    (at(
                      t,
                      typeof this._eventedParentData == "function"
                        ? this._eventedParentData()
                        : this._eventedParentData
                    ),
                    m.fire(t));
                } else t instanceof Ze && console.error(t.error);
                return this;
              }
              listens(t) {
                return (
                  (this._listeners &&
                    this._listeners[t] &&
                    this._listeners[t].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[t] &&
                    this._oneTimeListeners[t].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(t))
                );
              }
              setEventedParent(t, r) {
                return (
                  (this._eventedParent = t), (this._eventedParentData = r), this
                );
              }
            }
            var _e = {
              $version: 8,
              $root: {
                version: { required: !0, type: "enum", values: [8] },
                name: { type: "string" },
                metadata: { type: "*" },
                center: { type: "array", value: "number" },
                centerAltitude: { type: "number" },
                zoom: { type: "number" },
                bearing: {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                },
                pitch: { type: "number", default: 0, units: "degrees" },
                roll: { type: "number", default: 0, units: "degrees" },
                state: { type: "state", default: {} },
                light: { type: "light" },
                sky: { type: "sky" },
                projection: { type: "projection" },
                terrain: { type: "terrain" },
                sources: { required: !0, type: "sources" },
                sprite: { type: "sprite" },
                glyphs: { type: "string" },
                "font-faces": { type: "array", value: "fontFaces" },
                transition: { type: "transition" },
                layers: { required: !0, type: "array", value: "layer" },
              },
              sources: { "*": { type: "source" } },
              source: [
                "source_vector",
                "source_raster",
                "source_raster_dem",
                "source_geojson",
                "source_video",
                "source_image",
              ],
              source_vector: {
                type: { required: !0, type: "enum", values: { vector: {} } },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                scheme: {
                  type: "enum",
                  values: { xyz: {}, tms: {} },
                  default: "xyz",
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                attribution: { type: "string" },
                promoteId: { type: "promoteId" },
                volatile: { type: "boolean", default: !1 },
                encoding: {
                  type: "enum",
                  values: { mvt: {}, mlt: {} },
                  default: "mvt",
                },
                "*": { type: "*" },
              },
              source_raster: {
                type: { required: !0, type: "enum", values: { raster: {} } },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                tileSize: { type: "number", default: 512, units: "pixels" },
                scheme: {
                  type: "enum",
                  values: { xyz: {}, tms: {} },
                  default: "xyz",
                },
                attribution: { type: "string" },
                volatile: { type: "boolean", default: !1 },
                "*": { type: "*" },
              },
              source_raster_dem: {
                type: {
                  required: !0,
                  type: "enum",
                  values: { "raster-dem": {} },
                },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                tileSize: { type: "number", default: 512, units: "pixels" },
                attribution: { type: "string" },
                encoding: {
                  type: "enum",
                  values: { terrarium: {}, mapbox: {}, custom: {} },
                  default: "mapbox",
                },
                redFactor: { type: "number", default: 1 },
                blueFactor: { type: "number", default: 1 },
                greenFactor: { type: "number", default: 1 },
                baseShift: { type: "number", default: 0 },
                volatile: { type: "boolean", default: !1 },
                "*": { type: "*" },
              },
              source_geojson: {
                type: { required: !0, type: "enum", values: { geojson: {} } },
                data: { required: !0, type: "*" },
                maxzoom: { type: "number", default: 18 },
                attribution: { type: "string" },
                buffer: {
                  type: "number",
                  default: 128,
                  maximum: 512,
                  minimum: 0,
                },
                filter: { type: "*" },
                tolerance: { type: "number", default: 0.375 },
                cluster: { type: "boolean", default: !1 },
                clusterRadius: { type: "number", default: 50, minimum: 0 },
                clusterMaxZoom: { type: "number" },
                clusterMinPoints: { type: "number" },
                clusterProperties: { type: "*" },
                lineMetrics: { type: "boolean", default: !1 },
                generateId: { type: "boolean", default: !1 },
                promoteId: { type: "promoteId" },
              },
              source_video: {
                type: { required: !0, type: "enum", values: { video: {} } },
                urls: { required: !0, type: "array", value: "string" },
                coordinates: {
                  required: !0,
                  type: "array",
                  length: 4,
                  value: { type: "array", length: 2, value: "number" },
                },
              },
              source_image: {
                type: { required: !0, type: "enum", values: { image: {} } },
                url: { required: !0, type: "string" },
                coordinates: {
                  required: !0,
                  type: "array",
                  length: 4,
                  value: { type: "array", length: 2, value: "number" },
                },
              },
              layer: {
                id: { type: "string", required: !0 },
                type: {
                  type: "enum",
                  values: {
                    fill: {},
                    line: {},
                    symbol: {},
                    circle: {},
                    heatmap: {},
                    "fill-extrusion": {},
                    raster: {},
                    hillshade: {},
                    "color-relief": {},
                    background: {},
                  },
                  required: !0,
                },
                metadata: { type: "*" },
                source: { type: "string" },
                "source-layer": { type: "string" },
                minzoom: { type: "number", minimum: 0, maximum: 24 },
                maxzoom: { type: "number", minimum: 0, maximum: 24 },
                filter: { type: "filter" },
                layout: { type: "layout" },
                paint: { type: "paint" },
              },
              layout: [
                "layout_fill",
                "layout_line",
                "layout_circle",
                "layout_heatmap",
                "layout_fill-extrusion",
                "layout_symbol",
                "layout_raster",
                "layout_hillshade",
                "layout_color-relief",
                "layout_background",
              ],
              layout_background: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_fill: {
                "fill-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_circle: {
                "circle-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_heatmap: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              "layout_fill-extrusion": {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_line: {
                "line-cap": {
                  type: "enum",
                  values: { butt: {}, round: {}, square: {} },
                  default: "butt",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-join": {
                  type: "enum",
                  values: { bevel: {}, round: {}, miter: {} },
                  default: "miter",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "line-miter-limit": {
                  type: "number",
                  default: 2,
                  requires: [{ "line-join": "miter" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-round-limit": {
                  type: "number",
                  default: 1.05,
                  requires: [{ "line-join": "round" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_symbol: {
                "symbol-placement": {
                  type: "enum",
                  values: { point: {}, line: {}, "line-center": {} },
                  default: "point",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-spacing": {
                  type: "number",
                  default: 250,
                  minimum: 1,
                  units: "pixels",
                  requires: [{ "symbol-placement": "line" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-avoid-edges": {
                  type: "boolean",
                  default: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "symbol-z-order": {
                  type: "enum",
                  values: { auto: {}, "viewport-y": {}, source: {} },
                  default: "auto",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-allow-overlap": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image", { "!": "icon-overlap" }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-overlap": {
                  type: "enum",
                  values: { never: {}, always: {}, cooperative: {} },
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-ignore-placement": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-optional": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image", "text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-rotation-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-size": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  units: "factor of the original icon size",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-text-fit": {
                  type: "enum",
                  values: { none: {}, width: {}, height: {}, both: {} },
                  default: "none",
                  requires: ["icon-image", "text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-text-fit-padding": {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [0, 0, 0, 0],
                  units: "pixels",
                  requires: [
                    "icon-image",
                    "text-field",
                    { "icon-text-fit": ["both", "width", "height"] },
                  ],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-image": {
                  type: "resolvedImage",
                  tokens: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-padding": {
                  type: "padding",
                  default: [2],
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-keep-upright": {
                  type: "boolean",
                  default: !1,
                  requires: [
                    "icon-image",
                    { "icon-rotation-alignment": "map" },
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-offset": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-anchor": {
                  type: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  default: "center",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-rotation-alignment": {
                  type: "enum",
                  values: {
                    map: {},
                    viewport: {},
                    "viewport-glyph": {},
                    auto: {},
                  },
                  default: "auto",
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-field": {
                  type: "formatted",
                  default: "",
                  tokens: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-font": {
                  type: "array",
                  value: "string",
                  default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-size": {
                  type: "number",
                  default: 16,
                  minimum: 0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-max-width": {
                  type: "number",
                  default: 10,
                  minimum: 0,
                  units: "ems",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-line-height": {
                  type: "number",
                  default: 1.2,
                  units: "ems",
                  requires: ["text-field"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-letter-spacing": {
                  type: "number",
                  default: 0,
                  units: "ems",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-justify": {
                  type: "enum",
                  values: { auto: {}, left: {}, center: {}, right: {} },
                  default: "center",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-radial-offset": {
                  type: "number",
                  units: "ems",
                  default: 0,
                  requires: ["text-field"],
                  "property-type": "data-driven",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                },
                "text-variable-anchor": {
                  type: "array",
                  value: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  requires: ["text-field", { "symbol-placement": ["point"] }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-variable-anchor-offset": {
                  type: "variableAnchorOffsetCollection",
                  requires: ["text-field", { "symbol-placement": ["point"] }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-anchor": {
                  type: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  default: "center",
                  requires: ["text-field", { "!": "text-variable-anchor" }],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-max-angle": {
                  type: "number",
                  default: 45,
                  units: "degrees",
                  requires: [
                    "text-field",
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-writing-mode": {
                  type: "array",
                  value: "enum",
                  values: { horizontal: {}, vertical: {} },
                  requires: ["text-field", { "symbol-placement": ["point"] }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-padding": {
                  type: "number",
                  default: 2,
                  minimum: 0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-keep-upright": {
                  type: "boolean",
                  default: !0,
                  requires: [
                    "text-field",
                    { "text-rotation-alignment": "map" },
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-transform": {
                  type: "enum",
                  values: { none: {}, uppercase: {}, lowercase: {} },
                  default: "none",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-offset": {
                  type: "array",
                  value: "number",
                  units: "ems",
                  length: 2,
                  default: [0, 0],
                  requires: ["text-field", { "!": "text-radial-offset" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-allow-overlap": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field", { "!": "text-overlap" }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-overlap": {
                  type: "enum",
                  values: { never: {}, always: {}, cooperative: {} },
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-ignore-placement": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-optional": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field", "icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_raster: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_hillshade: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              "layout_color-relief": {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              filter: { type: "array", value: "*" },
              filter_operator: {
                type: "enum",
                values: {
                  "==": {},
                  "!=": {},
                  ">": {},
                  ">=": {},
                  "<": {},
                  "<=": {},
                  in: {},
                  "!in": {},
                  all: {},
                  any: {},
                  none: {},
                  has: {},
                  "!has": {},
                },
              },
              geometry_type: {
                type: "enum",
                values: { Point: {}, LineString: {}, Polygon: {} },
              },
              function: {
                expression: { type: "expression" },
                stops: { type: "array", value: "function_stop" },
                base: { type: "number", default: 1, minimum: 0 },
                property: { type: "string", default: "$zoom" },
                type: {
                  type: "enum",
                  values: {
                    identity: {},
                    exponential: {},
                    interval: {},
                    categorical: {},
                  },
                  default: "exponential",
                },
                colorSpace: {
                  type: "enum",
                  values: { rgb: {}, lab: {}, hcl: {} },
                  default: "rgb",
                },
                default: { type: "*", required: !1 },
              },
              function_stop: {
                type: "array",
                minimum: 0,
                maximum: 24,
                value: ["number", "color"],
                length: 2,
              },
              expression: { type: "array", value: "*", minimum: 1 },
              light: {
                anchor: {
                  type: "enum",
                  default: "viewport",
                  values: { map: {}, viewport: {} },
                  "property-type": "data-constant",
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                },
                position: {
                  type: "array",
                  default: [1.15, 210, 30],
                  length: 3,
                  value: "number",
                  "property-type": "data-constant",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                },
                color: {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#ffffff",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                intensity: {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.5,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
              },
              sky: {
                "sky-color": {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#88C6FC",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "horizon-color": {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#ffffff",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "fog-color": {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#ffffff",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "fog-ground-blend": {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.5,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "horizon-fog-blend": {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.8,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "sky-horizon-blend": {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.8,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "atmosphere-blend": {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.8,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
              },
              terrain: {
                source: { type: "string", required: !0 },
                exaggeration: { type: "number", minimum: 0, default: 1 },
              },
              projection: {
                type: {
                  type: "projectionDefinition",
                  default: "mercator",
                  "property-type": "data-constant",
                  transition: !1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                },
              },
              paint: [
                "paint_fill",
                "paint_line",
                "paint_circle",
                "paint_heatmap",
                "paint_fill-extrusion",
                "paint_symbol",
                "paint_raster",
                "paint_hillshade",
                "paint_color-relief",
                "paint_background",
              ],
              paint_fill: {
                "fill-antialias": {
                  type: "boolean",
                  default: !0,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "fill-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-outline-color": {
                  type: "color",
                  transition: !0,
                  requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["fill-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
              },
              "paint_fill-extrusion": {
                "fill-extrusion-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "fill-extrusion-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["fill-extrusion-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "fill-extrusion-height": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "meters",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-base": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "meters",
                  transition: !0,
                  requires: ["fill-extrusion-height"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-vertical-gradient": {
                  type: "boolean",
                  default: !0,
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_line: {
                "line-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "line-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["line-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-width": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-gap-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-offset": {
                  type: "number",
                  default: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-dasharray": {
                  type: "array",
                  value: "number",
                  minimum: 0,
                  transition: !0,
                  units: "line widths",
                  requires: [{ "!": "line-pattern" }],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "line-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "line-gradient": {
                  type: "color",
                  transition: !1,
                  requires: [
                    { "!": "line-dasharray" },
                    { "!": "line-pattern" },
                    { source: "geojson", has: { lineMetrics: !0 } },
                  ],
                  expression: {
                    interpolated: !0,
                    parameters: ["line-progress"],
                  },
                  "property-type": "color-ramp",
                },
              },
              paint_circle: {
                "circle-radius": {
                  type: "number",
                  default: 5,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-blur": {
                  type: "number",
                  default: 0,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["circle-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-pitch-scale": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "viewport",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-stroke-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-stroke-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-stroke-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
              },
              paint_heatmap: {
                "heatmap-radius": {
                  type: "number",
                  default: 30,
                  minimum: 1,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "heatmap-weight": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !1,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "heatmap-intensity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "heatmap-color": {
                  type: "color",
                  default: [
                    "interpolate",
                    ["linear"],
                    ["heatmap-density"],
                    0,
                    "rgba(0, 0, 255, 0)",
                    0.1,
                    "royalblue",
                    0.3,
                    "cyan",
                    0.5,
                    "lime",
                    0.7,
                    "yellow",
                    1,
                    "red",
                  ],
                  transition: !1,
                  expression: {
                    interpolated: !0,
                    parameters: ["heatmap-density"],
                  },
                  "property-type": "color-ramp",
                },
                "heatmap-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_symbol: {
                "icon-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-color": {
                  type: "color",
                  default: "rgba(0, 0, 0, 0)",
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["icon-image", "icon-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  overridable: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-color": {
                  type: "color",
                  default: "rgba(0, 0, 0, 0)",
                  transition: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["text-field", "text-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_raster: {
                "raster-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-hue-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  transition: !0,
                  units: "degrees",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-brightness-min": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-brightness-max": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-saturation": {
                  type: "number",
                  default: 0,
                  minimum: -1,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-contrast": {
                  type: "number",
                  default: 0,
                  minimum: -1,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-resampling": {
                  type: "enum",
                  values: { linear: {}, nearest: {} },
                  default: "linear",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-fade-duration": {
                  type: "number",
                  default: 300,
                  minimum: 0,
                  transition: !1,
                  units: "milliseconds",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_hillshade: {
                "hillshade-illumination-direction": {
                  type: "numberArray",
                  default: 335,
                  minimum: 0,
                  maximum: 359,
                  transition: !1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-illumination-altitude": {
                  type: "numberArray",
                  default: 45,
                  minimum: 0,
                  maximum: 90,
                  transition: !1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-illumination-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "viewport",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-exaggeration": {
                  type: "number",
                  default: 0.5,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-shadow-color": {
                  type: "colorArray",
                  default: "#000000",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-highlight-color": {
                  type: "colorArray",
                  default: "#FFFFFF",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-accent-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-method": {
                  type: "enum",
                  values: {
                    standard: {},
                    basic: {},
                    combined: {},
                    igor: {},
                    multidirectional: {},
                  },
                  default: "standard",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              "paint_color-relief": {
                "color-relief-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "color-relief-color": {
                  type: "color",
                  transition: !1,
                  expression: { interpolated: !0, parameters: ["elevation"] },
                  "property-type": "color-ramp",
                },
              },
              paint_background: {
                "background-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "background-pattern" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "background-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "cross-faded",
                },
                "background-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              transition: {
                duration: {
                  type: "number",
                  default: 300,
                  minimum: 0,
                  units: "milliseconds",
                },
                delay: {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "milliseconds",
                },
              },
              "property-type": {
                "data-driven": { type: "property-type" },
                "cross-faded": { type: "property-type" },
                "cross-faded-data-driven": { type: "property-type" },
                "color-ramp": { type: "property-type" },
                "data-constant": { type: "property-type" },
                constant: { type: "property-type" },
              },
              promoteId: { "*": { type: "string" } },
            };
            const Vt = [
              "type",
              "source",
              "source-layer",
              "minzoom",
              "maxzoom",
              "filter",
              "layout",
            ];
            function cr(n, t) {
              const r = {};
              for (const a in n) a !== "ref" && (r[a] = n[a]);
              return (
                Vt.forEach((a) => {
                  a in t && (r[a] = t[a]);
                }),
                r
              );
            }
            function Ot(n, t) {
              if (Array.isArray(n)) {
                if (!Array.isArray(t) || n.length !== t.length) return !1;
                for (let r = 0; r < n.length; r++)
                  if (!Ot(n[r], t[r])) return !1;
                return !0;
              }
              if (typeof n == "object" && n !== null && t !== null) {
                if (
                  typeof t != "object" ||
                  Object.keys(n).length !== Object.keys(t).length
                )
                  return !1;
                for (const r in n) if (!Ot(n[r], t[r])) return !1;
                return !0;
              }
              return n === t;
            }
            function ur(n, t) {
              n.push(t);
            }
            function Nr(n, t, r) {
              ur(r, { command: "addSource", args: [n, t[n]] });
            }
            function Ur(n, t, r) {
              ur(t, { command: "removeSource", args: [n] }), (r[n] = !0);
            }
            function Wr(n, t, r, a) {
              Ur(n, r, a), Nr(n, t, r);
            }
            function un(n, t, r) {
              let a;
              for (a in n[r])
                if (
                  Object.prototype.hasOwnProperty.call(n[r], a) &&
                  a !== "data" &&
                  !Ot(n[r][a], t[r][a])
                )
                  return !1;
              for (a in t[r])
                if (
                  Object.prototype.hasOwnProperty.call(t[r], a) &&
                  a !== "data" &&
                  !Ot(n[r][a], t[r][a])
                )
                  return !1;
              return !0;
            }
            function an(n, t, r, a, c, p) {
              (n = n || {}), (t = t || {});
              for (const m in n)
                Object.prototype.hasOwnProperty.call(n, m) &&
                  (Ot(n[m], t[m]) ||
                    r.push({ command: p, args: [a, m, t[m], c] }));
              for (const m in t)
                Object.prototype.hasOwnProperty.call(t, m) &&
                  !Object.prototype.hasOwnProperty.call(n, m) &&
                  (Ot(n[m], t[m]) ||
                    r.push({ command: p, args: [a, m, t[m], c] }));
            }
            function fn(n) {
              return n.id;
            }
            function rn(n, t) {
              return (n[t.id] = t), n;
            }
            class pt {
              constructor(t, r, a, c) {
                (this.message = (t ? `${t}: ` : "") + a),
                  c && (this.identifier = c),
                  r != null && r.__line__ && (this.line = r.__line__);
              }
            }
            function on(n, ...t) {
              for (const r of t) for (const a in r) n[a] = r[a];
              return n;
            }
            class Pn extends Error {
              constructor(t, r) {
                super(r), (this.message = r), (this.key = t);
              }
            }
            class zt {
              constructor(t, r = []) {
                (this.parent = t), (this.bindings = {});
                for (const [a, c] of r) this.bindings[a] = c;
              }
              concat(t) {
                return new zt(this, t);
              }
              get(t) {
                if (this.bindings[t]) return this.bindings[t];
                if (this.parent) return this.parent.get(t);
                throw new Error(`${t} not found in scope.`);
              }
              has(t) {
                return (
                  !!this.bindings[t] || (!!this.parent && this.parent.has(t))
                );
              }
            }
            const Qt = { kind: "null" },
              rt = { kind: "number" },
              $t = { kind: "string" },
              st = { kind: "boolean" },
              gt = { kind: "color" },
              Ut = { kind: "projectionDefinition" },
              br = { kind: "object" },
              wt = { kind: "value" },
              sr = { kind: "collator" },
              wr = { kind: "formatted" },
              jr = { kind: "padding" },
              Yr = { kind: "colorArray" },
              fr = { kind: "numberArray" },
              Zr = { kind: "resolvedImage" },
              nn = { kind: "variableAnchorOffsetCollection" };
            function Tn(n, t) {
              return { kind: "array", itemType: n, N: t };
            }
            function gn(n) {
              if (n.kind === "array") {
                const t = gn(n.itemType);
                return typeof n.N == "number"
                  ? `array<${t}, ${n.N}>`
                  : n.itemType.kind === "value"
                  ? "array"
                  : `array<${t}>`;
              }
              return n.kind;
            }
            const Gn = [
              Qt,
              rt,
              $t,
              st,
              gt,
              Ut,
              wr,
              br,
              Tn(wt),
              jr,
              fr,
              Yr,
              Zr,
              nn,
            ];
            function Rn(n, t) {
              if (t.kind === "error") return null;
              if (n.kind === "array") {
                if (
                  t.kind === "array" &&
                  ((t.N === 0 && t.itemType.kind === "value") ||
                    !Rn(n.itemType, t.itemType)) &&
                  (typeof n.N != "number" || n.N === t.N)
                )
                  return null;
              } else {
                if (n.kind === t.kind) return null;
                if (n.kind === "value") {
                  for (const r of Gn) if (!Rn(r, t)) return null;
                }
              }
              return `Expected ${gn(n)} but found ${gn(t)} instead.`;
            }
            function hn(n, t) {
              return t.some((r) => r.kind === n.kind);
            }
            function Qn(n, t) {
              return t.some((r) =>
                r === "null"
                  ? n === null
                  : r === "array"
                  ? Array.isArray(n)
                  : r === "object"
                  ? n && !Array.isArray(n) && typeof n == "object"
                  : r === typeof n
              );
            }
            function li(n, t) {
              return n.kind === "array" && t.kind === "array"
                ? n.itemType.kind === t.itemType.kind && typeof n.N == "number"
                : n.kind === t.kind;
            }
            const ii = 0.96422,
              pi = 0.82521,
              Qi = 4 / 29,
              xi = 6 / 29,
              Hi = 3 * xi * xi,
              ma = xi * xi * xi,
              Ta = Math.PI / 180,
              Na = 180 / Math.PI;
            function Do(n) {
              return (n %= 360) < 0 && (n += 360), n;
            }
            function Sa([n, t, r, a]) {
              let c, p;
              const m = vt(
                (0.2225045 * (n = Ca(n)) +
                  0.7168786 * (t = Ca(t)) +
                  0.0606169 * (r = Ca(r))) /
                  1
              );
              n === t && t === r
                ? (c = p = m)
                : ((c = vt(
                    (0.4360747 * n + 0.3850649 * t + 0.1430804 * r) / ii
                  )),
                  (p = vt(
                    (0.0139322 * n + 0.0971045 * t + 0.7141733 * r) / pi
                  )));
              const v = 116 * m - 16;
              return [v < 0 ? 0 : v, 500 * (c - m), 200 * (m - p), a];
            }
            function Ca(n) {
              return n <= 0.04045
                ? n / 12.92
                : Math.pow((n + 0.055) / 1.055, 2.4);
            }
            function vt(n) {
              return n > ma ? Math.pow(n, 1 / 3) : n / Hi + Qi;
            }
            function Kt([n, t, r, a]) {
              let c = (n + 16) / 116,
                p = isNaN(t) ? c : c + t / 500,
                m = isNaN(r) ? c : c - r / 200;
              return (
                (c = 1 * In(c)),
                (p = ii * In(p)),
                (m = pi * In(m)),
                [
                  qr(3.1338561 * p - 1.6168667 * c - 0.4906146 * m),
                  qr(-0.9787684 * p + 1.9161415 * c + 0.033454 * m),
                  qr(0.0719453 * p - 0.2289914 * c + 1.4052427 * m),
                  a,
                ]
              );
            }
            function qr(n) {
              return (n =
                n <= 0.00304
                  ? 12.92 * n
                  : 1.055 * Math.pow(n, 1 / 2.4) - 0.055) < 0
                ? 0
                : n > 1
                ? 1
                : n;
            }
            function In(n) {
              return n > xi ? n * n * n : Hi * (n - Qi);
            }
            const $n =
              Object.hasOwn ||
              function (n, t) {
                return Object.prototype.hasOwnProperty.call(n, t);
              };
            function Ci(n, t) {
              return $n(n, t) ? n[t] : void 0;
            }
            function Xn(n) {
              return parseInt(n.padEnd(2, n), 16) / 255;
            }
            function Mn(n, t) {
              return Vi(t ? n / 100 : n, 0, 1);
            }
            function Vi(n, t, r) {
              return Math.min(Math.max(t, n), r);
            }
            function Mr(n) {
              return !n.some(Number.isNaN);
            }
            const _r = {
              aliceblue: [240, 248, 255],
              antiquewhite: [250, 235, 215],
              aqua: [0, 255, 255],
              aquamarine: [127, 255, 212],
              azure: [240, 255, 255],
              beige: [245, 245, 220],
              bisque: [255, 228, 196],
              black: [0, 0, 0],
              blanchedalmond: [255, 235, 205],
              blue: [0, 0, 255],
              blueviolet: [138, 43, 226],
              brown: [165, 42, 42],
              burlywood: [222, 184, 135],
              cadetblue: [95, 158, 160],
              chartreuse: [127, 255, 0],
              chocolate: [210, 105, 30],
              coral: [255, 127, 80],
              cornflowerblue: [100, 149, 237],
              cornsilk: [255, 248, 220],
              crimson: [220, 20, 60],
              cyan: [0, 255, 255],
              darkblue: [0, 0, 139],
              darkcyan: [0, 139, 139],
              darkgoldenrod: [184, 134, 11],
              darkgray: [169, 169, 169],
              darkgreen: [0, 100, 0],
              darkgrey: [169, 169, 169],
              darkkhaki: [189, 183, 107],
              darkmagenta: [139, 0, 139],
              darkolivegreen: [85, 107, 47],
              darkorange: [255, 140, 0],
              darkorchid: [153, 50, 204],
              darkred: [139, 0, 0],
              darksalmon: [233, 150, 122],
              darkseagreen: [143, 188, 143],
              darkslateblue: [72, 61, 139],
              darkslategray: [47, 79, 79],
              darkslategrey: [47, 79, 79],
              darkturquoise: [0, 206, 209],
              darkviolet: [148, 0, 211],
              deeppink: [255, 20, 147],
              deepskyblue: [0, 191, 255],
              dimgray: [105, 105, 105],
              dimgrey: [105, 105, 105],
              dodgerblue: [30, 144, 255],
              firebrick: [178, 34, 34],
              floralwhite: [255, 250, 240],
              forestgreen: [34, 139, 34],
              fuchsia: [255, 0, 255],
              gainsboro: [220, 220, 220],
              ghostwhite: [248, 248, 255],
              gold: [255, 215, 0],
              goldenrod: [218, 165, 32],
              gray: [128, 128, 128],
              green: [0, 128, 0],
              greenyellow: [173, 255, 47],
              grey: [128, 128, 128],
              honeydew: [240, 255, 240],
              hotpink: [255, 105, 180],
              indianred: [205, 92, 92],
              indigo: [75, 0, 130],
              ivory: [255, 255, 240],
              khaki: [240, 230, 140],
              lavender: [230, 230, 250],
              lavenderblush: [255, 240, 245],
              lawngreen: [124, 252, 0],
              lemonchiffon: [255, 250, 205],
              lightblue: [173, 216, 230],
              lightcoral: [240, 128, 128],
              lightcyan: [224, 255, 255],
              lightgoldenrodyellow: [250, 250, 210],
              lightgray: [211, 211, 211],
              lightgreen: [144, 238, 144],
              lightgrey: [211, 211, 211],
              lightpink: [255, 182, 193],
              lightsalmon: [255, 160, 122],
              lightseagreen: [32, 178, 170],
              lightskyblue: [135, 206, 250],
              lightslategray: [119, 136, 153],
              lightslategrey: [119, 136, 153],
              lightsteelblue: [176, 196, 222],
              lightyellow: [255, 255, 224],
              lime: [0, 255, 0],
              limegreen: [50, 205, 50],
              linen: [250, 240, 230],
              magenta: [255, 0, 255],
              maroon: [128, 0, 0],
              mediumaquamarine: [102, 205, 170],
              mediumblue: [0, 0, 205],
              mediumorchid: [186, 85, 211],
              mediumpurple: [147, 112, 219],
              mediumseagreen: [60, 179, 113],
              mediumslateblue: [123, 104, 238],
              mediumspringgreen: [0, 250, 154],
              mediumturquoise: [72, 209, 204],
              mediumvioletred: [199, 21, 133],
              midnightblue: [25, 25, 112],
              mintcream: [245, 255, 250],
              mistyrose: [255, 228, 225],
              moccasin: [255, 228, 181],
              navajowhite: [255, 222, 173],
              navy: [0, 0, 128],
              oldlace: [253, 245, 230],
              olive: [128, 128, 0],
              olivedrab: [107, 142, 35],
              orange: [255, 165, 0],
              orangered: [255, 69, 0],
              orchid: [218, 112, 214],
              palegoldenrod: [238, 232, 170],
              palegreen: [152, 251, 152],
              paleturquoise: [175, 238, 238],
              palevioletred: [219, 112, 147],
              papayawhip: [255, 239, 213],
              peachpuff: [255, 218, 185],
              peru: [205, 133, 63],
              pink: [255, 192, 203],
              plum: [221, 160, 221],
              powderblue: [176, 224, 230],
              purple: [128, 0, 128],
              rebeccapurple: [102, 51, 153],
              red: [255, 0, 0],
              rosybrown: [188, 143, 143],
              royalblue: [65, 105, 225],
              saddlebrown: [139, 69, 19],
              salmon: [250, 128, 114],
              sandybrown: [244, 164, 96],
              seagreen: [46, 139, 87],
              seashell: [255, 245, 238],
              sienna: [160, 82, 45],
              silver: [192, 192, 192],
              skyblue: [135, 206, 235],
              slateblue: [106, 90, 205],
              slategray: [112, 128, 144],
              slategrey: [112, 128, 144],
              snow: [255, 250, 250],
              springgreen: [0, 255, 127],
              steelblue: [70, 130, 180],
              tan: [210, 180, 140],
              teal: [0, 128, 128],
              thistle: [216, 191, 216],
              tomato: [255, 99, 71],
              turquoise: [64, 224, 208],
              violet: [238, 130, 238],
              wheat: [245, 222, 179],
              white: [255, 255, 255],
              whitesmoke: [245, 245, 245],
              yellow: [255, 255, 0],
              yellowgreen: [154, 205, 50],
            };
            function dn(n, t, r) {
              return n + r * (t - n);
            }
            function wn(n, t, r) {
              return n.map((a, c) => dn(a, t[c], r));
            }
            class Cr {
              constructor(t, r, a, c = 1, p = !0) {
                (this.r = t),
                  (this.g = r),
                  (this.b = a),
                  (this.a = c),
                  p ||
                    ((this.r *= c),
                    (this.g *= c),
                    (this.b *= c),
                    c || this.overwriteGetter("rgb", [t, r, a, c]));
              }
              static parse(t) {
                if (t instanceof Cr) return t;
                if (typeof t != "string") return;
                const r = (function (a) {
                  if ((a = a.toLowerCase().trim()) === "transparent")
                    return [0, 0, 0, 0];
                  const c = Ci(_r, a);
                  if (c) {
                    const [m, v, b] = c;
                    return [m / 255, v / 255, b / 255, 1];
                  }
                  if (
                    a.startsWith("#") &&
                    /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)
                  ) {
                    const m = a.length < 6 ? 1 : 2;
                    let v = 1;
                    return [
                      Xn(a.slice(v, (v += m))),
                      Xn(a.slice(v, (v += m))),
                      Xn(a.slice(v, (v += m))),
                      Xn(a.slice(v, v + m) || "ff"),
                    ];
                  }
                  if (a.startsWith("rgb")) {
                    const m = a.match(
                      /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
                    );
                    if (m) {
                      const [v, b, C, I, R, U, Z, X, Q, ie, he, Oe] = m,
                        ye = [I || " ", Z || " ", ie].join("");
                      if (
                        ye === "  " ||
                        ye === "  /" ||
                        ye === ",," ||
                        ye === ",,,"
                      ) {
                        const Ce = [C, U, Q].join(""),
                          et = Ce === "%%%" ? 100 : Ce === "" ? 255 : 0;
                        if (et) {
                          const ht = [
                            Vi(+b / et, 0, 1),
                            Vi(+R / et, 0, 1),
                            Vi(+X / et, 0, 1),
                            he ? Mn(+he, Oe) : 1,
                          ];
                          if (Mr(ht)) return ht;
                        }
                      }
                      return;
                    }
                  }
                  const p = a.match(
                    /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
                  );
                  if (p) {
                    const [m, v, b, C, I, R, U, Z, X] = p,
                      Q = [b || " ", I || " ", U].join("");
                    if (
                      Q === "  " ||
                      Q === "  /" ||
                      Q === ",," ||
                      Q === ",,,"
                    ) {
                      const ie = [
                        +v,
                        Vi(+C, 0, 100),
                        Vi(+R, 0, 100),
                        Z ? Mn(+Z, X) : 1,
                      ];
                      if (Mr(ie))
                        return (function ([he, Oe, ye, Ce]) {
                          function et(ht) {
                            const Rt = (ht + he / 30) % 12,
                              or = Oe * Math.min(ye, 1 - ye);
                            return (
                              ye -
                              or * Math.max(-1, Math.min(Rt - 3, 9 - Rt, 1))
                            );
                          }
                          return (
                            (he = Do(he)),
                            (Oe /= 100),
                            (ye /= 100),
                            [et(0), et(8), et(4), Ce]
                          );
                        })(ie);
                    }
                  }
                })(t);
                return r ? new Cr(...r, !1) : void 0;
              }
              get rgb() {
                const { r: t, g: r, b: a, a: c } = this,
                  p = c || 1 / 0;
                return this.overwriteGetter("rgb", [t / p, r / p, a / p, c]);
              }
              get hcl() {
                return this.overwriteGetter(
                  "hcl",
                  (function (t) {
                    const [r, a, c, p] = Sa(t),
                      m = Math.sqrt(a * a + c * c);
                    return [
                      Math.round(1e4 * m) ? Do(Math.atan2(c, a) * Na) : NaN,
                      m,
                      r,
                      p,
                    ];
                  })(this.rgb)
                );
              }
              get lab() {
                return this.overwriteGetter("lab", Sa(this.rgb));
              }
              overwriteGetter(t, r) {
                return Object.defineProperty(this, t, { value: r }), r;
              }
              toString() {
                const [t, r, a, c] = this.rgb;
                return `rgba(${[t, r, a]
                  .map((p) => Math.round(255 * p))
                  .join(",")},${c})`;
              }
              static interpolate(t, r, a, c = "rgb") {
                switch (c) {
                  case "rgb": {
                    const [p, m, v, b] = wn(t.rgb, r.rgb, a);
                    return new Cr(p, m, v, b, !1);
                  }
                  case "hcl": {
                    const [p, m, v, b] = t.hcl,
                      [C, I, R, U] = r.hcl;
                    let Z, X;
                    if (isNaN(p) || isNaN(C))
                      isNaN(p)
                        ? isNaN(C)
                          ? (Z = NaN)
                          : ((Z = C), (v !== 1 && v !== 0) || (X = I))
                        : ((Z = p), (R !== 1 && R !== 0) || (X = m));
                    else {
                      let ye = C - p;
                      C > p && ye > 180
                        ? (ye -= 360)
                        : C < p && p - C > 180 && (ye += 360),
                        (Z = p + a * ye);
                    }
                    const [Q, ie, he, Oe] = (function ([ye, Ce, et, ht]) {
                      return (
                        (ye = isNaN(ye) ? 0 : ye * Ta),
                        Kt([et, Math.cos(ye) * Ce, Math.sin(ye) * Ce, ht])
                      );
                    })([Z, X ?? dn(m, I, a), dn(v, R, a), dn(b, U, a)]);
                    return new Cr(Q, ie, he, Oe, !1);
                  }
                  case "lab": {
                    const [p, m, v, b] = Kt(wn(t.lab, r.lab, a));
                    return new Cr(p, m, v, b, !1);
                  }
                }
              }
            }
            (Cr.black = new Cr(0, 0, 0, 1)),
              (Cr.white = new Cr(1, 1, 1, 1)),
              (Cr.transparent = new Cr(0, 0, 0, 0)),
              (Cr.red = new Cr(1, 0, 0, 1));
            class Pr {
              constructor(t, r, a) {
                (this.sensitivity = t
                  ? r
                    ? "variant"
                    : "case"
                  : r
                  ? "accent"
                  : "base"),
                  (this.locale = a),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    { sensitivity: this.sensitivity, usage: "search" }
                  ));
              }
              compare(t, r) {
                return this.collator.compare(t, r);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : []
                ).resolvedOptions().locale;
              }
            }
            const Cn = ["bottom", "center", "top"];
            class Vn {
              constructor(t, r, a, c, p, m) {
                (this.text = t),
                  (this.image = r),
                  (this.scale = a),
                  (this.fontStack = c),
                  (this.textColor = p),
                  (this.verticalAlign = m);
              }
            }
            class kn {
              constructor(t) {
                this.sections = t;
              }
              static fromString(t) {
                return new kn([new Vn(t, null, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  this.sections.length === 0 ||
                  !this.sections.some(
                    (t) =>
                      t.text.length !== 0 ||
                      (t.image && t.image.name.length !== 0)
                  )
                );
              }
              static factory(t) {
                return t instanceof kn ? t : kn.fromString(t);
              }
              toString() {
                return this.sections.length === 0
                  ? ""
                  : this.sections.map((t) => t.text).join("");
              }
            }
            class Sn {
              constructor(t) {
                this.values = t.slice();
              }
              static parse(t) {
                if (t instanceof Sn) return t;
                if (typeof t == "number") return new Sn([t, t, t, t]);
                if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                  for (const r of t) if (typeof r != "number") return;
                  switch (t.length) {
                    case 1:
                      t = [t[0], t[0], t[0], t[0]];
                      break;
                    case 2:
                      t = [t[0], t[1], t[0], t[1]];
                      break;
                    case 3:
                      t = [t[0], t[1], t[2], t[1]];
                  }
                  return new Sn(t);
                }
              }
              toString() {
                return JSON.stringify(this.values);
              }
              static interpolate(t, r, a) {
                return new Sn(wn(t.values, r.values, a));
              }
            }
            class Qr {
              constructor(t) {
                this.values = t.slice();
              }
              static parse(t) {
                if (t instanceof Qr) return t;
                if (typeof t == "number") return new Qr([t]);
                if (Array.isArray(t)) {
                  for (const r of t) if (typeof r != "number") return;
                  return new Qr(t);
                }
              }
              toString() {
                return JSON.stringify(this.values);
              }
              static interpolate(t, r, a) {
                return new Qr(wn(t.values, r.values, a));
              }
            }
            class Ar {
              constructor(t) {
                this.values = t.slice();
              }
              static parse(t) {
                if (t instanceof Ar) return t;
                if (typeof t == "string") {
                  const a = Cr.parse(t);
                  return a ? new Ar([a]) : void 0;
                }
                if (!Array.isArray(t)) return;
                const r = [];
                for (const a of t) {
                  if (typeof a != "string") return;
                  const c = Cr.parse(a);
                  if (!c) return;
                  r.push(c);
                }
                return new Ar(r);
              }
              toString() {
                return JSON.stringify(this.values);
              }
              static interpolate(t, r, a, c = "rgb") {
                const p = [];
                if (t.values.length != r.values.length)
                  throw new Error(
                    `colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`
                  );
                for (let m = 0; m < t.values.length; m++)
                  p.push(Cr.interpolate(t.values[m], r.values[m], a, c));
                return new Ar(p);
              }
            }
            class sn extends Error {
              constructor(t) {
                super(t), (this.name = "RuntimeError");
              }
              toJSON() {
                return this.message;
              }
            }
            const qn = new Set([
              "center",
              "left",
              "right",
              "top",
              "bottom",
              "top-left",
              "top-right",
              "bottom-left",
              "bottom-right",
            ]);
            class pn {
              constructor(t) {
                this.values = t.slice();
              }
              static parse(t) {
                if (t instanceof pn) return t;
                if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                  for (let r = 0; r < t.length; r += 2) {
                    const a = t[r],
                      c = t[r + 1];
                    if (
                      typeof a != "string" ||
                      !qn.has(a) ||
                      !Array.isArray(c) ||
                      c.length !== 2 ||
                      typeof c[0] != "number" ||
                      typeof c[1] != "number"
                    )
                      return;
                  }
                  return new pn(t);
                }
              }
              toString() {
                return JSON.stringify(this.values);
              }
              static interpolate(t, r, a) {
                const c = t.values,
                  p = r.values;
                if (c.length !== p.length)
                  throw new sn(
                    `Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`
                  );
                const m = [];
                for (let v = 0; v < c.length; v += 2) {
                  if (c[v] !== p[v])
                    throw new sn(
                      `Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${p[v]}`
                    );
                  m.push(c[v]);
                  const [b, C] = c[v + 1],
                    [I, R] = p[v + 1];
                  m.push([dn(b, I, a), dn(C, R, a)]);
                }
                return new pn(m);
              }
            }
            class En {
              constructor(t) {
                (this.name = t.name), (this.available = t.available);
              }
              toString() {
                return this.name;
              }
              static fromString(t) {
                return t ? new En({ name: t, available: !1 }) : null;
              }
            }
            class Yn {
              constructor(t, r, a) {
                (this.from = t), (this.to = r), (this.transition = a);
              }
              static interpolate(t, r, a) {
                return new Yn(t, r, a);
              }
              static parse(t) {
                return t instanceof Yn
                  ? t
                  : Array.isArray(t) &&
                    t.length === 3 &&
                    typeof t[0] == "string" &&
                    typeof t[1] == "string" &&
                    typeof t[2] == "number"
                  ? new Yn(t[0], t[1], t[2])
                  : typeof t == "object" &&
                    typeof t.from == "string" &&
                    typeof t.to == "string" &&
                    typeof t.transition == "number"
                  ? new Yn(t.from, t.to, t.transition)
                  : typeof t == "string"
                  ? new Yn(t, t, 1)
                  : void 0;
              }
            }
            function _a(n, t, r, a) {
              return typeof n == "number" &&
                n >= 0 &&
                n <= 255 &&
                typeof t == "number" &&
                t >= 0 &&
                t <= 255 &&
                typeof r == "number" &&
                r >= 0 &&
                r <= 255
                ? a === void 0 || (typeof a == "number" && a >= 0 && a <= 1)
                  ? null
                  : `Invalid rgba value [${[n, t, r, a].join(
                      ", "
                    )}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${(typeof a == "number"
                    ? [n, t, r, a]
                    : [n, t, r]
                  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function ea(n) {
              if (
                n === null ||
                typeof n == "string" ||
                typeof n == "boolean" ||
                typeof n == "number" ||
                n instanceof Yn ||
                n instanceof Cr ||
                n instanceof Pr ||
                n instanceof kn ||
                n instanceof Sn ||
                n instanceof Qr ||
                n instanceof Ar ||
                n instanceof pn ||
                n instanceof En
              )
                return !0;
              if (Array.isArray(n)) {
                for (const t of n) if (!ea(t)) return !1;
                return !0;
              }
              if (typeof n == "object") {
                for (const t in n) if (!ea(n[t])) return !1;
                return !0;
              }
              return !1;
            }
            function Dn(n) {
              if (n === null) return Qt;
              if (typeof n == "string") return $t;
              if (typeof n == "boolean") return st;
              if (typeof n == "number") return rt;
              if (n instanceof Cr) return gt;
              if (n instanceof Yn) return Ut;
              if (n instanceof Pr) return sr;
              if (n instanceof kn) return wr;
              if (n instanceof Sn) return jr;
              if (n instanceof Qr) return fr;
              if (n instanceof Ar) return Yr;
              if (n instanceof pn) return nn;
              if (n instanceof En) return Zr;
              if (Array.isArray(n)) {
                const t = n.length;
                let r;
                for (const a of n) {
                  const c = Dn(a);
                  if (r) {
                    if (r === c) continue;
                    r = wt;
                    break;
                  }
                  r = c;
                }
                return Tn(r || wt, t);
              }
              return br;
            }
            function ga(n) {
              const t = typeof n;
              return n === null
                ? ""
                : t === "string" || t === "number" || t === "boolean"
                ? String(n)
                : n instanceof Cr ||
                  n instanceof Yn ||
                  n instanceof kn ||
                  n instanceof Sn ||
                  n instanceof Qr ||
                  n instanceof Ar ||
                  n instanceof pn ||
                  n instanceof En
                ? n.toString()
                : JSON.stringify(n);
            }
            class ta {
              constructor(t, r) {
                (this.type = t), (this.value = r);
              }
              static parse(t, r) {
                if (t.length !== 2)
                  return r.error(
                    `'literal' expression requires exactly one argument, but found ${
                      t.length - 1
                    } instead.`
                  );
                if (!ea(t[1])) return r.error("invalid value");
                const a = t[1];
                let c = Dn(a);
                const p = r.expectedType;
                return (
                  c.kind !== "array" ||
                    c.N !== 0 ||
                    !p ||
                    p.kind !== "array" ||
                    (typeof p.N == "number" && p.N !== 0) ||
                    (c = p),
                  new ta(c, a)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
            }
            const va = { string: $t, number: rt, boolean: st, object: br };
            class _n {
              constructor(t, r) {
                (this.type = t), (this.args = r);
              }
              static parse(t, r) {
                if (t.length < 2)
                  return r.error("Expected at least one argument.");
                let a,
                  c = 1;
                const p = t[0];
                if (p === "array") {
                  let v, b;
                  if (t.length > 2) {
                    const C = t[1];
                    if (typeof C != "string" || !(C in va) || C === "object")
                      return r.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1
                      );
                    (v = va[C]), c++;
                  } else v = wt;
                  if (t.length > 3) {
                    if (
                      t[2] !== null &&
                      (typeof t[2] != "number" ||
                        t[2] < 0 ||
                        t[2] !== Math.floor(t[2]))
                    )
                      return r.error(
                        'The length argument to "array" must be a positive integer literal',
                        2
                      );
                    (b = t[2]), c++;
                  }
                  a = Tn(v, b);
                } else {
                  if (!va[p])
                    throw new Error(`Types doesn't contain name = ${p}`);
                  a = va[p];
                }
                const m = [];
                for (; c < t.length; c++) {
                  const v = r.parse(t[c], c, wt);
                  if (!v) return null;
                  m.push(v);
                }
                return new _n(a, m);
              }
              evaluate(t) {
                for (let r = 0; r < this.args.length; r++) {
                  const a = this.args[r].evaluate(t);
                  if (!Rn(this.type, Dn(a))) return a;
                  if (r === this.args.length - 1)
                    throw new sn(
                      `Expected value to be of type ${gn(
                        this.type
                      )}, but found ${gn(Dn(a))} instead.`
                    );
                }
                throw new Error();
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
            }
            const ja = {
              "to-boolean": st,
              "to-color": gt,
              "to-number": rt,
              "to-string": $t,
            };
            class en {
              constructor(t, r) {
                (this.type = t), (this.args = r);
              }
              static parse(t, r) {
                if (t.length < 2)
                  return r.error("Expected at least one argument.");
                const a = t[0];
                if (!ja[a])
                  throw new Error(
                    `Can't parse ${a} as it is not part of the known types`
                  );
                if ((a === "to-boolean" || a === "to-string") && t.length !== 2)
                  return r.error("Expected one argument.");
                const c = ja[a],
                  p = [];
                for (let m = 1; m < t.length; m++) {
                  const v = r.parse(t[m], m, wt);
                  if (!v) return null;
                  p.push(v);
                }
                return new en(c, p);
              }
              evaluate(t) {
                switch (this.type.kind) {
                  case "boolean":
                    return !!this.args[0].evaluate(t);
                  case "color": {
                    let r, a;
                    for (const c of this.args) {
                      if (((r = c.evaluate(t)), (a = null), r instanceof Cr))
                        return r;
                      if (typeof r == "string") {
                        const p = t.parseColor(r);
                        if (p) return p;
                      } else if (
                        Array.isArray(r) &&
                        ((a =
                          r.length < 3 || r.length > 4
                            ? `Invalid rgba value ${JSON.stringify(
                                r
                              )}: expected an array containing either three or four numeric values.`
                            : _a(r[0], r[1], r[2], r[3])),
                        !a)
                      )
                        return new Cr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
                    }
                    throw new sn(
                      a ||
                        `Could not parse color from value '${
                          typeof r == "string" ? r : JSON.stringify(r)
                        }'`
                    );
                  }
                  case "padding": {
                    let r;
                    for (const a of this.args) {
                      r = a.evaluate(t);
                      const c = Sn.parse(r);
                      if (c) return c;
                    }
                    throw new sn(
                      `Could not parse padding from value '${
                        typeof r == "string" ? r : JSON.stringify(r)
                      }'`
                    );
                  }
                  case "numberArray": {
                    let r;
                    for (const a of this.args) {
                      r = a.evaluate(t);
                      const c = Qr.parse(r);
                      if (c) return c;
                    }
                    throw new sn(
                      `Could not parse numberArray from value '${
                        typeof r == "string" ? r : JSON.stringify(r)
                      }'`
                    );
                  }
                  case "colorArray": {
                    let r;
                    for (const a of this.args) {
                      r = a.evaluate(t);
                      const c = Ar.parse(r);
                      if (c) return c;
                    }
                    throw new sn(
                      `Could not parse colorArray from value '${
                        typeof r == "string" ? r : JSON.stringify(r)
                      }'`
                    );
                  }
                  case "variableAnchorOffsetCollection": {
                    let r;
                    for (const a of this.args) {
                      r = a.evaluate(t);
                      const c = pn.parse(r);
                      if (c) return c;
                    }
                    throw new sn(
                      `Could not parse variableAnchorOffsetCollection from value '${
                        typeof r == "string" ? r : JSON.stringify(r)
                      }'`
                    );
                  }
                  case "number": {
                    let r = null;
                    for (const a of this.args) {
                      if (((r = a.evaluate(t)), r === null)) return 0;
                      const c = Number(r);
                      if (!isNaN(c)) return c;
                    }
                    throw new sn(
                      `Could not convert ${JSON.stringify(r)} to number.`
                    );
                  }
                  case "formatted":
                    return kn.fromString(ga(this.args[0].evaluate(t)));
                  case "resolvedImage":
                    return En.fromString(ga(this.args[0].evaluate(t)));
                  case "projectionDefinition":
                    return this.args[0].evaluate(t);
                  default:
                    return ga(this.args[0].evaluate(t));
                }
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
            }
            const ln = ["Unknown", "Point", "LineString", "Polygon"];
            class vo {
              constructor() {
                (this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = new Map()),
                  (this.availableImages = null),
                  (this.canonical = null);
              }
              id() {
                return this.feature && "id" in this.feature
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? typeof this.feature.type == "number"
                    ? ln[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              parseColor(t) {
                let r = this._parseColorCache.get(t);
                return (
                  r || ((r = Cr.parse(t)), this._parseColorCache.set(t, r)), r
                );
              }
            }
            class xn {
              constructor(t, r, a = [], c, p = new zt(), m = []) {
                (this.registry = t),
                  (this.path = a),
                  (this.key = a.map((v) => `[${v}]`).join("")),
                  (this.scope = p),
                  (this.errors = m),
                  (this.expectedType = c),
                  (this._isConstant = r);
              }
              parse(t, r, a, c, p = {}) {
                return r
                  ? this.concat(r, a, c)._parse(t, p)
                  : this._parse(t, p);
              }
              _parse(t, r) {
                function a(c, p, m) {
                  return m === "assert"
                    ? new _n(p, [c])
                    : m === "coerce"
                    ? new en(p, [c])
                    : c;
                }
                if (
                  ((t !== null &&
                    typeof t != "string" &&
                    typeof t != "boolean" &&
                    typeof t != "number") ||
                    (t = ["literal", t]),
                  Array.isArray(t))
                ) {
                  if (t.length === 0)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
                    );
                  const c = t[0];
                  if (typeof c != "string")
                    return (
                      this.error(
                        `Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`,
                        0
                      ),
                      null
                    );
                  const p = this.registry[c];
                  if (p) {
                    let m = p.parse(t, this);
                    if (!m) return null;
                    if (this.expectedType) {
                      const v = this.expectedType,
                        b = m.type;
                      if (
                        (v.kind !== "string" &&
                          v.kind !== "number" &&
                          v.kind !== "boolean" &&
                          v.kind !== "object" &&
                          v.kind !== "array") ||
                        b.kind !== "value"
                      ) {
                        if (
                          (v.kind === "projectionDefinition" &&
                            ["string", "array"].includes(b.kind)) ||
                          (["color", "formatted", "resolvedImage"].includes(
                            v.kind
                          ) &&
                            ["value", "string"].includes(b.kind)) ||
                          (["padding", "numberArray"].includes(v.kind) &&
                            ["value", "number", "array"].includes(b.kind)) ||
                          (v.kind === "colorArray" &&
                            ["value", "string", "array"].includes(b.kind)) ||
                          (v.kind === "variableAnchorOffsetCollection" &&
                            ["value", "array"].includes(b.kind))
                        )
                          m = a(m, v, r.typeAnnotation || "coerce");
                        else if (this.checkSubtype(v, b)) return null;
                      } else m = a(m, v, r.typeAnnotation || "assert");
                    }
                    if (
                      !(m instanceof ta) &&
                      m.type.kind !== "resolvedImage" &&
                      this._isConstant(m)
                    ) {
                      const v = new vo();
                      try {
                        m = new ta(m.type, m.evaluate(v));
                      } catch (b) {
                        return this.error(b.message), null;
                      }
                    }
                    return m;
                  }
                  return this.error(
                    `Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                }
                return this.error(
                  t === void 0
                    ? "'undefined' value invalid. Use null instead."
                    : typeof t == "object"
                    ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                    : `Expected an array, but found ${typeof t} instead.`
                );
              }
              concat(t, r, a) {
                const c =
                    typeof t == "number" ? this.path.concat(t) : this.path,
                  p = a ? this.scope.concat(a) : this.scope;
                return new xn(
                  this.registry,
                  this._isConstant,
                  c,
                  r || null,
                  p,
                  this.errors
                );
              }
              error(t, ...r) {
                const a = `${this.key}${r.map((c) => `[${c}]`).join("")}`;
                this.errors.push(new Pn(a, t));
              }
              checkSubtype(t, r) {
                const a = Rn(t, r);
                return a && this.error(a), a;
              }
            }
            class Ya {
              constructor(t, r) {
                (this.type = r.type),
                  (this.bindings = [].concat(t)),
                  (this.result = r);
              }
              evaluate(t) {
                return this.result.evaluate(t);
              }
              eachChild(t) {
                for (const r of this.bindings) t(r[1]);
                t(this.result);
              }
              static parse(t, r) {
                if (t.length < 4)
                  return r.error(
                    `Expected at least 3 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const a = [];
                for (let p = 1; p < t.length - 1; p += 2) {
                  const m = t[p];
                  if (typeof m != "string")
                    return r.error(
                      `Expected string, but found ${typeof m} instead.`,
                      p
                    );
                  if (/[^a-zA-Z0-9_]/.test(m))
                    return r.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      p
                    );
                  const v = r.parse(t[p + 1], p + 1);
                  if (!v) return null;
                  a.push([m, v]);
                }
                const c = r.parse(
                  t[t.length - 1],
                  t.length - 1,
                  r.expectedType,
                  a
                );
                return c ? new Ya(a, c) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
            }
            class Di {
              constructor(t, r) {
                (this.type = r.type),
                  (this.name = t),
                  (this.boundExpression = r);
              }
              static parse(t, r) {
                if (t.length !== 2 || typeof t[1] != "string")
                  return r.error(
                    "'var' expression requires exactly one string literal argument."
                  );
                const a = t[1];
                return r.scope.has(a)
                  ? new Di(a, r.scope.get(a))
                  : r.error(
                      `Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`,
                      1
                    );
              }
              evaluate(t) {
                return this.boundExpression.evaluate(t);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
            }
            class Ro {
              constructor(t, r, a) {
                (this.type = t), (this.index = r), (this.input = a);
              }
              static parse(t, r) {
                if (t.length !== 3)
                  return r.error(
                    `Expected 2 arguments, but found ${t.length - 1} instead.`
                  );
                const a = r.parse(t[1], 1, rt),
                  c = r.parse(t[2], 2, Tn(r.expectedType || wt));
                return a && c ? new Ro(c.type.itemType, a, c) : null;
              }
              evaluate(t) {
                const r = this.index.evaluate(t),
                  a = this.input.evaluate(t);
                if (r < 0) throw new sn(`Array index out of bounds: ${r} < 0.`);
                if (r >= a.length)
                  throw new sn(
                    `Array index out of bounds: ${r} > ${a.length - 1}.`
                  );
                if (r !== Math.floor(r))
                  throw new sn(
                    `Array index must be an integer, but found ${r} instead.`
                  );
                return a[r];
              }
              eachChild(t) {
                t(this.index), t(this.input);
              }
              outputDefined() {
                return !1;
              }
            }
            class Pa {
              constructor(t, r) {
                (this.type = st), (this.needle = t), (this.haystack = r);
              }
              static parse(t, r) {
                if (t.length !== 3)
                  return r.error(
                    `Expected 2 arguments, but found ${t.length - 1} instead.`
                  );
                const a = r.parse(t[1], 1, wt),
                  c = r.parse(t[2], 2, wt);
                return a && c
                  ? hn(a.type, [st, $t, rt, Qt, wt])
                    ? new Pa(a, c)
                    : r.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${gn(
                          a.type
                        )} instead`
                      )
                  : null;
              }
              evaluate(t) {
                const r = this.needle.evaluate(t),
                  a = this.haystack.evaluate(t);
                if (!a) return !1;
                if (!Qn(r, ["boolean", "string", "number", "null"]))
                  throw new sn(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gn(
                      Dn(r)
                    )} instead.`
                  );
                if (!Qn(a, ["string", "array"]))
                  throw new sn(
                    `Expected second argument to be of type array or string, but found ${gn(
                      Dn(a)
                    )} instead.`
                  );
                return a.indexOf(r) >= 0;
              }
              eachChild(t) {
                t(this.needle), t(this.haystack);
              }
              outputDefined() {
                return !0;
              }
            }
            class Ka {
              constructor(t, r, a) {
                (this.type = rt),
                  (this.needle = t),
                  (this.haystack = r),
                  (this.fromIndex = a);
              }
              static parse(t, r) {
                if (t.length <= 2 || t.length >= 5)
                  return r.error(
                    `Expected 2 or 3 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const a = r.parse(t[1], 1, wt),
                  c = r.parse(t[2], 2, wt);
                if (!a || !c) return null;
                if (!hn(a.type, [st, $t, rt, Qt, wt]))
                  return r.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gn(
                      a.type
                    )} instead`
                  );
                if (t.length === 4) {
                  const p = r.parse(t[3], 3, rt);
                  return p ? new Ka(a, c, p) : null;
                }
                return new Ka(a, c);
              }
              evaluate(t) {
                const r = this.needle.evaluate(t),
                  a = this.haystack.evaluate(t);
                if (!Qn(r, ["boolean", "string", "number", "null"]))
                  throw new sn(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gn(
                      Dn(r)
                    )} instead.`
                  );
                let c;
                if (
                  (this.fromIndex && (c = this.fromIndex.evaluate(t)),
                  Qn(a, ["string"]))
                ) {
                  const p = a.indexOf(r, c);
                  return p === -1 ? -1 : [...a.slice(0, p)].length;
                }
                if (Qn(a, ["array"])) return a.indexOf(r, c);
                throw new sn(
                  `Expected second argument to be of type array or string, but found ${gn(
                    Dn(a)
                  )} instead.`
                );
              }
              eachChild(t) {
                t(this.needle),
                  t(this.haystack),
                  this.fromIndex && t(this.fromIndex);
              }
              outputDefined() {
                return !1;
              }
            }
            class Fo {
              constructor(t, r, a, c, p, m) {
                (this.inputType = t),
                  (this.type = r),
                  (this.input = a),
                  (this.cases = c),
                  (this.outputs = p),
                  (this.otherwise = m);
              }
              static parse(t, r) {
                if (t.length < 5)
                  return r.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if (t.length % 2 != 1)
                  return r.error("Expected an even number of arguments.");
                let a, c;
                r.expectedType &&
                  r.expectedType.kind !== "value" &&
                  (c = r.expectedType);
                const p = {},
                  m = [];
                for (let C = 2; C < t.length - 1; C += 2) {
                  let I = t[C];
                  const R = t[C + 1];
                  Array.isArray(I) || (I = [I]);
                  const U = r.concat(C);
                  if (I.length === 0)
                    return U.error("Expected at least one branch label.");
                  for (const X of I) {
                    if (typeof X != "number" && typeof X != "string")
                      return U.error(
                        "Branch labels must be numbers or strings."
                      );
                    if (
                      typeof X == "number" &&
                      Math.abs(X) > Number.MAX_SAFE_INTEGER
                    )
                      return U.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
                      );
                    if (typeof X == "number" && Math.floor(X) !== X)
                      return U.error(
                        "Numeric branch labels must be integer values."
                      );
                    if (a) {
                      if (U.checkSubtype(a, Dn(X))) return null;
                    } else a = Dn(X);
                    if (p[String(X)] !== void 0)
                      return U.error("Branch labels must be unique.");
                    p[String(X)] = m.length;
                  }
                  const Z = r.parse(R, C, c);
                  if (!Z) return null;
                  (c = c || Z.type), m.push(Z);
                }
                const v = r.parse(t[1], 1, wt);
                if (!v) return null;
                const b = r.parse(t[t.length - 1], t.length - 1, c);
                return b
                  ? v.type.kind !== "value" &&
                    r.concat(1).checkSubtype(a, v.type)
                    ? null
                    : new Fo(a, c, v, p, m, b)
                  : null;
              }
              evaluate(t) {
                const r = this.input.evaluate(t);
                return (
                  (Dn(r) === this.inputType && this.outputs[this.cases[r]]) ||
                  this.otherwise
                ).evaluate(t);
              }
              eachChild(t) {
                t(this.input), this.outputs.forEach(t), t(this.otherwise);
              }
              outputDefined() {
                return (
                  this.outputs.every((t) => t.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
            }
            class Tl {
              constructor(t, r, a) {
                (this.type = t), (this.branches = r), (this.otherwise = a);
              }
              static parse(t, r) {
                if (t.length < 4)
                  return r.error(
                    `Expected at least 3 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if (t.length % 2 != 0)
                  return r.error("Expected an odd number of arguments.");
                let a;
                r.expectedType &&
                  r.expectedType.kind !== "value" &&
                  (a = r.expectedType);
                const c = [];
                for (let m = 1; m < t.length - 1; m += 2) {
                  const v = r.parse(t[m], m, st);
                  if (!v) return null;
                  const b = r.parse(t[m + 1], m + 1, a);
                  if (!b) return null;
                  c.push([v, b]), (a = a || b.type);
                }
                const p = r.parse(t[t.length - 1], t.length - 1, a);
                if (!p) return null;
                if (!a) throw new Error("Can't infer output type");
                return new Tl(a, c, p);
              }
              evaluate(t) {
                for (const [r, a] of this.branches)
                  if (r.evaluate(t)) return a.evaluate(t);
                return this.otherwise.evaluate(t);
              }
              eachChild(t) {
                for (const [r, a] of this.branches) t(r), t(a);
                t(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([t, r]) => r.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
            }
            class Sl {
              constructor(t, r, a, c) {
                (this.type = t),
                  (this.input = r),
                  (this.beginIndex = a),
                  (this.endIndex = c);
              }
              static parse(t, r) {
                if (t.length <= 2 || t.length >= 5)
                  return r.error(
                    `Expected 2 or 3 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const a = r.parse(t[1], 1, wt),
                  c = r.parse(t[2], 2, rt);
                if (!a || !c) return null;
                if (!hn(a.type, [Tn(wt), $t, wt]))
                  return r.error(
                    `Expected first argument to be of type array or string, but found ${gn(
                      a.type
                    )} instead`
                  );
                if (t.length === 4) {
                  const p = r.parse(t[3], 3, rt);
                  return p ? new Sl(a.type, a, c, p) : null;
                }
                return new Sl(a.type, a, c);
              }
              evaluate(t) {
                const r = this.input.evaluate(t),
                  a = this.beginIndex.evaluate(t);
                let c;
                if (
                  (this.endIndex && (c = this.endIndex.evaluate(t)),
                  Qn(r, ["string"]))
                )
                  return [...r].slice(a, c).join("");
                if (Qn(r, ["array"])) return r.slice(a, c);
                throw new sn(
                  `Expected first argument to be of type array or string, but found ${gn(
                    Dn(r)
                  )} instead.`
                );
              }
              eachChild(t) {
                t(this.input),
                  t(this.beginIndex),
                  this.endIndex && t(this.endIndex);
              }
              outputDefined() {
                return !1;
              }
            }
            function Ns(n, t) {
              const r = n.length - 1;
              let a,
                c,
                p = 0,
                m = r,
                v = 0;
              for (; p <= m; )
                if (
                  ((v = Math.floor((p + m) / 2)),
                  (a = n[v]),
                  (c = n[v + 1]),
                  a <= t)
                ) {
                  if (v === r || t < c) return v;
                  p = v + 1;
                } else {
                  if (!(a > t)) throw new sn("Input is not a number.");
                  m = v - 1;
                }
              return 0;
            }
            class fs {
              constructor(t, r, a) {
                (this.type = t),
                  (this.input = r),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [c, p] of a)
                  this.labels.push(c), this.outputs.push(p);
              }
              static parse(t, r) {
                if (t.length - 1 < 4)
                  return r.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if ((t.length - 1) % 2 != 0)
                  return r.error("Expected an even number of arguments.");
                const a = r.parse(t[1], 1, rt);
                if (!a) return null;
                const c = [];
                let p = null;
                r.expectedType &&
                  r.expectedType.kind !== "value" &&
                  (p = r.expectedType);
                for (let m = 1; m < t.length; m += 2) {
                  const v = m === 1 ? -1 / 0 : t[m],
                    b = t[m + 1],
                    C = m,
                    I = m + 1;
                  if (typeof v != "number")
                    return r.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      C
                    );
                  if (c.length && c[c.length - 1][0] >= v)
                    return r.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      C
                    );
                  const R = r.parse(b, I, p);
                  if (!R) return null;
                  (p = p || R.type), c.push([v, R]);
                }
                return new fs(p, a, c);
              }
              evaluate(t) {
                const r = this.labels,
                  a = this.outputs;
                if (r.length === 1) return a[0].evaluate(t);
                const c = this.input.evaluate(t);
                if (c <= r[0]) return a[0].evaluate(t);
                const p = r.length;
                return c >= r[p - 1]
                  ? a[p - 1].evaluate(t)
                  : a[Ns(r, c)].evaluate(t);
              }
              eachChild(t) {
                t(this.input);
                for (const r of this.outputs) t(r);
              }
              outputDefined() {
                return this.outputs.every((t) => t.outputDefined());
              }
            }
            function yo(n) {
              return n &&
                n.__esModule &&
                Object.prototype.hasOwnProperty.call(n, "default")
                ? n.default
                : n;
            }
            var Pi,
              js,
              Qh = (function () {
                if (js) return Pi;
                function n(t, r, a, c) {
                  (this.cx = 3 * t),
                    (this.bx = 3 * (a - t) - this.cx),
                    (this.ax = 1 - this.cx - this.bx),
                    (this.cy = 3 * r),
                    (this.by = 3 * (c - r) - this.cy),
                    (this.ay = 1 - this.cy - this.by),
                    (this.p1x = t),
                    (this.p1y = r),
                    (this.p2x = a),
                    (this.p2y = c);
                }
                return (
                  (js = 1),
                  (Pi = n),
                  (n.prototype = {
                    sampleCurveX: function (t) {
                      return ((this.ax * t + this.bx) * t + this.cx) * t;
                    },
                    sampleCurveY: function (t) {
                      return ((this.ay * t + this.by) * t + this.cy) * t;
                    },
                    sampleCurveDerivativeX: function (t) {
                      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
                    },
                    solveCurveX: function (t, r) {
                      if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
                      if (t > 1) return 1;
                      for (var a = t, c = 0; c < 8; c++) {
                        var p = this.sampleCurveX(a) - t;
                        if (Math.abs(p) < r) return a;
                        var m = this.sampleCurveDerivativeX(a);
                        if (Math.abs(m) < 1e-6) break;
                        a -= p / m;
                      }
                      var v = 0,
                        b = 1;
                      for (
                        a = t, c = 0;
                        c < 20 &&
                        ((p = this.sampleCurveX(a)), !(Math.abs(p - t) < r));
                        c++
                      )
                        t > p ? (v = a) : (b = a), (a = 0.5 * (b - v) + v);
                      return a;
                    },
                    solve: function (t, r) {
                      return this.sampleCurveY(this.solveCurveX(t, r));
                    },
                  }),
                  Pi
                );
              })(),
              Cl = yo(Qh);
            class zn {
              constructor(t, r, a, c, p) {
                (this.type = t),
                  (this.operator = r),
                  (this.interpolation = a),
                  (this.input = c),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [m, v] of p)
                  this.labels.push(m), this.outputs.push(v);
              }
              static interpolationFactor(t, r, a, c) {
                let p = 0;
                if (t.name === "exponential") p = Pl(r, t.base, a, c);
                else if (t.name === "linear") p = Pl(r, 1, a, c);
                else if (t.name === "cubic-bezier") {
                  const m = t.controlPoints;
                  p = new Cl(m[0], m[1], m[2], m[3]).solve(Pl(r, 1, a, c));
                }
                return p;
              }
              static parse(t, r) {
                let [a, c, p, ...m] = t;
                if (!Array.isArray(c) || c.length === 0)
                  return r.error(
                    "Expected an interpolation type expression.",
                    1
                  );
                if (c[0] === "linear") c = { name: "linear" };
                else if (c[0] === "exponential") {
                  const C = c[1];
                  if (typeof C != "number")
                    return r.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1
                    );
                  c = { name: "exponential", base: C };
                } else {
                  if (c[0] !== "cubic-bezier")
                    return r.error(
                      `Unknown interpolation type ${String(c[0])}`,
                      1,
                      0
                    );
                  {
                    const C = c.slice(1);
                    if (
                      C.length !== 4 ||
                      C.some((I) => typeof I != "number" || I < 0 || I > 1)
                    )
                      return r.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1
                      );
                    c = { name: "cubic-bezier", controlPoints: C };
                  }
                }
                if (t.length - 1 < 4)
                  return r.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if ((t.length - 1) % 2 != 0)
                  return r.error("Expected an even number of arguments.");
                if (((p = r.parse(p, 2, rt)), !p)) return null;
                const v = [];
                let b = null;
                (a !== "interpolate-hcl" && a !== "interpolate-lab") ||
                r.expectedType == Yr
                  ? r.expectedType &&
                    r.expectedType.kind !== "value" &&
                    (b = r.expectedType)
                  : (b = gt);
                for (let C = 0; C < m.length; C += 2) {
                  const I = m[C],
                    R = m[C + 1],
                    U = C + 3,
                    Z = C + 4;
                  if (typeof I != "number")
                    return r.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      U
                    );
                  if (v.length && v[v.length - 1][0] >= I)
                    return r.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      U
                    );
                  const X = r.parse(R, Z, b);
                  if (!X) return null;
                  (b = b || X.type), v.push([I, X]);
                }
                return li(b, rt) ||
                  li(b, Ut) ||
                  li(b, gt) ||
                  li(b, jr) ||
                  li(b, fr) ||
                  li(b, Yr) ||
                  li(b, nn) ||
                  li(b, Tn(rt))
                  ? new zn(b, a, c, p, v)
                  : r.error(`Type ${gn(b)} is not interpolatable.`);
              }
              evaluate(t) {
                const r = this.labels,
                  a = this.outputs;
                if (r.length === 1) return a[0].evaluate(t);
                const c = this.input.evaluate(t);
                if (c <= r[0]) return a[0].evaluate(t);
                const p = r.length;
                if (c >= r[p - 1]) return a[p - 1].evaluate(t);
                const m = Ns(r, c),
                  v = zn.interpolationFactor(
                    this.interpolation,
                    c,
                    r[m],
                    r[m + 1]
                  ),
                  b = a[m].evaluate(t),
                  C = a[m + 1].evaluate(t);
                switch (this.operator) {
                  case "interpolate":
                    switch (this.type.kind) {
                      case "number":
                        return dn(b, C, v);
                      case "color":
                        return Cr.interpolate(b, C, v);
                      case "padding":
                        return Sn.interpolate(b, C, v);
                      case "colorArray":
                        return Ar.interpolate(b, C, v);
                      case "numberArray":
                        return Qr.interpolate(b, C, v);
                      case "variableAnchorOffsetCollection":
                        return pn.interpolate(b, C, v);
                      case "array":
                        return wn(b, C, v);
                      case "projectionDefinition":
                        return Yn.interpolate(b, C, v);
                    }
                  case "interpolate-hcl":
                    switch (this.type.kind) {
                      case "color":
                        return Cr.interpolate(b, C, v, "hcl");
                      case "colorArray":
                        return Ar.interpolate(b, C, v, "hcl");
                    }
                  case "interpolate-lab":
                    switch (this.type.kind) {
                      case "color":
                        return Cr.interpolate(b, C, v, "lab");
                      case "colorArray":
                        return Ar.interpolate(b, C, v, "lab");
                    }
                }
              }
              eachChild(t) {
                t(this.input);
                for (const r of this.outputs) t(r);
              }
              outputDefined() {
                return this.outputs.every((t) => t.outputDefined());
              }
            }
            function Pl(n, t, r, a) {
              const c = a - r,
                p = n - r;
              return c === 0
                ? 0
                : t === 1
                ? p / c
                : (Math.pow(t, p) - 1) / (Math.pow(t, c) - 1);
            }
            const ya = {
              color: Cr.interpolate,
              number: dn,
              padding: Sn.interpolate,
              numberArray: Qr.interpolate,
              colorArray: Ar.interpolate,
              variableAnchorOffsetCollection: pn.interpolate,
              array: wn,
            };
            class Vs {
              constructor(t, r) {
                (this.type = t), (this.args = r);
              }
              static parse(t, r) {
                if (t.length < 2)
                  return r.error("Expected at least one argument.");
                let a = null;
                const c = r.expectedType;
                c && c.kind !== "value" && (a = c);
                const p = [];
                for (const v of t.slice(1)) {
                  const b = r.parse(v, 1 + p.length, a, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!b) return null;
                  (a = a || b.type), p.push(b);
                }
                if (!a) throw new Error("No output type");
                const m = c && p.some((v) => Rn(c, v.type));
                return new Vs(m ? wt : a, p);
              }
              evaluate(t) {
                let r,
                  a = null,
                  c = 0;
                for (const p of this.args)
                  if (
                    (c++,
                    (a = p.evaluate(t)),
                    a &&
                      a instanceof En &&
                      !a.available &&
                      (r || (r = a.name),
                      (a = null),
                      c === this.args.length && (a = r)),
                    a !== null)
                  )
                    break;
                return a;
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
            }
            function ed(n, t) {
              return n === "==" || n === "!="
                ? t.kind === "boolean" ||
                    t.kind === "string" ||
                    t.kind === "number" ||
                    t.kind === "null" ||
                    t.kind === "value"
                : t.kind === "string" ||
                    t.kind === "number" ||
                    t.kind === "value";
            }
            function Bo(n, t, r, a) {
              return a.compare(t, r) === 0;
            }
            function Ja(n, t, r) {
              const a = n !== "==" && n !== "!=";
              return class Q0 {
                constructor(p, m, v) {
                  (this.type = st),
                    (this.lhs = p),
                    (this.rhs = m),
                    (this.collator = v),
                    (this.hasUntypedArgument =
                      p.type.kind === "value" || m.type.kind === "value");
                }
                static parse(p, m) {
                  if (p.length !== 3 && p.length !== 4)
                    return m.error("Expected two or three arguments.");
                  const v = p[0];
                  let b = m.parse(p[1], 1, wt);
                  if (!b) return null;
                  if (!ed(v, b.type))
                    return m
                      .concat(1)
                      .error(
                        `"${v}" comparisons are not supported for type '${gn(
                          b.type
                        )}'.`
                      );
                  let C = m.parse(p[2], 2, wt);
                  if (!C) return null;
                  if (!ed(v, C.type))
                    return m
                      .concat(2)
                      .error(
                        `"${v}" comparisons are not supported for type '${gn(
                          C.type
                        )}'.`
                      );
                  if (
                    b.type.kind !== C.type.kind &&
                    b.type.kind !== "value" &&
                    C.type.kind !== "value"
                  )
                    return m.error(
                      `Cannot compare types '${gn(b.type)}' and '${gn(
                        C.type
                      )}'.`
                    );
                  a &&
                    (b.type.kind === "value" && C.type.kind !== "value"
                      ? (b = new _n(C.type, [b]))
                      : b.type.kind !== "value" &&
                        C.type.kind === "value" &&
                        (C = new _n(b.type, [C])));
                  let I = null;
                  if (p.length === 4) {
                    if (
                      b.type.kind !== "string" &&
                      C.type.kind !== "string" &&
                      b.type.kind !== "value" &&
                      C.type.kind !== "value"
                    )
                      return m.error(
                        "Cannot use collator to compare non-string types."
                      );
                    if (((I = m.parse(p[3], 3, sr)), !I)) return null;
                  }
                  return new Q0(b, C, I);
                }
                evaluate(p) {
                  const m = this.lhs.evaluate(p),
                    v = this.rhs.evaluate(p);
                  if (a && this.hasUntypedArgument) {
                    const b = Dn(m),
                      C = Dn(v);
                    if (
                      b.kind !== C.kind ||
                      (b.kind !== "string" && b.kind !== "number")
                    )
                      throw new sn(
                        `Expected arguments for "${n}" to be (string, string) or (number, number), but found (${b.kind}, ${C.kind}) instead.`
                      );
                  }
                  if (this.collator && !a && this.hasUntypedArgument) {
                    const b = Dn(m),
                      C = Dn(v);
                    if (b.kind !== "string" || C.kind !== "string")
                      return t(p, m, v);
                  }
                  return this.collator
                    ? r(p, m, v, this.collator.evaluate(p))
                    : t(p, m, v);
                }
                eachChild(p) {
                  p(this.lhs), p(this.rhs), this.collator && p(this.collator);
                }
                outputDefined() {
                  return !0;
                }
              };
            }
            const jc = Ja(
                "==",
                function (n, t, r) {
                  return t === r;
                },
                Bo
              ),
              rf = Ja(
                "!=",
                function (n, t, r) {
                  return t !== r;
                },
                function (n, t, r, a) {
                  return !Bo(0, t, r, a);
                }
              ),
              td = Ja(
                "<",
                function (n, t, r) {
                  return t < r;
                },
                function (n, t, r, a) {
                  return a.compare(t, r) < 0;
                }
              ),
              Il = Ja(
                ">",
                function (n, t, r) {
                  return t > r;
                },
                function (n, t, r, a) {
                  return a.compare(t, r) > 0;
                }
              ),
              Ml = Ja(
                "<=",
                function (n, t, r) {
                  return t <= r;
                },
                function (n, t, r, a) {
                  return a.compare(t, r) <= 0;
                }
              ),
              Ia = Ja(
                ">=",
                function (n, t, r) {
                  return t >= r;
                },
                function (n, t, r, a) {
                  return a.compare(t, r) >= 0;
                }
              );
            class qs {
              constructor(t, r, a) {
                (this.type = sr),
                  (this.locale = a),
                  (this.caseSensitive = t),
                  (this.diacriticSensitive = r);
              }
              static parse(t, r) {
                if (t.length !== 2) return r.error("Expected one argument.");
                const a = t[1];
                if (typeof a != "object" || Array.isArray(a))
                  return r.error(
                    "Collator options argument must be an object."
                  );
                const c = r.parse(
                  a["case-sensitive"] !== void 0 && a["case-sensitive"],
                  1,
                  st
                );
                if (!c) return null;
                const p = r.parse(
                  a["diacritic-sensitive"] !== void 0 &&
                    a["diacritic-sensitive"],
                  1,
                  st
                );
                if (!p) return null;
                let m = null;
                return a.locale && ((m = r.parse(a.locale, 1, $t)), !m)
                  ? null
                  : new qs(c, p, m);
              }
              evaluate(t) {
                return new Pr(
                  this.caseSensitive.evaluate(t),
                  this.diacriticSensitive.evaluate(t),
                  this.locale ? this.locale.evaluate(t) : null
                );
              }
              eachChild(t) {
                t(this.caseSensitive),
                  t(this.diacriticSensitive),
                  this.locale && t(this.locale);
              }
              outputDefined() {
                return !1;
              }
            }
            class ms {
              constructor(t, r, a, c, p) {
                (this.type = $t),
                  (this.number = t),
                  (this.locale = r),
                  (this.currency = a),
                  (this.minFractionDigits = c),
                  (this.maxFractionDigits = p);
              }
              static parse(t, r) {
                if (t.length !== 3) return r.error("Expected two arguments.");
                const a = r.parse(t[1], 1, rt);
                if (!a) return null;
                const c = t[2];
                if (typeof c != "object" || Array.isArray(c))
                  return r.error(
                    "NumberFormat options argument must be an object."
                  );
                let p = null;
                if (c.locale && ((p = r.parse(c.locale, 1, $t)), !p))
                  return null;
                let m = null;
                if (c.currency && ((m = r.parse(c.currency, 1, $t)), !m))
                  return null;
                let v = null;
                if (
                  c["min-fraction-digits"] &&
                  ((v = r.parse(c["min-fraction-digits"], 1, rt)), !v)
                )
                  return null;
                let b = null;
                return c["max-fraction-digits"] &&
                  ((b = r.parse(c["max-fraction-digits"], 1, rt)), !b)
                  ? null
                  : new ms(a, p, m, v, b);
              }
              evaluate(t) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(t) : [],
                  {
                    style: this.currency ? "currency" : "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(t)
                      : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(t)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(t)
                      : void 0,
                  }
                ).format(this.number.evaluate(t));
              }
              eachChild(t) {
                t(this.number),
                  this.locale && t(this.locale),
                  this.currency && t(this.currency),
                  this.minFractionDigits && t(this.minFractionDigits),
                  this.maxFractionDigits && t(this.maxFractionDigits);
              }
              outputDefined() {
                return !1;
              }
            }
            class Al {
              constructor(t) {
                (this.type = wr), (this.sections = t);
              }
              static parse(t, r) {
                if (t.length < 2)
                  return r.error("Expected at least one argument.");
                const a = t[1];
                if (!Array.isArray(a) && typeof a == "object")
                  return r.error(
                    "First argument must be an image or text section."
                  );
                const c = [];
                let p = !1;
                for (let m = 1; m <= t.length - 1; ++m) {
                  const v = t[m];
                  if (p && typeof v == "object" && !Array.isArray(v)) {
                    p = !1;
                    let b = null;
                    if (
                      v["font-scale"] &&
                      ((b = r.parse(v["font-scale"], 1, rt)), !b)
                    )
                      return null;
                    let C = null;
                    if (
                      v["text-font"] &&
                      ((C = r.parse(v["text-font"], 1, Tn($t))), !C)
                    )
                      return null;
                    let I = null;
                    if (
                      v["text-color"] &&
                      ((I = r.parse(v["text-color"], 1, gt)), !I)
                    )
                      return null;
                    let R = null;
                    if (v["vertical-align"]) {
                      if (
                        typeof v["vertical-align"] == "string" &&
                        !Cn.includes(v["vertical-align"])
                      )
                        return r.error(
                          `'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`
                        );
                      if (((R = r.parse(v["vertical-align"], 1, $t)), !R))
                        return null;
                    }
                    const U = c[c.length - 1];
                    (U.scale = b),
                      (U.font = C),
                      (U.textColor = I),
                      (U.verticalAlign = R);
                  } else {
                    const b = r.parse(t[m], 1, wt);
                    if (!b) return null;
                    const C = b.type.kind;
                    if (
                      C !== "string" &&
                      C !== "value" &&
                      C !== "null" &&
                      C !== "resolvedImage"
                    )
                      return r.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'."
                      );
                    (p = !0),
                      c.push({
                        content: b,
                        scale: null,
                        font: null,
                        textColor: null,
                        verticalAlign: null,
                      });
                  }
                }
                return new Al(c);
              }
              evaluate(t) {
                return new kn(
                  this.sections.map((r) => {
                    const a = r.content.evaluate(t);
                    return Dn(a) === Zr
                      ? new Vn(
                          "",
                          a,
                          null,
                          null,
                          null,
                          r.verticalAlign ? r.verticalAlign.evaluate(t) : null
                        )
                      : new Vn(
                          ga(a),
                          null,
                          r.scale ? r.scale.evaluate(t) : null,
                          r.font ? r.font.evaluate(t).join(",") : null,
                          r.textColor ? r.textColor.evaluate(t) : null,
                          r.verticalAlign ? r.verticalAlign.evaluate(t) : null
                        );
                  })
                );
              }
              eachChild(t) {
                for (const r of this.sections)
                  t(r.content),
                    r.scale && t(r.scale),
                    r.font && t(r.font),
                    r.textColor && t(r.textColor),
                    r.verticalAlign && t(r.verticalAlign);
              }
              outputDefined() {
                return !1;
              }
            }
            class Us {
              constructor(t) {
                (this.type = Zr), (this.input = t);
              }
              static parse(t, r) {
                if (t.length !== 2) return r.error("Expected two arguments.");
                const a = r.parse(t[1], 1, $t);
                return a ? new Us(a) : r.error("No image name provided.");
              }
              evaluate(t) {
                const r = this.input.evaluate(t),
                  a = En.fromString(r);
                return (
                  a &&
                    t.availableImages &&
                    (a.available = t.availableImages.indexOf(r) > -1),
                  a
                );
              }
              eachChild(t) {
                t(this.input);
              }
              outputDefined() {
                return !1;
              }
            }
            class Vc {
              constructor(t) {
                (this.type = rt), (this.input = t);
              }
              static parse(t, r) {
                if (t.length !== 2)
                  return r.error(
                    `Expected 1 argument, but found ${t.length - 1} instead.`
                  );
                const a = r.parse(t[1], 1);
                return a
                  ? a.type.kind !== "array" &&
                    a.type.kind !== "string" &&
                    a.type.kind !== "value"
                    ? r.error(
                        `Expected argument of type string or array, but found ${gn(
                          a.type
                        )} instead.`
                      )
                    : new Vc(a)
                  : null;
              }
              evaluate(t) {
                const r = this.input.evaluate(t);
                if (typeof r == "string") return [...r].length;
                if (Array.isArray(r)) return r.length;
                throw new sn(
                  `Expected value to be of type string or array, but found ${gn(
                    Dn(r)
                  )} instead.`
                );
              }
              eachChild(t) {
                t(this.input);
              }
              outputDefined() {
                return !1;
              }
            }
            const Va = 8192;
            function nf(n, t) {
              const r = (180 + n[0]) / 360,
                a =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (n[1] * Math.PI) / 360)
                      )) /
                  360,
                c = Math.pow(2, t.z);
              return [Math.round(r * c * Va), Math.round(a * c * Va)];
            }
            function qc(n, t) {
              const r = Math.pow(2, t.z);
              return [
                ((c = (n[0] / Va + t.x) / r), 360 * c - 180),
                ((a = (n[1] / Va + t.y) / r),
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * a) * Math.PI) / 180)) -
                  90),
              ];
              var a, c;
            }
            function xo(n, t) {
              (n[0] = Math.min(n[0], t[0])),
                (n[1] = Math.min(n[1], t[1])),
                (n[2] = Math.max(n[2], t[0])),
                (n[3] = Math.max(n[3], t[1]));
            }
            function Zs(n, t) {
              return !(
                n[0] <= t[0] ||
                n[2] >= t[2] ||
                n[1] <= t[1] ||
                n[3] >= t[3]
              );
            }
            function rd(n, t, r) {
              const a = n[0] - t[0],
                c = n[1] - t[1],
                p = n[0] - r[0],
                m = n[1] - r[1];
              return a * m - p * c == 0 && a * p <= 0 && c * m <= 0;
            }
            function Gs(n, t, r, a) {
              return (
                (c = [a[0] - r[0], a[1] - r[1]])[0] *
                  (p = [t[0] - n[0], t[1] - n[1]])[1] -
                  c[1] * p[0] !=
                  0 && !(!id(n, t, r, a) || !id(r, a, n, t))
              );
              var c, p;
            }
            function af(n, t, r) {
              for (const a of r)
                for (let c = 0; c < a.length - 1; ++c)
                  if (Gs(n, t, a[c], a[c + 1])) return !0;
              return !1;
            }
            function Oo(n, t, r = !1) {
              let a = !1;
              for (const v of t)
                for (let b = 0; b < v.length - 1; b++) {
                  if (rd(n, v[b], v[b + 1])) return r;
                  (p = v[b])[1] > (c = n)[1] != (m = v[b + 1])[1] > c[1] &&
                    c[0] <
                      ((m[0] - p[0]) * (c[1] - p[1])) / (m[1] - p[1]) + p[0] &&
                    (a = !a);
                }
              var c, p, m;
              return a;
            }
            function of(n, t) {
              for (const r of t) if (Oo(n, r)) return !0;
              return !1;
            }
            function nd(n, t) {
              for (const r of n) if (!Oo(r, t)) return !1;
              for (let r = 0; r < n.length - 1; ++r)
                if (af(n[r], n[r + 1], t)) return !1;
              return !0;
            }
            function sf(n, t) {
              for (const r of t) if (nd(n, r)) return !0;
              return !1;
            }
            function id(n, t, r, a) {
              const c = a[0] - r[0],
                p = a[1] - r[1],
                m = (n[0] - r[0]) * p - c * (n[1] - r[1]),
                v = (t[0] - r[0]) * p - c * (t[1] - r[1]);
              return (m > 0 && v < 0) || (m < 0 && v > 0);
            }
            function Uc(n, t, r) {
              const a = [];
              for (let c = 0; c < n.length; c++) {
                const p = [];
                for (let m = 0; m < n[c].length; m++) {
                  const v = nf(n[c][m], r);
                  xo(t, v), p.push(v);
                }
                a.push(p);
              }
              return a;
            }
            function Zc(n, t, r) {
              const a = [];
              for (let c = 0; c < n.length; c++) {
                const p = Uc(n[c], t, r);
                a.push(p);
              }
              return a;
            }
            function Gc(n, t, r, a) {
              if (n[0] < r[0] || n[0] > r[2]) {
                const c = 0.5 * a;
                let p = n[0] - r[0] > c ? -a : r[0] - n[0] > c ? a : 0;
                p === 0 && (p = n[0] - r[2] > c ? -a : r[2] - n[0] > c ? a : 0),
                  (n[0] += p);
              }
              xo(t, n);
            }
            function $c(n, t, r, a) {
              const c = Math.pow(2, a.z) * Va,
                p = [a.x * Va, a.y * Va],
                m = [];
              for (const v of n)
                for (const b of v) {
                  const C = [b.x + p[0], b.y + p[1]];
                  Gc(C, t, r, c), m.push(C);
                }
              return m;
            }
            function ad(n, t, r, a) {
              const c = Math.pow(2, a.z) * Va,
                p = [a.x * Va, a.y * Va],
                m = [];
              for (const b of n) {
                const C = [];
                for (const I of b) {
                  const R = [I.x + p[0], I.y + p[1]];
                  xo(t, R), C.push(R);
                }
                m.push(C);
              }
              if (t[2] - t[0] <= c / 2) {
                ((v = t)[0] = v[1] = 1 / 0), (v[2] = v[3] = -1 / 0);
                for (const b of m) for (const C of b) Gc(C, t, r, c);
              }
              var v;
              return m;
            }
            class No {
              constructor(t, r) {
                (this.type = st), (this.geojson = t), (this.geometries = r);
              }
              static parse(t, r) {
                if (t.length !== 2)
                  return r.error(
                    `'within' expression requires exactly one argument, but found ${
                      t.length - 1
                    } instead.`
                  );
                if (ea(t[1])) {
                  const a = t[1];
                  if (a.type === "FeatureCollection") {
                    const c = [];
                    for (const p of a.features) {
                      const { type: m, coordinates: v } = p.geometry;
                      m === "Polygon" && c.push(v),
                        m === "MultiPolygon" && c.push(...v);
                    }
                    if (c.length)
                      return new No(a, {
                        type: "MultiPolygon",
                        coordinates: c,
                      });
                  } else if (a.type === "Feature") {
                    const c = a.geometry.type;
                    if (c === "Polygon" || c === "MultiPolygon")
                      return new No(a, a.geometry);
                  } else if (a.type === "Polygon" || a.type === "MultiPolygon")
                    return new No(a, a);
                }
                return r.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type."
                );
              }
              evaluate(t) {
                if (t.geometry() != null && t.canonicalID() != null) {
                  if (t.geometryType() === "Point")
                    return (function (r, a) {
                      const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = r.canonicalID();
                      if (a.type === "Polygon") {
                        const v = Uc(a.coordinates, p, m),
                          b = $c(r.geometry(), c, p, m);
                        if (!Zs(c, p)) return !1;
                        for (const C of b) if (!Oo(C, v)) return !1;
                      }
                      if (a.type === "MultiPolygon") {
                        const v = Zc(a.coordinates, p, m),
                          b = $c(r.geometry(), c, p, m);
                        if (!Zs(c, p)) return !1;
                        for (const C of b) if (!of(C, v)) return !1;
                      }
                      return !0;
                    })(t, this.geometries);
                  if (t.geometryType() === "LineString")
                    return (function (r, a) {
                      const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = r.canonicalID();
                      if (a.type === "Polygon") {
                        const v = Uc(a.coordinates, p, m),
                          b = ad(r.geometry(), c, p, m);
                        if (!Zs(c, p)) return !1;
                        for (const C of b) if (!nd(C, v)) return !1;
                      }
                      if (a.type === "MultiPolygon") {
                        const v = Zc(a.coordinates, p, m),
                          b = ad(r.geometry(), c, p, m);
                        if (!Zs(c, p)) return !1;
                        for (const C of b) if (!sf(C, v)) return !1;
                      }
                      return !0;
                    })(t, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
            }
            let od = class {
              constructor(n = [], t = (r, a) => (r < a ? -1 : r > a ? 1 : 0)) {
                if (
                  ((this.data = n),
                  (this.length = this.data.length),
                  (this.compare = t),
                  this.length > 0)
                )
                  for (let r = (this.length >> 1) - 1; r >= 0; r--)
                    this._down(r);
              }
              push(n) {
                this.data.push(n), this._up(this.length++);
              }
              pop() {
                if (this.length === 0) return;
                const n = this.data[0],
                  t = this.data.pop();
                return (
                  --this.length > 0 && ((this.data[0] = t), this._down(0)), n
                );
              }
              peek() {
                return this.data[0];
              }
              _up(n) {
                const { data: t, compare: r } = this,
                  a = t[n];
                for (; n > 0; ) {
                  const c = (n - 1) >> 1,
                    p = t[c];
                  if (r(a, p) >= 0) break;
                  (t[n] = p), (n = c);
                }
                t[n] = a;
              }
              _down(n) {
                const { data: t, compare: r } = this,
                  a = this.length >> 1,
                  c = t[n];
                for (; n < a; ) {
                  let p = 1 + (n << 1);
                  const m = p + 1;
                  if (
                    (m < this.length && r(t[m], t[p]) < 0 && (p = m),
                    r(t[p], c) >= 0)
                  )
                    break;
                  (t[n] = t[p]), (n = p);
                }
                t[n] = c;
              }
            };
            function sd(n, t, r = 0, a = n.length - 1, c = lf) {
              for (; a > r; ) {
                if (a - r > 600) {
                  const b = a - r + 1,
                    C = t - r + 1,
                    I = Math.log(b),
                    R = 0.5 * Math.exp((2 * I) / 3),
                    U =
                      0.5 *
                      Math.sqrt((I * R * (b - R)) / b) *
                      (C - b / 2 < 0 ? -1 : 1);
                  sd(
                    n,
                    t,
                    Math.max(r, Math.floor(t - (C * R) / b + U)),
                    Math.min(a, Math.floor(t + ((b - C) * R) / b + U)),
                    c
                  );
                }
                const p = n[t];
                let m = r,
                  v = a;
                for (bo(n, r, t), c(n[a], p) > 0 && bo(n, r, a); m < v; ) {
                  for (bo(n, m, v), m++, v--; c(n[m], p) < 0; ) m++;
                  for (; c(n[v], p) > 0; ) v--;
                }
                c(n[r], p) === 0 ? bo(n, r, v) : (v++, bo(n, v, a)),
                  v <= t && (r = v + 1),
                  t <= v && (a = v - 1);
              }
            }
            function bo(n, t, r) {
              const a = n[t];
              (n[t] = n[r]), (n[r] = a);
            }
            function lf(n, t) {
              return n < t ? -1 : n > t ? 1 : 0;
            }
            function kl(n, t) {
              if (n.length <= 1) return [n];
              const r = [];
              let a, c;
              for (const p of n) {
                const m = uf(p);
                m !== 0 &&
                  ((p.area = Math.abs(m)),
                  c === void 0 && (c = m < 0),
                  c === m < 0 ? (a && r.push(a), (a = [p])) : a.push(p));
              }
              if ((a && r.push(a), t > 1))
                for (let p = 0; p < r.length; p++)
                  r[p].length <= t ||
                    (sd(r[p], t, 1, r[p].length - 1, cf),
                    (r[p] = r[p].slice(0, t)));
              return r;
            }
            function cf(n, t) {
              return t.area - n.area;
            }
            function uf(n) {
              let t = 0;
              for (let r, a, c = 0, p = n.length, m = p - 1; c < p; m = c++)
                (r = n[c]), (a = n[m]), (t += (a.x - r.x) * (r.y + a.y));
              return t;
            }
            const El = 1 / 298.257223563,
              Hc = El * (2 - El),
              ld = Math.PI / 180;
            class Wc {
              constructor(t) {
                const r = 6378.137 * ld * 1e3,
                  a = Math.cos(t * ld),
                  c = 1 / (1 - Hc * (1 - a * a)),
                  p = Math.sqrt(c);
                (this.kx = r * p * a), (this.ky = r * p * c * (1 - Hc));
              }
              distance(t, r) {
                const a = this.wrap(t[0] - r[0]) * this.kx,
                  c = (t[1] - r[1]) * this.ky;
                return Math.sqrt(a * a + c * c);
              }
              pointOnLine(t, r) {
                let a,
                  c,
                  p,
                  m,
                  v = 1 / 0;
                for (let b = 0; b < t.length - 1; b++) {
                  let C = t[b][0],
                    I = t[b][1],
                    R = this.wrap(t[b + 1][0] - C) * this.kx,
                    U = (t[b + 1][1] - I) * this.ky,
                    Z = 0;
                  (R === 0 && U === 0) ||
                    ((Z =
                      (this.wrap(r[0] - C) * this.kx * R +
                        (r[1] - I) * this.ky * U) /
                      (R * R + U * U)),
                    Z > 1
                      ? ((C = t[b + 1][0]), (I = t[b + 1][1]))
                      : Z > 0 &&
                        ((C += (R / this.kx) * Z), (I += (U / this.ky) * Z))),
                    (R = this.wrap(r[0] - C) * this.kx),
                    (U = (r[1] - I) * this.ky);
                  const X = R * R + U * U;
                  X < v && ((v = X), (a = C), (c = I), (p = b), (m = Z));
                }
                return {
                  point: [a, c],
                  index: p,
                  t: Math.max(0, Math.min(1, m)),
                };
              }
              wrap(t) {
                for (; t < -180; ) t += 360;
                for (; t > 180; ) t -= 360;
                return t;
              }
            }
            function Xc(n, t) {
              return t[0] - n[0];
            }
            function $s(n) {
              return n[1] - n[0] + 1;
            }
            function Qa(n, t) {
              return n[1] >= n[0] && n[1] < t;
            }
            function Yc(n, t) {
              if (n[0] > n[1]) return [null, null];
              const r = $s(n);
              if (t) {
                if (r === 2) return [n, null];
                const c = Math.floor(r / 2);
                return [
                  [n[0], n[0] + c],
                  [n[0] + c, n[1]],
                ];
              }
              if (r === 1) return [n, null];
              const a = Math.floor(r / 2) - 1;
              return [
                [n[0], n[0] + a],
                [n[0] + a + 1, n[1]],
              ];
            }
            function Kc(n, t) {
              if (!Qa(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let a = t[0]; a <= t[1]; ++a) xo(r, n[a]);
              return r;
            }
            function zl(n) {
              const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (const r of n) for (const a of r) xo(t, a);
              return t;
            }
            function cd(n) {
              return (
                n[0] !== -1 / 0 &&
                n[1] !== -1 / 0 &&
                n[2] !== 1 / 0 &&
                n[3] !== 1 / 0
              );
            }
            function Jc(n, t, r) {
              if (!cd(n) || !cd(t)) return NaN;
              let a = 0,
                c = 0;
              return (
                n[2] < t[0] && (a = t[0] - n[2]),
                n[0] > t[2] && (a = n[0] - t[2]),
                n[1] > t[3] && (c = n[1] - t[3]),
                n[3] < t[1] && (c = t[1] - n[3]),
                r.distance([0, 0], [a, c])
              );
            }
            function jo(n, t, r) {
              const a = r.pointOnLine(t, n);
              return r.distance(n, a.point);
            }
            function Qc(n, t, r, a, c) {
              const p = Math.min(jo(n, [r, a], c), jo(t, [r, a], c)),
                m = Math.min(jo(r, [n, t], c), jo(a, [n, t], c));
              return Math.min(p, m);
            }
            function An(n, t, r, a, c) {
              if (!Qa(t, n.length) || !Qa(a, r.length)) return 1 / 0;
              let p = 1 / 0;
              for (let m = t[0]; m < t[1]; ++m) {
                const v = n[m],
                  b = n[m + 1];
                for (let C = a[0]; C < a[1]; ++C) {
                  const I = r[C],
                    R = r[C + 1];
                  if (Gs(v, b, I, R)) return 0;
                  p = Math.min(p, Qc(v, b, I, R, c));
                }
              }
              return p;
            }
            function hf(n, t, r, a, c) {
              if (!Qa(t, n.length) || !Qa(a, r.length)) return NaN;
              let p = 1 / 0;
              for (let m = t[0]; m <= t[1]; ++m)
                for (let v = a[0]; v <= a[1]; ++v)
                  if (((p = Math.min(p, c.distance(n[m], r[v]))), p === 0))
                    return p;
              return p;
            }
            function df(n, t, r) {
              if (Oo(n, t, !0)) return 0;
              let a = 1 / 0;
              for (const c of t) {
                const p = c[0],
                  m = c[c.length - 1];
                if (p !== m && ((a = Math.min(a, jo(n, [m, p], r))), a === 0))
                  return a;
                const v = r.pointOnLine(c, n);
                if (((a = Math.min(a, r.distance(n, v.point))), a === 0))
                  return a;
              }
              return a;
            }
            function pf(n, t, r, a) {
              if (!Qa(t, n.length)) return NaN;
              for (let p = t[0]; p <= t[1]; ++p) if (Oo(n[p], r, !0)) return 0;
              let c = 1 / 0;
              for (let p = t[0]; p < t[1]; ++p) {
                const m = n[p],
                  v = n[p + 1];
                for (const b of r)
                  for (let C = 0, I = b.length, R = I - 1; C < I; R = C++) {
                    const U = b[R],
                      Z = b[C];
                    if (Gs(m, v, U, Z)) return 0;
                    c = Math.min(c, Qc(m, v, U, Z, a));
                  }
              }
              return c;
            }
            function ud(n, t) {
              for (const r of n) for (const a of r) if (Oo(a, t, !0)) return !0;
              return !1;
            }
            function ff(n, t, r, a = 1 / 0) {
              const c = zl(n),
                p = zl(t);
              if (a !== 1 / 0 && Jc(c, p, r) >= a) return a;
              if (Zs(c, p)) {
                if (ud(n, t)) return 0;
              } else if (ud(t, n)) return 0;
              let m = 1 / 0;
              for (const v of n)
                for (let b = 0, C = v.length, I = C - 1; b < C; I = b++) {
                  const R = v[I],
                    U = v[b];
                  for (const Z of t)
                    for (let X = 0, Q = Z.length, ie = Q - 1; X < Q; ie = X++) {
                      const he = Z[ie],
                        Oe = Z[X];
                      if (Gs(R, U, he, Oe)) return 0;
                      m = Math.min(m, Qc(R, U, he, Oe, r));
                    }
                }
              return m;
            }
            function hd(n, t, r, a, c, p) {
              if (!p) return;
              const m = Jc(Kc(a, p), c, r);
              m < t && n.push([m, p, [0, 0]]);
            }
            function Ll(n, t, r, a, c, p, m) {
              if (!p || !m) return;
              const v = Jc(Kc(a, p), Kc(c, m), r);
              v < t && n.push([v, p, m]);
            }
            function Dl(n, t, r, a, c = 1 / 0) {
              let p = Math.min(a.distance(n[0], r[0][0]), c);
              if (p === 0) return p;
              const m = new od([[0, [0, n.length - 1], [0, 0]]], Xc),
                v = zl(r);
              for (; m.length > 0; ) {
                const b = m.pop();
                if (b[0] >= p) continue;
                const C = b[1],
                  I = t ? 50 : 100;
                if ($s(C) <= I) {
                  if (!Qa(C, n.length)) return NaN;
                  if (t) {
                    const R = pf(n, C, r, a);
                    if (isNaN(R) || R === 0) return R;
                    p = Math.min(p, R);
                  } else
                    for (let R = C[0]; R <= C[1]; ++R) {
                      const U = df(n[R], r, a);
                      if (((p = Math.min(p, U)), p === 0)) return 0;
                    }
                } else {
                  const R = Yc(C, t);
                  hd(m, p, a, n, v, R[0]), hd(m, p, a, n, v, R[1]);
                }
              }
              return p;
            }
            function Rl(n, t, r, a, c, p = 1 / 0) {
              let m = Math.min(p, c.distance(n[0], r[0]));
              if (m === 0) return m;
              const v = new od([[0, [0, n.length - 1], [0, r.length - 1]]], Xc);
              for (; v.length > 0; ) {
                const b = v.pop();
                if (b[0] >= m) continue;
                const C = b[1],
                  I = b[2],
                  R = t ? 50 : 100,
                  U = a ? 50 : 100;
                if ($s(C) <= R && $s(I) <= U) {
                  if (!Qa(C, n.length) && Qa(I, r.length)) return NaN;
                  let Z;
                  if (t && a) (Z = An(n, C, r, I, c)), (m = Math.min(m, Z));
                  else if (t && !a) {
                    const X = n.slice(C[0], C[1] + 1);
                    for (let Q = I[0]; Q <= I[1]; ++Q)
                      if (((Z = jo(r[Q], X, c)), (m = Math.min(m, Z)), m === 0))
                        return m;
                  } else if (!t && a) {
                    const X = r.slice(I[0], I[1] + 1);
                    for (let Q = C[0]; Q <= C[1]; ++Q)
                      if (((Z = jo(n[Q], X, c)), (m = Math.min(m, Z)), m === 0))
                        return m;
                  } else (Z = hf(n, C, r, I, c)), (m = Math.min(m, Z));
                } else {
                  const Z = Yc(C, t),
                    X = Yc(I, a);
                  Ll(v, m, c, n, r, Z[0], X[0]),
                    Ll(v, m, c, n, r, Z[0], X[1]),
                    Ll(v, m, c, n, r, Z[1], X[0]),
                    Ll(v, m, c, n, r, Z[1], X[1]);
                }
              }
              return m;
            }
            function eu(n) {
              return n.type === "MultiPolygon"
                ? n.coordinates.map((t) => ({
                    type: "Polygon",
                    coordinates: t,
                  }))
                : n.type === "MultiLineString"
                ? n.coordinates.map((t) => ({
                    type: "LineString",
                    coordinates: t,
                  }))
                : n.type === "MultiPoint"
                ? n.coordinates.map((t) => ({ type: "Point", coordinates: t }))
                : [n];
            }
            class Vo {
              constructor(t, r) {
                (this.type = rt), (this.geojson = t), (this.geometries = r);
              }
              static parse(t, r) {
                if (t.length !== 2)
                  return r.error(
                    `'distance' expression requires exactly one argument, but found ${
                      t.length - 1
                    } instead.`
                  );
                if (ea(t[1])) {
                  const a = t[1];
                  if (a.type === "FeatureCollection")
                    return new Vo(
                      a,
                      a.features.map((c) => eu(c.geometry)).flat()
                    );
                  if (a.type === "Feature") return new Vo(a, eu(a.geometry));
                  if ("type" in a && "coordinates" in a)
                    return new Vo(a, eu(a));
                }
                return r.error(
                  "'distance' expression requires valid geojson object that contains polygon geometry type."
                );
              }
              evaluate(t) {
                if (t.geometry() != null && t.canonicalID() != null) {
                  if (t.geometryType() === "Point")
                    return (function (r, a) {
                      const c = r.geometry(),
                        p = c.flat().map((b) => qc([b.x, b.y], r.canonical));
                      if (c.length === 0) return NaN;
                      const m = new Wc(p[0][1]);
                      let v = 1 / 0;
                      for (const b of a) {
                        switch (b.type) {
                          case "Point":
                            v = Math.min(
                              v,
                              Rl(p, !1, [b.coordinates], !1, m, v)
                            );
                            break;
                          case "LineString":
                            v = Math.min(v, Rl(p, !1, b.coordinates, !0, m, v));
                            break;
                          case "Polygon":
                            v = Math.min(v, Dl(p, !1, b.coordinates, m, v));
                        }
                        if (v === 0) return v;
                      }
                      return v;
                    })(t, this.geometries);
                  if (t.geometryType() === "LineString")
                    return (function (r, a) {
                      const c = r.geometry(),
                        p = c.flat().map((b) => qc([b.x, b.y], r.canonical));
                      if (c.length === 0) return NaN;
                      const m = new Wc(p[0][1]);
                      let v = 1 / 0;
                      for (const b of a) {
                        switch (b.type) {
                          case "Point":
                            v = Math.min(
                              v,
                              Rl(p, !0, [b.coordinates], !1, m, v)
                            );
                            break;
                          case "LineString":
                            v = Math.min(v, Rl(p, !0, b.coordinates, !0, m, v));
                            break;
                          case "Polygon":
                            v = Math.min(v, Dl(p, !0, b.coordinates, m, v));
                        }
                        if (v === 0) return v;
                      }
                      return v;
                    })(t, this.geometries);
                  if (t.geometryType() === "Polygon")
                    return (function (r, a) {
                      const c = r.geometry();
                      if (c.length === 0 || c[0].length === 0) return NaN;
                      const p = kl(c, 0).map((b) =>
                          b.map((C) =>
                            C.map((I) => qc([I.x, I.y], r.canonical))
                          )
                        ),
                        m = new Wc(p[0][0][0][1]);
                      let v = 1 / 0;
                      for (const b of a)
                        for (const C of p) {
                          switch (b.type) {
                            case "Point":
                              v = Math.min(v, Dl([b.coordinates], !1, C, m, v));
                              break;
                            case "LineString":
                              v = Math.min(v, Dl(b.coordinates, !0, C, m, v));
                              break;
                            case "Polygon":
                              v = Math.min(v, ff(C, b.coordinates, m, v));
                          }
                          if (v === 0) return v;
                        }
                      return v;
                    })(t, this.geometries);
                }
                return NaN;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
            }
            class Hs {
              constructor(t) {
                (this.type = wt), (this.key = t);
              }
              static parse(t, r) {
                if (t.length !== 2)
                  return r.error(
                    `Expected 1 argument, but found ${t.length - 1} instead.`
                  );
                const a = t[1];
                return a == null
                  ? r.error("Global state property must be defined.")
                  : typeof a != "string"
                  ? r.error(
                      `Global state property must be string, but found ${typeof t[1]} instead.`
                    )
                  : new Hs(a);
              }
              evaluate(t) {
                var r;
                const a =
                  (r = t.globals) === null || r === void 0
                    ? void 0
                    : r.globalState;
                return a && Object.keys(a).length !== 0
                  ? Ci(a, this.key)
                  : null;
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
            }
            const _s = {
              "==": jc,
              "!=": rf,
              ">": Il,
              "<": td,
              ">=": Ia,
              "<=": Ml,
              array: _n,
              at: Ro,
              boolean: _n,
              case: Tl,
              coalesce: Vs,
              collator: qs,
              format: Al,
              image: Us,
              in: Pa,
              "index-of": Ka,
              interpolate: zn,
              "interpolate-hcl": zn,
              "interpolate-lab": zn,
              length: Vc,
              let: Ya,
              literal: ta,
              match: Fo,
              number: _n,
              "number-format": ms,
              object: _n,
              slice: Sl,
              step: fs,
              string: _n,
              "to-boolean": en,
              "to-color": en,
              "to-number": en,
              "to-string": en,
              var: Di,
              within: No,
              distance: Vo,
              "global-state": Hs,
            };
            class xa {
              constructor(t, r, a, c) {
                (this.name = t),
                  (this.type = r),
                  (this._evaluate = a),
                  (this.args = c);
              }
              evaluate(t) {
                return this._evaluate(t, this.args);
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return !1;
              }
              static parse(t, r) {
                const a = t[0],
                  c = xa.definitions[a];
                if (!c)
                  return r.error(
                    `Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                const p = Array.isArray(c) ? c[0] : c.type,
                  m = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads,
                  v = m.filter(
                    ([C]) => !Array.isArray(C) || C.length === t.length - 1
                  );
                let b = null;
                for (const [C, I] of v) {
                  b = new xn(r.registry, Fl, r.path, null, r.scope);
                  const R = [];
                  let U = !1;
                  for (let Z = 1; Z < t.length; Z++) {
                    const X = t[Z],
                      Q = Array.isArray(C) ? C[Z - 1] : C.type,
                      ie = b.parse(X, 1 + R.length, Q);
                    if (!ie) {
                      U = !0;
                      break;
                    }
                    R.push(ie);
                  }
                  if (!U)
                    if (Array.isArray(C) && C.length !== R.length)
                      b.error(
                        `Expected ${C.length} arguments, but found ${R.length} instead.`
                      );
                    else {
                      for (let Z = 0; Z < R.length; Z++) {
                        const X = Array.isArray(C) ? C[Z] : C.type,
                          Q = R[Z];
                        b.concat(Z + 1).checkSubtype(X, Q.type);
                      }
                      if (b.errors.length === 0) return new xa(a, p, I, R);
                    }
                }
                if (v.length === 1) r.errors.push(...b.errors);
                else {
                  const C = (v.length ? v : m)
                      .map(([R]) => {
                        return (
                          (U = R),
                          Array.isArray(U)
                            ? `(${U.map(gn).join(", ")})`
                            : `(${gn(U.type)}...)`
                        );
                        var U;
                      })
                      .join(" | "),
                    I = [];
                  for (let R = 1; R < t.length; R++) {
                    const U = r.parse(t[R], 1 + I.length);
                    if (!U) return null;
                    I.push(gn(U.type));
                  }
                  r.error(
                    `Expected arguments of type ${C}, but found (${I.join(
                      ", "
                    )}) instead.`
                  );
                }
                return null;
              }
              static register(t, r) {
                xa.definitions = r;
                for (const a in r) t[a] = xa;
              }
            }
            function dd(n, [t, r, a, c]) {
              (t = t.evaluate(n)), (r = r.evaluate(n)), (a = a.evaluate(n));
              const p = c ? c.evaluate(n) : 1,
                m = _a(t, r, a, p);
              if (m) throw new sn(m);
              return new Cr(t / 255, r / 255, a / 255, p, !1);
            }
            function pd(n, t) {
              return n in t;
            }
            function tu(n, t) {
              const r = t[n];
              return r === void 0 ? null : r;
            }
            function qo(n) {
              return { type: n };
            }
            function Fl(n) {
              if (n instanceof Di) return Fl(n.boundExpression);
              if (
                (n instanceof xa && n.name === "error") ||
                n instanceof qs ||
                n instanceof No ||
                n instanceof Vo ||
                n instanceof Hs
              )
                return !1;
              const t = n instanceof en || n instanceof _n;
              let r = !0;
              return (
                n.eachChild((a) => {
                  r = t ? r && Fl(a) : r && a instanceof ta;
                }),
                !!r &&
                  Bl(n) &&
                  Ol(n, [
                    "zoom",
                    "heatmap-density",
                    "elevation",
                    "line-progress",
                    "accumulated",
                    "is-supported-script",
                  ])
              );
            }
            function Bl(n) {
              if (
                (n instanceof xa &&
                  ((n.name === "get" && n.args.length === 1) ||
                    n.name === "feature-state" ||
                    (n.name === "has" && n.args.length === 1) ||
                    n.name === "properties" ||
                    n.name === "geometry-type" ||
                    n.name === "id" ||
                    /^filter-/.test(n.name))) ||
                n instanceof No ||
                n instanceof Vo
              )
                return !1;
              let t = !0;
              return (
                n.eachChild((r) => {
                  t && !Bl(r) && (t = !1);
                }),
                t
              );
            }
            function Ws(n) {
              if (n instanceof xa && n.name === "feature-state") return !1;
              let t = !0;
              return (
                n.eachChild((r) => {
                  t && !Ws(r) && (t = !1);
                }),
                t
              );
            }
            function Ol(n, t) {
              if (n instanceof xa && t.indexOf(n.name) >= 0) return !1;
              let r = !0;
              return (
                n.eachChild((a) => {
                  r && !Ol(a, t) && (r = !1);
                }),
                r
              );
            }
            function fd(n) {
              return { result: "success", value: n };
            }
            function gs(n) {
              return { result: "error", value: n };
            }
            function vs(n) {
              return (
                n["property-type"] === "data-driven" ||
                n["property-type"] === "cross-faded-data-driven"
              );
            }
            function md(n) {
              return (
                !!n.expression && n.expression.parameters.indexOf("zoom") > -1
              );
            }
            function ru(n) {
              return !!n.expression && n.expression.interpolated;
            }
            function vn(n) {
              return n instanceof Number
                ? "number"
                : n instanceof String
                ? "string"
                : n instanceof Boolean
                ? "boolean"
                : Array.isArray(n)
                ? "array"
                : n === null
                ? "null"
                : typeof n;
            }
            function Nl(n) {
              return (
                typeof n == "object" &&
                n !== null &&
                !Array.isArray(n) &&
                Dn(n) === br
              );
            }
            function mf(n) {
              return n;
            }
            function _d(n, t) {
              const r = n.stops && typeof n.stops[0][0] == "object",
                a = r || !(r || n.property !== void 0),
                c = n.type || (ru(t) ? "exponential" : "interval"),
                p = (function (I) {
                  switch (I.type) {
                    case "color":
                      return Cr.parse;
                    case "padding":
                      return Sn.parse;
                    case "numberArray":
                      return Qr.parse;
                    case "colorArray":
                      return Ar.parse;
                    default:
                      return null;
                  }
                })(t);
              if (
                (p &&
                  ((n = on({}, n)).stops &&
                    (n.stops = n.stops.map((I) => [I[0], p(I[1])])),
                  (n.default = p(n.default ? n.default : t.default))),
                n.colorSpace &&
                  (m = n.colorSpace) !== "rgb" &&
                  m !== "hcl" &&
                  m !== "lab")
              )
                throw new Error(`Unknown color space: "${n.colorSpace}"`);
              var m;
              const v = (function (I) {
                switch (I) {
                  case "exponential":
                    return gd;
                  case "interval":
                    return gf;
                  case "categorical":
                    return _f;
                  case "identity":
                    return vd;
                  default:
                    throw new Error(`Unknown function type "${I}"`);
                }
              })(c);
              let b, C;
              if (c === "categorical") {
                b = Object.create(null);
                for (const I of n.stops) b[I[0]] = I[1];
                C = typeof n.stops[0][0];
              }
              if (r) {
                const I = {},
                  R = [];
                for (let X = 0; X < n.stops.length; X++) {
                  const Q = n.stops[X],
                    ie = Q[0].zoom;
                  I[ie] === void 0 &&
                    ((I[ie] = {
                      zoom: ie,
                      type: n.type,
                      property: n.property,
                      default: n.default,
                      stops: [],
                    }),
                    R.push(ie)),
                    I[ie].stops.push([Q[0].value, Q[1]]);
                }
                const U = [];
                for (const X of R) U.push([I[X].zoom, _d(I[X], t)]);
                const Z = { name: "linear" };
                return {
                  kind: "composite",
                  interpolationType: Z,
                  interpolationFactor: zn.interpolationFactor.bind(void 0, Z),
                  zoomStops: U.map((X) => X[0]),
                  evaluate: ({ zoom: X }, Q) =>
                    gd({ stops: U, base: n.base }, t, X).evaluate(X, Q),
                };
              }
              if (a) {
                const I =
                  c === "exponential"
                    ? {
                        name: "exponential",
                        base: n.base !== void 0 ? n.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: I,
                  interpolationFactor: zn.interpolationFactor.bind(void 0, I),
                  zoomStops: n.stops.map((R) => R[0]),
                  evaluate: ({ zoom: R }) => v(n, t, R, b, C),
                };
              }
              return {
                kind: "source",
                evaluate(I, R) {
                  const U =
                    R && R.properties ? R.properties[n.property] : void 0;
                  return U === void 0
                    ? Uo(n.default, t.default)
                    : v(n, t, U, b, C);
                },
              };
            }
            function Uo(n, t, r) {
              return n !== void 0
                ? n
                : t !== void 0
                ? t
                : r !== void 0
                ? r
                : void 0;
            }
            function _f(n, t, r, a, c) {
              return Uo(typeof r === c ? a[r] : void 0, n.default, t.default);
            }
            function gf(n, t, r) {
              if (vn(r) !== "number") return Uo(n.default, t.default);
              const a = n.stops.length;
              if (a === 1 || r <= n.stops[0][0]) return n.stops[0][1];
              if (r >= n.stops[a - 1][0]) return n.stops[a - 1][1];
              const c = Ns(
                n.stops.map((p) => p[0]),
                r
              );
              return n.stops[c][1];
            }
            function gd(n, t, r) {
              const a = n.base !== void 0 ? n.base : 1;
              if (vn(r) !== "number") return Uo(n.default, t.default);
              const c = n.stops.length;
              if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
              if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
              const p = Ns(
                  n.stops.map((I) => I[0]),
                  r
                ),
                m = (function (I, R, U, Z) {
                  const X = Z - U,
                    Q = I - U;
                  return X === 0
                    ? 0
                    : R === 1
                    ? Q / X
                    : (Math.pow(R, Q) - 1) / (Math.pow(R, X) - 1);
                })(r, a, n.stops[p][0], n.stops[p + 1][0]),
                v = n.stops[p][1],
                b = n.stops[p + 1][1],
                C = ya[t.type] || mf;
              return typeof v.evaluate == "function"
                ? {
                    evaluate(...I) {
                      const R = v.evaluate.apply(void 0, I),
                        U = b.evaluate.apply(void 0, I);
                      if (R !== void 0 && U !== void 0)
                        return C(R, U, m, n.colorSpace);
                    },
                  }
                : C(v, b, m, n.colorSpace);
            }
            function vd(n, t, r) {
              switch (t.type) {
                case "color":
                  r = Cr.parse(r);
                  break;
                case "formatted":
                  r = kn.fromString(r.toString());
                  break;
                case "resolvedImage":
                  r = En.fromString(r.toString());
                  break;
                case "padding":
                  r = Sn.parse(r);
                  break;
                case "colorArray":
                  r = Ar.parse(r);
                  break;
                case "numberArray":
                  r = Qr.parse(r);
                  break;
                default:
                  vn(r) === t.type ||
                    (t.type === "enum" && t.values[r]) ||
                    (r = void 0);
              }
              return Uo(r, n.default, t.default);
            }
            xa.register(_s, {
              error: [
                { kind: "error" },
                [$t],
                (n, [t]) => {
                  throw new sn(t.evaluate(n));
                },
              ],
              typeof: [$t, [wt], (n, [t]) => gn(Dn(t.evaluate(n)))],
              "to-rgba": [
                Tn(rt, 4),
                [gt],
                (n, [t]) => {
                  const [r, a, c, p] = t.evaluate(n).rgb;
                  return [255 * r, 255 * a, 255 * c, p];
                },
              ],
              rgb: [gt, [rt, rt, rt], dd],
              rgba: [gt, [rt, rt, rt, rt], dd],
              has: {
                type: st,
                overloads: [
                  [[$t], (n, [t]) => pd(t.evaluate(n), n.properties())],
                  [[$t, br], (n, [t, r]) => pd(t.evaluate(n), r.evaluate(n))],
                ],
              },
              get: {
                type: wt,
                overloads: [
                  [[$t], (n, [t]) => tu(t.evaluate(n), n.properties())],
                  [[$t, br], (n, [t, r]) => tu(t.evaluate(n), r.evaluate(n))],
                ],
              },
              "feature-state": [
                wt,
                [$t],
                (n, [t]) => tu(t.evaluate(n), n.featureState || {}),
              ],
              properties: [br, [], (n) => n.properties()],
              "geometry-type": [$t, [], (n) => n.geometryType()],
              id: [wt, [], (n) => n.id()],
              zoom: [rt, [], (n) => n.globals.zoom],
              "heatmap-density": [rt, [], (n) => n.globals.heatmapDensity || 0],
              elevation: [rt, [], (n) => n.globals.elevation || 0],
              "line-progress": [rt, [], (n) => n.globals.lineProgress || 0],
              accumulated: [
                wt,
                [],
                (n) =>
                  n.globals.accumulated === void 0
                    ? null
                    : n.globals.accumulated,
              ],
              "+": [
                rt,
                qo(rt),
                (n, t) => {
                  let r = 0;
                  for (const a of t) r += a.evaluate(n);
                  return r;
                },
              ],
              "*": [
                rt,
                qo(rt),
                (n, t) => {
                  let r = 1;
                  for (const a of t) r *= a.evaluate(n);
                  return r;
                },
              ],
              "-": {
                type: rt,
                overloads: [
                  [[rt, rt], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)],
                  [[rt], (n, [t]) => -t.evaluate(n)],
                ],
              },
              "/": [rt, [rt, rt], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
              "%": [rt, [rt, rt], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
              ln2: [rt, [], () => Math.LN2],
              pi: [rt, [], () => Math.PI],
              e: [rt, [], () => Math.E],
              "^": [
                rt,
                [rt, rt],
                (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n)),
              ],
              sqrt: [rt, [rt], (n, [t]) => Math.sqrt(t.evaluate(n))],
              log10: [
                rt,
                [rt],
                (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10,
              ],
              ln: [rt, [rt], (n, [t]) => Math.log(t.evaluate(n))],
              log2: [rt, [rt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
              sin: [rt, [rt], (n, [t]) => Math.sin(t.evaluate(n))],
              cos: [rt, [rt], (n, [t]) => Math.cos(t.evaluate(n))],
              tan: [rt, [rt], (n, [t]) => Math.tan(t.evaluate(n))],
              asin: [rt, [rt], (n, [t]) => Math.asin(t.evaluate(n))],
              acos: [rt, [rt], (n, [t]) => Math.acos(t.evaluate(n))],
              atan: [rt, [rt], (n, [t]) => Math.atan(t.evaluate(n))],
              min: [
                rt,
                qo(rt),
                (n, t) => Math.min(...t.map((r) => r.evaluate(n))),
              ],
              max: [
                rt,
                qo(rt),
                (n, t) => Math.max(...t.map((r) => r.evaluate(n))),
              ],
              abs: [rt, [rt], (n, [t]) => Math.abs(t.evaluate(n))],
              round: [
                rt,
                [rt],
                (n, [t]) => {
                  const r = t.evaluate(n);
                  return r < 0 ? -Math.round(-r) : Math.round(r);
                },
              ],
              floor: [rt, [rt], (n, [t]) => Math.floor(t.evaluate(n))],
              ceil: [rt, [rt], (n, [t]) => Math.ceil(t.evaluate(n))],
              "filter-==": [
                st,
                [$t, wt],
                (n, [t, r]) => n.properties()[t.value] === r.value,
              ],
              "filter-id-==": [st, [wt], (n, [t]) => n.id() === t.value],
              "filter-type-==": [
                st,
                [$t],
                (n, [t]) => n.geometryType() === t.value,
              ],
              "filter-<": [
                st,
                [$t, wt],
                (n, [t, r]) => {
                  const a = n.properties()[t.value],
                    c = r.value;
                  return typeof a == typeof c && a < c;
                },
              ],
              "filter-id-<": [
                st,
                [wt],
                (n, [t]) => {
                  const r = n.id(),
                    a = t.value;
                  return typeof r == typeof a && r < a;
                },
              ],
              "filter->": [
                st,
                [$t, wt],
                (n, [t, r]) => {
                  const a = n.properties()[t.value],
                    c = r.value;
                  return typeof a == typeof c && a > c;
                },
              ],
              "filter-id->": [
                st,
                [wt],
                (n, [t]) => {
                  const r = n.id(),
                    a = t.value;
                  return typeof r == typeof a && r > a;
                },
              ],
              "filter-<=": [
                st,
                [$t, wt],
                (n, [t, r]) => {
                  const a = n.properties()[t.value],
                    c = r.value;
                  return typeof a == typeof c && a <= c;
                },
              ],
              "filter-id-<=": [
                st,
                [wt],
                (n, [t]) => {
                  const r = n.id(),
                    a = t.value;
                  return typeof r == typeof a && r <= a;
                },
              ],
              "filter->=": [
                st,
                [$t, wt],
                (n, [t, r]) => {
                  const a = n.properties()[t.value],
                    c = r.value;
                  return typeof a == typeof c && a >= c;
                },
              ],
              "filter-id->=": [
                st,
                [wt],
                (n, [t]) => {
                  const r = n.id(),
                    a = t.value;
                  return typeof r == typeof a && r >= a;
                },
              ],
              "filter-has": [st, [wt], (n, [t]) => t.value in n.properties()],
              "filter-has-id": [
                st,
                [],
                (n) => n.id() !== null && n.id() !== void 0,
              ],
              "filter-type-in": [
                st,
                [Tn($t)],
                (n, [t]) => t.value.indexOf(n.geometryType()) >= 0,
              ],
              "filter-id-in": [
                st,
                [Tn(wt)],
                (n, [t]) => t.value.indexOf(n.id()) >= 0,
              ],
              "filter-in-small": [
                st,
                [$t, Tn(wt)],
                (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0,
              ],
              "filter-in-large": [
                st,
                [$t, Tn(wt)],
                (n, [t, r]) =>
                  (function (a, c, p, m) {
                    for (; p <= m; ) {
                      const v = (p + m) >> 1;
                      if (c[v] === a) return !0;
                      c[v] > a ? (m = v - 1) : (p = v + 1);
                    }
                    return !1;
                  })(n.properties()[t.value], r.value, 0, r.value.length - 1),
              ],
              all: {
                type: st,
                overloads: [
                  [[st, st], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)],
                  [
                    qo(st),
                    (n, t) => {
                      for (const r of t) if (!r.evaluate(n)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: st,
                overloads: [
                  [[st, st], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)],
                  [
                    qo(st),
                    (n, t) => {
                      for (const r of t) if (r.evaluate(n)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [st, [st], (n, [t]) => !t.evaluate(n)],
              "is-supported-script": [
                st,
                [$t],
                (n, [t]) => {
                  const r = n.globals && n.globals.isSupportedScript;
                  return !r || r(t.evaluate(n));
                },
              ],
              upcase: [$t, [$t], (n, [t]) => t.evaluate(n).toUpperCase()],
              downcase: [$t, [$t], (n, [t]) => t.evaluate(n).toLowerCase()],
              concat: [
                $t,
                qo(wt),
                (n, t) => t.map((r) => ga(r.evaluate(n))).join(""),
              ],
              "resolved-locale": [
                $t,
                [sr],
                (n, [t]) => t.evaluate(n).resolvedLocale(),
              ],
            });
            class nu {
              constructor(t, r, a) {
                (this.expression = t),
                  (this._warningHistory = {}),
                  (this._evaluator = new vo()),
                  (this._defaultValue = r
                    ? (function (c) {
                        if (c.type === "color" && Nl(c.default))
                          return new Cr(0, 0, 0, 0);
                        switch (c.type) {
                          case "color":
                            return Cr.parse(c.default) || null;
                          case "padding":
                            return Sn.parse(c.default) || null;
                          case "numberArray":
                            return Qr.parse(c.default) || null;
                          case "colorArray":
                            return Ar.parse(c.default) || null;
                          case "variableAnchorOffsetCollection":
                            return pn.parse(c.default) || null;
                          case "projectionDefinition":
                            return Yn.parse(c.default) || null;
                          default:
                            return c.default === void 0 ? null : c.default;
                        }
                      })(r)
                    : null),
                  (this._enumValues = r && r.type === "enum" ? r.values : null),
                  (this._globalState = a);
              }
              evaluateWithoutErrorHandling(t, r, a, c, p, m) {
                return (
                  this._globalState && (t = Go(t, this._globalState)),
                  (this._evaluator.globals = t),
                  (this._evaluator.feature = r),
                  (this._evaluator.featureState = a),
                  (this._evaluator.canonical = c),
                  (this._evaluator.availableImages = p || null),
                  (this._evaluator.formattedSection = m),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(t, r, a, c, p, m) {
                this._globalState && (t = Go(t, this._globalState)),
                  (this._evaluator.globals = t),
                  (this._evaluator.feature = r || null),
                  (this._evaluator.featureState = a || null),
                  (this._evaluator.canonical = c),
                  (this._evaluator.availableImages = p || null),
                  (this._evaluator.formattedSection = m || null);
                try {
                  const v = this.expression.evaluate(this._evaluator);
                  if (v == null || (typeof v == "number" && v != v))
                    return this._defaultValue;
                  if (this._enumValues && !(v in this._enumValues))
                    throw new sn(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues
                      )
                        .map((b) => JSON.stringify(b))
                        .join(", ")}, but found ${JSON.stringify(v)} instead.`
                    );
                  return v;
                } catch (v) {
                  return (
                    this._warningHistory[v.message] ||
                      ((this._warningHistory[v.message] = !0),
                      typeof console < "u" && console.warn(v.message)),
                    this._defaultValue
                  );
                }
              }
            }
            function jl(n) {
              return (
                Array.isArray(n) &&
                n.length > 0 &&
                typeof n[0] == "string" &&
                n[0] in _s
              );
            }
            function Zo(n, t, r) {
              const a = new xn(
                  _s,
                  Fl,
                  [],
                  t
                    ? (function (p) {
                        const m = {
                          color: gt,
                          string: $t,
                          number: rt,
                          enum: $t,
                          boolean: st,
                          formatted: wr,
                          padding: jr,
                          numberArray: fr,
                          colorArray: Yr,
                          projectionDefinition: Ut,
                          resolvedImage: Zr,
                          variableAnchorOffsetCollection: nn,
                        };
                        return p.type === "array"
                          ? Tn(m[p.value] || wt, p.length)
                          : m[p.type];
                      })(t)
                    : void 0
                ),
                c = a.parse(
                  n,
                  void 0,
                  void 0,
                  void 0,
                  t && t.type === "string"
                    ? { typeAnnotation: "coerce" }
                    : void 0
                );
              return c ? fd(new nu(c, t, r)) : gs(a.errors);
            }
            class Xs {
              constructor(t, r, a) {
                (this.kind = t),
                  (this._styleExpression = r),
                  (this.isStateDependent =
                    t !== "constant" && !Ws(r.expression)),
                  (this.globalStateRefs = Ul(r.expression)),
                  (this._globalState = a);
              }
              evaluateWithoutErrorHandling(t, r, a, c, p, m) {
                return (
                  this._globalState && (t = Go(t, this._globalState)),
                  this._styleExpression.evaluateWithoutErrorHandling(
                    t,
                    r,
                    a,
                    c,
                    p,
                    m
                  )
                );
              }
              evaluate(t, r, a, c, p, m) {
                return (
                  this._globalState && (t = Go(t, this._globalState)),
                  this._styleExpression.evaluate(t, r, a, c, p, m)
                );
              }
            }
            class iu {
              constructor(t, r, a, c, p) {
                (this.kind = t),
                  (this.zoomStops = a),
                  (this._styleExpression = r),
                  (this.isStateDependent = t !== "camera" && !Ws(r.expression)),
                  (this.globalStateRefs = Ul(r.expression)),
                  (this.interpolationType = c),
                  (this._globalState = p);
              }
              evaluateWithoutErrorHandling(t, r, a, c, p, m) {
                return (
                  this._globalState && (t = Go(t, this._globalState)),
                  this._styleExpression.evaluateWithoutErrorHandling(
                    t,
                    r,
                    a,
                    c,
                    p,
                    m
                  )
                );
              }
              evaluate(t, r, a, c, p, m) {
                return (
                  this._globalState && (t = Go(t, this._globalState)),
                  this._styleExpression.evaluate(t, r, a, c, p, m)
                );
              }
              interpolationFactor(t, r, a) {
                return this.interpolationType
                  ? zn.interpolationFactor(this.interpolationType, t, r, a)
                  : 0;
              }
            }
            function yd(n, t, r) {
              const a = Zo(n, t, r);
              if (a.result === "error") return a;
              const c = a.value.expression,
                p = Bl(c);
              if (!p && !vs(t))
                return gs([new Pn("", "data expressions not supported")]);
              const m = Ol(c, ["zoom"]);
              if (!m && !md(t))
                return gs([new Pn("", "zoom expressions not supported")]);
              const v = ql(c);
              return v || m
                ? v instanceof Pn
                  ? gs([v])
                  : v instanceof zn && !ru(t)
                  ? gs([
                      new Pn(
                        "",
                        '"interpolate" expressions cannot be used with this property'
                      ),
                    ])
                  : fd(
                      v
                        ? new iu(
                            p ? "camera" : "composite",
                            a.value,
                            v.labels,
                            v instanceof zn ? v.interpolation : void 0,
                            r
                          )
                        : new Xs(p ? "constant" : "source", a.value, r)
                    )
                : gs([
                    new Pn(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                    ),
                  ]);
            }
            class Vl {
              constructor(t, r) {
                (this._parameters = t),
                  (this._specification = r),
                  on(this, _d(this._parameters, this._specification));
              }
              static deserialize(t) {
                return new Vl(t._parameters, t._specification);
              }
              static serialize(t) {
                return {
                  _parameters: t._parameters,
                  _specification: t._specification,
                };
              }
            }
            function ql(n) {
              let t = null;
              if (n instanceof Ya) t = ql(n.result);
              else if (n instanceof Vs) {
                for (const r of n.args) if (((t = ql(r)), t)) break;
              } else
                (n instanceof fs || n instanceof zn) &&
                  n.input instanceof xa &&
                  n.input.name === "zoom" &&
                  (t = n);
              return (
                t instanceof Pn ||
                  n.eachChild((r) => {
                    const a = ql(r);
                    a instanceof Pn
                      ? (t = a)
                      : !t && a
                      ? (t = new Pn(
                          "",
                          '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                        ))
                      : t &&
                        a &&
                        t !== a &&
                        (t = new Pn(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                        ));
                  }),
                t
              );
            }
            function Ul(n, t = new Set()) {
              return (
                n instanceof Hs && t.add(n.key),
                n.eachChild((r) => {
                  Ul(r, t);
                }),
                t
              );
            }
            function Go(n, t) {
              const {
                zoom: r,
                heatmapDensity: a,
                elevation: c,
                lineProgress: p,
                isSupportedScript: m,
                accumulated: v,
              } = n ?? {};
              return {
                zoom: r,
                heatmapDensity: a,
                elevation: c,
                lineProgress: p,
                isSupportedScript: m,
                accumulated: v,
                globalState: t,
              };
            }
            function Zl(n) {
              if (n === !0 || n === !1) return !0;
              if (!Array.isArray(n) || n.length === 0) return !1;
              switch (n[0]) {
                case "has":
                  return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
                case "in":
                  return (
                    n.length >= 3 &&
                    (typeof n[1] != "string" || Array.isArray(n[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2])
                  );
                case "any":
                case "all":
                  for (const t of n.slice(1))
                    if (!Zl(t) && typeof t != "boolean") return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            const vf = {
              type: "boolean",
              default: !1,
              transition: !1,
              "property-type": "data-driven",
              expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            };
            function Ys(n, t) {
              if (n == null)
                return {
                  filter: () => !0,
                  needGeometry: !1,
                  getGlobalStateRefs: () => new Set(),
                };
              Zl(n) || (n = Ks(n));
              const r = Zo(n, vf, t);
              if (r.result === "error")
                throw new Error(
                  r.value.map((a) => `${a.key}: ${a.message}`).join(", ")
                );
              return {
                filter: (a, c, p) => r.value.evaluate(a, c, {}, p),
                needGeometry: au(n),
                getGlobalStateRefs: () => Ul(r.value.expression),
              };
            }
            function xd(n, t) {
              return n < t ? -1 : n > t ? 1 : 0;
            }
            function au(n) {
              if (!Array.isArray(n)) return !1;
              if (n[0] === "within" || n[0] === "distance") return !0;
              for (let t = 1; t < n.length; t++) if (au(n[t])) return !0;
              return !1;
            }
            function Ks(n) {
              if (!n) return !0;
              const t = n[0];
              return n.length <= 1
                ? t !== "any"
                : t === "=="
                ? ou(n[1], n[2], "==")
                : t === "!="
                ? Gl(ou(n[1], n[2], "=="))
                : t === "<" || t === ">" || t === "<=" || t === ">="
                ? ou(n[1], n[2], t)
                : t === "any"
                ? ((r = n.slice(1)), ["any"].concat(r.map(Ks)))
                : t === "all"
                ? ["all"].concat(n.slice(1).map(Ks))
                : t === "none"
                ? ["all"].concat(n.slice(1).map(Ks).map(Gl))
                : t === "in"
                ? bd(n[1], n.slice(2))
                : t === "!in"
                ? Gl(bd(n[1], n.slice(2)))
                : t === "has"
                ? wd(n[1])
                : t !== "!has" || Gl(wd(n[1]));
              var r;
            }
            function ou(n, t, r) {
              switch (n) {
                case "$type":
                  return [`filter-type-${r}`, t];
                case "$id":
                  return [`filter-id-${r}`, t];
                default:
                  return [`filter-${r}`, n, t];
              }
            }
            function bd(n, t) {
              if (t.length === 0) return !1;
              switch (n) {
                case "$type":
                  return ["filter-type-in", ["literal", t]];
                case "$id":
                  return ["filter-id-in", ["literal", t]];
                default:
                  return t.length > 200 &&
                    !t.some((r) => typeof r != typeof t[0])
                    ? ["filter-in-large", n, ["literal", t.sort(xd)]]
                    : ["filter-in-small", n, ["literal", t]];
              }
            }
            function wd(n) {
              switch (n) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", n];
              }
            }
            function Gl(n) {
              return ["!", n];
            }
            function $l(n) {
              const t = typeof n;
              if (
                t === "number" ||
                t === "boolean" ||
                t === "string" ||
                n == null
              )
                return JSON.stringify(n);
              if (Array.isArray(n)) {
                let c = "[";
                for (const p of n) c += `${$l(p)},`;
                return `${c}]`;
              }
              const r = Object.keys(n).sort();
              let a = "{";
              for (let c = 0; c < r.length; c++)
                a += `${JSON.stringify(r[c])}:${$l(n[r[c]])},`;
              return `${a}}`;
            }
            function Td(n) {
              let t = "";
              for (const r of Vt) t += `/${$l(n[r])}`;
              return t;
            }
            function Hl(n) {
              const t = n.value;
              return t
                ? [new pt(n.key, t, "constants have been deprecated as of v8")]
                : [];
            }
            function ei(n) {
              return n instanceof Number ||
                n instanceof String ||
                n instanceof Boolean
                ? n.valueOf()
                : n;
            }
            function eo(n) {
              if (Array.isArray(n)) return n.map(eo);
              if (
                n instanceof Object &&
                !(
                  n instanceof Number ||
                  n instanceof String ||
                  n instanceof Boolean
                )
              ) {
                const t = {};
                for (const r in n) t[r] = eo(n[r]);
                return t;
              }
              return ei(n);
            }
            function ra(n) {
              const t = n.key,
                r = n.value,
                a = n.valueSpec || {},
                c = n.objectElementValidators || {},
                p = n.style,
                m = n.styleSpec,
                v = n.validateSpec;
              let b = [];
              const C = vn(r);
              if (C !== "object")
                return [new pt(t, r, `object expected, ${C} found`)];
              for (const I in r) {
                const R = I.split(".")[0],
                  U = Ci(a, R) || a["*"];
                let Z;
                if (Ci(c, R)) Z = c[R];
                else if (Ci(a, R)) Z = v;
                else if (c["*"]) Z = c["*"];
                else {
                  if (!a["*"]) {
                    b.push(new pt(t, r[I], `unknown property "${I}"`));
                    continue;
                  }
                  Z = v;
                }
                b = b.concat(
                  Z(
                    {
                      key: (t && `${t}.`) + I,
                      value: r[I],
                      valueSpec: U,
                      style: p,
                      styleSpec: m,
                      object: r,
                      objectKey: I,
                      validateSpec: v,
                    },
                    r
                  )
                );
              }
              for (const I in a)
                c[I] ||
                  (a[I].required &&
                    a[I].default === void 0 &&
                    r[I] === void 0 &&
                    b.push(new pt(t, r, `missing required property "${I}"`)));
              return b;
            }
            function ys(n) {
              const t = n.value,
                r = n.valueSpec,
                a = n.style,
                c = n.styleSpec,
                p = n.key,
                m = n.arrayElementValidator || n.validateSpec;
              if (vn(t) !== "array")
                return [new pt(p, t, `array expected, ${vn(t)} found`)];
              if (r.length && t.length !== r.length)
                return [
                  new pt(
                    p,
                    t,
                    `array length ${r.length} expected, length ${t.length} found`
                  ),
                ];
              if (r["min-length"] && t.length < r["min-length"])
                return [
                  new pt(
                    p,
                    t,
                    `array length at least ${r["min-length"]} expected, length ${t.length} found`
                  ),
                ];
              let v = { type: r.value, values: r.values };
              c.$version < 7 && (v.function = r.function),
                vn(r.value) === "object" && (v = r.value);
              let b = [];
              for (let C = 0; C < t.length; C++)
                b = b.concat(
                  m({
                    array: t,
                    arrayIndex: C,
                    value: t[C],
                    valueSpec: v,
                    validateSpec: n.validateSpec,
                    style: a,
                    styleSpec: c,
                    key: `${p}[${C}]`,
                  })
                );
              return b;
            }
            function Wl(n) {
              const t = n.key,
                r = n.value,
                a = n.valueSpec;
              let c = vn(r);
              return (
                c === "number" && r != r && (c = "NaN"),
                c !== "number"
                  ? [new pt(t, r, `number expected, ${c} found`)]
                  : "minimum" in a && r < a.minimum
                  ? [
                      new pt(
                        t,
                        r,
                        `${r} is less than the minimum value ${a.minimum}`
                      ),
                    ]
                  : "maximum" in a && r > a.maximum
                  ? [
                      new pt(
                        t,
                        r,
                        `${r} is greater than the maximum value ${a.maximum}`
                      ),
                    ]
                  : []
              );
            }
            function Sd(n) {
              const t = n.valueSpec,
                r = ei(n.value.type);
              let a,
                c,
                p,
                m = {};
              const v = r !== "categorical" && n.value.property === void 0,
                b = !v,
                C =
                  vn(n.value.stops) === "array" &&
                  vn(n.value.stops[0]) === "array" &&
                  vn(n.value.stops[0][0]) === "object",
                I = ra({
                  key: n.key,
                  value: n.value,
                  valueSpec: n.styleSpec.function,
                  validateSpec: n.validateSpec,
                  style: n.style,
                  styleSpec: n.styleSpec,
                  objectElementValidators: {
                    stops: function (Z) {
                      if (r === "identity")
                        return [
                          new pt(
                            Z.key,
                            Z.value,
                            'identity function may not have a "stops" property'
                          ),
                        ];
                      let X = [];
                      const Q = Z.value;
                      return (
                        (X = X.concat(
                          ys({
                            key: Z.key,
                            value: Q,
                            valueSpec: Z.valueSpec,
                            validateSpec: Z.validateSpec,
                            style: Z.style,
                            styleSpec: Z.styleSpec,
                            arrayElementValidator: R,
                          })
                        )),
                        vn(Q) === "array" &&
                          Q.length === 0 &&
                          X.push(
                            new pt(
                              Z.key,
                              Q,
                              "array must have at least one stop"
                            )
                          ),
                        X
                      );
                    },
                    default: function (Z) {
                      return Z.validateSpec({
                        key: Z.key,
                        value: Z.value,
                        valueSpec: t,
                        validateSpec: Z.validateSpec,
                        style: Z.style,
                        styleSpec: Z.styleSpec,
                      });
                    },
                  },
                });
              return (
                r === "identity" &&
                  v &&
                  I.push(
                    new pt(
                      n.key,
                      n.value,
                      'missing required property "property"'
                    )
                  ),
                r === "identity" ||
                  n.value.stops ||
                  I.push(
                    new pt(n.key, n.value, 'missing required property "stops"')
                  ),
                r === "exponential" &&
                  n.valueSpec.expression &&
                  !ru(n.valueSpec) &&
                  I.push(
                    new pt(
                      n.key,
                      n.value,
                      "exponential functions not supported"
                    )
                  ),
                n.styleSpec.$version >= 8 &&
                  (b && !vs(n.valueSpec)
                    ? I.push(
                        new pt(
                          n.key,
                          n.value,
                          "property functions not supported"
                        )
                      )
                    : v &&
                      !md(n.valueSpec) &&
                      I.push(
                        new pt(n.key, n.value, "zoom functions not supported")
                      )),
                (r !== "categorical" && !C) ||
                  n.value.property !== void 0 ||
                  I.push(
                    new pt(n.key, n.value, '"property" property is required')
                  ),
                I
              );
              function R(Z) {
                let X = [];
                const Q = Z.value,
                  ie = Z.key;
                if (vn(Q) !== "array")
                  return [new pt(ie, Q, `array expected, ${vn(Q)} found`)];
                if (Q.length !== 2)
                  return [
                    new pt(
                      ie,
                      Q,
                      `array length 2 expected, length ${Q.length} found`
                    ),
                  ];
                if (C) {
                  if (vn(Q[0]) !== "object")
                    return [
                      new pt(ie, Q, `object expected, ${vn(Q[0])} found`),
                    ];
                  if (Q[0].zoom === void 0)
                    return [new pt(ie, Q, "object stop key must have zoom")];
                  if (Q[0].value === void 0)
                    return [new pt(ie, Q, "object stop key must have value")];
                  if (p && p > ei(Q[0].zoom))
                    return [
                      new pt(
                        ie,
                        Q[0].zoom,
                        "stop zoom values must appear in ascending order"
                      ),
                    ];
                  ei(Q[0].zoom) !== p &&
                    ((p = ei(Q[0].zoom)), (c = void 0), (m = {})),
                    (X = X.concat(
                      ra({
                        key: `${ie}[0]`,
                        value: Q[0],
                        valueSpec: { zoom: {} },
                        validateSpec: Z.validateSpec,
                        style: Z.style,
                        styleSpec: Z.styleSpec,
                        objectElementValidators: { zoom: Wl, value: U },
                      })
                    ));
                } else X = X.concat(U({ key: `${ie}[0]`, value: Q[0], validateSpec: Z.validateSpec, style: Z.style, styleSpec: Z.styleSpec }, Q));
                return jl(eo(Q[1]))
                  ? X.concat([
                      new pt(
                        `${ie}[1]`,
                        Q[1],
                        "expressions are not allowed in function stops."
                      ),
                    ])
                  : X.concat(
                      Z.validateSpec({
                        key: `${ie}[1]`,
                        value: Q[1],
                        valueSpec: t,
                        validateSpec: Z.validateSpec,
                        style: Z.style,
                        styleSpec: Z.styleSpec,
                      })
                    );
              }
              function U(Z, X) {
                const Q = vn(Z.value),
                  ie = ei(Z.value),
                  he = Z.value !== null ? Z.value : X;
                if (a) {
                  if (Q !== a)
                    return [
                      new pt(
                        Z.key,
                        he,
                        `${Q} stop domain type must match previous stop domain type ${a}`
                      ),
                    ];
                } else a = Q;
                if (Q !== "number" && Q !== "string" && Q !== "boolean")
                  return [
                    new pt(
                      Z.key,
                      he,
                      "stop domain value must be a number, string, or boolean"
                    ),
                  ];
                if (Q !== "number" && r !== "categorical") {
                  let Oe = `number expected, ${Q} found`;
                  return (
                    vs(t) &&
                      r === void 0 &&
                      (Oe +=
                        '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new pt(Z.key, he, Oe)]
                  );
                }
                return r !== "categorical" ||
                  Q !== "number" ||
                  (isFinite(ie) && Math.floor(ie) === ie)
                  ? r !== "categorical" &&
                    Q === "number" &&
                    c !== void 0 &&
                    ie < c
                    ? [
                        new pt(
                          Z.key,
                          he,
                          "stop domain values must appear in ascending order"
                        ),
                      ]
                    : ((c = ie),
                      r === "categorical" && ie in m
                        ? [
                            new pt(
                              Z.key,
                              he,
                              "stop domain values must be unique"
                            ),
                          ]
                        : ((m[ie] = !0), []))
                  : [new pt(Z.key, he, `integer expected, found ${ie}`)];
              }
            }
            function xs(n) {
              const t = (n.expressionContext === "property" ? yd : Zo)(
                eo(n.value),
                n.valueSpec
              );
              if (t.result === "error")
                return t.value.map(
                  (a) => new pt(`${n.key}${a.key}`, n.value, a.message)
                );
              const r =
                t.value.expression || t.value._styleExpression.expression;
              if (
                n.expressionContext === "property" &&
                n.propertyKey === "text-font" &&
                !r.outputDefined()
              )
                return [
                  new pt(
                    n.key,
                    n.value,
                    `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`
                  ),
                ];
              if (
                n.expressionContext === "property" &&
                n.propertyType === "layout" &&
                !Ws(r)
              )
                return [
                  new pt(
                    n.key,
                    n.value,
                    '"feature-state" data expressions are not supported with layout properties.'
                  ),
                ];
              if (n.expressionContext === "filter" && !Ws(r))
                return [
                  new pt(
                    n.key,
                    n.value,
                    '"feature-state" data expressions are not supported with filters.'
                  ),
                ];
              if (
                n.expressionContext &&
                n.expressionContext.indexOf("cluster") === 0
              ) {
                if (!Ol(r, ["zoom", "feature-state"]))
                  return [
                    new pt(
                      n.key,
                      n.value,
                      '"zoom" and "feature-state" expressions are not supported with cluster properties.'
                    ),
                  ];
                if (n.expressionContext === "cluster-initial" && !Bl(r))
                  return [
                    new pt(
                      n.key,
                      n.value,
                      "Feature data expressions are not supported with initial expression part of cluster properties."
                    ),
                  ];
              }
              return [];
            }
            function su(n) {
              const t = n.key,
                r = n.value,
                a = vn(r);
              return a !== "string"
                ? [new pt(t, r, `color expected, ${a} found`)]
                : Cr.parse(String(r))
                ? []
                : [new pt(t, r, `color expected, "${r}" found`)];
            }
            function Js(n) {
              const t = n.key,
                r = n.value,
                a = n.valueSpec,
                c = [];
              return (
                Array.isArray(a.values)
                  ? a.values.indexOf(ei(r)) === -1 &&
                    c.push(
                      new pt(
                        t,
                        r,
                        `expected one of [${a.values.join(
                          ", "
                        )}], ${JSON.stringify(r)} found`
                      )
                    )
                  : Object.keys(a.values).indexOf(ei(r)) === -1 &&
                    c.push(
                      new pt(
                        t,
                        r,
                        `expected one of [${Object.keys(a.values).join(
                          ", "
                        )}], ${JSON.stringify(r)} found`
                      )
                    ),
                c
              );
            }
            function lu(n) {
              return Zl(eo(n.value))
                ? xs(
                    on({}, n, {
                      expressionContext: "filter",
                      valueSpec: { value: "boolean" },
                    })
                  )
                : cu(n);
            }
            function cu(n) {
              const t = n.value,
                r = n.key;
              if (vn(t) !== "array")
                return [new pt(r, t, `array expected, ${vn(t)} found`)];
              const a = n.styleSpec;
              let c,
                p = [];
              if (t.length < 1)
                return [
                  new pt(r, t, "filter array must have at least 1 element"),
                ];
              switch (
                ((p = p.concat(
                  Js({
                    key: `${r}[0]`,
                    value: t[0],
                    valueSpec: a.filter_operator,
                    style: n.style,
                    styleSpec: n.styleSpec,
                  })
                )),
                ei(t[0]))
              ) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  t.length >= 2 &&
                    ei(t[1]) === "$type" &&
                    p.push(
                      new pt(
                        r,
                        t,
                        `"$type" cannot be use with operator "${t[0]}"`
                      )
                    );
                case "==":
                case "!=":
                  t.length !== 3 &&
                    p.push(
                      new pt(
                        r,
                        t,
                        `filter array for operator "${t[0]}" must have 3 elements`
                      )
                    );
                case "in":
                case "!in":
                  t.length >= 2 &&
                    ((c = vn(t[1])),
                    c !== "string" &&
                      p.push(
                        new pt(`${r}[1]`, t[1], `string expected, ${c} found`)
                      ));
                  for (let m = 2; m < t.length; m++)
                    (c = vn(t[m])),
                      ei(t[1]) === "$type"
                        ? (p = p.concat(
                            Js({
                              key: `${r}[${m}]`,
                              value: t[m],
                              valueSpec: a.geometry_type,
                              style: n.style,
                              styleSpec: n.styleSpec,
                            })
                          ))
                        : c !== "string" &&
                          c !== "number" &&
                          c !== "boolean" &&
                          p.push(
                            new pt(
                              `${r}[${m}]`,
                              t[m],
                              `string, number, or boolean expected, ${c} found`
                            )
                          );
                  break;
                case "any":
                case "all":
                case "none":
                  for (let m = 1; m < t.length; m++)
                    p = p.concat(
                      cu({
                        key: `${r}[${m}]`,
                        value: t[m],
                        style: n.style,
                        styleSpec: n.styleSpec,
                      })
                    );
                  break;
                case "has":
                case "!has":
                  (c = vn(t[1])),
                    t.length !== 2
                      ? p.push(
                          new pt(
                            r,
                            t,
                            `filter array for "${t[0]}" operator must have 2 elements`
                          )
                        )
                      : c !== "string" &&
                        p.push(
                          new pt(`${r}[1]`, t[1], `string expected, ${c} found`)
                        );
              }
              return p;
            }
            function uu(n, t) {
              const r = n.key,
                a = n.validateSpec,
                c = n.style,
                p = n.styleSpec,
                m = n.value,
                v = n.objectKey,
                b = p[`${t}_${n.layerType}`];
              if (!b) return [];
              const C = v.match(/^(.*)-transition$/);
              if (t === "paint" && C && b[C[1]] && b[C[1]].transition)
                return a({
                  key: r,
                  value: m,
                  valueSpec: p.transition,
                  style: c,
                  styleSpec: p,
                });
              const I = n.valueSpec || b[v];
              if (!I) return [new pt(r, m, `unknown property "${v}"`)];
              let R;
              if (
                vn(m) === "string" &&
                vs(I) &&
                !I.tokens &&
                (R = /^{([^}]+)}$/.exec(m))
              )
                return [
                  new pt(
                    r,
                    m,
                    `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
                      R[1]
                    )} }\`.`
                  ),
                ];
              const U = [];
              return (
                n.layerType === "symbol" &&
                  v === "text-font" &&
                  Nl(eo(m)) &&
                  ei(m.type) === "identity" &&
                  U.push(
                    new pt(
                      r,
                      m,
                      '"text-font" does not support identity functions'
                    )
                  ),
                U.concat(
                  a({
                    key: n.key,
                    value: m,
                    valueSpec: I,
                    style: c,
                    styleSpec: p,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: v,
                  })
                )
              );
            }
            function Qs(n) {
              return uu(n, "paint");
            }
            function Cd(n) {
              return uu(n, "layout");
            }
            function hu(n) {
              let t = [];
              const r = n.value,
                a = n.key,
                c = n.style,
                p = n.styleSpec;
              if (vn(r) !== "object")
                return [new pt(a, r, `object expected, ${vn(r)} found`)];
              r.type ||
                r.ref ||
                t.push(new pt(a, r, 'either "type" or "ref" is required'));
              let m = ei(r.type);
              const v = ei(r.ref);
              if (r.id) {
                const b = ei(r.id);
                for (let C = 0; C < n.arrayIndex; C++) {
                  const I = c.layers[C];
                  ei(I.id) === b &&
                    t.push(
                      new pt(
                        a,
                        r.id,
                        `duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`
                      )
                    );
                }
              }
              if ("ref" in r) {
                let b;
                ["type", "source", "source-layer", "filter", "layout"].forEach(
                  (C) => {
                    C in r &&
                      t.push(
                        new pt(a, r[C], `"${C}" is prohibited for ref layers`)
                      );
                  }
                ),
                  c.layers.forEach((C) => {
                    ei(C.id) === v && (b = C);
                  }),
                  b
                    ? b.ref
                      ? t.push(
                          new pt(
                            a,
                            r.ref,
                            "ref cannot reference another ref layer"
                          )
                        )
                      : (m = ei(b.type))
                    : t.push(new pt(a, r.ref, `ref layer "${v}" not found`));
              } else if (m !== "background")
                if (r.source) {
                  const b = c.sources && c.sources[r.source],
                    C = b && ei(b.type);
                  b
                    ? C === "vector" && m === "raster"
                      ? t.push(
                          new pt(
                            a,
                            r.source,
                            `layer "${r.id}" requires a raster source`
                          )
                        )
                      : (C !== "raster-dem" && m === "hillshade") ||
                        (C !== "raster-dem" && m === "color-relief")
                      ? t.push(
                          new pt(
                            a,
                            r.source,
                            `layer "${r.id}" requires a raster-dem source`
                          )
                        )
                      : C === "raster" && m !== "raster"
                      ? t.push(
                          new pt(
                            a,
                            r.source,
                            `layer "${r.id}" requires a vector source`
                          )
                        )
                      : C !== "vector" || r["source-layer"]
                      ? C === "raster-dem" &&
                        m !== "hillshade" &&
                        m !== "color-relief"
                        ? t.push(
                            new pt(
                              a,
                              r.source,
                              "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'."
                            )
                          )
                        : m !== "line" ||
                          !r.paint ||
                          !r.paint["line-gradient"] ||
                          (C === "geojson" && b.lineMetrics) ||
                          t.push(
                            new pt(
                              a,
                              r,
                              `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                            )
                          )
                      : t.push(
                          new pt(
                            a,
                            r,
                            `layer "${r.id}" must specify a "source-layer"`
                          )
                        )
                    : t.push(
                        new pt(a, r.source, `source "${r.source}" not found`)
                      );
                } else
                  t.push(new pt(a, r, 'missing required property "source"'));
              return (
                (t = t.concat(
                  ra({
                    key: a,
                    value: r,
                    valueSpec: p.layer,
                    style: n.style,
                    styleSpec: n.styleSpec,
                    validateSpec: n.validateSpec,
                    objectElementValidators: {
                      "*": () => [],
                      type: () =>
                        n.validateSpec({
                          key: `${a}.type`,
                          value: r.type,
                          valueSpec: p.layer.type,
                          style: n.style,
                          styleSpec: n.styleSpec,
                          validateSpec: n.validateSpec,
                          object: r,
                          objectKey: "type",
                        }),
                      filter: lu,
                      layout: (b) =>
                        ra({
                          layer: r,
                          key: b.key,
                          value: b.value,
                          style: b.style,
                          styleSpec: b.styleSpec,
                          validateSpec: b.validateSpec,
                          objectElementValidators: {
                            "*": (C) => Cd(on({ layerType: m }, C)),
                          },
                        }),
                      paint: (b) =>
                        ra({
                          layer: r,
                          key: b.key,
                          value: b.value,
                          style: b.style,
                          styleSpec: b.styleSpec,
                          validateSpec: b.validateSpec,
                          objectElementValidators: {
                            "*": (C) => Qs(on({ layerType: m }, C)),
                          },
                        }),
                    },
                  })
                )),
                t
              );
            }
            function wo(n) {
              const t = n.value,
                r = n.key,
                a = vn(t);
              return a !== "string"
                ? [new pt(r, t, `string expected, ${a} found`)]
                : [];
            }
            const Pd = {
              promoteId: function ({ key: n, value: t }) {
                if (vn(t) === "string") return wo({ key: n, value: t });
                {
                  const r = [];
                  for (const a in t)
                    r.push(...wo({ key: `${n}.${a}`, value: t[a] }));
                  return r;
                }
              },
            };
            function du(n) {
              const t = n.value,
                r = n.key,
                a = n.styleSpec,
                c = n.style,
                p = n.validateSpec;
              if (!t.type) return [new pt(r, t, '"type" is required')];
              const m = ei(t.type);
              let v;
              switch (m) {
                case "vector":
                case "raster":
                  return (
                    (v = ra({
                      key: r,
                      value: t,
                      valueSpec: a[`source_${m.replace("-", "_")}`],
                      style: n.style,
                      styleSpec: a,
                      objectElementValidators: Pd,
                      validateSpec: p,
                    })),
                    v
                  );
                case "raster-dem":
                  return (
                    (v = (function (b) {
                      var C;
                      const I =
                          (C = b.sourceName) !== null && C !== void 0 ? C : "",
                        R = b.value,
                        U = b.styleSpec,
                        Z = U.source_raster_dem,
                        X = b.style;
                      let Q = [];
                      const ie = vn(R);
                      if (R === void 0) return Q;
                      if (ie !== "object")
                        return (
                          Q.push(
                            new pt(
                              "source_raster_dem",
                              R,
                              `object expected, ${ie} found`
                            )
                          ),
                          Q
                        );
                      const he = ei(R.encoding) === "custom",
                        Oe = [
                          "redFactor",
                          "greenFactor",
                          "blueFactor",
                          "baseShift",
                        ],
                        ye = b.value.encoding
                          ? `"${b.value.encoding}"`
                          : "Default";
                      for (const Ce in R)
                        !he && Oe.includes(Ce)
                          ? Q.push(
                              new pt(
                                Ce,
                                R[Ce],
                                `In "${I}": "${Ce}" is only valid when "encoding" is set to "custom". ${ye} encoding found`
                              )
                            )
                          : Z[Ce]
                          ? (Q = Q.concat(
                              b.validateSpec({
                                key: Ce,
                                value: R[Ce],
                                valueSpec: Z[Ce],
                                validateSpec: b.validateSpec,
                                style: X,
                                styleSpec: U,
                              })
                            ))
                          : Q.push(
                              new pt(Ce, R[Ce], `unknown property "${Ce}"`)
                            );
                      return Q;
                    })({
                      sourceName: r,
                      value: t,
                      style: n.style,
                      styleSpec: a,
                      validateSpec: p,
                    })),
                    v
                  );
                case "geojson":
                  if (
                    ((v = ra({
                      key: r,
                      value: t,
                      valueSpec: a.source_geojson,
                      style: c,
                      styleSpec: a,
                      validateSpec: p,
                      objectElementValidators: Pd,
                    })),
                    t.cluster)
                  )
                    for (const b in t.clusterProperties) {
                      const [C, I] = t.clusterProperties[b],
                        R =
                          typeof C == "string"
                            ? [C, ["accumulated"], ["get", b]]
                            : C;
                      v.push(
                        ...xs({
                          key: `${r}.${b}.map`,
                          value: I,
                          expressionContext: "cluster-map",
                        })
                      ),
                        v.push(
                          ...xs({
                            key: `${r}.${b}.reduce`,
                            value: R,
                            expressionContext: "cluster-reduce",
                          })
                        );
                    }
                  return v;
                case "video":
                  return ra({
                    key: r,
                    value: t,
                    valueSpec: a.source_video,
                    style: c,
                    validateSpec: p,
                    styleSpec: a,
                  });
                case "image":
                  return ra({
                    key: r,
                    value: t,
                    valueSpec: a.source_image,
                    style: c,
                    validateSpec: p,
                    styleSpec: a,
                  });
                case "canvas":
                  return [
                    new pt(
                      r,
                      null,
                      "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                      "source.canvas"
                    ),
                  ];
                default:
                  return Js({
                    key: `${r}.type`,
                    value: t.type,
                    valueSpec: {
                      values: [
                        "vector",
                        "raster",
                        "raster-dem",
                        "geojson",
                        "video",
                        "image",
                      ],
                    },
                  });
              }
            }
            function pu(n) {
              const t = n.value,
                r = n.styleSpec,
                a = r.light,
                c = n.style;
              let p = [];
              const m = vn(t);
              if (t === void 0) return p;
              if (m !== "object")
                return (
                  (p = p.concat([
                    new pt("light", t, `object expected, ${m} found`),
                  ])),
                  p
                );
              for (const v in t) {
                const b = v.match(/^(.*)-transition$/);
                p = p.concat(
                  b && a[b[1]] && a[b[1]].transition
                    ? n.validateSpec({
                        key: v,
                        value: t[v],
                        valueSpec: r.transition,
                        validateSpec: n.validateSpec,
                        style: c,
                        styleSpec: r,
                      })
                    : a[v]
                    ? n.validateSpec({
                        key: v,
                        value: t[v],
                        valueSpec: a[v],
                        validateSpec: n.validateSpec,
                        style: c,
                        styleSpec: r,
                      })
                    : [new pt(v, t[v], `unknown property "${v}"`)]
                );
              }
              return p;
            }
            function bs(n) {
              const t = n.value,
                r = n.styleSpec,
                a = r.sky,
                c = n.style,
                p = vn(t);
              if (t === void 0) return [];
              if (p !== "object")
                return [new pt("sky", t, `object expected, ${p} found`)];
              let m = [];
              for (const v in t)
                m = m.concat(
                  a[v]
                    ? n.validateSpec({
                        key: v,
                        value: t[v],
                        valueSpec: a[v],
                        style: c,
                        styleSpec: r,
                      })
                    : [new pt(v, t[v], `unknown property "${v}"`)]
                );
              return m;
            }
            function Id(n) {
              const t = n.value,
                r = n.styleSpec,
                a = r.terrain,
                c = n.style;
              let p = [];
              const m = vn(t);
              if (t === void 0) return p;
              if (m !== "object")
                return (
                  (p = p.concat([
                    new pt("terrain", t, `object expected, ${m} found`),
                  ])),
                  p
                );
              for (const v in t)
                p = p.concat(
                  a[v]
                    ? n.validateSpec({
                        key: v,
                        value: t[v],
                        valueSpec: a[v],
                        validateSpec: n.validateSpec,
                        style: c,
                        styleSpec: r,
                      })
                    : [new pt(v, t[v], `unknown property "${v}"`)]
                );
              return p;
            }
            function Md(n) {
              let t = [];
              const r = n.value,
                a = n.key;
              if (Array.isArray(r)) {
                const c = [],
                  p = [];
                for (const m in r)
                  r[m].id &&
                    c.includes(r[m].id) &&
                    t.push(
                      new pt(
                        a,
                        r,
                        `all the sprites' ids must be unique, but ${r[m].id} is duplicated`
                      )
                    ),
                    c.push(r[m].id),
                    r[m].url &&
                      p.includes(r[m].url) &&
                      t.push(
                        new pt(
                          a,
                          r,
                          `all the sprites' URLs must be unique, but ${r[m].url} is duplicated`
                        )
                      ),
                    p.push(r[m].url),
                    (t = t.concat(
                      ra({
                        key: `${a}[${m}]`,
                        value: r[m],
                        valueSpec: {
                          id: { type: "string", required: !0 },
                          url: { type: "string", required: !0 },
                        },
                        validateSpec: n.validateSpec,
                      })
                    ));
                return t;
              }
              return wo({ key: a, value: r });
            }
            function Ad(n) {
              return (
                (t = n.value),
                t && t.constructor === Object
                  ? []
                  : [
                      new pt(
                        n.key,
                        n.value,
                        `object expected, ${vn(n.value)} found`
                      ),
                    ]
              );
              var t;
            }
            const kd = {
              "*": () => [],
              array: ys,
              boolean: function (n) {
                const t = n.value,
                  r = n.key,
                  a = vn(t);
                return a !== "boolean"
                  ? [new pt(r, t, `boolean expected, ${a} found`)]
                  : [];
              },
              number: Wl,
              color: su,
              constants: Hl,
              enum: Js,
              filter: lu,
              function: Sd,
              layer: hu,
              object: ra,
              source: du,
              light: pu,
              sky: bs,
              terrain: Id,
              projection: function (n) {
                const t = n.value,
                  r = n.styleSpec,
                  a = r.projection,
                  c = n.style,
                  p = vn(t);
                if (t === void 0) return [];
                if (p !== "object")
                  return [
                    new pt("projection", t, `object expected, ${p} found`),
                  ];
                let m = [];
                for (const v in t)
                  m = m.concat(
                    a[v]
                      ? n.validateSpec({
                          key: v,
                          value: t[v],
                          valueSpec: a[v],
                          style: c,
                          styleSpec: r,
                        })
                      : [new pt(v, t[v], `unknown property "${v}"`)]
                  );
                return m;
              },
              projectionDefinition: function (n) {
                const t = n.key;
                let r = n.value;
                r = r instanceof String ? r.valueOf() : r;
                const a = vn(r);
                return a !== "array" ||
                  (function (c) {
                    return (
                      Array.isArray(c) &&
                      c.length === 3 &&
                      typeof c[0] == "string" &&
                      typeof c[1] == "string" &&
                      typeof c[2] == "number"
                    );
                  })(r) ||
                  (function (c) {
                    return !!["interpolate", "step", "literal"].includes(c[0]);
                  })(r)
                  ? ["array", "string"].includes(a)
                    ? []
                    : [
                        new pt(
                          t,
                          r,
                          `projection expected, invalid type "${a}" found`
                        ),
                      ]
                  : [
                      new pt(
                        t,
                        r,
                        `projection expected, invalid array ${JSON.stringify(
                          r
                        )} found`
                      ),
                    ];
              },
              string: wo,
              formatted: function (n) {
                return wo(n).length === 0 ? [] : xs(n);
              },
              resolvedImage: function (n) {
                return wo(n).length === 0 ? [] : xs(n);
              },
              padding: function (n) {
                const t = n.key,
                  r = n.value;
                if (vn(r) === "array") {
                  if (r.length < 1 || r.length > 4)
                    return [
                      new pt(
                        t,
                        r,
                        `padding requires 1 to 4 values; ${r.length} values found`
                      ),
                    ];
                  const a = { type: "number" };
                  let c = [];
                  for (let p = 0; p < r.length; p++)
                    c = c.concat(
                      n.validateSpec({
                        key: `${t}[${p}]`,
                        value: r[p],
                        validateSpec: n.validateSpec,
                        valueSpec: a,
                      })
                    );
                  return c;
                }
                return Wl({ key: t, value: r, valueSpec: {} });
              },
              numberArray: function (n) {
                const t = n.key,
                  r = n.value;
                if (vn(r) === "array") {
                  const a = { type: "number" };
                  if (r.length < 1)
                    return [
                      new pt(
                        t,
                        r,
                        "array length at least 1 expected, length 0 found"
                      ),
                    ];
                  let c = [];
                  for (let p = 0; p < r.length; p++)
                    c = c.concat(
                      n.validateSpec({
                        key: `${t}[${p}]`,
                        value: r[p],
                        validateSpec: n.validateSpec,
                        valueSpec: a,
                      })
                    );
                  return c;
                }
                return Wl({ key: t, value: r, valueSpec: {} });
              },
              colorArray: function (n) {
                const t = n.key,
                  r = n.value;
                if (vn(r) === "array") {
                  if (r.length < 1)
                    return [
                      new pt(
                        t,
                        r,
                        "array length at least 1 expected, length 0 found"
                      ),
                    ];
                  let a = [];
                  for (let c = 0; c < r.length; c++)
                    a = a.concat(su({ key: `${t}[${c}]`, value: r[c] }));
                  return a;
                }
                return su({ key: t, value: r });
              },
              variableAnchorOffsetCollection: function (n) {
                const t = n.key,
                  r = n.value,
                  a = vn(r),
                  c = n.styleSpec;
                if (a !== "array" || r.length < 1 || r.length % 2 != 0)
                  return [
                    new pt(
                      t,
                      r,
                      "variableAnchorOffsetCollection requires a non-empty array of even length"
                    ),
                  ];
                let p = [];
                for (let m = 0; m < r.length; m += 2)
                  (p = p.concat(
                    Js({
                      key: `${t}[${m}]`,
                      value: r[m],
                      valueSpec: c.layout_symbol["text-anchor"],
                    })
                  )),
                    (p = p.concat(
                      ys({
                        key: `${t}[${m + 1}]`,
                        value: r[m + 1],
                        valueSpec: { length: 2, value: "number" },
                        validateSpec: n.validateSpec,
                        style: n.style,
                        styleSpec: c,
                      })
                    ));
                return p;
              },
              sprite: Md,
              state: Ad,
            };
            function Xl(n) {
              const t = n.value,
                r = n.valueSpec,
                a = n.styleSpec;
              return (
                (n.validateSpec = Xl),
                r.expression && Nl(ei(t))
                  ? Sd(n)
                  : r.expression && jl(eo(t))
                  ? xs(n)
                  : r.type && kd[r.type]
                  ? kd[r.type](n)
                  : ra(on({}, n, { valueSpec: r.type ? a[r.type] : r }))
              );
            }
            function Ed(n) {
              const t = n.value,
                r = n.key,
                a = wo(n);
              return (
                a.length ||
                  (t.indexOf("{fontstack}") === -1 &&
                    a.push(
                      new pt(
                        r,
                        t,
                        '"glyphs" url must include a "{fontstack}" token'
                      )
                    ),
                  t.indexOf("{range}") === -1 &&
                    a.push(
                      new pt(
                        r,
                        t,
                        '"glyphs" url must include a "{range}" token'
                      )
                    )),
                a
              );
            }
            function qi(n, t = _e) {
              let r = [];
              return (
                (r = r.concat(
                  Xl({
                    key: "",
                    value: n,
                    valueSpec: t.$root,
                    styleSpec: t,
                    style: n,
                    validateSpec: Xl,
                    objectElementValidators: { glyphs: Ed, "*": () => [] },
                  })
                )),
                n.constants &&
                  (r = r.concat(Hl({ key: "constants", value: n.constants }))),
                na(r)
              );
            }
            function Wi(n) {
              return function (t) {
                return n(Object.assign({}, t, { validateSpec: Xl }));
              };
            }
            function na(n) {
              return [].concat(n).sort((t, r) => t.line - r.line);
            }
            function Xi(n) {
              return function (...t) {
                return na(n.apply(this, t));
              };
            }
            (qi.source = Xi(Wi(du))),
              (qi.sprite = Xi(Wi(Md))),
              (qi.glyphs = Xi(Wi(Ed))),
              (qi.light = Xi(Wi(pu))),
              (qi.sky = Xi(Wi(bs))),
              (qi.terrain = Xi(Wi(Id))),
              (qi.state = Xi(Wi(Ad))),
              (qi.layer = Xi(Wi(hu))),
              (qi.filter = Xi(Wi(lu))),
              (qi.paintProperty = Xi(Wi(Qs))),
              (qi.layoutProperty = Xi(Wi(Cd)));
            const zd = _e,
              ws = qi,
              yf = ws.light,
              el = ws.sky,
              Ld = ws.paintProperty,
              fu = ws.layoutProperty;
            function Dd(n, t) {
              let r = !1;
              if (t && t.length)
                for (const a of t)
                  n.fire(new Ze(new Error(a.message))), (r = !0);
              return r;
            }
            class $o {
              constructor(t, r, a) {
                const c = (this.cells = []);
                if (t instanceof ArrayBuffer) {
                  this.arrayBuffer = t;
                  const m = new Int32Array(this.arrayBuffer);
                  (t = m[0]), (this.d = (r = m[1]) + 2 * (a = m[2]));
                  for (let b = 0; b < this.d * this.d; b++) {
                    const C = m[3 + b],
                      I = m[3 + b + 1];
                    c.push(C === I ? null : m.subarray(C, I));
                  }
                  const v = m[3 + c.length + 1];
                  (this.keys = m.subarray(m[3 + c.length], v)),
                    (this.bboxes = m.subarray(v)),
                    (this.insert = this._insertReadonly);
                } else {
                  this.d = r + 2 * a;
                  for (let m = 0; m < this.d * this.d; m++) c.push([]);
                  (this.keys = []), (this.bboxes = []);
                }
                (this.n = r),
                  (this.extent = t),
                  (this.padding = a),
                  (this.scale = r / t),
                  (this.uid = 0);
                const p = (a / r) * t;
                (this.min = -p), (this.max = t + p);
              }
              insert(t, r, a, c, p) {
                this._forEachCell(
                  r,
                  a,
                  c,
                  p,
                  this._insertCell,
                  this.uid++,
                  void 0,
                  void 0
                ),
                  this.keys.push(t),
                  this.bboxes.push(r),
                  this.bboxes.push(a),
                  this.bboxes.push(c),
                  this.bboxes.push(p);
              }
              _insertReadonly() {
                throw new Error(
                  "Cannot insert into a GridIndex created from an ArrayBuffer."
                );
              }
              _insertCell(t, r, a, c, p, m) {
                this.cells[p].push(m);
              }
              query(t, r, a, c, p) {
                const m = this.min,
                  v = this.max;
                if (t <= m && r <= m && v <= a && v <= c && !p)
                  return Array.prototype.slice.call(this.keys);
                {
                  const b = [];
                  return (
                    this._forEachCell(t, r, a, c, this._queryCell, b, {}, p), b
                  );
                }
              }
              _queryCell(t, r, a, c, p, m, v, b) {
                const C = this.cells[p];
                if (C !== null) {
                  const I = this.keys,
                    R = this.bboxes;
                  for (let U = 0; U < C.length; U++) {
                    const Z = C[U];
                    if (v[Z] === void 0) {
                      const X = 4 * Z;
                      (
                        b
                          ? b(R[X + 0], R[X + 1], R[X + 2], R[X + 3])
                          : t <= R[X + 2] &&
                            r <= R[X + 3] &&
                            a >= R[X + 0] &&
                            c >= R[X + 1]
                      )
                        ? ((v[Z] = !0), m.push(I[Z]))
                        : (v[Z] = !1);
                    }
                  }
                }
              }
              _forEachCell(t, r, a, c, p, m, v, b) {
                const C = this._convertToCellCoord(t),
                  I = this._convertToCellCoord(r),
                  R = this._convertToCellCoord(a),
                  U = this._convertToCellCoord(c);
                for (let Z = C; Z <= R; Z++)
                  for (let X = I; X <= U; X++) {
                    const Q = this.d * X + Z;
                    if (
                      (!b ||
                        b(
                          this._convertFromCellCoord(Z),
                          this._convertFromCellCoord(X),
                          this._convertFromCellCoord(Z + 1),
                          this._convertFromCellCoord(X + 1)
                        )) &&
                      p.call(this, t, r, a, c, Q, m, v, b)
                    )
                      return;
                  }
              }
              _convertFromCellCoord(t) {
                return (t - this.padding) / this.scale;
              }
              _convertToCellCoord(t) {
                return Math.max(
                  0,
                  Math.min(
                    this.d - 1,
                    Math.floor(t * this.scale) + this.padding
                  )
                );
              }
              toArrayBuffer() {
                if (this.arrayBuffer) return this.arrayBuffer;
                const t = this.cells,
                  r = 3 + this.cells.length + 1 + 1;
                let a = 0;
                for (let m = 0; m < this.cells.length; m++)
                  a += this.cells[m].length;
                const c = new Int32Array(
                  r + a + this.keys.length + this.bboxes.length
                );
                (c[0] = this.extent), (c[1] = this.n), (c[2] = this.padding);
                let p = r;
                for (let m = 0; m < t.length; m++) {
                  const v = t[m];
                  (c[3 + m] = p), c.set(v, p), (p += v.length);
                }
                return (
                  (c[3 + t.length] = p),
                  c.set(this.keys, p),
                  (p += this.keys.length),
                  (c[3 + t.length + 1] = p),
                  c.set(this.bboxes, p),
                  (p += this.bboxes.length),
                  c.buffer
                );
              }
              static serialize(t, r) {
                const a = t.toArrayBuffer();
                return r && r.push(a), { buffer: a };
              }
              static deserialize(t) {
                return new $o(t.buffer);
              }
            }
            const to = {};
            function hr(n, t, r = {}) {
              if (to[n]) throw new Error(`${n} is already registered.`);
              Object.defineProperty(t, "_classRegistryKey", {
                value: n,
                writeable: !1,
              }),
                (to[n] = {
                  klass: t,
                  omit: r.omit || [],
                  shallow: r.shallow || [],
                });
            }
            hr("Object", Object),
              hr("Set", Set),
              hr("TransferableGridIndex", $o),
              hr("Color", Cr),
              hr("Error", Error),
              hr("AJAXError", H),
              hr("ResolvedImage", En),
              hr("StylePropertyFunction", Vl),
              hr("StyleExpression", nu, { omit: ["_evaluator"] }),
              hr("ZoomDependentExpression", iu),
              hr("ZoomConstantExpression", Xs),
              hr("CompoundExpression", xa, { omit: ["_evaluate"] });
            for (const n in _s)
              _s[n]._classRegistryKey || hr(`Expression_${n}`, _s[n]);
            function Rd(n) {
              return (
                n &&
                typeof ArrayBuffer < "u" &&
                (n instanceof ArrayBuffer ||
                  (n.constructor && n.constructor.name === "ArrayBuffer"))
              );
            }
            function mu(n) {
              return n.$name || n.constructor._classRegistryKey;
            }
            function Fd(n) {
              return (
                !(function (t) {
                  if (t === null || typeof t != "object") return !1;
                  const r = mu(t);
                  return !(!r || r === "Object");
                })(n) &&
                (n == null ||
                  typeof n == "boolean" ||
                  typeof n == "number" ||
                  typeof n == "string" ||
                  n instanceof Boolean ||
                  n instanceof Number ||
                  n instanceof String ||
                  n instanceof Date ||
                  n instanceof RegExp ||
                  n instanceof Blob ||
                  n instanceof Error ||
                  Rd(n) ||
                  Nt(n) ||
                  ArrayBuffer.isView(n) ||
                  n instanceof ImageData)
              );
            }
            function ro(n, t) {
              if (Fd(n))
                return (
                  (Rd(n) || Nt(n)) && t && t.push(n),
                  ArrayBuffer.isView(n) && t && t.push(n.buffer),
                  n instanceof ImageData && t && t.push(n.data.buffer),
                  n
                );
              if (Array.isArray(n)) {
                const p = [];
                for (const m of n) p.push(ro(m, t));
                return p;
              }
              if (typeof n != "object")
                throw new Error("can't serialize object of type " + typeof n);
              const r = mu(n);
              if (!r)
                throw new Error(
                  `can't serialize object of unregistered class ${n.constructor.name}`
                );
              if (!to[r]) throw new Error(`${r} is not registered.`);
              const { klass: a } = to[r],
                c = a.serialize ? a.serialize(n, t) : {};
              if (a.serialize) {
                if (t && c === t[t.length - 1])
                  throw new Error(
                    "statically serialized object won't survive transfer of $name property"
                  );
              } else {
                for (const p in n) {
                  if (!n.hasOwnProperty(p) || to[r].omit.indexOf(p) >= 0)
                    continue;
                  const m = n[p];
                  c[p] = to[r].shallow.indexOf(p) >= 0 ? m : ro(m, t);
                }
                n instanceof Error && (c.message = n.message);
              }
              if (c.$name)
                throw new Error(
                  "$name property is reserved for worker serialization logic."
                );
              return r !== "Object" && (c.$name = r), c;
            }
            function tl(n) {
              if (Fd(n)) return n;
              if (Array.isArray(n)) return n.map(tl);
              if (typeof n != "object")
                throw new Error("can't deserialize object of type " + typeof n);
              const t = mu(n) || "Object";
              if (!to[t])
                throw new Error(`can't deserialize unregistered class ${t}`);
              const { klass: r } = to[t];
              if (!r)
                throw new Error(`can't deserialize unregistered class ${t}`);
              if (r.deserialize) return r.deserialize(n);
              const a = Object.create(r.prototype);
              for (const c of Object.keys(n)) {
                if (c === "$name") continue;
                const p = n[c];
                a[c] = to[t].shallow.indexOf(c) >= 0 ? p : tl(p);
              }
              return a;
            }
            class _u {
              constructor() {
                this.first = !0;
              }
              update(t, r) {
                const a = Math.floor(t);
                return this.first
                  ? ((this.first = !1),
                    (this.lastIntegerZoom = a),
                    (this.lastIntegerZoomTime = 0),
                    (this.lastZoom = t),
                    (this.lastFloorZoom = a),
                    !0)
                  : (this.lastFloorZoom > a
                      ? ((this.lastIntegerZoom = a + 1),
                        (this.lastIntegerZoomTime = r))
                      : this.lastFloorZoom < a &&
                        ((this.lastIntegerZoom = a),
                        (this.lastIntegerZoomTime = r)),
                    t !== this.lastZoom &&
                      ((this.lastZoom = t), (this.lastFloorZoom = a), !0));
              }
            }
            const mn = {
              "Latin-1 Supplement": (n) => n >= 128 && n <= 255,
              "Hangul Jamo": (n) => n >= 4352 && n <= 4607,
              Khmer: (n) => n >= 6016 && n <= 6143,
              "General Punctuation": (n) => n >= 8192 && n <= 8303,
              "Letterlike Symbols": (n) => n >= 8448 && n <= 8527,
              "Number Forms": (n) => n >= 8528 && n <= 8591,
              "Miscellaneous Technical": (n) => n >= 8960 && n <= 9215,
              "Control Pictures": (n) => n >= 9216 && n <= 9279,
              "Optical Character Recognition": (n) => n >= 9280 && n <= 9311,
              "Enclosed Alphanumerics": (n) => n >= 9312 && n <= 9471,
              "Geometric Shapes": (n) => n >= 9632 && n <= 9727,
              "Miscellaneous Symbols": (n) => n >= 9728 && n <= 9983,
              "Miscellaneous Symbols and Arrows": (n) =>
                n >= 11008 && n <= 11263,
              "Ideographic Description Characters": (n) =>
                n >= 12272 && n <= 12287,
              "CJK Symbols and Punctuation": (n) => n >= 12288 && n <= 12351,
              Hiragana: (n) => n >= 12352 && n <= 12447,
              Katakana: (n) => n >= 12448 && n <= 12543,
              Kanbun: (n) => n >= 12688 && n <= 12703,
              "CJK Strokes": (n) => n >= 12736 && n <= 12783,
              "Enclosed CJK Letters and Months": (n) =>
                n >= 12800 && n <= 13055,
              "CJK Compatibility": (n) => n >= 13056 && n <= 13311,
              "Yijing Hexagram Symbols": (n) => n >= 19904 && n <= 19967,
              "CJK Unified Ideographs": (n) => n >= 19968 && n <= 40959,
              "Hangul Syllables": (n) => n >= 44032 && n <= 55215,
              "Private Use Area": (n) => n >= 57344 && n <= 63743,
              "Vertical Forms": (n) => n >= 65040 && n <= 65055,
              "CJK Compatibility Forms": (n) => n >= 65072 && n <= 65103,
              "Small Form Variants": (n) => n >= 65104 && n <= 65135,
              "Halfwidth and Fullwidth Forms": (n) => n >= 65280 && n <= 65519,
            };
            function gu(n) {
              for (const t of n) if (Yl(t.charCodeAt(0))) return !0;
              return !1;
            }
            function vu(n) {
              for (const t of n) if (!Od(t.charCodeAt(0))) return !1;
              return !0;
            }
            function Ts(n) {
              const t = n
                .map((r) => {
                  try {
                    return new RegExp(`\\p{sc=${r}}`, "u").source;
                  } catch {
                    return null;
                  }
                })
                .filter((r) => r);
              return new RegExp(t.join("|"), "u");
            }
            const Bd = Ts(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
            function Od(n) {
              return !Bd.test(String.fromCodePoint(n));
            }
            const yu = Ts([
              "Bopo",
              "Hani",
              "Hira",
              "Kana",
              "Kits",
              "Nshu",
              "Tang",
              "Yiii",
            ]);
            function Yl(n) {
              return !(
                n !== 746 &&
                n !== 747 &&
                (n < 4352 ||
                  !(
                    (mn["CJK Compatibility Forms"](n) &&
                      !(n >= 65097 && n <= 65103)) ||
                    mn["CJK Compatibility"](n) ||
                    mn["CJK Strokes"](n) ||
                    !(
                      !mn["CJK Symbols and Punctuation"](n) ||
                      (n >= 12296 && n <= 12305) ||
                      (n >= 12308 && n <= 12319) ||
                      n === 12336
                    ) ||
                    mn["Enclosed CJK Letters and Months"](n) ||
                    mn["Ideographic Description Characters"](n) ||
                    mn.Kanbun(n) ||
                    (mn.Katakana(n) && n !== 12540) ||
                    !(
                      !mn["Halfwidth and Fullwidth Forms"](n) ||
                      n === 65288 ||
                      n === 65289 ||
                      n === 65293 ||
                      (n >= 65306 && n <= 65310) ||
                      n === 65339 ||
                      n === 65341 ||
                      n === 65343 ||
                      (n >= 65371 && n <= 65503) ||
                      n === 65507 ||
                      (n >= 65512 && n <= 65519)
                    ) ||
                    !(
                      !mn["Small Form Variants"](n) ||
                      (n >= 65112 && n <= 65118) ||
                      (n >= 65123 && n <= 65126)
                    ) ||
                    mn["Vertical Forms"](n) ||
                    mn["Yijing Hexagram Symbols"](n) ||
                    new RegExp("\\p{sc=Cans}", "u").test(
                      String.fromCodePoint(n)
                    ) ||
                    new RegExp("\\p{sc=Hang}", "u").test(
                      String.fromCodePoint(n)
                    ) ||
                    yu.test(String.fromCodePoint(n))
                  ))
              );
            }
            function Kl(n) {
              return !(
                Yl(n) ||
                (function (t) {
                  return !!(
                    (mn["Latin-1 Supplement"](t) &&
                      (t === 167 ||
                        t === 169 ||
                        t === 174 ||
                        t === 177 ||
                        t === 188 ||
                        t === 189 ||
                        t === 190 ||
                        t === 215 ||
                        t === 247)) ||
                    (mn["General Punctuation"](t) &&
                      (t === 8214 ||
                        t === 8224 ||
                        t === 8225 ||
                        t === 8240 ||
                        t === 8241 ||
                        t === 8251 ||
                        t === 8252 ||
                        t === 8258 ||
                        t === 8263 ||
                        t === 8264 ||
                        t === 8265 ||
                        t === 8273)) ||
                    mn["Letterlike Symbols"](t) ||
                    mn["Number Forms"](t) ||
                    (mn["Miscellaneous Technical"](t) &&
                      ((t >= 8960 && t <= 8967) ||
                        (t >= 8972 && t <= 8991) ||
                        (t >= 8996 && t <= 9e3) ||
                        t === 9003 ||
                        (t >= 9085 && t <= 9114) ||
                        (t >= 9150 && t <= 9165) ||
                        t === 9167 ||
                        (t >= 9169 && t <= 9179) ||
                        (t >= 9186 && t <= 9215))) ||
                    (mn["Control Pictures"](t) && t !== 9251) ||
                    mn["Optical Character Recognition"](t) ||
                    mn["Enclosed Alphanumerics"](t) ||
                    mn["Geometric Shapes"](t) ||
                    (mn["Miscellaneous Symbols"](t) &&
                      !(t >= 9754 && t <= 9759)) ||
                    (mn["Miscellaneous Symbols and Arrows"](t) &&
                      ((t >= 11026 && t <= 11055) ||
                        (t >= 11088 && t <= 11097) ||
                        (t >= 11192 && t <= 11243))) ||
                    mn["CJK Symbols and Punctuation"](t) ||
                    mn.Katakana(t) ||
                    mn["Private Use Area"](t) ||
                    mn["CJK Compatibility Forms"](t) ||
                    mn["Small Form Variants"](t) ||
                    mn["Halfwidth and Fullwidth Forms"](t) ||
                    t === 8734 ||
                    t === 8756 ||
                    t === 8757 ||
                    (t >= 9984 && t <= 10087) ||
                    (t >= 10102 && t <= 10131) ||
                    t === 65532 ||
                    t === 65533
                  );
                })(n)
              );
            }
            const Nd = Ts([
              "Adlm",
              "Arab",
              "Armi",
              "Avst",
              "Chrs",
              "Cprt",
              "Egyp",
              "Elym",
              "Gara",
              "Hatr",
              "Hebr",
              "Hung",
              "Khar",
              "Lydi",
              "Mand",
              "Mani",
              "Mend",
              "Merc",
              "Mero",
              "Narb",
              "Nbat",
              "Nkoo",
              "Orkh",
              "Palm",
              "Phli",
              "Phlp",
              "Phnx",
              "Prti",
              "Rohg",
              "Samr",
              "Sarb",
              "Sogo",
              "Syrc",
              "Thaa",
              "Todr",
              "Yezi",
            ]);
            function jd(n) {
              return Nd.test(String.fromCodePoint(n));
            }
            function Vd(n, t) {
              return !(
                (!t && jd(n)) ||
                (n >= 2304 && n <= 3583) ||
                (n >= 3840 && n <= 4255) ||
                mn.Khmer(n)
              );
            }
            function xf(n) {
              for (const t of n) if (jd(t.charCodeAt(0))) return !0;
              return !1;
            }
            const no = new (class {
              constructor() {
                (this.TIMEOUT = 5e3),
                  (this.applyArabicShaping = null),
                  (this.processBidirectionalText = null),
                  (this.processStyledBidirectionalText = null),
                  (this.pluginStatus = "unavailable"),
                  (this.pluginURL = null),
                  (this.loadScriptResolve = () => {});
              }
              setState(n) {
                (this.pluginStatus = n.pluginStatus),
                  (this.pluginURL = n.pluginURL);
              }
              getState() {
                return {
                  pluginStatus: this.pluginStatus,
                  pluginURL: this.pluginURL,
                };
              }
              setMethods(n) {
                if (no.isParsed())
                  throw new Error("RTL text plugin already registered.");
                (this.applyArabicShaping = n.applyArabicShaping),
                  (this.processBidirectionalText = n.processBidirectionalText),
                  (this.processStyledBidirectionalText =
                    n.processStyledBidirectionalText),
                  this.loadScriptResolve();
              }
              isParsed() {
                return (
                  this.applyArabicShaping != null &&
                  this.processBidirectionalText != null &&
                  this.processStyledBidirectionalText != null
                );
              }
              getRTLTextPluginStatus() {
                return this.pluginStatus;
              }
              syncState(n, t) {
                return s(this, void 0, void 0, function* () {
                  if (this.isParsed()) return this.getState();
                  if (n.pluginStatus !== "loading") return this.setState(n), n;
                  const r = n.pluginURL,
                    a = new Promise((p) => {
                      this.loadScriptResolve = p;
                    });
                  t(r);
                  const c = new Promise((p) =>
                    setTimeout(() => p(), this.TIMEOUT)
                  );
                  if ((yield Promise.race([a, c]), this.isParsed())) {
                    const p = { pluginStatus: "loaded", pluginURL: r };
                    return this.setState(p), p;
                  }
                  throw (
                    (this.setState({ pluginStatus: "error", pluginURL: "" }),
                    new Error(
                      `RTL Text Plugin failed to import scripts from ${r}`
                    ))
                  );
                });
              }
            })();
            class On {
              constructor(t, r) {
                (this.isSupportedScript = qd),
                  (this.zoom = t),
                  r
                    ? ((this.now = r.now || 0),
                      (this.fadeDuration = r.fadeDuration || 0),
                      (this.zoomHistory = r.zoomHistory || new _u()),
                      (this.transition = r.transition || {}))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.zoomHistory = new _u()),
                      (this.transition = {}));
              }
              crossFadingFactor() {
                return this.fadeDuration === 0
                  ? 1
                  : Math.min(
                      (this.now - this.zoomHistory.lastIntegerZoomTime) /
                        this.fadeDuration,
                      1
                    );
              }
              getCrossfadeParameters() {
                const t = this.zoom,
                  r = t - Math.floor(t),
                  a = this.crossFadingFactor();
                return t > this.zoomHistory.lastIntegerZoom
                  ? { fromScale: 2, toScale: 1, t: r + (1 - r) * a }
                  : { fromScale: 0.5, toScale: 1, t: 1 - (1 - a) * r };
              }
            }
            function qd(n) {
              return (function (t, r) {
                for (const a of t) if (!Vd(a.charCodeAt(0), r)) return !1;
                return !0;
              })(n, no.getRTLTextPluginStatus() === "loaded");
            }
            class rl {
              constructor(t, r, a) {
                (this.property = t),
                  (this.value = r),
                  (this.expression = (function (c, p, m) {
                    if (Nl(c)) return new Vl(c, p);
                    if (jl(c)) {
                      const v = yd(c, p, m);
                      if (v.result === "error")
                        throw new Error(
                          v.value
                            .map((b) => `${b.key}: ${b.message}`)
                            .join(", ")
                        );
                      return v.value;
                    }
                    {
                      let v = c;
                      return (
                        p.type === "color" && typeof c == "string"
                          ? (v = Cr.parse(c))
                          : p.type !== "padding" ||
                            (typeof c != "number" && !Array.isArray(c))
                          ? p.type !== "numberArray" ||
                            (typeof c != "number" && !Array.isArray(c))
                            ? p.type !== "colorArray" ||
                              (typeof c != "string" && !Array.isArray(c))
                              ? p.type === "variableAnchorOffsetCollection" &&
                                Array.isArray(c)
                                ? (v = pn.parse(c))
                                : p.type === "projectionDefinition" &&
                                  typeof c == "string" &&
                                  (v = Yn.parse(c))
                              : (v = Ar.parse(c))
                            : (v = Qr.parse(c))
                          : (v = Sn.parse(c)),
                        {
                          globalStateRefs: new Set(),
                          _globalState: null,
                          kind: "constant",
                          evaluate: () => v,
                        }
                      );
                    }
                  })(
                    r === void 0 ? t.specification.default : r,
                    t.specification,
                    a
                  ));
              }
              isDataDriven() {
                return (
                  this.expression.kind === "source" ||
                  this.expression.kind === "composite"
                );
              }
              getGlobalStateRefs() {
                return this.expression.globalStateRefs || new Set();
              }
              possiblyEvaluate(t, r, a) {
                return this.property.possiblyEvaluate(this, t, r, a);
              }
            }
            class xu {
              constructor(t, r) {
                (this.property = t), (this.value = new rl(t, void 0, r));
              }
              transitioned(t, r) {
                return new bu(
                  this.property,
                  this.value,
                  r,
                  at({}, t.transition, this.transition),
                  t.now
                );
              }
              untransitioned() {
                return new bu(this.property, this.value, null, {}, 0);
              }
            }
            class Ud {
              constructor(t, r) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultTransitionablePropertyValues
                  )),
                  (this._globalState = r);
              }
              getValue(t) {
                return Mt(this._values[t].value.value);
              }
              setValue(t, r) {
                Object.prototype.hasOwnProperty.call(this._values, t) ||
                  (this._values[t] = new xu(
                    this._values[t].property,
                    this._globalState
                  )),
                  (this._values[t].value = new rl(
                    this._values[t].property,
                    r === null ? void 0 : Mt(r),
                    this._globalState
                  ));
              }
              getTransition(t) {
                return Mt(this._values[t].transition);
              }
              setTransition(t, r) {
                Object.prototype.hasOwnProperty.call(this._values, t) ||
                  (this._values[t] = new xu(
                    this._values[t].property,
                    this._globalState
                  )),
                  (this._values[t].transition = Mt(r) || void 0);
              }
              serialize() {
                const t = {};
                for (const r of Object.keys(this._values)) {
                  const a = this.getValue(r);
                  a !== void 0 && (t[r] = a);
                  const c = this.getTransition(r);
                  c !== void 0 && (t[`${r}-transition`] = c);
                }
                return t;
              }
              transitioned(t, r) {
                const a = new wu(this._properties);
                for (const c of Object.keys(this._values))
                  a._values[c] = this._values[c].transitioned(t, r._values[c]);
                return a;
              }
              untransitioned() {
                const t = new wu(this._properties);
                for (const r of Object.keys(this._values))
                  t._values[r] = this._values[r].untransitioned();
                return t;
              }
            }
            class bu {
              constructor(t, r, a, c, p) {
                (this.property = t),
                  (this.value = r),
                  (this.begin = p + c.delay || 0),
                  (this.end = this.begin + c.duration || 0),
                  t.specification.transition &&
                    (c.delay || c.duration) &&
                    (this.prior = a);
              }
              possiblyEvaluate(t, r, a) {
                const c = t.now || 0,
                  p = this.value.possiblyEvaluate(t, r, a),
                  m = this.prior;
                if (m) {
                  if (c > this.end) return (this.prior = null), p;
                  if (this.value.isDataDriven()) return (this.prior = null), p;
                  if (c < this.begin) return m.possiblyEvaluate(t, r, a);
                  {
                    const v = (c - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      m.possiblyEvaluate(t, r, a),
                      p,
                      mt(v)
                    );
                  }
                }
                return p;
              }
            }
            class wu {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultTransitioningPropertyValues
                  ));
              }
              possiblyEvaluate(t, r, a) {
                const c = new Ho(this._properties);
                for (const p of Object.keys(this._values))
                  c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
                return c;
              }
              hasTransition() {
                for (const t of Object.keys(this._values))
                  if (this._values[t].prior) return !0;
                return !1;
              }
            }
            class Zd {
              constructor(t, r) {
                (this._properties = t),
                  (this._values = Object.create(t.defaultPropertyValues)),
                  (this._globalState = r);
              }
              hasValue(t) {
                return this._values[t].value !== void 0;
              }
              getValue(t) {
                return Mt(this._values[t].value);
              }
              setValue(t, r) {
                this._values[t] = new rl(
                  this._values[t].property,
                  r === null ? void 0 : Mt(r),
                  this._globalState
                );
              }
              serialize() {
                const t = {};
                for (const r of Object.keys(this._values)) {
                  const a = this.getValue(r);
                  a !== void 0 && (t[r] = a);
                }
                return t;
              }
              possiblyEvaluate(t, r, a) {
                const c = new Ho(this._properties);
                for (const p of Object.keys(this._values))
                  c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
                return c;
              }
            }
            class Ma {
              constructor(t, r, a) {
                (this.property = t), (this.value = r), (this.parameters = a);
              }
              isConstant() {
                return this.value.kind === "constant";
              }
              constantOr(t) {
                return this.value.kind === "constant" ? this.value.value : t;
              }
              evaluate(t, r, a, c) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  t,
                  r,
                  a,
                  c
                );
              }
            }
            class Ho {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultPossiblyEvaluatedValues
                  ));
              }
              get(t) {
                return this._values[t];
              }
            }
            class zr {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, r) {
                if (t.isDataDriven())
                  throw new Error("Value should not be data driven");
                return t.expression.evaluate(r);
              }
              interpolate(t, r, a) {
                const c = ya[this.specification.type];
                return c ? c(t, r, a) : t;
              }
            }
            class Gr {
              constructor(t, r) {
                (this.specification = t), (this.overrides = r);
              }
              possiblyEvaluate(t, r, a, c) {
                return new Ma(
                  this,
                  t.expression.kind === "constant" ||
                  t.expression.kind === "camera"
                    ? {
                        kind: "constant",
                        value: t.expression.evaluate(r, null, {}, a, c),
                      }
                    : t.expression,
                  r
                );
              }
              interpolate(t, r, a) {
                if (t.value.kind !== "constant" || r.value.kind !== "constant")
                  return t;
                if (t.value.value === void 0 || r.value.value === void 0)
                  return new Ma(
                    this,
                    { kind: "constant", value: void 0 },
                    t.parameters
                  );
                const c = ya[this.specification.type];
                if (c) {
                  const p = c(t.value.value, r.value.value, a);
                  return new Ma(
                    this,
                    { kind: "constant", value: p },
                    t.parameters
                  );
                }
                return t;
              }
              evaluate(t, r, a, c, p, m) {
                return t.kind === "constant"
                  ? t.value
                  : t.evaluate(r, a, c, p, m);
              }
            }
            class nl extends Gr {
              possiblyEvaluate(t, r, a, c) {
                if (t.value === void 0)
                  return new Ma(this, { kind: "constant", value: void 0 }, r);
                if (t.expression.kind === "constant") {
                  const p = t.expression.evaluate(r, null, {}, a, c),
                    m =
                      t.property.specification.type === "resolvedImage" &&
                      typeof p != "string"
                        ? p.name
                        : p,
                    v = this._calculate(m, m, m, r);
                  return new Ma(this, { kind: "constant", value: v }, r);
                }
                if (t.expression.kind === "camera") {
                  const p = this._calculate(
                    t.expression.evaluate({ zoom: r.zoom - 1 }),
                    t.expression.evaluate({ zoom: r.zoom }),
                    t.expression.evaluate({ zoom: r.zoom + 1 }),
                    r
                  );
                  return new Ma(this, { kind: "constant", value: p }, r);
                }
                return new Ma(this, t.expression, r);
              }
              evaluate(t, r, a, c, p, m) {
                if (t.kind === "source") {
                  const v = t.evaluate(r, a, c, p, m);
                  return this._calculate(v, v, v, r);
                }
                return t.kind === "composite"
                  ? this._calculate(
                      t.evaluate({ zoom: Math.floor(r.zoom) - 1 }, a, c),
                      t.evaluate({ zoom: Math.floor(r.zoom) }, a, c),
                      t.evaluate({ zoom: Math.floor(r.zoom) + 1 }, a, c),
                      r
                    )
                  : t.value;
              }
              _calculate(t, r, a, c) {
                return c.zoom > c.zoomHistory.lastIntegerZoom
                  ? { from: t, to: r }
                  : { from: a, to: r };
              }
              interpolate(t) {
                return t;
              }
            }
            class Gd {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, r, a, c) {
                if (t.value !== void 0) {
                  if (t.expression.kind === "constant") {
                    const p = t.expression.evaluate(r, null, {}, a, c);
                    return this._calculate(p, p, p, r);
                  }
                  return this._calculate(
                    t.expression.evaluate(new On(Math.floor(r.zoom - 1), r)),
                    t.expression.evaluate(new On(Math.floor(r.zoom), r)),
                    t.expression.evaluate(new On(Math.floor(r.zoom + 1), r)),
                    r
                  );
                }
              }
              _calculate(t, r, a, c) {
                return c.zoom > c.zoomHistory.lastIntegerZoom
                  ? { from: t, to: r }
                  : { from: a, to: r };
              }
              interpolate(t) {
                return t;
              }
            }
            class il {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, r, a, c) {
                return !!t.expression.evaluate(r, null, {}, a, c);
              }
              interpolate() {
                return !1;
              }
            }
            class Ui {
              constructor(t) {
                (this.properties = t),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []);
                for (const r in t) {
                  const a = t[r];
                  a.specification.overridable &&
                    this.overridableProperties.push(r);
                  const c = (this.defaultPropertyValues[r] = new rl(
                      a,
                      void 0,
                      void 0
                    )),
                    p = (this.defaultTransitionablePropertyValues[r] = new xu(
                      a,
                      void 0
                    ));
                  (this.defaultTransitioningPropertyValues[r] =
                    p.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[r] =
                      c.possiblyEvaluate({}));
                }
              }
            }
            hr("DataDrivenProperty", Gr),
              hr("DataConstantProperty", zr),
              hr("CrossFadedDataDrivenProperty", nl),
              hr("CrossFadedProperty", Gd),
              hr("ColorRampProperty", il);
            const Tu = "-transition";
            class Aa extends Ct {
              constructor(t, r, a) {
                if (
                  (super(),
                  (this.id = t.id),
                  (this.type = t.type),
                  (this._globalState = a),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    getGlobalStateRefs: () => new Set(),
                  }),
                  t.type !== "custom" &&
                    ((this.metadata = t.metadata),
                    (this.minzoom = t.minzoom),
                    (this.maxzoom = t.maxzoom),
                    t.type !== "background" &&
                      ((this.source = t.source),
                      (this.sourceLayer = t["source-layer"]),
                      (this.filter = t.filter),
                      (this._featureFilter = Ys(t.filter, a))),
                    r.layout && (this._unevaluatedLayout = new Zd(r.layout, a)),
                    r.paint))
                ) {
                  this._transitionablePaint = new Ud(r.paint, a);
                  for (const c in t.paint)
                    this.setPaintProperty(c, t.paint[c], { validate: !1 });
                  for (const c in t.layout)
                    this.setLayoutProperty(c, t.layout[c], { validate: !1 });
                  (this._transitioningPaint =
                    this._transitionablePaint.untransitioned()),
                    (this.paint = new Ho(r.paint));
                }
              }
              setFilter(t) {
                (this.filter = t),
                  (this._featureFilter = Ys(t, this._globalState));
              }
              getCrossfadeParameters() {
                return this._crossfadeParameters;
              }
              getLayoutProperty(t) {
                return t === "visibility"
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(t);
              }
              getLayoutAffectingGlobalStateRefs() {
                const t = new Set();
                if (this._unevaluatedLayout)
                  for (const r in this._unevaluatedLayout._values) {
                    const a = this._unevaluatedLayout._values[r];
                    for (const c of a.getGlobalStateRefs()) t.add(c);
                  }
                for (const r of this._featureFilter.getGlobalStateRefs())
                  t.add(r);
                return t;
              }
              getPaintAffectingGlobalStateRefs() {
                var t;
                const r = new globalThis.Map();
                if (this._transitionablePaint)
                  for (const a in this._transitionablePaint._values) {
                    const c = this._transitionablePaint._values[a].value;
                    for (const p of c.getGlobalStateRefs()) {
                      const m =
                        (t = r.get(p)) !== null && t !== void 0 ? t : [];
                      m.push({ name: a, value: c.value }), r.set(p, m);
                    }
                  }
                return r;
              }
              setLayoutProperty(t, r, a = {}) {
                (r != null &&
                  this._validate(
                    fu,
                    `layers.${this.id}.layout.${t}`,
                    t,
                    r,
                    a
                  )) ||
                  (t !== "visibility"
                    ? this._unevaluatedLayout.setValue(t, r)
                    : (this.visibility = r));
              }
              getPaintProperty(t) {
                return t.endsWith(Tu)
                  ? this._transitionablePaint.getTransition(t.slice(0, -11))
                  : this._transitionablePaint.getValue(t);
              }
              setPaintProperty(t, r, a = {}) {
                if (
                  r != null &&
                  this._validate(Ld, `layers.${this.id}.paint.${t}`, t, r, a)
                )
                  return !1;
                if (t.endsWith(Tu))
                  return (
                    this._transitionablePaint.setTransition(
                      t.slice(0, -11),
                      r || void 0
                    ),
                    !1
                  );
                {
                  const c = this._transitionablePaint._values[t],
                    p =
                      c.property.specification["property-type"] ===
                      "cross-faded-data-driven",
                    m = c.value.isDataDriven(),
                    v = c.value;
                  this._transitionablePaint.setValue(t, r),
                    this._handleSpecialPaintPropertyUpdate(t);
                  const b = this._transitionablePaint._values[t].value;
                  return (
                    b.isDataDriven() ||
                    m ||
                    p ||
                    this._handleOverridablePaintPropertyUpdate(t, v, b)
                  );
                }
              }
              _handleSpecialPaintPropertyUpdate(t) {}
              _handleOverridablePaintPropertyUpdate(t, r, a) {
                return !1;
              }
              isHidden(t, r = !1) {
                return (
                  !!(
                    this.minzoom &&
                    t < (r ? Math.floor(this.minzoom) : this.minzoom)
                  ) ||
                  !!(this.maxzoom && t >= this.maxzoom) ||
                  this.visibility === "none"
                );
              }
              updateTransitions(t) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    t,
                    this._transitioningPaint
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(t, r) {
                t.getCrossfadeParameters &&
                  (this._crossfadeParameters = t.getCrossfadeParameters()),
                  this._unevaluatedLayout &&
                    (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                      t,
                      void 0,
                      r
                    )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    t,
                    void 0,
                    r
                  ));
              }
              serialize() {
                const t = {
                  id: this.id,
                  type: this.type,
                  source: this.source,
                  "source-layer": this.sourceLayer,
                  metadata: this.metadata,
                  minzoom: this.minzoom,
                  maxzoom: this.maxzoom,
                  filter: this.filter,
                  layout:
                    this._unevaluatedLayout &&
                    this._unevaluatedLayout.serialize(),
                  paint:
                    this._transitionablePaint &&
                    this._transitionablePaint.serialize(),
                };
                return (
                  this.visibility &&
                    ((t.layout = t.layout || {}),
                    (t.layout.visibility = this.visibility)),
                  Tt(
                    t,
                    (r, a) =>
                      !(
                        r === void 0 ||
                        (a === "layout" && !Object.keys(r).length) ||
                        (a === "paint" && !Object.keys(r).length)
                      )
                  )
                );
              }
              _validate(t, r, a, c, p = {}) {
                return (
                  (!p || p.validate !== !1) &&
                  Dd(
                    this,
                    t.call(ws, {
                      key: r,
                      layerType: this.type,
                      objectKey: a,
                      value: c,
                      styleSpec: _e,
                      style: { glyphs: !0, sprite: !0 },
                    })
                  )
                );
              }
              is3D() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              resize() {}
              isStateDependent() {
                for (const t in this.paint._values) {
                  const r = this.paint.get(t);
                  if (
                    r instanceof Ma &&
                    vs(r.property.specification) &&
                    (r.value.kind === "source" ||
                      r.value.kind === "composite") &&
                    r.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
            }
            let $d;
            var bf = {
              get paint() {
                return ($d =
                  $d ||
                  new Ui({
                    "raster-opacity": new zr(_e.paint_raster["raster-opacity"]),
                    "raster-hue-rotate": new zr(
                      _e.paint_raster["raster-hue-rotate"]
                    ),
                    "raster-brightness-min": new zr(
                      _e.paint_raster["raster-brightness-min"]
                    ),
                    "raster-brightness-max": new zr(
                      _e.paint_raster["raster-brightness-max"]
                    ),
                    "raster-saturation": new zr(
                      _e.paint_raster["raster-saturation"]
                    ),
                    "raster-contrast": new zr(
                      _e.paint_raster["raster-contrast"]
                    ),
                    "raster-resampling": new zr(
                      _e.paint_raster["raster-resampling"]
                    ),
                    "raster-fade-duration": new zr(
                      _e.paint_raster["raster-fade-duration"]
                    ),
                  }));
              },
            };
            class wf extends Aa {
              constructor(t, r) {
                super(t, bf, r);
              }
            }
            const Tf = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class qa {
              constructor(t, r) {
                (this._structArray = t),
                  (this._pos1 = r * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8);
              }
            }
            class ti {
              constructor() {
                (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
              }
              static serialize(t, r) {
                return (
                  t._trim(),
                  r && ((t.isTransferred = !0), r.push(t.arrayBuffer)),
                  { length: t.length, arrayBuffer: t.arrayBuffer }
                );
              }
              static deserialize(t) {
                const r = Object.create(this.prototype);
                return (
                  (r.arrayBuffer = t.arrayBuffer),
                  (r.length = t.length),
                  (r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement),
                  r._refreshViews(),
                  r
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(t) {
                this.reserve(t), (this.length = t);
              }
              reserve(t) {
                if (t > this.capacity) {
                  (this.capacity = Math.max(
                    t,
                    Math.floor(5 * this.capacity),
                    128
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement
                    ));
                  const r = this.uint8;
                  this._refreshViews(), r && this.uint8.set(r);
                }
              }
              _refreshViews() {
                throw new Error(
                  "_refreshViews() must be implemented by each concrete StructArray layout"
                );
              }
            }
            function ci(n, t = 1) {
              let r = 0,
                a = 0;
              return {
                members: n.map((c) => {
                  const p = Tf[c.type].BYTES_PER_ELEMENT,
                    m = (r = Hd(r, Math.max(t, p))),
                    v = c.components || 1;
                  return (
                    (a = Math.max(a, p)),
                    (r += p * v),
                    { name: c.name, type: c.type, components: v, offset: m }
                  );
                }),
                size: Hd(r, Math.max(a, t)),
                alignment: t,
              };
            }
            function Hd(n, t) {
              return Math.ceil(n / t) * t;
            }
            class Ss extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t, r);
              }
              emplace(t, r, a) {
                const c = 2 * t;
                return (this.int16[c + 0] = r), (this.int16[c + 1] = a), t;
              }
            }
            (Ss.prototype.bytesPerElement = 4), hr("StructArrayLayout2i4", Ss);
            class Jl extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t, r, a);
              }
              emplace(t, r, a, c) {
                const p = 3 * t;
                return (
                  (this.int16[p + 0] = r),
                  (this.int16[p + 1] = a),
                  (this.int16[p + 2] = c),
                  t
                );
              }
            }
            (Jl.prototype.bytesPerElement = 6), hr("StructArrayLayout3i6", Jl);
            class Su extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t, r, a, c);
              }
              emplace(t, r, a, c, p) {
                const m = 4 * t;
                return (
                  (this.int16[m + 0] = r),
                  (this.int16[m + 1] = a),
                  (this.int16[m + 2] = c),
                  (this.int16[m + 3] = p),
                  t
                );
              }
            }
            (Su.prototype.bytesPerElement = 8), hr("StructArrayLayout4i8", Su);
            class io extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m) {
                const v = this.length;
                return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m);
              }
              emplace(t, r, a, c, p, m, v) {
                const b = 6 * t;
                return (
                  (this.int16[b + 0] = r),
                  (this.int16[b + 1] = a),
                  (this.int16[b + 2] = c),
                  (this.int16[b + 3] = p),
                  (this.int16[b + 4] = m),
                  (this.int16[b + 5] = v),
                  t
                );
              }
            }
            (io.prototype.bytesPerElement = 12),
              hr("StructArrayLayout2i4i12", io);
            class Ql extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m) {
                const v = this.length;
                return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m);
              }
              emplace(t, r, a, c, p, m, v) {
                const b = 4 * t,
                  C = 8 * t;
                return (
                  (this.int16[b + 0] = r),
                  (this.int16[b + 1] = a),
                  (this.uint8[C + 4] = c),
                  (this.uint8[C + 5] = p),
                  (this.uint8[C + 6] = m),
                  (this.uint8[C + 7] = v),
                  t
                );
              }
            }
            (Ql.prototype.bytesPerElement = 8),
              hr("StructArrayLayout2i4ub8", Ql);
            class Wo extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, r) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t, r);
              }
              emplace(t, r, a) {
                const c = 2 * t;
                return (this.float32[c + 0] = r), (this.float32[c + 1] = a), t;
              }
            }
            (Wo.prototype.bytesPerElement = 8), hr("StructArrayLayout2f8", Wo);
            class ec extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m, v, b, C, I) {
                const R = this.length;
                return (
                  this.resize(R + 1),
                  this.emplace(R, t, r, a, c, p, m, v, b, C, I)
                );
              }
              emplace(t, r, a, c, p, m, v, b, C, I, R) {
                const U = 10 * t;
                return (
                  (this.uint16[U + 0] = r),
                  (this.uint16[U + 1] = a),
                  (this.uint16[U + 2] = c),
                  (this.uint16[U + 3] = p),
                  (this.uint16[U + 4] = m),
                  (this.uint16[U + 5] = v),
                  (this.uint16[U + 6] = b),
                  (this.uint16[U + 7] = C),
                  (this.uint16[U + 8] = I),
                  (this.uint16[U + 9] = R),
                  t
                );
              }
            }
            (ec.prototype.bytesPerElement = 20),
              hr("StructArrayLayout10ui20", ec);
            class al extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m, v, b) {
                const C = this.length;
                return (
                  this.resize(C + 1), this.emplace(C, t, r, a, c, p, m, v, b)
                );
              }
              emplace(t, r, a, c, p, m, v, b, C) {
                const I = 8 * t;
                return (
                  (this.uint16[I + 0] = r),
                  (this.uint16[I + 1] = a),
                  (this.uint16[I + 2] = c),
                  (this.uint16[I + 3] = p),
                  (this.uint16[I + 4] = m),
                  (this.uint16[I + 5] = v),
                  (this.uint16[I + 6] = b),
                  (this.uint16[I + 7] = C),
                  t
                );
              }
            }
            (al.prototype.bytesPerElement = 16),
              hr("StructArrayLayout8ui16", al);
            class Cu extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m, v, b, C, I, R, U) {
                const Z = this.length;
                return (
                  this.resize(Z + 1),
                  this.emplace(Z, t, r, a, c, p, m, v, b, C, I, R, U)
                );
              }
              emplace(t, r, a, c, p, m, v, b, C, I, R, U, Z) {
                const X = 12 * t;
                return (
                  (this.int16[X + 0] = r),
                  (this.int16[X + 1] = a),
                  (this.int16[X + 2] = c),
                  (this.int16[X + 3] = p),
                  (this.uint16[X + 4] = m),
                  (this.uint16[X + 5] = v),
                  (this.uint16[X + 6] = b),
                  (this.uint16[X + 7] = C),
                  (this.int16[X + 8] = I),
                  (this.int16[X + 9] = R),
                  (this.int16[X + 10] = U),
                  (this.int16[X + 11] = Z),
                  t
                );
              }
            }
            (Cu.prototype.bytesPerElement = 24),
              hr("StructArrayLayout4i4ui4i24", Cu);
            class Cs extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t, r, a);
              }
              emplace(t, r, a, c) {
                const p = 3 * t;
                return (
                  (this.float32[p + 0] = r),
                  (this.float32[p + 1] = a),
                  (this.float32[p + 2] = c),
                  t
                );
              }
            }
            (Cs.prototype.bytesPerElement = 12),
              hr("StructArrayLayout3f12", Cs);
            class Xo extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t);
              }
              emplace(t, r) {
                return (this.uint32[1 * t + 0] = r), t;
              }
            }
            (Xo.prototype.bytesPerElement = 4), hr("StructArrayLayout1ul4", Xo);
            class Pu extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m, v, b, C) {
                const I = this.length;
                return (
                  this.resize(I + 1), this.emplace(I, t, r, a, c, p, m, v, b, C)
                );
              }
              emplace(t, r, a, c, p, m, v, b, C, I) {
                const R = 10 * t,
                  U = 5 * t;
                return (
                  (this.int16[R + 0] = r),
                  (this.int16[R + 1] = a),
                  (this.int16[R + 2] = c),
                  (this.int16[R + 3] = p),
                  (this.int16[R + 4] = m),
                  (this.int16[R + 5] = v),
                  (this.uint32[U + 3] = b),
                  (this.uint16[R + 8] = C),
                  (this.uint16[R + 9] = I),
                  t
                );
              }
            }
            (Pu.prototype.bytesPerElement = 20),
              hr("StructArrayLayout6i1ul2ui20", Pu);
            class tc extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m) {
                const v = this.length;
                return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m);
              }
              emplace(t, r, a, c, p, m, v) {
                const b = 6 * t;
                return (
                  (this.int16[b + 0] = r),
                  (this.int16[b + 1] = a),
                  (this.int16[b + 2] = c),
                  (this.int16[b + 3] = p),
                  (this.int16[b + 4] = m),
                  (this.int16[b + 5] = v),
                  t
                );
              }
            }
            (tc.prototype.bytesPerElement = 12),
              hr("StructArrayLayout2i2i2i12", tc);
            class Yo extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, t, r, a, c, p);
              }
              emplace(t, r, a, c, p, m) {
                const v = 4 * t,
                  b = 8 * t;
                return (
                  (this.float32[v + 0] = r),
                  (this.float32[v + 1] = a),
                  (this.float32[v + 2] = c),
                  (this.int16[b + 6] = p),
                  (this.int16[b + 7] = m),
                  t
                );
              }
            }
            (Yo.prototype.bytesPerElement = 16),
              hr("StructArrayLayout2f1f2i16", Yo);
            class Iu extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m) {
                const v = this.length;
                return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m);
              }
              emplace(t, r, a, c, p, m, v) {
                const b = 16 * t,
                  C = 4 * t,
                  I = 8 * t;
                return (
                  (this.uint8[b + 0] = r),
                  (this.uint8[b + 1] = a),
                  (this.float32[C + 1] = c),
                  (this.float32[C + 2] = p),
                  (this.int16[I + 6] = m),
                  (this.int16[I + 7] = v),
                  t
                );
              }
            }
            (Iu.prototype.bytesPerElement = 16),
              hr("StructArrayLayout2ub2f2i16", Iu);
            class rc extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t, r, a);
              }
              emplace(t, r, a, c) {
                const p = 3 * t;
                return (
                  (this.uint16[p + 0] = r),
                  (this.uint16[p + 1] = a),
                  (this.uint16[p + 2] = c),
                  t
                );
              }
            }
            (rc.prototype.bytesPerElement = 6), hr("StructArrayLayout3ui6", rc);
            class nc extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, he) {
                const Oe = this.length;
                return (
                  this.resize(Oe + 1),
                  this.emplace(
                    Oe,
                    t,
                    r,
                    a,
                    c,
                    p,
                    m,
                    v,
                    b,
                    C,
                    I,
                    R,
                    U,
                    Z,
                    X,
                    Q,
                    ie,
                    he
                  )
                );
              }
              emplace(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, he, Oe) {
                const ye = 24 * t,
                  Ce = 12 * t,
                  et = 48 * t;
                return (
                  (this.int16[ye + 0] = r),
                  (this.int16[ye + 1] = a),
                  (this.uint16[ye + 2] = c),
                  (this.uint16[ye + 3] = p),
                  (this.uint32[Ce + 2] = m),
                  (this.uint32[Ce + 3] = v),
                  (this.uint32[Ce + 4] = b),
                  (this.uint16[ye + 10] = C),
                  (this.uint16[ye + 11] = I),
                  (this.uint16[ye + 12] = R),
                  (this.float32[Ce + 7] = U),
                  (this.float32[Ce + 8] = Z),
                  (this.uint8[et + 36] = X),
                  (this.uint8[et + 37] = Q),
                  (this.uint8[et + 38] = ie),
                  (this.uint32[Ce + 10] = he),
                  (this.int16[ye + 22] = Oe),
                  t
                );
              }
            }
            (nc.prototype.bytesPerElement = 48),
              hr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", nc);
            class Mu extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(
                t,
                r,
                a,
                c,
                p,
                m,
                v,
                b,
                C,
                I,
                R,
                U,
                Z,
                X,
                Q,
                ie,
                he,
                Oe,
                ye,
                Ce,
                et,
                ht,
                Rt,
                or,
                Yt,
                rr,
                Fr,
                er
              ) {
                const nr = this.length;
                return (
                  this.resize(nr + 1),
                  this.emplace(
                    nr,
                    t,
                    r,
                    a,
                    c,
                    p,
                    m,
                    v,
                    b,
                    C,
                    I,
                    R,
                    U,
                    Z,
                    X,
                    Q,
                    ie,
                    he,
                    Oe,
                    ye,
                    Ce,
                    et,
                    ht,
                    Rt,
                    or,
                    Yt,
                    rr,
                    Fr,
                    er
                  )
                );
              }
              emplace(
                t,
                r,
                a,
                c,
                p,
                m,
                v,
                b,
                C,
                I,
                R,
                U,
                Z,
                X,
                Q,
                ie,
                he,
                Oe,
                ye,
                Ce,
                et,
                ht,
                Rt,
                or,
                Yt,
                rr,
                Fr,
                er,
                nr
              ) {
                const St = 32 * t,
                  Hr = 16 * t;
                return (
                  (this.int16[St + 0] = r),
                  (this.int16[St + 1] = a),
                  (this.int16[St + 2] = c),
                  (this.int16[St + 3] = p),
                  (this.int16[St + 4] = m),
                  (this.int16[St + 5] = v),
                  (this.int16[St + 6] = b),
                  (this.int16[St + 7] = C),
                  (this.uint16[St + 8] = I),
                  (this.uint16[St + 9] = R),
                  (this.uint16[St + 10] = U),
                  (this.uint16[St + 11] = Z),
                  (this.uint16[St + 12] = X),
                  (this.uint16[St + 13] = Q),
                  (this.uint16[St + 14] = ie),
                  (this.uint16[St + 15] = he),
                  (this.uint16[St + 16] = Oe),
                  (this.uint16[St + 17] = ye),
                  (this.uint16[St + 18] = Ce),
                  (this.uint16[St + 19] = et),
                  (this.uint16[St + 20] = ht),
                  (this.uint16[St + 21] = Rt),
                  (this.uint16[St + 22] = or),
                  (this.uint32[Hr + 12] = Yt),
                  (this.float32[Hr + 13] = rr),
                  (this.float32[Hr + 14] = Fr),
                  (this.uint16[St + 30] = er),
                  (this.uint16[St + 31] = nr),
                  t
                );
              }
            }
            (Mu.prototype.bytesPerElement = 64),
              hr("StructArrayLayout8i15ui1ul2f2ui64", Mu);
            class h extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t);
              }
              emplace(t, r) {
                return (this.float32[1 * t + 0] = r), t;
              }
            }
            (h.prototype.bytesPerElement = 4), hr("StructArrayLayout1f4", h);
            class e extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t, r, a);
              }
              emplace(t, r, a, c) {
                const p = 3 * t;
                return (
                  (this.uint16[6 * t + 0] = r),
                  (this.float32[p + 1] = a),
                  (this.float32[p + 2] = c),
                  t
                );
              }
            }
            (e.prototype.bytesPerElement = 12),
              hr("StructArrayLayout1ui2f12", e);
            class i extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t, r, a);
              }
              emplace(t, r, a, c) {
                const p = 4 * t;
                return (
                  (this.uint32[2 * t + 0] = r),
                  (this.uint16[p + 2] = a),
                  (this.uint16[p + 3] = c),
                  t
                );
              }
            }
            (i.prototype.bytesPerElement = 8),
              hr("StructArrayLayout1ul2ui8", i);
            class l extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, r) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t, r);
              }
              emplace(t, r, a) {
                const c = 2 * t;
                return (this.uint16[c + 0] = r), (this.uint16[c + 1] = a), t;
              }
            }
            (l.prototype.bytesPerElement = 4), hr("StructArrayLayout2ui4", l);
            class u extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t);
              }
              emplace(t, r) {
                return (this.uint16[1 * t + 0] = r), t;
              }
            }
            (u.prototype.bytesPerElement = 2), hr("StructArrayLayout1ui2", u);
            class d extends ti {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, r, a, c) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t, r, a, c);
              }
              emplace(t, r, a, c, p) {
                const m = 4 * t;
                return (
                  (this.float32[m + 0] = r),
                  (this.float32[m + 1] = a),
                  (this.float32[m + 2] = c),
                  (this.float32[m + 3] = p),
                  t
                );
              }
            }
            (d.prototype.bytesPerElement = 16), hr("StructArrayLayout4f16", d);
            class g extends qa {
              get anchorPointX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get anchorPointY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get x1() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get y1() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get x2() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get y2() {
                return this._structArray.int16[this._pos2 + 5];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 3];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get anchorPoint() {
                return new B(this.anchorPointX, this.anchorPointY);
              }
            }
            g.prototype.size = 20;
            class w extends Pu {
              get(t) {
                return new g(this, t);
              }
            }
            hr("CollisionBoxArray", w);
            class S extends qa {
              get anchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get anchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 2];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 3];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 4];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 10];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 11];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 12];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 7];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 8];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 36];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 37];
              }
              set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 37] = t;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 38];
              }
              set hidden(t) {
                this._structArray.uint8[this._pos1 + 38] = t;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 10];
              }
              set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 10] = t;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 22];
              }
            }
            S.prototype.size = 48;
            class k extends nc {
              get(t) {
                return new S(this, t);
              }
            }
            hr("PlacedSymbolArray", k);
            class z extends qa {
              get anchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get anchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 5];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 6];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 10];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 11];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 12];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 13];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 12];
              }
              set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 12] = t;
              }
              get textBoxScale() {
                return this._structArray.float32[this._pos4 + 13];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 14];
              }
              get textAnchorOffsetStartIndex() {
                return this._structArray.uint16[this._pos2 + 30];
              }
              get textAnchorOffsetEndIndex() {
                return this._structArray.uint16[this._pos2 + 31];
              }
            }
            z.prototype.size = 64;
            class V extends Mu {
              get(t) {
                return new z(this, t);
              }
            }
            hr("SymbolInstanceArray", V);
            class F extends h {
              getoffsetX(t) {
                return this.float32[1 * t + 0];
              }
            }
            hr("GlyphOffsetArray", F);
            class $ extends Jl {
              getx(t) {
                return this.int16[3 * t + 0];
              }
              gety(t) {
                return this.int16[3 * t + 1];
              }
              gettileUnitDistanceFromAnchor(t) {
                return this.int16[3 * t + 2];
              }
            }
            hr("SymbolLineVertexArray", $);
            class J extends qa {
              get textAnchor() {
                return this._structArray.uint16[this._pos2 + 0];
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 2];
              }
            }
            J.prototype.size = 12;
            class ae extends e {
              get(t) {
                return new J(this, t);
              }
            }
            hr("TextAnchorOffsetArray", ae);
            class oe extends qa {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
            }
            oe.prototype.size = 8;
            class se extends i {
              get(t) {
                return new oe(this, t);
              }
            }
            hr("FeatureIndexArray", se);
            class fe extends Ss {}
            class be extends Ss {}
            class pe extends Ss {}
            class we extends io {}
            class Pe extends Ql {}
            class ve extends Wo {}
            class Re extends ec {}
            class it extends al {}
            class Qe extends Cu {}
            class tt extends Cs {}
            class ot extends Xo {}
            class Zt extends tc {}
            class Ht extends Iu {}
            class Pt extends rc {}
            class yr extends l {}
            const tn = ci([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: Ln } = tn;
            class cn {
              constructor(t = []) {
                (this._forceNewSegmentOnNextPrepare = !1), (this.segments = t);
              }
              prepareSegment(t, r, a, c) {
                const p = this.segments[this.segments.length - 1];
                return (
                  t > cn.MAX_VERTEX_ARRAY_LENGTH &&
                    Bt(
                      `Max vertices per segment is ${cn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${cn.MAX_VERTEX_ARRAY_LENGTH} vertices.`
                    ),
                  this._forceNewSegmentOnNextPrepare ||
                  !p ||
                  p.vertexLength + t > cn.MAX_VERTEX_ARRAY_LENGTH ||
                  p.sortKey !== c
                    ? this.createNewSegment(r, a, c)
                    : p
                );
              }
              createNewSegment(t, r, a) {
                const c = {
                  vertexOffset: t.length,
                  primitiveOffset: r.length,
                  vertexLength: 0,
                  primitiveLength: 0,
                  vaos: {},
                };
                return (
                  a !== void 0 && (c.sortKey = a),
                  (this._forceNewSegmentOnNextPrepare = !1),
                  this.segments.push(c),
                  c
                );
              }
              getOrCreateLatestSegment(t, r, a) {
                return this.prepareSegment(0, t, r, a);
              }
              forceNewSegmentOnNextPrepare() {
                this._forceNewSegmentOnNextPrepare = !0;
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const t of this.segments)
                  for (const r in t.vaos) t.vaos[r].destroy();
              }
              static simpleSegment(t, r, a, c) {
                return new cn([
                  {
                    vertexOffset: t,
                    primitiveOffset: r,
                    vertexLength: a,
                    primitiveLength: c,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            function Nn(n, t) {
              return (
                256 * (n = Ft(Math.floor(n), 0, 255)) +
                Ft(Math.floor(t), 0, 255)
              );
            }
            (cn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              hr("SegmentVector", cn);
            const ri = ci([
                { name: "a_pattern_from", components: 4, type: "Uint16" },
                { name: "a_pattern_to", components: 4, type: "Uint16" },
                { name: "a_pixel_ratio_from", components: 1, type: "Uint16" },
                { name: "a_pixel_ratio_to", components: 1, type: "Uint16" },
              ]),
              Un = ci([
                { name: "a_dasharray_from", components: 4, type: "Uint16" },
                { name: "a_dasharray_to", components: 4, type: "Uint16" },
              ]);
            var gi,
              Kn,
              Ii,
              Jn = { exports: {} },
              fi = { exports: {} },
              Yi = { exports: {} },
              Ko = (function () {
                if (Ii) return Jn.exports;
                Ii = 1;
                var n =
                    (gi ||
                      ((gi = 1),
                      (fi.exports = function (r, a) {
                        var c, p, m, v, b, C, I, R;
                        for (
                          p = r.length - (c = 3 & r.length),
                            m = a,
                            b = 3432918353,
                            C = 461845907,
                            R = 0;
                          R < p;

                        )
                          (I =
                            (255 & r.charCodeAt(R)) |
                            ((255 & r.charCodeAt(++R)) << 8) |
                            ((255 & r.charCodeAt(++R)) << 16) |
                            ((255 & r.charCodeAt(++R)) << 24)),
                            ++R,
                            (m =
                              27492 +
                              (65535 &
                                (v =
                                  (5 *
                                    (65535 &
                                      (m =
                                        ((m ^= I =
                                          ((65535 &
                                            (I =
                                              ((I =
                                                ((65535 & I) * b +
                                                  ((((I >>> 16) * b) & 65535) <<
                                                    16)) &
                                                4294967295) <<
                                                15) |
                                              (I >>> 17))) *
                                            C +
                                            ((((I >>> 16) * C) & 65535) <<
                                              16)) &
                                          4294967295) <<
                                          13) |
                                        (m >>> 19))) +
                                    (((5 * (m >>> 16)) & 65535) << 16)) &
                                  4294967295)) +
                              (((58964 + (v >>> 16)) & 65535) << 16));
                        switch (((I = 0), c)) {
                          case 3:
                            I ^= (255 & r.charCodeAt(R + 2)) << 16;
                          case 2:
                            I ^= (255 & r.charCodeAt(R + 1)) << 8;
                          case 1:
                            m ^= I =
                              ((65535 &
                                (I =
                                  ((I =
                                    ((65535 & (I ^= 255 & r.charCodeAt(R))) *
                                      b +
                                      ((((I >>> 16) * b) & 65535) << 16)) &
                                    4294967295) <<
                                    15) |
                                  (I >>> 17))) *
                                C +
                                ((((I >>> 16) * C) & 65535) << 16)) &
                              4294967295;
                        }
                        return (
                          (m ^= r.length),
                          (m =
                            (2246822507 * (65535 & (m ^= m >>> 16)) +
                              (((2246822507 * (m >>> 16)) & 65535) << 16)) &
                            4294967295),
                          (m =
                            (3266489909 * (65535 & (m ^= m >>> 13)) +
                              (((3266489909 * (m >>> 16)) & 65535) << 16)) &
                            4294967295),
                          (m ^= m >>> 16) >>> 0
                        );
                      })),
                    fi.exports),
                  t =
                    (Kn ||
                      ((Kn = 1),
                      (Yi.exports = function (r, a) {
                        for (var c, p = r.length, m = a ^ p, v = 0; p >= 4; )
                          (c =
                            1540483477 *
                              (65535 &
                                (c =
                                  (255 & r.charCodeAt(v)) |
                                  ((255 & r.charCodeAt(++v)) << 8) |
                                  ((255 & r.charCodeAt(++v)) << 16) |
                                  ((255 & r.charCodeAt(++v)) << 24))) +
                            (((1540483477 * (c >>> 16)) & 65535) << 16)),
                            (m =
                              (1540483477 * (65535 & m) +
                                (((1540483477 * (m >>> 16)) & 65535) << 16)) ^
                              (c =
                                1540483477 * (65535 & (c ^= c >>> 24)) +
                                (((1540483477 * (c >>> 16)) & 65535) << 16))),
                            (p -= 4),
                            ++v;
                        switch (p) {
                          case 3:
                            m ^= (255 & r.charCodeAt(v + 2)) << 16;
                          case 2:
                            m ^= (255 & r.charCodeAt(v + 1)) << 8;
                          case 1:
                            m =
                              1540483477 *
                                (65535 & (m ^= 255 & r.charCodeAt(v))) +
                              (((1540483477 * (m >>> 16)) & 65535) << 16);
                        }
                        return (
                          (m =
                            1540483477 * (65535 & (m ^= m >>> 13)) +
                            (((1540483477 * (m >>> 16)) & 65535) << 16)),
                          (m ^= m >>> 15) >>> 0
                        );
                      })),
                    Yi.exports);
                return (
                  (Jn.exports = n),
                  (Jn.exports.murmur3 = n),
                  (Jn.exports.murmur2 = t),
                  Jn.exports
                );
              })(),
              ao = N(Ko);
            class Ua {
              constructor() {
                (this.ids = []), (this.positions = []), (this.indexed = !1);
              }
              add(t, r, a, c) {
                this.ids.push(Jo(t)), this.positions.push(r, a, c);
              }
              getPositions(t) {
                if (!this.indexed)
                  throw new Error(
                    "Trying to get index, but feature positions are not indexed"
                  );
                const r = Jo(t);
                let a = 0,
                  c = this.ids.length - 1;
                for (; a < c; ) {
                  const m = (a + c) >> 1;
                  this.ids[m] >= r ? (c = m) : (a = m + 1);
                }
                const p = [];
                for (; this.ids[a] === r; )
                  p.push({
                    index: this.positions[3 * a],
                    start: this.positions[3 * a + 1],
                    end: this.positions[3 * a + 2],
                  }),
                    a++;
                return p;
              }
              static serialize(t, r) {
                const a = new Float64Array(t.ids),
                  c = new Uint32Array(t.positions);
                return (
                  Ps(a, c, 0, a.length - 1),
                  r && r.push(a.buffer, c.buffer),
                  { ids: a, positions: c }
                );
              }
              static deserialize(t) {
                const r = new Ua();
                return (
                  (r.ids = t.ids),
                  (r.positions = t.positions),
                  (r.indexed = !0),
                  r
                );
              }
            }
            function Jo(n) {
              const t = +n;
              return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER
                ? t
                : ao(String(n));
            }
            function Ps(n, t, r, a) {
              for (; r < a; ) {
                const c = n[(r + a) >> 1];
                let p = r - 1,
                  m = a + 1;
                for (;;) {
                  do p++;
                  while (n[p] < c);
                  do m--;
                  while (n[m] > c);
                  if (p >= m) break;
                  Qo(n, p, m),
                    Qo(t, 3 * p, 3 * m),
                    Qo(t, 3 * p + 1, 3 * m + 1),
                    Qo(t, 3 * p + 2, 3 * m + 2);
                }
                m - r < a - m
                  ? (Ps(n, t, r, m), (r = m + 1))
                  : (Ps(n, t, m + 1, a), (a = m));
              }
            }
            function Qo(n, t, r) {
              const a = n[t];
              (n[t] = n[r]), (n[r] = a);
            }
            hr("FeaturePositionMap", Ua);
            class ia {
              constructor(t, r) {
                (this.gl = t.gl), (this.location = r);
              }
            }
            class Ki extends ia {
              constructor(t, r) {
                super(t, r), (this.current = 0);
              }
              set(t) {
                this.current !== t &&
                  ((this.current = t), this.gl.uniform1f(this.location, t));
              }
            }
            class oo extends ia {
              constructor(t, r) {
                super(t, r), (this.current = [0, 0, 0, 0]);
              }
              set(t) {
                (t[0] === this.current[0] &&
                  t[1] === this.current[1] &&
                  t[2] === this.current[2] &&
                  t[3] === this.current[3]) ||
                  ((this.current = t),
                  this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
              }
            }
            class To extends ia {
              constructor(t, r) {
                super(t, r), (this.current = Cr.transparent);
              }
              set(t) {
                (t.r === this.current.r &&
                  t.g === this.current.g &&
                  t.b === this.current.b &&
                  t.a === this.current.a) ||
                  ((this.current = t),
                  this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
              }
            }
            const ol = new Float32Array(16);
            function mi(n) {
              return [Nn(255 * n.r, 255 * n.g), Nn(255 * n.b, 255 * n.a)];
            }
            class ui {
              constructor(t, r, a) {
                (this.value = t),
                  (this.uniformNames = r.map((c) => `u_${c}`)),
                  (this.type = a);
              }
              setUniform(t, r, a) {
                t.set(a.constantOr(this.value));
              }
              getBinding(t, r, a) {
                return this.type === "color" ? new To(t, r) : new Ki(t, r);
              }
            }
            class Mi {
              constructor(t, r) {
                (this.uniformNames = r.map((a) => `u_${a}`)),
                  (this.patternFrom = null),
                  (this.patternTo = null),
                  (this.pixelRatioFrom = 1),
                  (this.pixelRatioTo = 1);
              }
              setConstantPatternPositions(t, r) {
                (this.pixelRatioFrom = r.pixelRatio),
                  (this.pixelRatioTo = t.pixelRatio),
                  (this.patternFrom = r.tlbr),
                  (this.patternTo = t.tlbr);
              }
              setConstantDashPositions(t, r) {
                (this.dashTo = [0, t.y, t.height, t.width]),
                  (this.dashFrom = [0, r.y, r.height, r.width]);
              }
              setUniform(t, r, a, c) {
                let p = null;
                c === "u_pattern_to"
                  ? (p = this.patternTo)
                  : c === "u_pattern_from"
                  ? (p = this.patternFrom)
                  : c === "u_dasharray_to"
                  ? (p = this.dashTo)
                  : c === "u_dasharray_from"
                  ? (p = this.dashFrom)
                  : c === "u_pixel_ratio_to"
                  ? (p = this.pixelRatioTo)
                  : c === "u_pixel_ratio_from" && (p = this.pixelRatioFrom),
                  p !== null && t.set(p);
              }
              getBinding(t, r, a) {
                return a.substr(0, 9) === "u_pattern" ||
                  a.substr(0, 12) === "u_dasharray_"
                  ? new oo(t, r)
                  : new Ki(t, r);
              }
            }
            class Hn {
              constructor(t, r, a, c) {
                (this.expression = t),
                  (this.type = a),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = r.map((p) => ({
                    name: `a_${p}`,
                    type: "Float32",
                    components: a === "color" ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new c());
              }
              populatePaintArray(t, r, a) {
                const c = this.paintVertexArray.length,
                  p = this.expression.evaluate(
                    new On(0, a),
                    r,
                    {},
                    a.canonical,
                    [],
                    a.formattedSection
                  );
                this.paintVertexArray.resize(t), this._setPaintValue(c, t, p);
              }
              updatePaintArray(t, r, a, c, p) {
                const m = this.expression.evaluate(new On(0, p), a, c);
                this._setPaintValue(t, r, m);
              }
              _setPaintValue(t, r, a) {
                if (this.type === "color") {
                  const c = mi(a);
                  for (let p = t; p < r; p++)
                    this.paintVertexArray.emplace(p, c[0], c[1]);
                } else {
                  for (let c = t; c < r; c++)
                    this.paintVertexArray.emplace(c, a);
                  this.maxValue = Math.max(this.maxValue, Math.abs(a));
                }
              }
              upload(t) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = t.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class ka {
              constructor(t, r, a, c, p, m) {
                (this.expression = t),
                  (this.uniformNames = r.map((v) => `u_${v}_t`)),
                  (this.type = a),
                  (this.useIntegerZoom = c),
                  (this.zoom = p),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = r.map((v) => ({
                    name: `a_${v}`,
                    type: "Float32",
                    components: a === "color" ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new m());
              }
              populatePaintArray(t, r, a) {
                const c = this.expression.evaluate(
                    new On(this.zoom, a),
                    r,
                    {},
                    a.canonical,
                    [],
                    a.formattedSection
                  ),
                  p = this.expression.evaluate(
                    new On(this.zoom + 1, a),
                    r,
                    {},
                    a.canonical,
                    [],
                    a.formattedSection
                  ),
                  m = this.paintVertexArray.length;
                this.paintVertexArray.resize(t),
                  this._setPaintValue(m, t, c, p);
              }
              updatePaintArray(t, r, a, c, p) {
                const m = this.expression.evaluate(new On(this.zoom, p), a, c),
                  v = this.expression.evaluate(new On(this.zoom + 1, p), a, c);
                this._setPaintValue(t, r, m, v);
              }
              _setPaintValue(t, r, a, c) {
                if (this.type === "color") {
                  const p = mi(a),
                    m = mi(c);
                  for (let v = t; v < r; v++)
                    this.paintVertexArray.emplace(v, p[0], p[1], m[0], m[1]);
                } else {
                  for (let p = t; p < r; p++)
                    this.paintVertexArray.emplace(p, a, c);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(a),
                    Math.abs(c)
                  );
                }
              }
              upload(t) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = t.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(t, r) {
                const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
                  c = Ft(
                    this.expression.interpolationFactor(
                      a,
                      this.zoom,
                      this.zoom + 1
                    ),
                    0,
                    1
                  );
                t.set(c);
              }
              getBinding(t, r, a) {
                return new Ki(t, r);
              }
            }
            class So {
              constructor(t, r, a, c, p, m) {
                (this.expression = t),
                  (this.type = r),
                  (this.useIntegerZoom = a),
                  (this.zoom = c),
                  (this.layerId = m),
                  (this.zoomInPaintVertexArray = new p()),
                  (this.zoomOutPaintVertexArray = new p());
              }
              populatePaintArray(t, r, a) {
                const c = this.zoomInPaintVertexArray.length;
                this.zoomInPaintVertexArray.resize(t),
                  this.zoomOutPaintVertexArray.resize(t),
                  this._setPaintValues(c, t, this.getPositionIds(r), a);
              }
              updatePaintArray(t, r, a, c, p) {
                this._setPaintValues(t, r, this.getPositionIds(a), p);
              }
              _setPaintValues(t, r, a, c) {
                const p = this.getPositions(c);
                if (!p || !a) return;
                const m = p[a.min],
                  v = p[a.mid],
                  b = p[a.max];
                if (m && v && b)
                  for (let C = t; C < r; C++)
                    this.emplace(this.zoomInPaintVertexArray, C, v, m),
                      this.emplace(this.zoomOutPaintVertexArray, C, v, b);
              }
              upload(t) {
                if (
                  this.zoomInPaintVertexArray &&
                  this.zoomInPaintVertexArray.arrayBuffer &&
                  this.zoomOutPaintVertexArray &&
                  this.zoomOutPaintVertexArray.arrayBuffer
                ) {
                  const r = this.getVertexAttributes();
                  (this.zoomInPaintVertexBuffer = t.createVertexBuffer(
                    this.zoomInPaintVertexArray,
                    r,
                    this.expression.isStateDependent
                  )),
                    (this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
                      this.zoomOutPaintVertexArray,
                      r,
                      this.expression.isStateDependent
                    ));
                }
              }
              destroy() {
                this.zoomOutPaintVertexBuffer &&
                  this.zoomOutPaintVertexBuffer.destroy(),
                  this.zoomInPaintVertexBuffer &&
                    this.zoomInPaintVertexBuffer.destroy();
              }
            }
            class Wd extends So {
              getPositions(t) {
                return t.imagePositions;
              }
              getPositionIds(t) {
                return t.patterns && t.patterns[this.layerId];
              }
              getVertexAttributes() {
                return ri.members;
              }
              emplace(t, r, a, c) {
                t.emplace(
                  r,
                  a.tlbr[0],
                  a.tlbr[1],
                  a.tlbr[2],
                  a.tlbr[3],
                  c.tlbr[0],
                  c.tlbr[1],
                  c.tlbr[2],
                  c.tlbr[3],
                  a.pixelRatio,
                  c.pixelRatio
                );
              }
            }
            class Xd extends So {
              getPositions(t) {
                return t.dashPositions;
              }
              getPositionIds(t) {
                return t.dashes && t.dashes[this.layerId];
              }
              getVertexAttributes() {
                return Un.members;
              }
              emplace(t, r, a, c) {
                t.emplace(
                  r,
                  0,
                  a.y,
                  a.height,
                  a.width,
                  0,
                  c.y,
                  c.height,
                  c.width
                );
              }
            }
            class Yd {
              constructor(t, r, a) {
                (this.binders = {}), (this._buffers = []);
                const c = [];
                for (const p in t.paint._values) {
                  if (!a(p)) continue;
                  const m = t.paint.get(p);
                  if (!(m instanceof Ma && vs(m.property.specification)))
                    continue;
                  const v = ts(p, t.type),
                    b = m.value,
                    C = m.property.specification.type,
                    I = m.property.useIntegerZoom,
                    R = m.property.specification["property-type"],
                    U = R === "cross-faded" || R === "cross-faded-data-driven";
                  if (b.kind === "constant")
                    (this.binders[p] = U
                      ? new Mi(b.value, v)
                      : new ui(b.value, v, C)),
                      c.push(`/u_${p}`);
                  else if (b.kind === "source" || U) {
                    const Z = Au(p, C, "source");
                    (this.binders[p] = U
                      ? p === "line-dasharray"
                        ? new Xd(b, C, I, r, Z, t.id)
                        : new Wd(b, C, I, r, Z, t.id)
                      : new Hn(b, v, C, Z)),
                      c.push(`/a_${p}`);
                  } else {
                    const Z = Au(p, C, "composite");
                    (this.binders[p] = new ka(b, v, C, I, r, Z)),
                      c.push(`/z_${p}`);
                  }
                }
                this.cacheKey = c.sort().join("");
              }
              getMaxValue(t) {
                const r = this.binders[t];
                return r instanceof Hn || r instanceof ka ? r.maxValue : 0;
              }
              populatePaintArrays(t, r, a) {
                for (const c in this.binders) {
                  const p = this.binders[c];
                  (p instanceof Hn || p instanceof ka || p instanceof So) &&
                    p.populatePaintArray(t, r, a);
                }
              }
              setConstantPatternPositions(t, r) {
                for (const a in this.binders) {
                  const c = this.binders[a];
                  c instanceof Mi && c.setConstantPatternPositions(t, r);
                }
              }
              setConstantDashPositions(t, r) {
                for (const a in this.binders) {
                  const c = this.binders[a];
                  c instanceof Mi && c.setConstantDashPositions(t, r);
                }
              }
              updatePaintArrays(t, r, a, c, p) {
                let m = !1;
                for (const v in t) {
                  const b = r.getPositions(v);
                  for (const C of b) {
                    const I = a.feature(C.index);
                    for (const R in this.binders) {
                      const U = this.binders[R];
                      if (
                        (U instanceof Hn ||
                          U instanceof ka ||
                          U instanceof So) &&
                        U.expression.isStateDependent === !0
                      ) {
                        const Z = c.paint.get(R);
                        (U.expression = Z.value),
                          U.updatePaintArray(C.start, C.end, I, t[v], p),
                          (m = !0);
                      }
                    }
                  }
                }
                return m;
              }
              defines() {
                const t = [];
                for (const r in this.binders) {
                  const a = this.binders[r];
                  (a instanceof ui || a instanceof Mi) &&
                    t.push(
                      ...a.uniformNames.map((c) => `#define HAS_UNIFORM_${c}`)
                    );
                }
                return t;
              }
              getBinderAttributes() {
                const t = [];
                for (const r in this.binders) {
                  const a = this.binders[r];
                  if (a instanceof Hn || a instanceof ka)
                    for (let c = 0; c < a.paintVertexAttributes.length; c++)
                      t.push(a.paintVertexAttributes[c].name);
                  else if (a instanceof So) {
                    const c = a.getVertexAttributes();
                    for (const p of c) t.push(p.name);
                  }
                }
                return t;
              }
              getBinderUniforms() {
                const t = [];
                for (const r in this.binders) {
                  const a = this.binders[r];
                  if (a instanceof ui || a instanceof Mi || a instanceof ka)
                    for (const c of a.uniformNames) t.push(c);
                }
                return t;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(t, r) {
                const a = [];
                for (const c in this.binders) {
                  const p = this.binders[c];
                  if (p instanceof ui || p instanceof Mi || p instanceof ka) {
                    for (const m of p.uniformNames)
                      if (r[m]) {
                        const v = p.getBinding(t, r[m], m);
                        a.push({ name: m, property: c, binding: v });
                      }
                  }
                }
                return a;
              }
              setUniforms(t, r, a, c) {
                for (const { name: p, property: m, binding: v } of r)
                  this.binders[m].setUniform(v, c, a.get(m), p);
              }
              updatePaintBuffers(t) {
                this._buffers = [];
                for (const r in this.binders) {
                  const a = this.binders[r];
                  if (t && a instanceof So) {
                    const c =
                      t.fromScale === 2
                        ? a.zoomInPaintVertexBuffer
                        : a.zoomOutPaintVertexBuffer;
                    c && this._buffers.push(c);
                  } else
                    (a instanceof Hn || a instanceof ka) &&
                      a.paintVertexBuffer &&
                      this._buffers.push(a.paintVertexBuffer);
                }
              }
              upload(t) {
                for (const r in this.binders) {
                  const a = this.binders[r];
                  (a instanceof Hn || a instanceof ka || a instanceof So) &&
                    a.upload(t);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const t in this.binders) {
                  const r = this.binders[t];
                  (r instanceof Hn || r instanceof ka || r instanceof So) &&
                    r.destroy();
                }
              }
            }
            class es {
              constructor(t, r, a = () => !0) {
                this.programConfigurations = {};
                for (const c of t)
                  this.programConfigurations[c.id] = new Yd(c, r, a);
                (this.needsUpload = !1),
                  (this._featureMap = new Ua()),
                  (this._bufferOffset = 0);
              }
              populatePaintArrays(t, r, a, c) {
                for (const p in this.programConfigurations)
                  this.programConfigurations[p].populatePaintArrays(t, r, c);
                r.id !== void 0 &&
                  this._featureMap.add(r.id, a, this._bufferOffset, t),
                  (this._bufferOffset = t),
                  (this.needsUpload = !0);
              }
              updatePaintArrays(t, r, a, c) {
                for (const p of a)
                  this.needsUpload =
                    this.programConfigurations[p.id].updatePaintArrays(
                      t,
                      this._featureMap,
                      r,
                      p,
                      c
                    ) || this.needsUpload;
              }
              get(t) {
                return this.programConfigurations[t];
              }
              upload(t) {
                if (this.needsUpload) {
                  for (const r in this.programConfigurations)
                    this.programConfigurations[r].upload(t);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const t in this.programConfigurations)
                  this.programConfigurations[t].destroy();
              }
            }
            function ts(n, t) {
              return (
                {
                  "text-opacity": ["opacity"],
                  "icon-opacity": ["opacity"],
                  "text-color": ["fill_color"],
                  "icon-color": ["fill_color"],
                  "text-halo-color": ["halo_color"],
                  "icon-halo-color": ["halo_color"],
                  "text-halo-blur": ["halo_blur"],
                  "icon-halo-blur": ["halo_blur"],
                  "text-halo-width": ["halo_width"],
                  "icon-halo-width": ["halo_width"],
                  "line-gap-width": ["gapwidth"],
                  "line-dasharray": ["dasharray_to", "dasharray_from"],
                  "line-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from",
                  ],
                  "fill-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from",
                  ],
                  "fill-extrusion-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from",
                  ],
                }[n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
              );
            }
            function Au(n, t, r) {
              const a = {
                  color: { source: Wo, composite: d },
                  number: { source: h, composite: Wo },
                },
                c = (function (p) {
                  return {
                    "line-pattern": { source: Re, composite: Re },
                    "fill-pattern": { source: Re, composite: Re },
                    "fill-extrusion-pattern": { source: Re, composite: Re },
                    "line-dasharray": { source: it, composite: it },
                  }[p];
                })(n);
              return (c && c[r]) || a[t][r];
            }
            hr("ConstantBinder", ui),
              hr("CrossFadedConstantBinder", Mi),
              hr("SourceExpressionBinder", Hn),
              hr("CrossFadedPatternBinder", Wd),
              hr("CrossFadedDasharrayBinder", Xd),
              hr("CompositeExpressionBinder", ka),
              hr("ProgramConfiguration", Yd, { omit: ["_buffers"] }),
              hr("ProgramConfigurationSet", es);
            const ic = Math.pow(2, 14) - 1,
              ku = -ic - 1;
            function so(n) {
              const t = Fe / n.extent,
                r = n.loadGeometry();
              for (let a = 0; a < r.length; a++) {
                const c = r[a];
                for (let p = 0; p < c.length; p++) {
                  const m = c[p],
                    v = Math.round(m.x * t),
                    b = Math.round(m.y * t);
                  (m.x = Ft(v, ku, ic)),
                    (m.y = Ft(b, ku, ic)),
                    (v < m.x || v > m.x + 1 || b < m.y || b > m.y + 1) &&
                      Bt(
                        "Geometry exceeds allowed extent, reduce your vector tile buffer size"
                      );
                }
              }
              return r;
            }
            function Co(n, t) {
              return {
                type: n.type,
                id: n.id,
                properties: n.properties,
                geometry: t ? so(n) : [],
              };
            }
            const ac = -32768;
            function Yy(n, t, r, a, c) {
              n.emplaceBack(ac + 8 * t + a, ac + 8 * r + c);
            }
            class Sf {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((r) => r.id)),
                  (this.index = t.index),
                  (this.hasDependencies = !1),
                  (this.layoutVertexArray = new be()),
                  (this.indexArray = new Pt()),
                  (this.segments = new cn()),
                  (this.programConfigurations = new es(t.layers, t.zoom)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((r) => r.isStateDependent())
                    .map((r) => r.id));
              }
              populate(t, r, a) {
                const c = this.layers[0],
                  p = [];
                let m = null,
                  v = !1,
                  b = c.type === "heatmap";
                if (c.type === "circle") {
                  const I = c;
                  (m = I.layout.get("circle-sort-key")),
                    (v = !m.isConstant()),
                    (b = b || I.paint.get("circle-pitch-alignment") === "map");
                }
                const C = b ? r.subdivisionGranularity.circle : 1;
                for (const {
                  feature: I,
                  id: R,
                  index: U,
                  sourceLayerIndex: Z,
                } of t) {
                  const X = this.layers[0]._featureFilter.needGeometry,
                    Q = Co(I, X);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new On(this.zoom),
                      Q,
                      a
                    )
                  )
                    continue;
                  const ie = v ? m.evaluate(Q, {}, a) : void 0,
                    he = {
                      id: R,
                      properties: I.properties,
                      type: I.type,
                      sourceLayerIndex: Z,
                      index: U,
                      geometry: X ? Q.geometry : so(I),
                      patterns: {},
                      sortKey: ie,
                    };
                  p.push(he);
                }
                v && p.sort((I, R) => I.sortKey - R.sortKey);
                for (const I of p) {
                  const { geometry: R, index: U, sourceLayerIndex: Z } = I,
                    X = t[U].feature;
                  this.addFeature(I, R, U, a, C),
                    r.featureIndex.insert(X, R, U, Z, this.index);
                }
              }
              update(t, r, a) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.stateDependentLayers,
                    { imagePositions: a }
                  );
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    Ln
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(t, r, a, c, p = 1) {
                let m;
                switch (p) {
                  case 1:
                    m = [0, 7];
                    break;
                  case 3:
                    m = [0, 2, 5, 7];
                    break;
                  case 5:
                    m = [0, 1, 3, 4, 6, 7];
                    break;
                  case 7:
                    m = [0, 1, 2, 3, 4, 5, 6, 7];
                    break;
                  default:
                    throw new Error(
                      `Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`
                    );
                }
                const v = m.length;
                for (const b of r)
                  for (const C of b) {
                    const I = C.x,
                      R = C.y;
                    if (I < 0 || I >= Fe || R < 0 || R >= Fe) continue;
                    const U = this.segments.prepareSegment(
                        v * v,
                        this.layoutVertexArray,
                        this.indexArray,
                        t.sortKey
                      ),
                      Z = U.vertexLength;
                    for (let X = 0; X < v; X++)
                      for (let Q = 0; Q < v; Q++)
                        Yy(this.layoutVertexArray, I, R, m[Q], m[X]);
                    for (let X = 0; X < v - 1; X++)
                      for (let Q = 0; Q < v - 1; Q++) {
                        const ie = Z + X * v + Q,
                          he = Z + (X + 1) * v + Q;
                        this.indexArray.emplaceBack(ie, he + 1, ie + 1),
                          this.indexArray.emplaceBack(ie, he, he + 1);
                      }
                    (U.vertexLength += v * v),
                      (U.primitiveLength += (v - 1) * (v - 1) * 2);
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  a,
                  { imagePositions: {}, canonical: c }
                );
              }
            }
            function $_(n, t) {
              for (let r = 0; r < n.length; r++) if (oc(t, n[r])) return !0;
              for (let r = 0; r < t.length; r++) if (oc(n, t[r])) return !0;
              return !!Cf(n, t);
            }
            function Kd(n, t, r) {
              return !!oc(n, t) || !!Pf(t, n, r);
            }
            function H_(n, t) {
              if (n.length === 1) return X_(t, n[0]);
              for (let r = 0; r < t.length; r++) {
                const a = t[r];
                for (let c = 0; c < a.length; c++) if (oc(n, a[c])) return !0;
              }
              for (let r = 0; r < n.length; r++) if (X_(t, n[r])) return !0;
              for (let r = 0; r < t.length; r++) if (Cf(n, t[r])) return !0;
              return !1;
            }
            function Ky(n, t, r) {
              if (n.length > 1) {
                if (Cf(n, t)) return !0;
                for (let a = 0; a < t.length; a++)
                  if (Pf(t[a], n, r)) return !0;
              }
              for (let a = 0; a < n.length; a++) if (Pf(n[a], t, r)) return !0;
              return !1;
            }
            function Cf(n, t) {
              if (n.length === 0 || t.length === 0) return !1;
              for (let r = 0; r < n.length - 1; r++) {
                const a = n[r],
                  c = n[r + 1];
                for (let p = 0; p < t.length - 1; p++)
                  if (Jy(a, c, t[p], t[p + 1])) return !0;
              }
              return !1;
            }
            function Jy(n, t, r, a) {
              return Gt(n, r, a) !== Gt(t, r, a) && Gt(n, t, r) !== Gt(n, t, a);
            }
            function Pf(n, t, r) {
              const a = r * r;
              if (t.length === 1) return n.distSqr(t[0]) < a;
              for (let c = 1; c < t.length; c++)
                if (W_(n, t[c - 1], t[c]) < a) return !0;
              return !1;
            }
            function W_(n, t, r) {
              const a = t.distSqr(r);
              if (a === 0) return n.distSqr(t);
              const c =
                ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / a;
              return n.distSqr(
                c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t)
              );
            }
            function X_(n, t) {
              let r,
                a,
                c,
                p = !1;
              for (let m = 0; m < n.length; m++) {
                r = n[m];
                for (let v = 0, b = r.length - 1; v < r.length; b = v++)
                  (a = r[v]),
                    (c = r[b]),
                    a.y > t.y != c.y > t.y &&
                      t.x < ((c.x - a.x) * (t.y - a.y)) / (c.y - a.y) + a.x &&
                      (p = !p);
              }
              return p;
            }
            function oc(n, t) {
              let r = !1;
              for (let a = 0, c = n.length - 1; a < n.length; c = a++) {
                const p = n[a],
                  m = n[c];
                p.y > t.y != m.y > t.y &&
                  t.x < ((m.x - p.x) * (t.y - p.y)) / (m.y - p.y) + p.x &&
                  (r = !r);
              }
              return r;
            }
            function Qy(n, t, r) {
              const a = r[0],
                c = r[2];
              if (
                (n.x < a.x && t.x < a.x) ||
                (n.x > c.x && t.x > c.x) ||
                (n.y < a.y && t.y < a.y) ||
                (n.y > c.y && t.y > c.y)
              )
                return !1;
              const p = Gt(n, t, r[0]);
              return (
                p !== Gt(n, t, r[1]) ||
                p !== Gt(n, t, r[2]) ||
                p !== Gt(n, t, r[3])
              );
            }
            function sc(n, t, r) {
              const a = t.paint.get(n).value;
              return a.kind === "constant"
                ? a.value
                : r.programConfigurations.get(t.id).getMaxValue(n);
            }
            function Jd(n) {
              return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
            }
            function Qd(n, t, r, a, c) {
              if (!t[0] && !t[1]) return n;
              const p = B.convert(t)._mult(c);
              r === "viewport" && p._rotate(-a);
              const m = [];
              for (let v = 0; v < n.length; v++) m.push(n[v].sub(p));
              return m;
            }
            function e1({ queryGeometry: n, size: t }, r) {
              return Kd(n, r, t);
            }
            function t1(
              {
                queryGeometry: n,
                size: t,
                transform: r,
                unwrappedTileID: a,
                getElevation: c,
              },
              p
            ) {
              return Kd(
                n,
                p,
                t *
                  (r.projectTileCoordinates(p.x, p.y, a, c)
                    .signedDistanceFromCamera /
                    r.cameraToCenterDistance)
              );
            }
            function r1(
              {
                queryGeometry: n,
                size: t,
                transform: r,
                unwrappedTileID: a,
                getElevation: c,
              },
              p
            ) {
              const m = r.projectTileCoordinates(
                  p.x,
                  p.y,
                  a,
                  c
                ).signedDistanceFromCamera,
                v = t * (r.cameraToCenterDistance / m);
              return Kd(n, If(p, r, a, c), v);
            }
            function n1(
              {
                queryGeometry: n,
                size: t,
                transform: r,
                unwrappedTileID: a,
                getElevation: c,
              },
              p
            ) {
              return Kd(n, If(p, r, a, c), t);
            }
            function Y_(
              {
                queryGeometry: n,
                size: t,
                transform: r,
                unwrappedTileID: a,
                getElevation: c,
                pitchAlignment: p = "map",
                pitchScale: m = "map",
              },
              v
            ) {
              const b =
                  p === "map" ? (m === "map" ? e1 : t1) : m === "map" ? r1 : n1,
                C = {
                  queryGeometry: n,
                  size: t,
                  transform: r,
                  unwrappedTileID: a,
                  getElevation: c,
                };
              for (const I of v) for (const R of I) if (b(C, R)) return !0;
              return !1;
            }
            function If(n, t, r, a) {
              const c = t.projectTileCoordinates(n.x, n.y, r, a).point;
              return new B(
                (0.5 * c.x + 0.5) * t.width,
                (0.5 * -c.y + 0.5) * t.height
              );
            }
            let K_, J_;
            hr("CircleBucket", Sf, { omit: ["layers"] });
            var i1 = {
              get paint() {
                return (J_ =
                  J_ ||
                  new Ui({
                    "circle-radius": new Gr(_e.paint_circle["circle-radius"]),
                    "circle-color": new Gr(_e.paint_circle["circle-color"]),
                    "circle-blur": new Gr(_e.paint_circle["circle-blur"]),
                    "circle-opacity": new Gr(_e.paint_circle["circle-opacity"]),
                    "circle-translate": new zr(
                      _e.paint_circle["circle-translate"]
                    ),
                    "circle-translate-anchor": new zr(
                      _e.paint_circle["circle-translate-anchor"]
                    ),
                    "circle-pitch-scale": new zr(
                      _e.paint_circle["circle-pitch-scale"]
                    ),
                    "circle-pitch-alignment": new zr(
                      _e.paint_circle["circle-pitch-alignment"]
                    ),
                    "circle-stroke-width": new Gr(
                      _e.paint_circle["circle-stroke-width"]
                    ),
                    "circle-stroke-color": new Gr(
                      _e.paint_circle["circle-stroke-color"]
                    ),
                    "circle-stroke-opacity": new Gr(
                      _e.paint_circle["circle-stroke-opacity"]
                    ),
                  }));
              },
              get layout() {
                return (K_ =
                  K_ ||
                  new Ui({
                    "circle-sort-key": new Gr(
                      _e.layout_circle["circle-sort-key"]
                    ),
                  }));
              },
            };
            class a1 extends Aa {
              constructor(t, r) {
                super(t, i1, r);
              }
              createBucket(t) {
                return new Sf(t);
              }
              queryRadius(t) {
                const r = t;
                return (
                  sc("circle-radius", this, r) +
                  sc("circle-stroke-width", this, r) +
                  Jd(this.paint.get("circle-translate"))
                );
              }
              queryIntersectsFeature({
                queryGeometry: t,
                feature: r,
                featureState: a,
                geometry: c,
                transform: p,
                pixelsToTileUnits: m,
                unwrappedTileID: v,
                getElevation: b,
              }) {
                const C = Qd(
                    t,
                    this.paint.get("circle-translate"),
                    this.paint.get("circle-translate-anchor"),
                    -p.bearingInRadians,
                    m
                  ),
                  I =
                    this.paint.get("circle-radius").evaluate(r, a) +
                    this.paint.get("circle-stroke-width").evaluate(r, a),
                  R = this.paint.get("circle-pitch-scale"),
                  U = this.paint.get("circle-pitch-alignment");
                let Z, X;
                return (
                  U === "map"
                    ? ((Z = C), (X = I * m))
                    : ((Z = (function (Q, ie, he, Oe) {
                        return Q.map((ye) => If(ye, ie, he, Oe));
                      })(C, p, v, b)),
                      (X = I)),
                  Y_(
                    {
                      queryGeometry: Z,
                      size: X,
                      transform: p,
                      unwrappedTileID: v,
                      getElevation: b,
                      pitchAlignment: U,
                      pitchScale: R,
                    },
                    c
                  )
                );
              }
            }
            class Q_ extends Sf {}
            let eg;
            hr("HeatmapBucket", Q_, { omit: ["layers"] });
            var o1 = {
              get paint() {
                return (eg =
                  eg ||
                  new Ui({
                    "heatmap-radius": new Gr(
                      _e.paint_heatmap["heatmap-radius"]
                    ),
                    "heatmap-weight": new Gr(
                      _e.paint_heatmap["heatmap-weight"]
                    ),
                    "heatmap-intensity": new zr(
                      _e.paint_heatmap["heatmap-intensity"]
                    ),
                    "heatmap-color": new il(_e.paint_heatmap["heatmap-color"]),
                    "heatmap-opacity": new zr(
                      _e.paint_heatmap["heatmap-opacity"]
                    ),
                  }));
              },
            };
            function Mf(n, { width: t, height: r }, a, c) {
              if (c) {
                if (c instanceof Uint8ClampedArray)
                  c = new Uint8Array(c.buffer);
                else if (c.length !== t * r * a)
                  throw new RangeError(
                    `mismatched image size. expected: ${c.length} but got: ${
                      t * r * a
                    }`
                  );
              } else c = new Uint8Array(t * r * a);
              return (n.width = t), (n.height = r), (n.data = c), n;
            }
            function tg(n, { width: t, height: r }, a) {
              if (t === n.width && r === n.height) return;
              const c = Mf({}, { width: t, height: r }, a);
              Af(
                n,
                c,
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { width: Math.min(n.width, t), height: Math.min(n.height, r) },
                a
              ),
                (n.width = t),
                (n.height = r),
                (n.data = c.data);
            }
            function Af(n, t, r, a, c, p) {
              if (c.width === 0 || c.height === 0) return t;
              if (
                c.width > n.width ||
                c.height > n.height ||
                r.x > n.width - c.width ||
                r.y > n.height - c.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy"
                );
              if (
                c.width > t.width ||
                c.height > t.height ||
                a.x > t.width - c.width ||
                a.y > t.height - c.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy"
                );
              const m = n.data,
                v = t.data;
              if (m === v)
                throw new Error(
                  "srcData equals dstData, so image is already copied"
                );
              for (let b = 0; b < c.height; b++) {
                const C = ((r.y + b) * n.width + r.x) * p,
                  I = ((a.y + b) * t.width + a.x) * p;
                for (let R = 0; R < c.width * p; R++) v[I + R] = m[C + R];
              }
              return t;
            }
            class Eu {
              constructor(t, r) {
                Mf(this, t, 1, r);
              }
              resize(t) {
                tg(this, t, 1);
              }
              clone() {
                return new Eu(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(t, r, a, c, p) {
                Af(t, r, a, c, p, 1);
              }
            }
            class la {
              constructor(t, r) {
                Mf(this, t, 4, r);
              }
              resize(t) {
                tg(this, t, 4);
              }
              replace(t, r) {
                r
                  ? this.data.set(t)
                  : (this.data =
                      t instanceof Uint8ClampedArray
                        ? new Uint8Array(t.buffer)
                        : t);
              }
              clone() {
                return new la(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(t, r, a, c, p) {
                Af(t, r, a, c, p, 4);
              }
              setPixel(t, r, a) {
                const c = 4 * (t * this.width + r);
                (this.data[c + 0] = Math.round((255 * a.r) / a.a)),
                  (this.data[c + 1] = Math.round((255 * a.g) / a.a)),
                  (this.data[c + 2] = Math.round((255 * a.b) / a.a)),
                  (this.data[c + 3] = Math.round(255 * a.a));
              }
            }
            function rg(n) {
              const t = {},
                r = n.resolution || 256,
                a = n.clips ? n.clips.length : 1,
                c = n.image || new la({ width: r, height: a });
              if ((Math.log(r) / Math.LN2) % 1 != 0)
                throw new Error(`width is not a power of 2 - ${r}`);
              const p = (m, v, b) => {
                t[n.evaluationKey] = b;
                const C = n.expression.evaluate(t);
                c.setPixel(m / 4 / r, v / 4, C);
              };
              if (n.clips)
                for (let m = 0, v = 0; m < a; ++m, v += 4 * r)
                  for (let b = 0, C = 0; b < r; b++, C += 4) {
                    const I = b / (r - 1),
                      { start: R, end: U } = n.clips[m];
                    p(v, C, R * (1 - I) + U * I);
                  }
              else
                for (let m = 0, v = 0; m < r; m++, v += 4) p(0, v, m / (r - 1));
              return c;
            }
            hr("AlphaImage", Eu), hr("RGBAImage", la);
            const kf = "big-fb";
            class s1 extends Aa {
              createBucket(t) {
                return new Q_(t);
              }
              constructor(t, r) {
                super(t, o1, r),
                  (this.heatmapFbos = new Map()),
                  this._updateColorRamp();
              }
              _handleSpecialPaintPropertyUpdate(t) {
                t === "heatmap-color" && this._updateColorRamp();
              }
              _updateColorRamp() {
                (this.colorRamp = rg({
                  expression:
                    this._transitionablePaint._values["heatmap-color"].value
                      .expression,
                  evaluationKey: "heatmapDensity",
                  image: this.colorRamp,
                })),
                  (this.colorRampTexture = null);
              }
              resize() {
                this.heatmapFbos.has(kf) && this.heatmapFbos.delete(kf);
              }
              queryRadius(t) {
                return sc("heatmap-radius", this, t);
              }
              queryIntersectsFeature({
                queryGeometry: t,
                feature: r,
                featureState: a,
                geometry: c,
                transform: p,
                pixelsToTileUnits: m,
                unwrappedTileID: v,
                getElevation: b,
              }) {
                return Y_(
                  {
                    queryGeometry: t,
                    size: this.paint.get("heatmap-radius").evaluate(r, a) * m,
                    transform: p,
                    unwrappedTileID: v,
                    getElevation: b,
                  },
                  c
                );
              }
              hasOffscreenPass() {
                return (
                  this.paint.get("heatmap-opacity") !== 0 &&
                  this.visibility !== "none"
                );
              }
            }
            let ng;
            var l1 = {
              get paint() {
                return (ng =
                  ng ||
                  new Ui({
                    "hillshade-illumination-direction": new zr(
                      _e.paint_hillshade["hillshade-illumination-direction"]
                    ),
                    "hillshade-illumination-altitude": new zr(
                      _e.paint_hillshade["hillshade-illumination-altitude"]
                    ),
                    "hillshade-illumination-anchor": new zr(
                      _e.paint_hillshade["hillshade-illumination-anchor"]
                    ),
                    "hillshade-exaggeration": new zr(
                      _e.paint_hillshade["hillshade-exaggeration"]
                    ),
                    "hillshade-shadow-color": new zr(
                      _e.paint_hillshade["hillshade-shadow-color"]
                    ),
                    "hillshade-highlight-color": new zr(
                      _e.paint_hillshade["hillshade-highlight-color"]
                    ),
                    "hillshade-accent-color": new zr(
                      _e.paint_hillshade["hillshade-accent-color"]
                    ),
                    "hillshade-method": new zr(
                      _e.paint_hillshade["hillshade-method"]
                    ),
                  }));
              },
            };
            class c1 extends Aa {
              constructor(t, r) {
                super(t, l1, r),
                  this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
              }
              getIlluminationProperties() {
                let t = this.paint.get(
                    "hillshade-illumination-direction"
                  ).values,
                  r = this.paint.get("hillshade-illumination-altitude").values,
                  a = this.paint.get("hillshade-highlight-color").values,
                  c = this.paint.get("hillshade-shadow-color").values;
                const p = Math.max(t.length, r.length, a.length, c.length);
                (t = t.concat(Array(p - t.length).fill(t.at(-1)))),
                  (r = r.concat(Array(p - r.length).fill(r.at(-1)))),
                  (a = a.concat(Array(p - a.length).fill(a.at(-1)))),
                  (c = c.concat(Array(p - c.length).fill(c.at(-1))));
                const m = r.map(pr);
                return {
                  directionRadians: t.map(pr),
                  altitudeRadians: m,
                  shadowColor: c,
                  highlightColor: a,
                };
              }
              hasOffscreenPass() {
                return (
                  this.paint.get("hillshade-exaggeration") !== 0 &&
                  this.visibility !== "none"
                );
              }
            }
            let ig;
            var u1 = {
              get paint() {
                return (ig =
                  ig ||
                  new Ui({
                    "color-relief-opacity": new zr(
                      _e["paint_color-relief"]["color-relief-opacity"]
                    ),
                    "color-relief-color": new il(
                      _e["paint_color-relief"]["color-relief-color"]
                    ),
                  }));
              },
            };
            class Ef {
              constructor(t, r, a, c) {
                (this.context = t),
                  (this.format = a),
                  (this.texture = t.gl.createTexture()),
                  this.update(r, c);
              }
              update(t, r, a) {
                const { width: c, height: p } = t,
                  m = !(
                    (this.size && this.size[0] === c && this.size[1] === p) ||
                    a
                  ),
                  { context: v } = this,
                  { gl: b } = v;
                if (
                  ((this.useMipmap = !!(r && r.useMipmap)),
                  b.bindTexture(b.TEXTURE_2D, this.texture),
                  v.pixelStoreUnpackFlipY.set(!1),
                  v.pixelStoreUnpack.set(1),
                  v.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === b.RGBA && (!r || r.premultiply !== !1)
                  ),
                  m)
                )
                  (this.size = [c, p]),
                    t instanceof HTMLImageElement ||
                    t instanceof HTMLCanvasElement ||
                    t instanceof HTMLVideoElement ||
                    t instanceof ImageData ||
                    Nt(t)
                      ? b.texImage2D(
                          b.TEXTURE_2D,
                          0,
                          this.format,
                          this.format,
                          b.UNSIGNED_BYTE,
                          t
                        )
                      : b.texImage2D(
                          b.TEXTURE_2D,
                          0,
                          this.format,
                          c,
                          p,
                          0,
                          this.format,
                          b.UNSIGNED_BYTE,
                          t.data
                        );
                else {
                  const { x: C, y: I } = a || { x: 0, y: 0 };
                  t instanceof HTMLImageElement ||
                  t instanceof HTMLCanvasElement ||
                  t instanceof HTMLVideoElement ||
                  t instanceof ImageData ||
                  Nt(t)
                    ? b.texSubImage2D(
                        b.TEXTURE_2D,
                        0,
                        C,
                        I,
                        b.RGBA,
                        b.UNSIGNED_BYTE,
                        t
                      )
                    : b.texSubImage2D(
                        b.TEXTURE_2D,
                        0,
                        C,
                        I,
                        c,
                        p,
                        b.RGBA,
                        b.UNSIGNED_BYTE,
                        t.data
                      );
                }
                this.useMipmap &&
                  this.isSizePowerOfTwo() &&
                  b.generateMipmap(b.TEXTURE_2D),
                  v.pixelStoreUnpackFlipY.setDefault(),
                  v.pixelStoreUnpack.setDefault(),
                  v.pixelStoreUnpackPremultiplyAlpha.setDefault();
              }
              bind(t, r, a) {
                const { context: c } = this,
                  { gl: p } = c;
                p.bindTexture(p.TEXTURE_2D, this.texture),
                  a !== p.LINEAR_MIPMAP_NEAREST ||
                    this.isSizePowerOfTwo() ||
                    (a = p.LINEAR),
                  t !== this.filter &&
                    (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t),
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t),
                    (this.filter = t)),
                  r !== this.wrap &&
                    (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r),
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r),
                    (this.wrap = r));
              }
              isSizePowerOfTwo() {
                return (
                  this.size[0] === this.size[1] &&
                  (Math.log(this.size[0]) / Math.LN2) % 1 == 0
                );
              }
              destroy() {
                const { gl: t } = this.context;
                t.deleteTexture(this.texture), (this.texture = null);
              }
            }
            class ag {
              constructor(t, r, a, c = 1, p = 1, m = 1, v = 0) {
                if (((this.uid = t), r.height !== r.width))
                  throw new RangeError("DEM tiles must be square");
                if (a && !["mapbox", "terrarium", "custom"].includes(a))
                  return void Bt(
                    `"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`
                  );
                this.stride = r.height;
                const b = (this.dim = r.height - 2);
                switch (((this.data = new Uint32Array(r.data.buffer)), a)) {
                  case "terrarium":
                    (this.redFactor = 256),
                      (this.greenFactor = 1),
                      (this.blueFactor = 1 / 256),
                      (this.baseShift = 32768);
                    break;
                  case "custom":
                    (this.redFactor = c),
                      (this.greenFactor = p),
                      (this.blueFactor = m),
                      (this.baseShift = v);
                    break;
                  default:
                    (this.redFactor = 6553.6),
                      (this.greenFactor = 25.6),
                      (this.blueFactor = 0.1),
                      (this.baseShift = 1e4);
                }
                for (let C = 0; C < b; C++)
                  (this.data[this._idx(-1, C)] = this.data[this._idx(0, C)]),
                    (this.data[this._idx(b, C)] =
                      this.data[this._idx(b - 1, C)]),
                    (this.data[this._idx(C, -1)] = this.data[this._idx(C, 0)]),
                    (this.data[this._idx(C, b)] =
                      this.data[this._idx(C, b - 1)]);
                (this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
                  (this.data[this._idx(b, -1)] =
                    this.data[this._idx(b - 1, 0)]),
                  (this.data[this._idx(-1, b)] =
                    this.data[this._idx(0, b - 1)]),
                  (this.data[this._idx(b, b)] =
                    this.data[this._idx(b - 1, b - 1)]),
                  (this.min = Number.MAX_SAFE_INTEGER),
                  (this.max = Number.MIN_SAFE_INTEGER);
                for (let C = 0; C < b; C++)
                  for (let I = 0; I < b; I++) {
                    const R = this.get(C, I);
                    R > this.max && (this.max = R),
                      R < this.min && (this.min = R);
                  }
              }
              get(t, r) {
                const a = new Uint8Array(this.data.buffer),
                  c = 4 * this._idx(t, r);
                return this.unpack(a[c], a[c + 1], a[c + 2]);
              }
              getUnpackVector() {
                return [
                  this.redFactor,
                  this.greenFactor,
                  this.blueFactor,
                  this.baseShift,
                ];
              }
              _idx(t, r) {
                if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1)
                  throw new RangeError(
                    "out of range source coordinates for DEM data"
                  );
                return (r + 1) * this.stride + (t + 1);
              }
              unpack(t, r, a) {
                return (
                  t * this.redFactor +
                  r * this.greenFactor +
                  a * this.blueFactor -
                  this.baseShift
                );
              }
              pack(t) {
                return og(t, this.getUnpackVector());
              }
              getPixels() {
                return new la(
                  { width: this.stride, height: this.stride },
                  new Uint8Array(this.data.buffer)
                );
              }
              backfillBorder(t, r, a) {
                if (this.dim !== t.dim)
                  throw new Error("dem dimension mismatch");
                let c = r * this.dim,
                  p = r * this.dim + this.dim,
                  m = a * this.dim,
                  v = a * this.dim + this.dim;
                switch (r) {
                  case -1:
                    c = p - 1;
                    break;
                  case 1:
                    p = c + 1;
                }
                switch (a) {
                  case -1:
                    m = v - 1;
                    break;
                  case 1:
                    v = m + 1;
                }
                const b = -r * this.dim,
                  C = -a * this.dim;
                for (let I = m; I < v; I++)
                  for (let R = c; R < p; R++)
                    this.data[this._idx(R, I)] =
                      t.data[this._idx(R + b, I + C)];
              }
            }
            function og(n, t) {
              const r = t[0],
                a = t[1],
                c = t[2],
                p = t[3],
                m = Math.min(r, a, c),
                v = Math.round((n + p) / m);
              return {
                r: Math.floor((v * m) / r) % 256,
                g: Math.floor((v * m) / a) % 256,
                b: Math.floor((v * m) / c) % 256,
              };
            }
            hr("DEMData", ag);
            class h1 extends Aa {
              constructor(t, r) {
                super(t, u1, r);
              }
              _createColorRamp(t) {
                const r = { elevationStops: [], colorStops: [] },
                  a =
                    this._transitionablePaint._values["color-relief-color"]
                      .value.expression;
                if (
                  a instanceof Xs &&
                  a._styleExpression.expression instanceof zn
                ) {
                  this.colorRampExpression = a;
                  const m = a._styleExpression.expression;
                  (r.elevationStops = m.labels), (r.colorStops = []);
                  for (const v of r.elevationStops)
                    r.colorStops.push(
                      m.evaluate({ globals: { elevation: v } })
                    );
                }
                if (
                  (r.elevationStops.length < 1 &&
                    ((r.elevationStops = [0]),
                    (r.colorStops = [Cr.transparent])),
                  r.elevationStops.length < 2 &&
                    (r.elevationStops.push(r.elevationStops[0] + 1),
                    r.colorStops.push(r.colorStops[0])),
                  r.elevationStops.length <= t)
                )
                  return r;
                const c = { elevationStops: [], colorStops: [] },
                  p = (r.elevationStops.length - 1) / (t - 1);
                for (let m = 0; m < r.elevationStops.length - 0.5; m += p)
                  c.elevationStops.push(r.elevationStops[Math.round(m)]),
                    c.colorStops.push(r.colorStops[Math.round(m)]);
                return (
                  Bt(
                    `Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${r.elevationStops.length}`
                  ),
                  c
                );
              }
              _colorRampChanged() {
                return (
                  this.colorRampExpression !=
                  this._transitionablePaint._values["color-relief-color"].value
                    .expression
                );
              }
              getColorRampTextures(t, r, a) {
                if (this.colorRampTextures && !this._colorRampChanged())
                  return this.colorRampTextures;
                const c = this._createColorRamp(r),
                  p = new la({ width: c.colorStops.length, height: 1 }),
                  m = new la({ width: c.colorStops.length, height: 1 });
                for (let v = 0; v < c.elevationStops.length; v++) {
                  const b = og(c.elevationStops[v], a);
                  m.setPixel(0, v, new Cr(b.r / 255, b.g / 255, b.b / 255, 1)),
                    p.setPixel(0, v, c.colorStops[v]);
                }
                return (
                  (this.colorRampTextures = {
                    elevationTexture: new Ef(t, m, t.gl.RGBA),
                    colorTexture: new Ef(t, p, t.gl.RGBA),
                  }),
                  this.colorRampTextures
                );
              }
              hasOffscreenPass() {
                return this.visibility !== "none" && !!this.colorRampTextures;
              }
            }
            const d1 = ci([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: p1 } = d1;
            function ep(n, t, r) {
              const a = r.patternDependencies;
              let c = !1;
              for (const p of t) {
                const m = p.paint.get(`${n}-pattern`);
                m.isConstant() || (c = !0);
                const v = m.constantOr(null);
                v && ((c = !0), (a[v.to] = !0), (a[v.from] = !0));
              }
              return c;
            }
            function zf(n, t, r, a, c) {
              const { zoom: p } = a,
                m = c.patternDependencies;
              for (const v of t) {
                const b = v.paint.get(`${n}-pattern`).value;
                if (b.kind !== "constant") {
                  let C = b.evaluate({ zoom: p - 1 }, r, {}, c.availableImages),
                    I = b.evaluate({ zoom: p }, r, {}, c.availableImages),
                    R = b.evaluate({ zoom: p + 1 }, r, {}, c.availableImages);
                  (C = C && C.name ? C.name : C),
                    (I = I && I.name ? I.name : I),
                    (R = R && R.name ? R.name : R),
                    (m[C] = !0),
                    (m[I] = !0),
                    (m[R] = !0),
                    (r.patterns[v.id] = { min: C, mid: I, max: R });
                }
              }
              return r;
            }
            function sg(n, t, r, a, c) {
              let p;
              if (
                c ===
                (function (m, v, b, C) {
                  let I = 0;
                  for (let R = v, U = b - C; R < b; R += C)
                    (I += (m[U] - m[R]) * (m[R + 1] + m[U + 1])), (U = R);
                  return I;
                })(n, t, r, a) >
                  0
              )
                for (let m = t; m < r; m += a)
                  p = hg((m / a) | 0, n[m], n[m + 1], p);
              else
                for (let m = r - a; m >= t; m -= a)
                  p = hg((m / a) | 0, n[m], n[m + 1], p);
              return p && lc(p, p.next) && (Ru(p), (p = p.next)), p;
            }
            function sl(n, t) {
              if (!n) return n;
              t || (t = n);
              let r,
                a = n;
              do
                if (
                  ((r = !1),
                  a.steiner || (!lc(a, a.next) && _i(a.prev, a, a.next) !== 0))
                )
                  a = a.next;
                else {
                  if ((Ru(a), (a = t = a.prev), a === a.next)) break;
                  r = !0;
                }
              while (r || a !== t);
              return t;
            }
            function zu(n, t, r, a, c, p, m) {
              if (!n) return;
              !m &&
                p &&
                (function (b, C, I, R) {
                  let U = b;
                  do
                    U.z === 0 && (U.z = Lf(U.x, U.y, C, I, R)),
                      (U.prevZ = U.prev),
                      (U.nextZ = U.next),
                      (U = U.next);
                  while (U !== b);
                  (U.prevZ.nextZ = null),
                    (U.prevZ = null),
                    (function (Z) {
                      let X,
                        Q = 1;
                      do {
                        let ie,
                          he = Z;
                        Z = null;
                        let Oe = null;
                        for (X = 0; he; ) {
                          X++;
                          let ye = he,
                            Ce = 0;
                          for (
                            let ht = 0;
                            ht < Q && (Ce++, (ye = ye.nextZ), ye);
                            ht++
                          );
                          let et = Q;
                          for (; Ce > 0 || (et > 0 && ye); )
                            Ce !== 0 && (et === 0 || !ye || he.z <= ye.z)
                              ? ((ie = he), (he = he.nextZ), Ce--)
                              : ((ie = ye), (ye = ye.nextZ), et--),
                              Oe ? (Oe.nextZ = ie) : (Z = ie),
                              (ie.prevZ = Oe),
                              (Oe = ie);
                          he = ye;
                        }
                        (Oe.nextZ = null), (Q *= 2);
                      } while (X > 1);
                    })(U);
                })(n, a, c, p);
              let v = n;
              for (; n.prev !== n.next; ) {
                const b = n.prev,
                  C = n.next;
                if (p ? m1(n, a, c, p) : f1(n))
                  t.push(b.i, n.i, C.i), Ru(n), (n = C.next), (v = C.next);
                else if ((n = C) === v) {
                  m
                    ? m === 1
                      ? zu((n = _1(sl(n), t)), t, r, a, c, p, 2)
                      : m === 2 && g1(n, t, r, a, c, p)
                    : zu(sl(n), t, r, a, c, p, 1);
                  break;
                }
              }
            }
            function f1(n) {
              const t = n.prev,
                r = n,
                a = n.next;
              if (_i(t, r, a) >= 0) return !1;
              const c = t.x,
                p = r.x,
                m = a.x,
                v = t.y,
                b = r.y,
                C = a.y,
                I = Math.min(c, p, m),
                R = Math.min(v, b, C),
                U = Math.max(c, p, m),
                Z = Math.max(v, b, C);
              let X = a.next;
              for (; X !== t; ) {
                if (
                  X.x >= I &&
                  X.x <= U &&
                  X.y >= R &&
                  X.y <= Z &&
                  Lu(c, v, p, b, m, C, X.x, X.y) &&
                  _i(X.prev, X, X.next) >= 0
                )
                  return !1;
                X = X.next;
              }
              return !0;
            }
            function m1(n, t, r, a) {
              const c = n.prev,
                p = n,
                m = n.next;
              if (_i(c, p, m) >= 0) return !1;
              const v = c.x,
                b = p.x,
                C = m.x,
                I = c.y,
                R = p.y,
                U = m.y,
                Z = Math.min(v, b, C),
                X = Math.min(I, R, U),
                Q = Math.max(v, b, C),
                ie = Math.max(I, R, U),
                he = Lf(Z, X, t, r, a),
                Oe = Lf(Q, ie, t, r, a);
              let ye = n.prevZ,
                Ce = n.nextZ;
              for (; ye && ye.z >= he && Ce && Ce.z <= Oe; ) {
                if (
                  (ye.x >= Z &&
                    ye.x <= Q &&
                    ye.y >= X &&
                    ye.y <= ie &&
                    ye !== c &&
                    ye !== m &&
                    Lu(v, I, b, R, C, U, ye.x, ye.y) &&
                    _i(ye.prev, ye, ye.next) >= 0) ||
                  ((ye = ye.prevZ),
                  Ce.x >= Z &&
                    Ce.x <= Q &&
                    Ce.y >= X &&
                    Ce.y <= ie &&
                    Ce !== c &&
                    Ce !== m &&
                    Lu(v, I, b, R, C, U, Ce.x, Ce.y) &&
                    _i(Ce.prev, Ce, Ce.next) >= 0)
                )
                  return !1;
                Ce = Ce.nextZ;
              }
              for (; ye && ye.z >= he; ) {
                if (
                  ye.x >= Z &&
                  ye.x <= Q &&
                  ye.y >= X &&
                  ye.y <= ie &&
                  ye !== c &&
                  ye !== m &&
                  Lu(v, I, b, R, C, U, ye.x, ye.y) &&
                  _i(ye.prev, ye, ye.next) >= 0
                )
                  return !1;
                ye = ye.prevZ;
              }
              for (; Ce && Ce.z <= Oe; ) {
                if (
                  Ce.x >= Z &&
                  Ce.x <= Q &&
                  Ce.y >= X &&
                  Ce.y <= ie &&
                  Ce !== c &&
                  Ce !== m &&
                  Lu(v, I, b, R, C, U, Ce.x, Ce.y) &&
                  _i(Ce.prev, Ce, Ce.next) >= 0
                )
                  return !1;
                Ce = Ce.nextZ;
              }
              return !0;
            }
            function _1(n, t) {
              let r = n;
              do {
                const a = r.prev,
                  c = r.next.next;
                !lc(a, c) &&
                  cg(a, r, r.next, c) &&
                  Du(a, c) &&
                  Du(c, a) &&
                  (t.push(a.i, r.i, c.i), Ru(r), Ru(r.next), (r = n = c)),
                  (r = r.next);
              } while (r !== n);
              return sl(r);
            }
            function g1(n, t, r, a, c, p) {
              let m = n;
              do {
                let v = m.next.next;
                for (; v !== m.prev; ) {
                  if (m.i !== v.i && w1(m, v)) {
                    let b = ug(m, v);
                    return (
                      (m = sl(m, m.next)),
                      (b = sl(b, b.next)),
                      zu(m, t, r, a, c, p, 0),
                      void zu(b, t, r, a, c, p, 0)
                    );
                  }
                  v = v.next;
                }
                m = m.next;
              } while (m !== n);
            }
            function v1(n, t) {
              let r = n.x - t.x;
              return (
                r === 0 &&
                  ((r = n.y - t.y), r === 0) &&
                  (r =
                    (n.next.y - n.y) / (n.next.x - n.x) -
                    (t.next.y - t.y) / (t.next.x - t.x)),
                r
              );
            }
            function y1(n, t) {
              const r = (function (c, p) {
                let m = p;
                const v = c.x,
                  b = c.y;
                let C,
                  I = -1 / 0;
                if (lc(c, m)) return m;
                do {
                  if (lc(c, m.next)) return m.next;
                  if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                    const Q =
                      m.x + ((b - m.y) * (m.next.x - m.x)) / (m.next.y - m.y);
                    if (
                      Q <= v &&
                      Q > I &&
                      ((I = Q), (C = m.x < m.next.x ? m : m.next), Q === v)
                    )
                      return C;
                  }
                  m = m.next;
                } while (m !== p);
                if (!C) return null;
                const R = C,
                  U = C.x,
                  Z = C.y;
                let X = 1 / 0;
                m = C;
                do {
                  if (
                    v >= m.x &&
                    m.x >= U &&
                    v !== m.x &&
                    lg(b < Z ? v : I, b, U, Z, b < Z ? I : v, b, m.x, m.y)
                  ) {
                    const Q = Math.abs(b - m.y) / (v - m.x);
                    Du(m, c) &&
                      (Q < X ||
                        (Q === X &&
                          (m.x > C.x || (m.x === C.x && x1(C, m))))) &&
                      ((C = m), (X = Q));
                  }
                  m = m.next;
                } while (m !== R);
                return C;
              })(n, t);
              if (!r) return t;
              const a = ug(r, n);
              return sl(a, a.next), sl(r, r.next);
            }
            function x1(n, t) {
              return _i(n.prev, n, t.prev) < 0 && _i(t.next, n, n.next) < 0;
            }
            function Lf(n, t, r, a, c) {
              return (
                (n =
                  1431655765 &
                  ((n =
                    858993459 &
                    ((n =
                      252645135 &
                      ((n = 16711935 & ((n = ((n - r) * c) | 0) | (n << 8))) |
                        (n << 4))) |
                      (n << 2))) |
                    (n << 1))) |
                ((t =
                  1431655765 &
                  ((t =
                    858993459 &
                    ((t =
                      252645135 &
                      ((t = 16711935 & ((t = ((t - a) * c) | 0) | (t << 8))) |
                        (t << 4))) |
                      (t << 2))) |
                    (t << 1))) <<
                  1)
              );
            }
            function b1(n) {
              let t = n,
                r = n;
              do
                (t.x < r.x || (t.x === r.x && t.y < r.y)) && (r = t),
                  (t = t.next);
              while (t !== n);
              return r;
            }
            function lg(n, t, r, a, c, p, m, v) {
              return (
                (c - m) * (t - v) >= (n - m) * (p - v) &&
                (n - m) * (a - v) >= (r - m) * (t - v) &&
                (r - m) * (p - v) >= (c - m) * (a - v)
              );
            }
            function Lu(n, t, r, a, c, p, m, v) {
              return !(n === m && t === v) && lg(n, t, r, a, c, p, m, v);
            }
            function w1(n, t) {
              return (
                n.next.i !== t.i &&
                n.prev.i !== t.i &&
                !(function (r, a) {
                  let c = r;
                  do {
                    if (
                      c.i !== r.i &&
                      c.next.i !== r.i &&
                      c.i !== a.i &&
                      c.next.i !== a.i &&
                      cg(c, c.next, r, a)
                    )
                      return !0;
                    c = c.next;
                  } while (c !== r);
                  return !1;
                })(n, t) &&
                ((Du(n, t) &&
                  Du(t, n) &&
                  (function (r, a) {
                    let c = r,
                      p = !1;
                    const m = (r.x + a.x) / 2,
                      v = (r.y + a.y) / 2;
                    do
                      c.y > v != c.next.y > v &&
                        c.next.y !== c.y &&
                        m <
                          ((c.next.x - c.x) * (v - c.y)) / (c.next.y - c.y) +
                            c.x &&
                        (p = !p),
                        (c = c.next);
                    while (c !== r);
                    return p;
                  })(n, t) &&
                  (_i(n.prev, n, t.prev) || _i(n, t.prev, t))) ||
                  (lc(n, t) &&
                    _i(n.prev, n, n.next) > 0 &&
                    _i(t.prev, t, t.next) > 0))
              );
            }
            function _i(n, t, r) {
              return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y);
            }
            function lc(n, t) {
              return n.x === t.x && n.y === t.y;
            }
            function cg(n, t, r, a) {
              const c = rp(_i(n, t, r)),
                p = rp(_i(n, t, a)),
                m = rp(_i(r, a, n)),
                v = rp(_i(r, a, t));
              return (
                (c !== p && m !== v) ||
                !(c !== 0 || !tp(n, r, t)) ||
                !(p !== 0 || !tp(n, a, t)) ||
                !(m !== 0 || !tp(r, n, a)) ||
                !(v !== 0 || !tp(r, t, a))
              );
            }
            function tp(n, t, r) {
              return (
                t.x <= Math.max(n.x, r.x) &&
                t.x >= Math.min(n.x, r.x) &&
                t.y <= Math.max(n.y, r.y) &&
                t.y >= Math.min(n.y, r.y)
              );
            }
            function rp(n) {
              return n > 0 ? 1 : n < 0 ? -1 : 0;
            }
            function Du(n, t) {
              return _i(n.prev, n, n.next) < 0
                ? _i(n, t, n.next) >= 0 && _i(n, n.prev, t) >= 0
                : _i(n, t, n.prev) < 0 || _i(n, n.next, t) < 0;
            }
            function ug(n, t) {
              const r = Df(n.i, n.x, n.y),
                a = Df(t.i, t.x, t.y),
                c = n.next,
                p = t.prev;
              return (
                (n.next = t),
                (t.prev = n),
                (r.next = c),
                (c.prev = r),
                (a.next = r),
                (r.prev = a),
                (p.next = a),
                (a.prev = p),
                a
              );
            }
            function hg(n, t, r, a) {
              const c = Df(n, t, r);
              return (
                a
                  ? ((c.next = a.next),
                    (c.prev = a),
                    (a.next.prev = c),
                    (a.next = c))
                  : ((c.prev = c), (c.next = c)),
                c
              );
            }
            function Ru(n) {
              (n.next.prev = n.prev),
                (n.prev.next = n.next),
                n.prevZ && (n.prevZ.nextZ = n.nextZ),
                n.nextZ && (n.nextZ.prevZ = n.prevZ);
            }
            function Df(n, t, r) {
              return {
                i: n,
                x: t,
                y: r,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1,
              };
            }
            class cc {
              constructor(t, r) {
                if (r > t)
                  throw new Error(
                    "Min granularity must not be greater than base granularity."
                  );
                (this._baseZoomGranularity = t), (this._minGranularity = r);
              }
              getGranularityForZoomLevel(t) {
                return Math.max(
                  Math.floor(this._baseZoomGranularity / (1 << t)),
                  this._minGranularity,
                  1
                );
              }
            }
            class np {
              constructor(t) {
                (this.fill = t.fill),
                  (this.line = t.line),
                  (this.tile = t.tile),
                  (this.stencil = t.stencil),
                  (this.circle = t.circle);
              }
            }
            (np.noSubdivision = new np({
              fill: new cc(0, 0),
              line: new cc(0, 0),
              tile: new cc(0, 0),
              stencil: new cc(0, 0),
              circle: 1,
            })),
              hr("SubdivisionGranularityExpression", cc),
              hr("SubdivisionGranularitySetting", np);
            const uc = -32768,
              Fu = 32767;
            class T1 {
              constructor(t, r) {
                (this._vertexBuffer = []),
                  (this._vertexDictionary = new Map()),
                  (this._used = !1),
                  (this._granularity = t),
                  (this._granularityCellSize = Fe / t),
                  (this._canonical = r);
              }
              _getKey(t, r) {
                return ((t += 32768) << 16) | (r + 32768);
              }
              _vertexToIndex(t, r) {
                if (t < -32768 || r < -32768 || t > 32767 || r > 32767)
                  throw new Error(
                    "Vertex coordinates are out of signed 16 bit integer range."
                  );
                const a = 0 | Math.round(t),
                  c = 0 | Math.round(r),
                  p = this._getKey(a, c);
                if (this._vertexDictionary.has(p))
                  return this._vertexDictionary.get(p);
                const m = this._vertexBuffer.length / 2;
                return (
                  this._vertexDictionary.set(p, m),
                  this._vertexBuffer.push(a, c),
                  m
                );
              }
              _subdivideTrianglesScanline(t) {
                if (this._granularity < 2)
                  return (function (c, p) {
                    const m = [];
                    for (let v = 0; v < p.length; v += 3) {
                      const b = p[v],
                        C = p[v + 1],
                        I = p[v + 2],
                        R = c[2 * b],
                        U = c[2 * b + 1];
                      (c[2 * C] - R) * (c[2 * I + 1] - U) -
                        (c[2 * C + 1] - U) * (c[2 * I] - R) >
                      0
                        ? (m.push(b), m.push(I), m.push(C))
                        : (m.push(b), m.push(C), m.push(I));
                    }
                    return m;
                  })(this._vertexBuffer, t);
                const r = [],
                  a = t.length;
                for (let c = 0; c < a; c += 3) {
                  const p = [t[c + 0], t[c + 1], t[c + 2]],
                    m = [
                      this._vertexBuffer[2 * t[c + 0] + 0],
                      this._vertexBuffer[2 * t[c + 0] + 1],
                      this._vertexBuffer[2 * t[c + 1] + 0],
                      this._vertexBuffer[2 * t[c + 1] + 1],
                      this._vertexBuffer[2 * t[c + 2] + 0],
                      this._vertexBuffer[2 * t[c + 2] + 1],
                    ];
                  let v = 1 / 0,
                    b = 1 / 0,
                    C = -1 / 0,
                    I = -1 / 0;
                  for (let Q = 0; Q < 3; Q++) {
                    const ie = m[2 * Q],
                      he = m[2 * Q + 1];
                    (v = Math.min(v, ie)),
                      (C = Math.max(C, ie)),
                      (b = Math.min(b, he)),
                      (I = Math.max(I, he));
                  }
                  if (v === C || b === I) continue;
                  const R = Math.floor(v / this._granularityCellSize),
                    U = Math.ceil(C / this._granularityCellSize),
                    Z = Math.floor(b / this._granularityCellSize),
                    X = Math.ceil(I / this._granularityCellSize);
                  if (R !== U || Z !== X)
                    for (let Q = Z; Q < X; Q++) {
                      const ie = this._scanlineGenerateVertexRingForCellRow(
                        Q,
                        m,
                        p
                      );
                      S1(this._vertexBuffer, ie, r);
                    }
                  else r.push(...p);
                }
                return r;
              }
              _scanlineGenerateVertexRingForCellRow(t, r, a) {
                const c = t * this._granularityCellSize,
                  p = c + this._granularityCellSize,
                  m = [];
                for (let v = 0; v < 3; v++) {
                  const b = r[2 * v],
                    C = r[2 * v + 1],
                    I = r[(2 * (v + 1)) % 6],
                    R = r[(2 * (v + 1) + 1) % 6],
                    U = r[(2 * (v + 2)) % 6],
                    Z = r[(2 * (v + 2) + 1) % 6],
                    X = I - b,
                    Q = R - C,
                    ie = X === 0,
                    he = Q === 0,
                    Oe = (c - C) / Q,
                    ye = (p - C) / Q,
                    Ce = Math.min(Oe, ye),
                    et = Math.max(Oe, ye);
                  if (
                    (!he && (Ce >= 1 || et <= 0)) ||
                    (he && (C < c || C > p))
                  ) {
                    R >= c && R <= p && m.push(a[(v + 1) % 3]);
                    continue;
                  }
                  !he &&
                    Ce > 0 &&
                    m.push(this._vertexToIndex(b + X * Ce, C + Q * Ce));
                  const ht = b + X * Math.max(Ce, 0),
                    Rt = b + X * Math.min(et, 1);
                  ie || this._generateIntraEdgeVertices(m, b, C, I, R, ht, Rt),
                    !he &&
                      et < 1 &&
                      m.push(this._vertexToIndex(b + X * et, C + Q * et)),
                    (he || (R >= c && R <= p)) && m.push(a[(v + 1) % 3]),
                    !he &&
                      (R <= c || R >= p) &&
                      this._generateInterEdgeVertices(
                        m,
                        b,
                        C,
                        I,
                        R,
                        U,
                        Z,
                        Rt,
                        c,
                        p
                      );
                }
                return m;
              }
              _generateIntraEdgeVertices(t, r, a, c, p, m, v) {
                const b = c - r,
                  C = p - a,
                  I = C === 0,
                  R = I ? Math.min(r, c) : Math.min(m, v),
                  U = I ? Math.max(r, c) : Math.max(m, v),
                  Z = Math.floor(R / this._granularityCellSize) + 1,
                  X = Math.ceil(U / this._granularityCellSize) - 1;
                if (I ? r < c : m < v)
                  for (let Q = Z; Q <= X; Q++) {
                    const ie = Q * this._granularityCellSize;
                    t.push(this._vertexToIndex(ie, a + (C * (ie - r)) / b));
                  }
                else
                  for (let Q = X; Q >= Z; Q--) {
                    const ie = Q * this._granularityCellSize;
                    t.push(this._vertexToIndex(ie, a + (C * (ie - r)) / b));
                  }
              }
              _generateInterEdgeVertices(t, r, a, c, p, m, v, b, C, I) {
                const R = p - a,
                  U = m - c,
                  Z = v - p,
                  X = (C - p) / Z,
                  Q = (I - p) / Z,
                  ie = Math.min(X, Q),
                  he = Math.max(X, Q),
                  Oe = c + U * ie;
                let ye =
                    Math.floor(Math.min(Oe, b) / this._granularityCellSize) + 1,
                  Ce =
                    Math.ceil(Math.max(Oe, b) / this._granularityCellSize) - 1,
                  et = b < Oe;
                const ht = Z === 0;
                if (ht && (v === C || v === I)) return;
                if (ht || ie >= 1 || he <= 0) {
                  const or = a - v,
                    Yt = m + (r - m) * Math.min((C - v) / or, (I - v) / or);
                  (ye =
                    Math.floor(Math.min(Yt, b) / this._granularityCellSize) +
                    1),
                    (Ce =
                      Math.ceil(Math.max(Yt, b) / this._granularityCellSize) -
                      1),
                    (et = b < Yt);
                }
                const Rt = R > 0 ? I : C;
                if (et)
                  for (let or = ye; or <= Ce; or++)
                    t.push(
                      this._vertexToIndex(or * this._granularityCellSize, Rt)
                    );
                else
                  for (let or = Ce; or >= ye; or--)
                    t.push(
                      this._vertexToIndex(or * this._granularityCellSize, Rt)
                    );
              }
              _generateOutline(t) {
                const r = [];
                for (const a of t) {
                  const c = ll(a, this._granularity, !0),
                    p = this._pointArrayToIndices(c),
                    m = [];
                  for (let v = 1; v < p.length; v++)
                    m.push(p[v - 1]), m.push(p[v]);
                  r.push(m);
                }
                return r;
              }
              _handlePoles(t) {
                let r = !1,
                  a = !1;
                this._canonical &&
                  (this._canonical.y === 0 && (r = !0),
                  this._canonical.y === (1 << this._canonical.z) - 1 &&
                    (a = !0)),
                  (r || a) && this._fillPoles(t, r, a);
              }
              _ensureNoPoleVertices() {
                const t = this._vertexBuffer;
                for (let r = 0; r < t.length; r += 2) {
                  const a = t[r + 1];
                  a === uc && (t[r + 1] = -32767),
                    a === Fu && (t[r + 1] = 32766);
                }
              }
              _generatePoleQuad(t, r, a, c, p, m) {
                c > p != (m === uc)
                  ? (t.push(r),
                    t.push(a),
                    t.push(this._vertexToIndex(c, m)),
                    t.push(a),
                    t.push(this._vertexToIndex(p, m)),
                    t.push(this._vertexToIndex(c, m)))
                  : (t.push(a),
                    t.push(r),
                    t.push(this._vertexToIndex(c, m)),
                    t.push(this._vertexToIndex(p, m)),
                    t.push(a),
                    t.push(this._vertexToIndex(c, m)));
              }
              _fillPoles(t, r, a) {
                const c = this._vertexBuffer,
                  p = Fe,
                  m = t.length;
                for (let v = 2; v < m; v += 3) {
                  const b = t[v - 2],
                    C = t[v - 1],
                    I = t[v],
                    R = c[2 * b],
                    U = c[2 * b + 1],
                    Z = c[2 * C],
                    X = c[2 * C + 1],
                    Q = c[2 * I],
                    ie = c[2 * I + 1];
                  r &&
                    (U === 0 &&
                      X === 0 &&
                      this._generatePoleQuad(t, b, C, R, Z, uc),
                    X === 0 &&
                      ie === 0 &&
                      this._generatePoleQuad(t, C, I, Z, Q, uc),
                    ie === 0 &&
                      U === 0 &&
                      this._generatePoleQuad(t, I, b, Q, R, uc)),
                    a &&
                      (U === p &&
                        X === p &&
                        this._generatePoleQuad(t, b, C, R, Z, Fu),
                      X === p &&
                        ie === p &&
                        this._generatePoleQuad(t, C, I, Z, Q, Fu),
                      ie === p &&
                        U === p &&
                        this._generatePoleQuad(t, I, b, Q, R, Fu));
                }
              }
              _initializeVertices(t) {
                for (let r = 0; r < t.length; r += 2)
                  this._vertexToIndex(t[r], t[r + 1]);
              }
              subdividePolygonInternal(t, r) {
                if (this._used)
                  throw new Error("Subdivision: multiple use not allowed.");
                this._used = !0;
                const { flattened: a, holeIndices: c } = (function (v) {
                  const b = [],
                    C = [];
                  for (const I of v)
                    if (I.length !== 0) {
                      I !== v[0] && b.push(C.length / 2);
                      for (let R = 0; R < I.length; R++)
                        C.push(I[R].x), C.push(I[R].y);
                    }
                  return { flattened: C, holeIndices: b };
                })(t);
                let p;
                this._initializeVertices(a);
                try {
                  const v = (function (C, I, R = 2) {
                      const U = I && I.length,
                        Z = U ? I[0] * R : C.length;
                      let X = sg(C, 0, Z, R, !0);
                      const Q = [];
                      if (!X || X.next === X.prev) return Q;
                      let ie, he, Oe;
                      if (
                        (U &&
                          (X = (function (ye, Ce, et, ht) {
                            const Rt = [];
                            for (let or = 0, Yt = Ce.length; or < Yt; or++) {
                              const rr = sg(
                                ye,
                                Ce[or] * ht,
                                or < Yt - 1 ? Ce[or + 1] * ht : ye.length,
                                ht,
                                !1
                              );
                              rr === rr.next && (rr.steiner = !0),
                                Rt.push(b1(rr));
                            }
                            Rt.sort(v1);
                            for (let or = 0; or < Rt.length; or++)
                              et = y1(Rt[or], et);
                            return et;
                          })(C, I, X, R)),
                        C.length > 80 * R)
                      ) {
                        (ie = C[0]), (he = C[1]);
                        let ye = ie,
                          Ce = he;
                        for (let et = R; et < Z; et += R) {
                          const ht = C[et],
                            Rt = C[et + 1];
                          ht < ie && (ie = ht),
                            Rt < he && (he = Rt),
                            ht > ye && (ye = ht),
                            Rt > Ce && (Ce = Rt);
                        }
                        (Oe = Math.max(ye - ie, Ce - he)),
                          (Oe = Oe !== 0 ? 32767 / Oe : 0);
                      }
                      return zu(X, Q, R, ie, he, Oe, 0), Q;
                    })(a, c),
                    b = this._convertIndices(a, v);
                  p = this._subdivideTrianglesScanline(b);
                } catch (v) {
                  console.error(v);
                }
                let m = [];
                return (
                  r && (m = this._generateOutline(t)),
                  this._ensureNoPoleVertices(),
                  this._handlePoles(p),
                  {
                    verticesFlattened: this._vertexBuffer,
                    indicesTriangles: p,
                    indicesLineList: m,
                  }
                );
              }
              _convertIndices(t, r) {
                const a = [];
                for (let c = 0; c < r.length; c++)
                  a.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
                return a;
              }
              _pointArrayToIndices(t) {
                const r = [];
                for (let a = 0; a < t.length; a++) {
                  const c = t[a];
                  r.push(this._vertexToIndex(c.x, c.y));
                }
                return r;
              }
            }
            function dg(n, t, r, a = !0) {
              return new T1(r, t).subdividePolygonInternal(n, a);
            }
            function ll(n, t, r = !1) {
              if (!n || n.length < 1) return [];
              if (n.length < 2) return [];
              const a = n[0],
                c = n[n.length - 1],
                p = r && (a.x !== c.x || a.y !== c.y);
              if (t < 2) return p ? [...n, n[0]] : [...n];
              const m = Math.floor(Fe / t),
                v = [];
              v.push(new B(n[0].x, n[0].y));
              const b = n.length,
                C = p ? b : b - 1;
              for (let I = 0; I < C; I++) {
                const R = n[I],
                  U = I < b - 1 ? n[I + 1] : n[0],
                  Z = R.x,
                  X = R.y,
                  Q = U.x,
                  ie = U.y,
                  he = Z !== Q,
                  Oe = X !== ie;
                if (!he && !Oe) continue;
                const ye = Q - Z,
                  Ce = ie - X,
                  et = Math.abs(ye),
                  ht = Math.abs(Ce);
                let Rt = Z,
                  or = X;
                for (;;) {
                  const rr =
                      ye > 0
                        ? (Math.floor(Rt / m) + 1) * m
                        : (Math.ceil(Rt / m) - 1) * m,
                    Fr =
                      Ce > 0
                        ? (Math.floor(or / m) + 1) * m
                        : (Math.ceil(or / m) - 1) * m,
                    er = Math.abs(Rt - rr),
                    nr = Math.abs(or - Fr),
                    St = Math.abs(Rt - Q),
                    Hr = Math.abs(or - ie),
                    Kr = he ? er / et : Number.POSITIVE_INFINITY,
                    Vr = Oe ? nr / ht : Number.POSITIVE_INFINITY;
                  if ((St <= er || !he) && (Hr <= nr || !Oe)) break;
                  if ((Kr < Vr && he) || !Oe) {
                    (Rt = rr), (or += Ce * Kr);
                    const kr = new B(Rt, Math.round(or));
                    (v[v.length - 1].x === kr.x &&
                      v[v.length - 1].y === kr.y) ||
                      v.push(kr);
                  } else {
                    (Rt += ye * Vr), (or = Fr);
                    const kr = new B(Math.round(Rt), or);
                    (v[v.length - 1].x === kr.x &&
                      v[v.length - 1].y === kr.y) ||
                      v.push(kr);
                  }
                }
                const Yt = new B(Q, ie);
                (v[v.length - 1].x === Yt.x && v[v.length - 1].y === Yt.y) ||
                  v.push(Yt);
              }
              return v;
            }
            function S1(n, t, r) {
              if (t.length === 0)
                throw new Error("Subdivision vertex ring is empty.");
              let a = 0,
                c = n[2 * t[0]];
              for (let b = 1; b < t.length; b++) {
                const C = n[2 * t[b]];
                C < c && ((c = C), (a = b));
              }
              const p = t.length;
              let m = a,
                v = (m + 1) % p;
              for (;;) {
                const b = m - 1 >= 0 ? m - 1 : p - 1,
                  C = (v + 1) % p,
                  I = n[2 * t[b]],
                  R = n[2 * t[C]],
                  U = n[2 * t[m]],
                  Z = n[2 * t[m] + 1],
                  X = n[2 * t[v] + 1];
                let Q = !1;
                if (I < R) Q = !0;
                else if (I > R) Q = !1;
                else {
                  const ie = X - Z,
                    he = -(n[2 * t[v]] - U),
                    Oe = Z < X ? 1 : -1;
                  ((I - U) * ie + (n[2 * t[b] + 1] - Z) * he) * Oe >
                    ((R - U) * ie + (n[2 * t[C] + 1] - Z) * he) * Oe &&
                    (Q = !0);
                }
                if (Q) {
                  const ie = t[b],
                    he = t[m],
                    Oe = t[v];
                  ie !== he && ie !== Oe && he !== Oe && r.push(Oe, he, ie),
                    m--,
                    m < 0 && (m = p - 1);
                } else {
                  const ie = t[C],
                    he = t[m],
                    Oe = t[v];
                  ie !== he && ie !== Oe && he !== Oe && r.push(Oe, he, ie),
                    v++,
                    v >= p && (v = 0);
                }
                if (b === C) break;
              }
            }
            function pg(n, t, r, a, c, p, m, v, b) {
              const C = c.length / 2,
                I = m && v && b;
              if (C < cn.MAX_VERTEX_ARRAY_LENGTH) {
                const R = t.prepareSegment(C, r, a),
                  U = R.vertexLength;
                for (let Q = 0; Q < p.length; Q += 3)
                  a.emplaceBack(U + p[Q], U + p[Q + 1], U + p[Q + 2]);
                let Z, X;
                (R.vertexLength += C),
                  (R.primitiveLength += p.length / 3),
                  I &&
                    ((X = m.prepareSegment(C, r, v)),
                    (Z = X.vertexLength),
                    (X.vertexLength += C));
                for (let Q = 0; Q < c.length; Q += 2) n(c[Q], c[Q + 1]);
                if (I)
                  for (let Q = 0; Q < b.length; Q++) {
                    const ie = b[Q];
                    for (let he = 1; he < ie.length; he += 2)
                      v.emplaceBack(Z + ie[he - 1], Z + ie[he]);
                    X.primitiveLength += ie.length / 2;
                  }
              } else
                (function (R, U, Z, X, Q, ie) {
                  const he = [];
                  for (let ht = 0; ht < X.length / 2; ht++) he.push(-1);
                  const Oe = { count: 0 };
                  let ye = 0,
                    Ce = R.getOrCreateLatestSegment(U, Z),
                    et = Ce.vertexLength;
                  for (let ht = 2; ht < Q.length; ht += 3) {
                    const Rt = Q[ht - 2],
                      or = Q[ht - 1],
                      Yt = Q[ht];
                    let rr = he[Rt] < ye,
                      Fr = he[or] < ye,
                      er = he[Yt] < ye;
                    Ce.vertexLength +
                      ((rr ? 1 : 0) + (Fr ? 1 : 0) + (er ? 1 : 0)) >
                      cn.MAX_VERTEX_ARRAY_LENGTH &&
                      ((Ce = R.createNewSegment(U, Z)),
                      (ye = Oe.count),
                      (rr = !0),
                      (Fr = !0),
                      (er = !0),
                      (et = 0));
                    const nr = Bu(he, X, ie, Oe, Rt, rr, Ce),
                      St = Bu(he, X, ie, Oe, or, Fr, Ce),
                      Hr = Bu(he, X, ie, Oe, Yt, er, Ce);
                    Z.emplaceBack(et + nr - ye, et + St - ye, et + Hr - ye),
                      Ce.primitiveLength++;
                  }
                })(t, r, a, c, p, n),
                  I &&
                    (function (R, U, Z, X, Q, ie) {
                      const he = [];
                      for (let ht = 0; ht < X.length / 2; ht++) he.push(-1);
                      const Oe = { count: 0 };
                      let ye = 0,
                        Ce = R.getOrCreateLatestSegment(U, Z),
                        et = Ce.vertexLength;
                      for (let ht = 0; ht < Q.length; ht++) {
                        const Rt = Q[ht];
                        for (let or = 1; or < Q[ht].length; or += 2) {
                          const Yt = Rt[or - 1],
                            rr = Rt[or];
                          let Fr = he[Yt] < ye,
                            er = he[rr] < ye;
                          Ce.vertexLength + ((Fr ? 1 : 0) + (er ? 1 : 0)) >
                            cn.MAX_VERTEX_ARRAY_LENGTH &&
                            ((Ce = R.createNewSegment(U, Z)),
                            (ye = Oe.count),
                            (Fr = !0),
                            (er = !0),
                            (et = 0));
                          const nr = Bu(he, X, ie, Oe, Yt, Fr, Ce),
                            St = Bu(he, X, ie, Oe, rr, er, Ce);
                          Z.emplaceBack(et + nr - ye, et + St - ye),
                            Ce.primitiveLength++;
                        }
                      }
                    })(m, r, v, c, b, n),
                  t.forceNewSegmentOnNextPrepare(),
                  m == null || m.forceNewSegmentOnNextPrepare();
            }
            function Bu(n, t, r, a, c, p, m) {
              if (p) {
                const v = a.count;
                return (
                  r(t[2 * c], t[2 * c + 1]),
                  (n[c] = a.count),
                  a.count++,
                  m.vertexLength++,
                  v
                );
              }
              return n[c];
            }
            class Rf {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((r) => r.id)),
                  (this.index = t.index),
                  (this.hasDependencies = !1),
                  (this.patternFeatures = []),
                  (this.layoutVertexArray = new pe()),
                  (this.indexArray = new Pt()),
                  (this.indexArray2 = new yr()),
                  (this.programConfigurations = new es(t.layers, t.zoom)),
                  (this.segments = new cn()),
                  (this.segments2 = new cn()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((r) => r.isStateDependent())
                    .map((r) => r.id));
              }
              populate(t, r, a) {
                this.hasDependencies = ep("fill", this.layers, r);
                const c = this.layers[0].layout.get("fill-sort-key"),
                  p = !c.isConstant(),
                  m = [];
                for (const {
                  feature: v,
                  id: b,
                  index: C,
                  sourceLayerIndex: I,
                } of t) {
                  const R = this.layers[0]._featureFilter.needGeometry,
                    U = Co(v, R);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new On(this.zoom),
                      U,
                      a
                    )
                  )
                    continue;
                  const Z = p
                      ? c.evaluate(U, {}, a, r.availableImages)
                      : void 0,
                    X = {
                      id: b,
                      properties: v.properties,
                      type: v.type,
                      sourceLayerIndex: I,
                      index: C,
                      geometry: R ? U.geometry : so(v),
                      patterns: {},
                      sortKey: Z,
                    };
                  m.push(X);
                }
                p && m.sort((v, b) => v.sortKey - b.sortKey);
                for (const v of m) {
                  const { geometry: b, index: C, sourceLayerIndex: I } = v;
                  if (this.hasDependencies) {
                    const R = zf(
                      "fill",
                      this.layers,
                      v,
                      { zoom: this.zoom },
                      r
                    );
                    this.patternFeatures.push(R);
                  } else
                    this.addFeature(v, b, C, a, {}, r.subdivisionGranularity);
                  r.featureIndex.insert(t[C].feature, b, C, I, this.index);
                }
              }
              update(t, r, a) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.stateDependentLayers,
                    { imagePositions: a }
                  );
              }
              addFeatures(t, r, a) {
                for (const c of this.patternFeatures)
                  this.addFeature(
                    c,
                    c.geometry,
                    c.index,
                    r,
                    a,
                    t.subdivisionGranularity
                  );
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    p1
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                  (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.indexBuffer2.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.segments2.destroy());
              }
              addFeature(t, r, a, c, p, m) {
                for (const v of kl(r, 500)) {
                  const b = dg(v, c, m.fill.getGranularityForZoomLevel(c.z)),
                    C = this.layoutVertexArray;
                  pg(
                    (I, R) => {
                      C.emplaceBack(I, R);
                    },
                    this.segments,
                    this.layoutVertexArray,
                    this.indexArray,
                    b.verticesFlattened,
                    b.indicesTriangles,
                    this.segments2,
                    this.indexArray2,
                    b.indicesLineList
                  );
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  a,
                  { imagePositions: p, canonical: c }
                );
              }
            }
            let fg, mg;
            hr("FillBucket", Rf, { omit: ["layers", "patternFeatures"] });
            var C1 = {
              get paint() {
                return (mg =
                  mg ||
                  new Ui({
                    "fill-antialias": new zr(_e.paint_fill["fill-antialias"]),
                    "fill-opacity": new Gr(_e.paint_fill["fill-opacity"]),
                    "fill-color": new Gr(_e.paint_fill["fill-color"]),
                    "fill-outline-color": new Gr(
                      _e.paint_fill["fill-outline-color"]
                    ),
                    "fill-translate": new zr(_e.paint_fill["fill-translate"]),
                    "fill-translate-anchor": new zr(
                      _e.paint_fill["fill-translate-anchor"]
                    ),
                    "fill-pattern": new nl(_e.paint_fill["fill-pattern"]),
                  }));
              },
              get layout() {
                return (fg =
                  fg ||
                  new Ui({
                    "fill-sort-key": new Gr(_e.layout_fill["fill-sort-key"]),
                  }));
              },
            };
            class P1 extends Aa {
              constructor(t, r) {
                super(t, C1, r);
              }
              recalculate(t, r) {
                super.recalculate(t, r);
                const a = this.paint._values["fill-outline-color"];
                a.value.kind === "constant" &&
                  a.value.value === void 0 &&
                  (this.paint._values["fill-outline-color"] =
                    this.paint._values["fill-color"]);
              }
              createBucket(t) {
                return new Rf(t);
              }
              queryRadius() {
                return Jd(this.paint.get("fill-translate"));
              }
              queryIntersectsFeature({
                queryGeometry: t,
                geometry: r,
                transform: a,
                pixelsToTileUnits: c,
              }) {
                return H_(
                  Qd(
                    t,
                    this.paint.get("fill-translate"),
                    this.paint.get("fill-translate-anchor"),
                    -a.bearingInRadians,
                    c
                  ),
                  r
                );
              }
              isTileClipped() {
                return !0;
              }
            }
            const I1 = ci(
                [
                  { name: "a_pos", components: 2, type: "Int16" },
                  { name: "a_normal_ed", components: 4, type: "Int16" },
                ],
                4
              ),
              M1 = ci(
                [{ name: "a_centroid", components: 2, type: "Int16" }],
                4
              ),
              { members: A1 } = I1;
            class hc {
              constructor(t, r, a, c, p) {
                (this.properties = {}),
                  (this.extent = a),
                  (this.type = 0),
                  (this.id = void 0),
                  (this._pbf = t),
                  (this._geometry = -1),
                  (this._keys = c),
                  (this._values = p),
                  t.readFields(k1, this, r);
              }
              loadGeometry() {
                const t = this._pbf;
                t.pos = this._geometry;
                const r = t.readVarint() + t.pos,
                  a = [];
                let c,
                  p = 1,
                  m = 0,
                  v = 0,
                  b = 0;
                for (; t.pos < r; ) {
                  if (m <= 0) {
                    const C = t.readVarint();
                    (p = 7 & C), (m = C >> 3);
                  }
                  if ((m--, p === 1 || p === 2))
                    (v += t.readSVarint()),
                      (b += t.readSVarint()),
                      p === 1 && (c && a.push(c), (c = [])),
                      c && c.push(new B(v, b));
                  else {
                    if (p !== 7) throw new Error(`unknown command ${p}`);
                    c && c.push(c[0].clone());
                  }
                }
                return c && a.push(c), a;
              }
              bbox() {
                const t = this._pbf;
                t.pos = this._geometry;
                const r = t.readVarint() + t.pos;
                let a = 1,
                  c = 0,
                  p = 0,
                  m = 0,
                  v = 1 / 0,
                  b = -1 / 0,
                  C = 1 / 0,
                  I = -1 / 0;
                for (; t.pos < r; ) {
                  if (c <= 0) {
                    const R = t.readVarint();
                    (a = 7 & R), (c = R >> 3);
                  }
                  if ((c--, a === 1 || a === 2))
                    (p += t.readSVarint()),
                      (m += t.readSVarint()),
                      p < v && (v = p),
                      p > b && (b = p),
                      m < C && (C = m),
                      m > I && (I = m);
                  else if (a !== 7) throw new Error(`unknown command ${a}`);
                }
                return [v, C, b, I];
              }
              toGeoJSON(t, r, a) {
                const c = this.extent * Math.pow(2, a),
                  p = this.extent * t,
                  m = this.extent * r,
                  v = this.loadGeometry();
                function b(U) {
                  return [
                    (360 * (U.x + p)) / c - 180,
                    (360 / Math.PI) *
                      Math.atan(Math.exp((1 - (2 * (U.y + m)) / c) * Math.PI)) -
                      90,
                  ];
                }
                function C(U) {
                  return U.map(b);
                }
                let I;
                if (this.type === 1) {
                  const U = [];
                  for (const X of v) U.push(X[0]);
                  const Z = C(U);
                  I =
                    U.length === 1
                      ? { type: "Point", coordinates: Z[0] }
                      : { type: "MultiPoint", coordinates: Z };
                } else if (this.type === 2) {
                  const U = v.map(C);
                  I =
                    U.length === 1
                      ? { type: "LineString", coordinates: U[0] }
                      : { type: "MultiLineString", coordinates: U };
                } else {
                  if (this.type !== 3) throw new Error("unknown feature type");
                  {
                    const U = (function (X) {
                        const Q = X.length;
                        if (Q <= 1) return [X];
                        const ie = [];
                        let he, Oe;
                        for (let ye = 0; ye < Q; ye++) {
                          const Ce = E1(X[ye]);
                          Ce !== 0 &&
                            (Oe === void 0 && (Oe = Ce < 0),
                            Oe === Ce < 0
                              ? (he && ie.push(he), (he = [X[ye]]))
                              : he && he.push(X[ye]));
                        }
                        return he && ie.push(he), ie;
                      })(v),
                      Z = [];
                    for (const X of U) Z.push(X.map(C));
                    I =
                      Z.length === 1
                        ? { type: "Polygon", coordinates: Z[0] }
                        : { type: "MultiPolygon", coordinates: Z };
                  }
                }
                const R = {
                  type: "Feature",
                  geometry: I,
                  properties: this.properties,
                };
                return this.id != null && (R.id = this.id), R;
              }
            }
            function k1(n, t, r) {
              n === 1
                ? (t.id = r.readVarint())
                : n === 2
                ? (function (a, c) {
                    const p = a.readVarint() + a.pos;
                    for (; a.pos < p; ) {
                      const m = c._keys[a.readVarint()],
                        v = c._values[a.readVarint()];
                      c.properties[m] = v;
                    }
                  })(r, t)
                : n === 3
                ? (t.type = r.readVarint())
                : n === 4 && (t._geometry = r.pos);
            }
            function E1(n) {
              let t = 0;
              for (let r, a, c = 0, p = n.length, m = p - 1; c < p; m = c++)
                (r = n[c]), (a = n[m]), (t += (a.x - r.x) * (r.y + a.y));
              return t;
            }
            hc.types = ["Unknown", "Point", "LineString", "Polygon"];
            class _g {
              constructor(t, r) {
                (this.version = 1),
                  (this.name = ""),
                  (this.extent = 4096),
                  (this.length = 0),
                  (this._pbf = t),
                  (this._keys = []),
                  (this._values = []),
                  (this._features = []),
                  t.readFields(z1, this, r),
                  (this.length = this._features.length);
              }
              feature(t) {
                if (t < 0 || t >= this._features.length)
                  throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[t];
                const r = this._pbf.readVarint() + this._pbf.pos;
                return new hc(
                  this._pbf,
                  r,
                  this.extent,
                  this._keys,
                  this._values
                );
              }
            }
            function z1(n, t, r) {
              n === 15
                ? (t.version = r.readVarint())
                : n === 1
                ? (t.name = r.readString())
                : n === 5
                ? (t.extent = r.readVarint())
                : n === 2
                ? t._features.push(r.pos)
                : n === 3
                ? t._keys.push(r.readString())
                : n === 4 &&
                  t._values.push(
                    (function (a) {
                      let c = null;
                      const p = a.readVarint() + a.pos;
                      for (; a.pos < p; ) {
                        const m = a.readVarint() >> 3;
                        c =
                          m === 1
                            ? a.readString()
                            : m === 2
                            ? a.readFloat()
                            : m === 3
                            ? a.readDouble()
                            : m === 4
                            ? a.readVarint64()
                            : m === 5
                            ? a.readVarint()
                            : m === 6
                            ? a.readSVarint()
                            : m === 7
                            ? a.readBoolean()
                            : null;
                      }
                      if (c == null) throw new Error("unknown feature value");
                      return c;
                    })(r)
                  );
            }
            class gg {
              constructor(t, r) {
                this.layers = t.readFields(L1, {}, r);
              }
            }
            function L1(n, t, r) {
              if (n === 3) {
                const a = new _g(r, r.readVarint() + r.pos);
                a.length && (t[a.name] = a);
              }
            }
            const Ff = Math.pow(2, 13);
            function Ou(n, t, r, a, c, p, m, v) {
              n.emplaceBack(
                t,
                r,
                2 * Math.floor(a * Ff) + m,
                c * Ff * 2,
                p * Ff * 2,
                Math.round(v)
              );
            }
            class Bf {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((r) => r.id)),
                  (this.index = t.index),
                  (this.hasDependencies = !1),
                  (this.layoutVertexArray = new we()),
                  (this.centroidVertexArray = new fe()),
                  (this.indexArray = new Pt()),
                  (this.programConfigurations = new es(t.layers, t.zoom)),
                  (this.segments = new cn()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((r) => r.isStateDependent())
                    .map((r) => r.id));
              }
              populate(t, r, a) {
                (this.features = []),
                  (this.hasDependencies = ep("fill-extrusion", this.layers, r));
                for (const {
                  feature: c,
                  id: p,
                  index: m,
                  sourceLayerIndex: v,
                } of t) {
                  const b = this.layers[0]._featureFilter.needGeometry,
                    C = Co(c, b);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new On(this.zoom),
                      C,
                      a
                    )
                  )
                    continue;
                  const I = {
                    id: p,
                    sourceLayerIndex: v,
                    index: m,
                    geometry: b ? C.geometry : so(c),
                    properties: c.properties,
                    type: c.type,
                    patterns: {},
                  };
                  this.hasDependencies
                    ? this.features.push(
                        zf(
                          "fill-extrusion",
                          this.layers,
                          I,
                          { zoom: this.zoom },
                          r
                        )
                      )
                    : this.addFeature(
                        I,
                        I.geometry,
                        m,
                        a,
                        {},
                        r.subdivisionGranularity
                      ),
                    r.featureIndex.insert(c, I.geometry, m, v, this.index, !0);
                }
              }
              addFeatures(t, r, a) {
                for (const c of this.features) {
                  const { geometry: p } = c;
                  this.addFeature(
                    c,
                    p,
                    c.index,
                    r,
                    a,
                    t.subdivisionGranularity
                  );
                }
              }
              update(t, r, a) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.stateDependentLayers,
                    { imagePositions: a }
                  );
              }
              isEmpty() {
                return (
                  this.layoutVertexArray.length === 0 &&
                  this.centroidVertexArray.length === 0
                );
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    A1
                  )),
                  (this.centroidVertexBuffer = t.createVertexBuffer(
                    this.centroidVertexArray,
                    M1.members,
                    !0
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.centroidVertexBuffer.destroy());
              }
              addFeature(t, r, a, c, p, m) {
                for (const v of kl(r, 500)) {
                  const b = { x: 0, y: 0, sampleCount: 0 },
                    C = this.layoutVertexArray.length;
                  this.processPolygon(b, c, t, v, m);
                  const I = this.layoutVertexArray.length - C,
                    R = Math.floor(b.x / b.sampleCount),
                    U = Math.floor(b.y / b.sampleCount);
                  for (let Z = 0; Z < I; Z++)
                    this.centroidVertexArray.emplaceBack(R, U);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  a,
                  { imagePositions: p, canonical: c }
                );
              }
              processPolygon(t, r, a, c, p) {
                if (c.length < 1 || vg(c[0])) return;
                for (const R of c) R.length !== 0 && D1(t, R);
                const m = {
                    segment: this.segments.prepareSegment(
                      4,
                      this.layoutVertexArray,
                      this.indexArray
                    ),
                  },
                  v = p.fill.getGranularityForZoomLevel(r.z),
                  b = hc.types[a.type] === "Polygon";
                for (const R of c) {
                  if (R.length === 0 || vg(R)) continue;
                  const U = ll(R, v, b);
                  this._generateSideFaces(U, m);
                }
                if (!b) return;
                const C = dg(c, r, v, !1),
                  I = this.layoutVertexArray;
                pg(
                  (R, U) => {
                    Ou(I, R, U, 0, 0, 1, 1, 0);
                  },
                  this.segments,
                  this.layoutVertexArray,
                  this.indexArray,
                  C.verticesFlattened,
                  C.indicesTriangles
                );
              }
              _generateSideFaces(t, r) {
                let a = 0;
                for (let c = 1; c < t.length; c++) {
                  const p = t[c],
                    m = t[c - 1];
                  if (R1(p, m)) continue;
                  r.segment.vertexLength + 4 > cn.MAX_VERTEX_ARRAY_LENGTH &&
                    (r.segment = this.segments.prepareSegment(
                      4,
                      this.layoutVertexArray,
                      this.indexArray
                    ));
                  const v = p.sub(m)._perp()._unit(),
                    b = m.dist(p);
                  a + b > 32768 && (a = 0),
                    Ou(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 0, a),
                    Ou(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 1, a),
                    (a += b),
                    Ou(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 0, a),
                    Ou(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 1, a);
                  const C = r.segment.vertexLength;
                  this.indexArray.emplaceBack(C, C + 2, C + 1),
                    this.indexArray.emplaceBack(C + 1, C + 2, C + 3),
                    (r.segment.vertexLength += 4),
                    (r.segment.primitiveLength += 2);
                }
              }
            }
            function D1(n, t) {
              for (let r = 0; r < t.length; r++) {
                const a = t[r];
                (r === t.length - 1 && t[0].x === a.x && t[0].y === a.y) ||
                  ((n.x += a.x), (n.y += a.y), n.sampleCount++);
              }
            }
            function R1(n, t) {
              return (
                (n.x === t.x && (n.x < 0 || n.x > Fe)) ||
                (n.y === t.y && (n.y < 0 || n.y > Fe))
              );
            }
            function vg(n) {
              return (
                n.every((t) => t.x < 0) ||
                n.every((t) => t.x > Fe) ||
                n.every((t) => t.y < 0) ||
                n.every((t) => t.y > Fe)
              );
            }
            let yg;
            hr("FillExtrusionBucket", Bf, { omit: ["layers", "features"] });
            var F1 = {
              get paint() {
                return (yg =
                  yg ||
                  new Ui({
                    "fill-extrusion-opacity": new zr(
                      _e["paint_fill-extrusion"]["fill-extrusion-opacity"]
                    ),
                    "fill-extrusion-color": new Gr(
                      _e["paint_fill-extrusion"]["fill-extrusion-color"]
                    ),
                    "fill-extrusion-translate": new zr(
                      _e["paint_fill-extrusion"]["fill-extrusion-translate"]
                    ),
                    "fill-extrusion-translate-anchor": new zr(
                      _e["paint_fill-extrusion"][
                        "fill-extrusion-translate-anchor"
                      ]
                    ),
                    "fill-extrusion-pattern": new nl(
                      _e["paint_fill-extrusion"]["fill-extrusion-pattern"]
                    ),
                    "fill-extrusion-height": new Gr(
                      _e["paint_fill-extrusion"]["fill-extrusion-height"]
                    ),
                    "fill-extrusion-base": new Gr(
                      _e["paint_fill-extrusion"]["fill-extrusion-base"]
                    ),
                    "fill-extrusion-vertical-gradient": new zr(
                      _e["paint_fill-extrusion"][
                        "fill-extrusion-vertical-gradient"
                      ]
                    ),
                  }));
              },
            };
            class B1 extends Aa {
              constructor(t, r) {
                super(t, F1, r);
              }
              createBucket(t) {
                return new Bf(t);
              }
              queryRadius() {
                return Jd(this.paint.get("fill-extrusion-translate"));
              }
              is3D() {
                return !0;
              }
              queryIntersectsFeature({
                queryGeometry: t,
                feature: r,
                featureState: a,
                geometry: c,
                transform: p,
                pixelsToTileUnits: m,
                pixelPosMatrix: v,
              }) {
                const b = Qd(
                    t,
                    this.paint.get("fill-extrusion-translate"),
                    this.paint.get("fill-extrusion-translate-anchor"),
                    -p.bearingInRadians,
                    m
                  ),
                  C = this.paint.get("fill-extrusion-height").evaluate(r, a),
                  I = this.paint.get("fill-extrusion-base").evaluate(r, a),
                  R = (function (Z, X) {
                    const Q = [];
                    for (const ie of Z) {
                      const he = [ie.x, ie.y, 0, 1];
                      Ge(he, he, X),
                        Q.push(new B(he[0] / he[3], he[1] / he[3]));
                    }
                    return Q;
                  })(b, v),
                  U = (function (Z, X, Q, ie) {
                    const he = [],
                      Oe = [],
                      ye = ie[8] * X,
                      Ce = ie[9] * X,
                      et = ie[10] * X,
                      ht = ie[11] * X,
                      Rt = ie[8] * Q,
                      or = ie[9] * Q,
                      Yt = ie[10] * Q,
                      rr = ie[11] * Q;
                    for (const Fr of Z) {
                      const er = [],
                        nr = [];
                      for (const St of Fr) {
                        const Hr = St.x,
                          Kr = St.y,
                          Vr = ie[0] * Hr + ie[4] * Kr + ie[12],
                          kr = ie[1] * Hr + ie[5] * Kr + ie[13],
                          bn = ie[2] * Hr + ie[6] * Kr + ie[14],
                          ai = ie[3] * Hr + ie[7] * Kr + ie[15],
                          bi = bn + et,
                          Gi = ai + ht,
                          za = Vr + Rt,
                          ca = kr + or,
                          Ri = bn + Yt,
                          ni = ai + rr,
                          ki = new B((Vr + ye) / Gi, (kr + Ce) / Gi);
                        (ki.z = bi / Gi), er.push(ki);
                        const Fi = new B(za / ni, ca / ni);
                        (Fi.z = Ri / ni), nr.push(Fi);
                      }
                      he.push(er), Oe.push(nr);
                    }
                    return [he, Oe];
                  })(c, I, C, v);
                return (function (Z, X, Q) {
                  let ie = 1 / 0;
                  H_(Q, X) && (ie = xg(Q, X[0]));
                  for (let he = 0; he < X.length; he++) {
                    const Oe = X[he],
                      ye = Z[he];
                    for (let Ce = 0; Ce < Oe.length - 1; Ce++) {
                      const et = Oe[Ce],
                        ht = [et, Oe[Ce + 1], ye[Ce + 1], ye[Ce], et];
                      $_(Q, ht) && (ie = Math.min(ie, xg(Q, ht)));
                    }
                  }
                  return ie !== 1 / 0 && ie;
                })(U[0], U[1], R);
              }
            }
            function Nu(n, t) {
              return n.x * t.x + n.y * t.y;
            }
            function xg(n, t) {
              if (n.length === 1) {
                let r = 0;
                const a = t[r++];
                let c;
                for (; !c || a.equals(c); )
                  if (((c = t[r++]), !c)) return 1 / 0;
                for (; r < t.length; r++) {
                  const p = t[r],
                    m = n[0],
                    v = c.sub(a),
                    b = p.sub(a),
                    C = m.sub(a),
                    I = Nu(v, v),
                    R = Nu(v, b),
                    U = Nu(b, b),
                    Z = Nu(C, v),
                    X = Nu(C, b),
                    Q = I * U - R * R,
                    ie = (U * Z - R * X) / Q,
                    he = (I * X - R * Z) / Q,
                    Oe = a.z * (1 - ie - he) + c.z * ie + p.z * he;
                  if (isFinite(Oe)) return Oe;
                }
                return 1 / 0;
              }
              {
                let r = 1 / 0;
                for (const a of t) r = Math.min(r, a.z);
                return r;
              }
            }
            const O1 = ci(
                [
                  { name: "a_pos_normal", components: 2, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint8" },
                ],
                4
              ),
              { members: N1 } = O1,
              j1 = ci([
                { name: "a_uv_x", components: 1, type: "Float32" },
                { name: "a_split_index", components: 1, type: "Float32" },
              ]),
              { members: V1 } = j1,
              q1 = Math.cos((Math.PI / 180) * 37.5),
              bg = Math.pow(2, 14) / 0.5;
            class Of {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((r) => r.id)),
                  (this.index = t.index),
                  (this.hasDependencies = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((r) => {
                    this.gradients[r.id] = {};
                  }),
                  (this.layoutVertexArray = new Pe()),
                  (this.layoutVertexArray2 = new ve()),
                  (this.indexArray = new Pt()),
                  (this.programConfigurations = new es(t.layers, t.zoom)),
                  (this.segments = new cn()),
                  (this.maxLineLength = 0),
                  (this.stateDependentLayerIds = this.layers
                    .filter((r) => r.isStateDependent())
                    .map((r) => r.id));
              }
              populate(t, r, a) {
                this.hasDependencies =
                  ep("line", this.layers, r) ||
                  this.hasLineDasharray(this.layers);
                const c = this.layers[0].layout.get("line-sort-key"),
                  p = !c.isConstant(),
                  m = [];
                for (const {
                  feature: v,
                  id: b,
                  index: C,
                  sourceLayerIndex: I,
                } of t) {
                  const R = this.layers[0]._featureFilter.needGeometry,
                    U = Co(v, R);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new On(this.zoom),
                      U,
                      a
                    )
                  )
                    continue;
                  const Z = p ? c.evaluate(U, {}, a) : void 0,
                    X = {
                      id: b,
                      properties: v.properties,
                      type: v.type,
                      sourceLayerIndex: I,
                      index: C,
                      geometry: R ? U.geometry : so(v),
                      patterns: {},
                      dashes: {},
                      sortKey: Z,
                    };
                  m.push(X);
                }
                p && m.sort((v, b) => v.sortKey - b.sortKey);
                for (const v of m) {
                  const { geometry: b, index: C, sourceLayerIndex: I } = v;
                  this.hasDependencies
                    ? (ep("line", this.layers, r)
                        ? zf("line", this.layers, v, { zoom: this.zoom }, r)
                        : this.hasLineDasharray(this.layers) &&
                          this.addLineDashDependencies(
                            this.layers,
                            v,
                            this.zoom,
                            r
                          ),
                      this.patternFeatures.push(v))
                    : this.addFeature(
                        v,
                        b,
                        C,
                        a,
                        {},
                        {},
                        r.subdivisionGranularity
                      ),
                    r.featureIndex.insert(t[C].feature, b, C, I, this.index);
                }
              }
              update(t, r, a, c) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.stateDependentLayers,
                    { imagePositions: a, dashPositions: c }
                  );
              }
              addFeatures(t, r, a, c) {
                for (const p of this.patternFeatures)
                  this.addFeature(
                    p,
                    p.geometry,
                    p.index,
                    r,
                    a,
                    c,
                    t.subdivisionGranularity
                  );
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  (this.layoutVertexArray2.length !== 0 &&
                    (this.layoutVertexBuffer2 = t.createVertexBuffer(
                      this.layoutVertexArray2,
                      V1
                    )),
                  (this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    N1
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(t) {
                if (
                  t.properties &&
                  Object.prototype.hasOwnProperty.call(
                    t.properties,
                    "mapbox_clip_start"
                  ) &&
                  Object.prototype.hasOwnProperty.call(
                    t.properties,
                    "mapbox_clip_end"
                  )
                )
                  return {
                    start: +t.properties.mapbox_clip_start,
                    end: +t.properties.mapbox_clip_end,
                  };
              }
              addFeature(t, r, a, c, p, m, v) {
                const b = this.layers[0].layout,
                  C = b.get("line-join").evaluate(t, {}),
                  I = b.get("line-cap"),
                  R = b.get("line-miter-limit"),
                  U = b.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t);
                for (const Z of r) this.addLine(Z, t, C, I, R, U, c, v);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  a,
                  { imagePositions: p, dashPositions: m, canonical: c }
                );
              }
              addLine(t, r, a, c, p, m, v, b) {
                if (
                  ((this.distance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (t = ll(t, v ? b.line.getGranularityForZoomLevel(v.z) : 1)),
                  this.lineClips)
                ) {
                  this.lineClipsArray.push(this.lineClips);
                  for (let ye = 0; ye < t.length - 1; ye++)
                    this.totalDistance += t[ye].dist(t[ye + 1]);
                  this.updateScaledDistance(),
                    (this.maxLineLength = Math.max(
                      this.maxLineLength,
                      this.totalDistance
                    ));
                }
                const C = hc.types[r.type] === "Polygon";
                let I = t.length;
                for (; I >= 2 && t[I - 1].equals(t[I - 2]); ) I--;
                let R = 0;
                for (; R < I - 1 && t[R].equals(t[R + 1]); ) R++;
                if (I < (C ? 3 : 2)) return;
                a === "bevel" && (p = 1.05);
                const U =
                    this.overscaling <= 16
                      ? 122880 / (512 * this.overscaling)
                      : 0,
                  Z = this.segments.prepareSegment(
                    10 * I,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                let X, Q, ie, he, Oe;
                (this.e1 = this.e2 = -1),
                  C && ((X = t[I - 2]), (Oe = t[R].sub(X)._unit()._perp()));
                for (let ye = R; ye < I; ye++) {
                  if (
                    ((ie = ye === I - 1 ? (C ? t[R + 1] : void 0) : t[ye + 1]),
                    ie && t[ye].equals(ie))
                  )
                    continue;
                  Oe && (he = Oe),
                    X && (Q = X),
                    (X = t[ye]),
                    (Oe = ie ? ie.sub(X)._unit()._perp() : he),
                    (he = he || Oe);
                  let Ce = he.add(Oe);
                  (Ce.x === 0 && Ce.y === 0) || Ce._unit();
                  const et = he.x * Oe.x + he.y * Oe.y,
                    ht = Ce.x * Oe.x + Ce.y * Oe.y,
                    Rt = ht !== 0 ? 1 / ht : 1 / 0,
                    or = 2 * Math.sqrt(2 - 2 * ht),
                    Yt = ht < q1 && Q && ie,
                    rr = he.x * Oe.y - he.y * Oe.x > 0;
                  if (Yt && ye > R) {
                    const nr = X.dist(Q);
                    if (nr > 2 * U) {
                      const St = X.sub(
                        X.sub(Q)
                          ._mult(U / nr)
                          ._round()
                      );
                      this.updateDistance(Q, St),
                        this.addCurrentVertex(St, he, 0, 0, Z),
                        (Q = St);
                    }
                  }
                  const Fr = Q && ie;
                  let er = Fr ? a : C ? "butt" : c;
                  if (
                    (Fr &&
                      er === "round" &&
                      (Rt < m ? (er = "miter") : Rt <= 2 && (er = "fakeround")),
                    er === "miter" && Rt > p && (er = "bevel"),
                    er === "bevel" &&
                      (Rt > 2 && (er = "flipbevel"), Rt < p && (er = "miter")),
                    Q && this.updateDistance(Q, X),
                    er === "miter")
                  )
                    Ce._mult(Rt), this.addCurrentVertex(X, Ce, 0, 0, Z);
                  else if (er === "flipbevel") {
                    if (Rt > 100) Ce = Oe.mult(-1);
                    else {
                      const nr = (Rt * he.add(Oe).mag()) / he.sub(Oe).mag();
                      Ce._perp()._mult(nr * (rr ? -1 : 1));
                    }
                    this.addCurrentVertex(X, Ce, 0, 0, Z),
                      this.addCurrentVertex(X, Ce.mult(-1), 0, 0, Z);
                  } else if (er === "bevel" || er === "fakeround") {
                    const nr = -Math.sqrt(Rt * Rt - 1),
                      St = rr ? nr : 0,
                      Hr = rr ? 0 : nr;
                    if (
                      (Q && this.addCurrentVertex(X, he, St, Hr, Z),
                      er === "fakeround")
                    ) {
                      const Kr = Math.round((180 * or) / Math.PI / 20);
                      for (let Vr = 1; Vr < Kr; Vr++) {
                        let kr = Vr / Kr;
                        if (kr !== 0.5) {
                          const ai = kr - 0.5;
                          kr +=
                            kr *
                            ai *
                            (kr - 1) *
                            ((1.0904 +
                              et * (et * (3.55645 - 1.43519 * et) - 3.2452)) *
                              ai *
                              ai +
                              (0.848013 + et * (0.215638 * et - 1.06021)));
                        }
                        const bn = Oe.sub(he)
                          ._mult(kr)
                          ._add(he)
                          ._unit()
                          ._mult(rr ? -1 : 1);
                        this.addHalfVertex(X, bn.x, bn.y, !1, rr, 0, Z);
                      }
                    }
                    ie && this.addCurrentVertex(X, Oe, -St, -Hr, Z);
                  } else if (er === "butt")
                    this.addCurrentVertex(X, Ce, 0, 0, Z);
                  else if (er === "square") {
                    const nr = Q ? 1 : -1;
                    this.addCurrentVertex(X, Ce, nr, nr, Z);
                  } else
                    er === "round" &&
                      (Q &&
                        (this.addCurrentVertex(X, he, 0, 0, Z),
                        this.addCurrentVertex(X, he, 1, 1, Z, !0)),
                      ie &&
                        (this.addCurrentVertex(X, Oe, -1, -1, Z, !0),
                        this.addCurrentVertex(X, Oe, 0, 0, Z)));
                  if (Yt && ye < I - 1) {
                    const nr = X.dist(ie);
                    if (nr > 2 * U) {
                      const St = X.add(
                        ie
                          .sub(X)
                          ._mult(U / nr)
                          ._round()
                      );
                      this.updateDistance(X, St),
                        this.addCurrentVertex(St, Oe, 0, 0, Z),
                        (X = St);
                    }
                  }
                }
              }
              addCurrentVertex(t, r, a, c, p, m = !1) {
                const v = r.y * c - r.x,
                  b = -r.y - r.x * c;
                this.addHalfVertex(
                  t,
                  r.x + r.y * a,
                  r.y - r.x * a,
                  m,
                  !1,
                  a,
                  p
                ),
                  this.addHalfVertex(t, v, b, m, !0, -c, p),
                  this.distance > bg / 2 &&
                    this.totalDistance === 0 &&
                    ((this.distance = 0),
                    this.updateScaledDistance(),
                    this.addCurrentVertex(t, r, a, c, p, m));
              }
              addHalfVertex({ x: t, y: r }, a, c, p, m, v, b) {
                const C =
                  0.5 *
                  (this.lineClips
                    ? this.scaledDistance * (bg - 1)
                    : this.scaledDistance);
                this.layoutVertexArray.emplaceBack(
                  (t << 1) + (p ? 1 : 0),
                  (r << 1) + (m ? 1 : 0),
                  Math.round(63 * a) + 128,
                  Math.round(63 * c) + 128,
                  (1 + (v === 0 ? 0 : v < 0 ? -1 : 1)) | ((63 & C) << 2),
                  C >> 6
                ),
                  this.lineClips &&
                    this.layoutVertexArray2.emplaceBack(
                      (this.scaledDistance - this.lineClips.start) /
                        (this.lineClips.end - this.lineClips.start),
                      this.lineClipsArray.length
                    );
                const I = b.vertexLength++;
                this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, I, this.e2),
                  b.primitiveLength++),
                  m ? (this.e2 = I) : (this.e1 = I);
              }
              updateScaledDistance() {
                this.scaledDistance = this.lineClips
                  ? this.lineClips.start +
                    ((this.lineClips.end - this.lineClips.start) *
                      this.distance) /
                      this.totalDistance
                  : this.distance;
              }
              updateDistance(t, r) {
                (this.distance += t.dist(r)), this.updateScaledDistance();
              }
              hasLineDasharray(t) {
                for (const r of t) {
                  const a = r.paint.get("line-dasharray");
                  if (a && !a.isConstant()) return !0;
                }
                return !1;
              }
              addLineDashDependencies(t, r, a, c) {
                for (const p of t) {
                  const m = p.paint.get("line-dasharray");
                  if (!m || m.value.kind === "constant") continue;
                  const v = p.layout.get("line-cap") === "round",
                    b = {
                      dasharray: m.value.evaluate({ zoom: a - 1 }, r, {}),
                      round: v,
                    },
                    C = {
                      dasharray: m.value.evaluate({ zoom: a }, r, {}),
                      round: v,
                    },
                    I = {
                      dasharray: m.value.evaluate({ zoom: a + 1 }, r, {}),
                      round: v,
                    },
                    R = `${b.dasharray.join(",")},${b.round}`,
                    U = `${C.dasharray.join(",")},${C.round}`,
                    Z = `${I.dasharray.join(",")},${I.round}`;
                  (c.dashDependencies[R] = b),
                    (c.dashDependencies[U] = C),
                    (c.dashDependencies[Z] = I),
                    (r.dashes[p.id] = { min: R, mid: U, max: Z });
                }
              }
            }
            let wg, Tg;
            hr("LineBucket", Of, { omit: ["layers", "patternFeatures"] });
            var Sg = {
              get paint() {
                return (Tg =
                  Tg ||
                  new Ui({
                    "line-opacity": new Gr(_e.paint_line["line-opacity"]),
                    "line-color": new Gr(_e.paint_line["line-color"]),
                    "line-translate": new zr(_e.paint_line["line-translate"]),
                    "line-translate-anchor": new zr(
                      _e.paint_line["line-translate-anchor"]
                    ),
                    "line-width": new Gr(_e.paint_line["line-width"]),
                    "line-gap-width": new Gr(_e.paint_line["line-gap-width"]),
                    "line-offset": new Gr(_e.paint_line["line-offset"]),
                    "line-blur": new Gr(_e.paint_line["line-blur"]),
                    "line-dasharray": new nl(_e.paint_line["line-dasharray"]),
                    "line-pattern": new nl(_e.paint_line["line-pattern"]),
                    "line-gradient": new il(_e.paint_line["line-gradient"]),
                  }));
              },
              get layout() {
                return (wg =
                  wg ||
                  new Ui({
                    "line-cap": new zr(_e.layout_line["line-cap"]),
                    "line-join": new Gr(_e.layout_line["line-join"]),
                    "line-miter-limit": new zr(
                      _e.layout_line["line-miter-limit"]
                    ),
                    "line-round-limit": new zr(
                      _e.layout_line["line-round-limit"]
                    ),
                    "line-sort-key": new Gr(_e.layout_line["line-sort-key"]),
                  }));
              },
            };
            class U1 extends Gr {
              possiblyEvaluate(t, r) {
                return (
                  (r = new On(Math.floor(r.zoom), {
                    now: r.now,
                    fadeDuration: r.fadeDuration,
                    zoomHistory: r.zoomHistory,
                    transition: r.transition,
                  })),
                  super.possiblyEvaluate(t, r)
                );
              }
              evaluate(t, r, a, c) {
                return (
                  (r = at({}, r, { zoom: Math.floor(r.zoom) })),
                  super.evaluate(t, r, a, c)
                );
              }
            }
            let ip;
            class Z1 extends Aa {
              constructor(t, r) {
                super(t, Sg, r),
                  (this.gradientVersion = 0),
                  ip ||
                    ((ip = new U1(
                      Sg.paint.properties["line-width"].specification
                    )),
                    (ip.useIntegerZoom = !0));
              }
              _handleSpecialPaintPropertyUpdate(t) {
                if (t === "line-gradient") {
                  const r = this.gradientExpression();
                  (this.stepInterpolant =
                    !!(function (a) {
                      return a._styleExpression !== void 0;
                    })(r) && r._styleExpression.expression instanceof fs),
                    (this.gradientVersion =
                      (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
                }
              }
              gradientExpression() {
                return this
                  ._transitionablePaint._values["line-gradient"].value.expression;
              }
              recalculate(t, r) {
                super.recalculate(t, r),
                  (this.paint._values["line-floorwidth"] = ip.possiblyEvaluate(
                    this._transitioningPaint._values["line-width"].value,
                    t
                  ));
              }
              createBucket(t) {
                return new Of(t);
              }
              queryRadius(t) {
                const r = t,
                  a = Cg(
                    sc("line-width", this, r),
                    sc("line-gap-width", this, r)
                  ),
                  c = sc("line-offset", this, r);
                return (
                  a / 2 + Math.abs(c) + Jd(this.paint.get("line-translate"))
                );
              }
              queryIntersectsFeature({
                queryGeometry: t,
                feature: r,
                featureState: a,
                geometry: c,
                transform: p,
                pixelsToTileUnits: m,
              }) {
                const v = Qd(
                    t,
                    this.paint.get("line-translate"),
                    this.paint.get("line-translate-anchor"),
                    -p.bearingInRadians,
                    m
                  ),
                  b =
                    (m / 2) *
                    Cg(
                      this.paint.get("line-width").evaluate(r, a),
                      this.paint.get("line-gap-width").evaluate(r, a)
                    ),
                  C = this.paint.get("line-offset").evaluate(r, a);
                return (
                  C &&
                    (c = (function (I, R) {
                      const U = [];
                      for (let Z = 0; Z < I.length; Z++) {
                        const X = I[Z],
                          Q = [];
                        for (let ie = 0; ie < X.length; ie++) {
                          const he = X[ie - 1],
                            Oe = X[ie],
                            ye = X[ie + 1],
                            Ce =
                              ie === 0
                                ? new B(0, 0)
                                : Oe.sub(he)._unit()._perp(),
                            et =
                              ie === X.length - 1
                                ? new B(0, 0)
                                : ye.sub(Oe)._unit()._perp(),
                            ht = Ce._add(et)._unit(),
                            Rt = ht.x * et.x + ht.y * et.y;
                          Rt !== 0 && ht._mult(1 / Rt),
                            Q.push(ht._mult(R)._add(Oe));
                        }
                        U.push(Q);
                      }
                      return U;
                    })(c, C * m)),
                  (function (I, R, U) {
                    for (let Z = 0; Z < R.length; Z++) {
                      const X = R[Z];
                      if (I.length >= 3) {
                        for (let Q = 0; Q < X.length; Q++)
                          if (oc(I, X[Q])) return !0;
                      }
                      if (Ky(I, X, U)) return !0;
                    }
                    return !1;
                  })(v, c, b)
                );
              }
              isTileClipped() {
                return !0;
              }
            }
            function Cg(n, t) {
              return t > 0 ? t + 2 * n : n;
            }
            const G1 = ci(
                [
                  { name: "a_pos_offset", components: 4, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint16" },
                  { name: "a_pixeloffset", components: 4, type: "Int16" },
                ],
                4
              ),
              $1 = ci(
                [{ name: "a_projected_pos", components: 3, type: "Float32" }],
                4
              );
            ci([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const H1 = ci([
              { name: "a_placed", components: 2, type: "Uint8" },
              { name: "a_shift", components: 2, type: "Float32" },
              { name: "a_box_real", components: 2, type: "Int16" },
            ]);
            ci([
              { type: "Int16", name: "anchorPointX" },
              { type: "Int16", name: "anchorPointY" },
              { type: "Int16", name: "x1" },
              { type: "Int16", name: "y1" },
              { type: "Int16", name: "x2" },
              { type: "Int16", name: "y2" },
              { type: "Uint32", name: "featureIndex" },
              { type: "Uint16", name: "sourceLayerIndex" },
              { type: "Uint16", name: "bucketIndex" },
            ]);
            const Pg = ci(
                [
                  { name: "a_pos", components: 2, type: "Int16" },
                  { name: "a_anchor_pos", components: 2, type: "Int16" },
                  { name: "a_extrude", components: 2, type: "Int16" },
                ],
                4
              ),
              W1 = ci(
                [
                  { name: "a_pos", components: 2, type: "Float32" },
                  { name: "a_radius", components: 1, type: "Float32" },
                  { name: "a_flags", components: 2, type: "Int16" },
                ],
                4
              );
            function X1(n, t, r) {
              return (
                n.sections.forEach((a) => {
                  a.text = (function (c, p, m) {
                    const v = p.layout.get("text-transform").evaluate(m, {});
                    return (
                      v === "uppercase"
                        ? (c = c.toLocaleUpperCase())
                        : v === "lowercase" && (c = c.toLocaleLowerCase()),
                      no.applyArabicShaping && (c = no.applyArabicShaping(c)),
                      c
                    );
                  })(a.text, t, r);
                }),
                n
              );
            }
            ci([{ name: "triangle", components: 3, type: "Uint16" }]),
              ci([
                { type: "Int16", name: "anchorX" },
                { type: "Int16", name: "anchorY" },
                { type: "Uint16", name: "glyphStartIndex" },
                { type: "Uint16", name: "numGlyphs" },
                { type: "Uint32", name: "vertexStartIndex" },
                { type: "Uint32", name: "lineStartIndex" },
                { type: "Uint32", name: "lineLength" },
                { type: "Uint16", name: "segment" },
                { type: "Uint16", name: "lowerSize" },
                { type: "Uint16", name: "upperSize" },
                { type: "Float32", name: "lineOffsetX" },
                { type: "Float32", name: "lineOffsetY" },
                { type: "Uint8", name: "writingMode" },
                { type: "Uint8", name: "placedOrientation" },
                { type: "Uint8", name: "hidden" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Int16", name: "associatedIconIndex" },
              ]),
              ci([
                { type: "Int16", name: "anchorX" },
                { type: "Int16", name: "anchorY" },
                { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
                { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
                { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
                { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
                { type: "Int16", name: "placedIconSymbolIndex" },
                { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
                { type: "Uint16", name: "key" },
                { type: "Uint16", name: "textBoxStartIndex" },
                { type: "Uint16", name: "textBoxEndIndex" },
                { type: "Uint16", name: "verticalTextBoxStartIndex" },
                { type: "Uint16", name: "verticalTextBoxEndIndex" },
                { type: "Uint16", name: "iconBoxStartIndex" },
                { type: "Uint16", name: "iconBoxEndIndex" },
                { type: "Uint16", name: "verticalIconBoxStartIndex" },
                { type: "Uint16", name: "verticalIconBoxEndIndex" },
                { type: "Uint16", name: "featureIndex" },
                { type: "Uint16", name: "numHorizontalGlyphVertices" },
                { type: "Uint16", name: "numVerticalGlyphVertices" },
                { type: "Uint16", name: "numIconVertices" },
                { type: "Uint16", name: "numVerticalIconVertices" },
                { type: "Uint16", name: "useRuntimeCollisionCircles" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Float32", name: "textBoxScale" },
                { type: "Float32", name: "collisionCircleDiameter" },
                { type: "Uint16", name: "textAnchorOffsetStartIndex" },
                { type: "Uint16", name: "textAnchorOffsetEndIndex" },
              ]),
              ci([{ type: "Float32", name: "offsetX" }]),
              ci([
                { type: "Int16", name: "x" },
                { type: "Int16", name: "y" },
                { type: "Int16", name: "tileUnitDistanceFromAnchor" },
              ]),
              ci([
                { type: "Uint16", name: "textAnchor" },
                { type: "Float32", components: 2, name: "textOffset" },
              ]);
            const ju = {
              "!": "Ô∏ï",
              "#": "ÔºÉ",
              $: "ÔºÑ",
              "%": "ÔºÖ",
              "&": "ÔºÜ",
              "(": "Ô∏µ",
              ")": "Ô∏∂",
              "*": "Ôºä",
              "+": "Ôºã",
              ",": "Ô∏ê",
              "-": "Ô∏≤",
              ".": "„Éª",
              "/": "Ôºè",
              ":": "Ô∏ì",
              ";": "Ô∏î",
              "<": "Ô∏ø",
              "=": "Ôºù",
              ">": "ÔπÄ",
              "?": "Ô∏ñ",
              "@": "Ôº†",
              "[": "Ôπá",
              "\\": "Ôºº",
              "]": "Ôπà",
              "^": "Ôºæ",
              _: "Ô∏≥",
              "`": "ÔΩÄ",
              "{": "Ô∏∑",
              "|": "‚Äï",
              "}": "Ô∏∏",
              "~": "ÔΩû",
              "¬¢": "Ôø†",
              "¬£": "Ôø°",
              "¬•": "Ôø•",
              "¬¶": "Ôø§",
              "¬¨": "Ôø¢",
              "¬Ø": "Ôø£",
              "‚Äì": "Ô∏≤",
              "‚Äî": "Ô∏±",
              "‚Äò": "ÔπÉ",
              "‚Äô": "ÔπÑ",
              "‚Äú": "ÔπÅ",
              "‚Äù": "ÔπÇ",
              "‚Ä¶": "Ô∏ô",
              "‚Äß": "„Éª",
              "‚Ç©": "Ôø¶",
              "„ÄÅ": "Ô∏ë",
              "„ÄÇ": "Ô∏í",
              "„Äà": "Ô∏ø",
              "„Äâ": "ÔπÄ",
              "„Ää": "Ô∏Ω",
              "„Äã": "Ô∏æ",
              "„Äå": "ÔπÅ",
              "„Äç": "ÔπÇ",
              "„Äé": "ÔπÉ",
              "„Äè": "ÔπÑ",
              "„Äê": "Ô∏ª",
              "„Äë": "Ô∏º",
              "„Äî": "Ô∏π",
              "„Äï": "Ô∏∫",
              "„Äñ": "Ô∏ó",
              "„Äó": "Ô∏ò",
              "ÔºÅ": "Ô∏ï",
              "Ôºà": "Ô∏µ",
              "Ôºâ": "Ô∏∂",
              "Ôºå": "Ô∏ê",
              "Ôºç": "Ô∏≤",
              "Ôºé": "„Éª",
              "Ôºö": "Ô∏ì",
              "Ôºõ": "Ô∏î",
              "Ôºú": "Ô∏ø",
              "Ôºû": "ÔπÄ",
              "Ôºü": "Ô∏ñ",
              "Ôºª": "Ôπá",
              "ÔºΩ": "Ôπà",
              "Ôºø": "Ô∏≥",
              "ÔΩõ": "Ô∏∑",
              "ÔΩú": "‚Äï",
              "ÔΩù": "Ô∏∏",
              "ÔΩü": "Ô∏µ",
              "ÔΩ†": "Ô∏∂",
              "ÔΩ°": "Ô∏í",
              "ÔΩ¢": "ÔπÅ",
              "ÔΩ£": "ÔπÇ",
            };
            var Ai = 24;
            const Nf = 4294967296,
              Ig = 1 / Nf,
              Mg = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
            class jf {
              constructor(t = new Uint8Array(16)) {
                (this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t)),
                  (this.dataView = new DataView(this.buf.buffer)),
                  (this.pos = 0),
                  (this.type = 0),
                  (this.length = this.buf.length);
              }
              readFields(t, r, a = this.length) {
                for (; this.pos < a; ) {
                  const c = this.readVarint(),
                    p = c >> 3,
                    m = this.pos;
                  (this.type = 7 & c),
                    t(p, r, this),
                    this.pos === m && this.skip(c);
                }
                return r;
              }
              readMessage(t, r) {
                return this.readFields(t, r, this.readVarint() + this.pos);
              }
              readFixed32() {
                const t = this.dataView.getUint32(this.pos, !0);
                return (this.pos += 4), t;
              }
              readSFixed32() {
                const t = this.dataView.getInt32(this.pos, !0);
                return (this.pos += 4), t;
              }
              readFixed64() {
                const t =
                  this.dataView.getUint32(this.pos, !0) +
                  this.dataView.getUint32(this.pos + 4, !0) * Nf;
                return (this.pos += 8), t;
              }
              readSFixed64() {
                const t =
                  this.dataView.getUint32(this.pos, !0) +
                  this.dataView.getInt32(this.pos + 4, !0) * Nf;
                return (this.pos += 8), t;
              }
              readFloat() {
                const t = this.dataView.getFloat32(this.pos, !0);
                return (this.pos += 4), t;
              }
              readDouble() {
                const t = this.dataView.getFloat64(this.pos, !0);
                return (this.pos += 8), t;
              }
              readVarint(t) {
                const r = this.buf;
                let a, c;
                return (
                  (c = r[this.pos++]),
                  (a = 127 & c),
                  c < 128
                    ? a
                    : ((c = r[this.pos++]),
                      (a |= (127 & c) << 7),
                      c < 128
                        ? a
                        : ((c = r[this.pos++]),
                          (a |= (127 & c) << 14),
                          c < 128
                            ? a
                            : ((c = r[this.pos++]),
                              (a |= (127 & c) << 21),
                              c < 128
                                ? a
                                : ((c = r[this.pos]),
                                  (a |= (15 & c) << 28),
                                  (function (p, m, v) {
                                    const b = v.buf;
                                    let C, I;
                                    if (
                                      ((I = b[v.pos++]),
                                      (C = (112 & I) >> 4),
                                      I < 128 ||
                                        ((I = b[v.pos++]),
                                        (C |= (127 & I) << 3),
                                        I < 128) ||
                                        ((I = b[v.pos++]),
                                        (C |= (127 & I) << 10),
                                        I < 128) ||
                                        ((I = b[v.pos++]),
                                        (C |= (127 & I) << 17),
                                        I < 128) ||
                                        ((I = b[v.pos++]),
                                        (C |= (127 & I) << 24),
                                        I < 128) ||
                                        ((I = b[v.pos++]),
                                        (C |= (1 & I) << 31),
                                        I < 128))
                                    )
                                      return dc(p, C, m);
                                    throw new Error(
                                      "Expected varint not more than 10 bytes"
                                    );
                                  })(a, t, this)))))
                );
              }
              readVarint64() {
                return this.readVarint(!0);
              }
              readSVarint() {
                const t = this.readVarint();
                return t % 2 == 1 ? (t + 1) / -2 : t / 2;
              }
              readBoolean() {
                return !!this.readVarint();
              }
              readString() {
                const t = this.readVarint() + this.pos,
                  r = this.pos;
                return (
                  (this.pos = t),
                  t - r >= 12 && Mg
                    ? Mg.decode(this.buf.subarray(r, t))
                    : (function (a, c, p) {
                        let m = "",
                          v = c;
                        for (; v < p; ) {
                          const b = a[v];
                          let C,
                            I,
                            R,
                            U = null,
                            Z = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                          if (v + Z > p) break;
                          Z === 1
                            ? b < 128 && (U = b)
                            : Z === 2
                            ? ((C = a[v + 1]),
                              (192 & C) == 128 &&
                                ((U = ((31 & b) << 6) | (63 & C)),
                                U <= 127 && (U = null)))
                            : Z === 3
                            ? ((C = a[v + 1]),
                              (I = a[v + 2]),
                              (192 & C) == 128 &&
                                (192 & I) == 128 &&
                                ((U =
                                  ((15 & b) << 12) |
                                  ((63 & C) << 6) |
                                  (63 & I)),
                                (U <= 2047 || (U >= 55296 && U <= 57343)) &&
                                  (U = null)))
                            : Z === 4 &&
                              ((C = a[v + 1]),
                              (I = a[v + 2]),
                              (R = a[v + 3]),
                              (192 & C) == 128 &&
                                (192 & I) == 128 &&
                                (192 & R) == 128 &&
                                ((U =
                                  ((15 & b) << 18) |
                                  ((63 & C) << 12) |
                                  ((63 & I) << 6) |
                                  (63 & R)),
                                (U <= 65535 || U >= 1114112) && (U = null))),
                            U === null
                              ? ((U = 65533), (Z = 1))
                              : U > 65535 &&
                                ((U -= 65536),
                                (m += String.fromCharCode(
                                  ((U >>> 10) & 1023) | 55296
                                )),
                                (U = 56320 | (1023 & U))),
                            (m += String.fromCharCode(U)),
                            (v += Z);
                        }
                        return m;
                      })(this.buf, r, t)
                );
              }
              readBytes() {
                const t = this.readVarint() + this.pos,
                  r = this.buf.subarray(this.pos, t);
                return (this.pos = t), r;
              }
              readPackedVarint(t = [], r) {
                const a = this.readPackedEnd();
                for (; this.pos < a; ) t.push(this.readVarint(r));
                return t;
              }
              readPackedSVarint(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readSVarint());
                return t;
              }
              readPackedBoolean(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readBoolean());
                return t;
              }
              readPackedFloat(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readFloat());
                return t;
              }
              readPackedDouble(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readDouble());
                return t;
              }
              readPackedFixed32(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readFixed32());
                return t;
              }
              readPackedSFixed32(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readSFixed32());
                return t;
              }
              readPackedFixed64(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readFixed64());
                return t;
              }
              readPackedSFixed64(t = []) {
                const r = this.readPackedEnd();
                for (; this.pos < r; ) t.push(this.readSFixed64());
                return t;
              }
              readPackedEnd() {
                return this.type === 2
                  ? this.readVarint() + this.pos
                  : this.pos + 1;
              }
              skip(t) {
                const r = 7 & t;
                if (r === 0) for (; this.buf[this.pos++] > 127; );
                else if (r === 2) this.pos = this.readVarint() + this.pos;
                else if (r === 5) this.pos += 4;
                else {
                  if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
                  this.pos += 8;
                }
              }
              writeTag(t, r) {
                this.writeVarint((t << 3) | r);
              }
              realloc(t) {
                let r = this.length || 16;
                for (; r < this.pos + t; ) r *= 2;
                if (r !== this.length) {
                  const a = new Uint8Array(r);
                  a.set(this.buf),
                    (this.buf = a),
                    (this.dataView = new DataView(a.buffer)),
                    (this.length = r);
                }
              }
              finish() {
                return (
                  (this.length = this.pos),
                  (this.pos = 0),
                  this.buf.subarray(0, this.length)
                );
              }
              writeFixed32(t) {
                this.realloc(4),
                  this.dataView.setInt32(this.pos, t, !0),
                  (this.pos += 4);
              }
              writeSFixed32(t) {
                this.realloc(4),
                  this.dataView.setInt32(this.pos, t, !0),
                  (this.pos += 4);
              }
              writeFixed64(t) {
                this.realloc(8),
                  this.dataView.setInt32(this.pos, -1 & t, !0),
                  this.dataView.setInt32(this.pos + 4, Math.floor(t * Ig), !0),
                  (this.pos += 8);
              }
              writeSFixed64(t) {
                this.realloc(8),
                  this.dataView.setInt32(this.pos, -1 & t, !0),
                  this.dataView.setInt32(this.pos + 4, Math.floor(t * Ig), !0),
                  (this.pos += 8);
              }
              writeVarint(t) {
                (t = +t || 0) > 268435455 || t < 0
                  ? (function (r, a) {
                      let c, p;
                      if (
                        (r >= 0
                          ? ((c = r % 4294967296 | 0),
                            (p = (r / 4294967296) | 0))
                          : ((c = ~(-r % 4294967296)),
                            (p = ~(-r / 4294967296)),
                            4294967295 ^ c
                              ? (c = (c + 1) | 0)
                              : ((c = 0), (p = (p + 1) | 0))),
                        r >= 18446744073709552e3 || r < -18446744073709552e3)
                      )
                        throw new Error(
                          "Given varint doesn't fit into 10 bytes"
                        );
                      a.realloc(10),
                        (function (m, v, b) {
                          (b.buf[b.pos++] = (127 & m) | 128),
                            (m >>>= 7),
                            (b.buf[b.pos++] = (127 & m) | 128),
                            (m >>>= 7),
                            (b.buf[b.pos++] = (127 & m) | 128),
                            (m >>>= 7),
                            (b.buf[b.pos++] = (127 & m) | 128),
                            (b.buf[b.pos] = 127 & (m >>>= 7));
                        })(c, 0, a),
                        (function (m, v) {
                          const b = (7 & m) << 4;
                          (v.buf[v.pos++] |= b | ((m >>>= 3) ? 128 : 0)),
                            m &&
                              ((v.buf[v.pos++] =
                                (127 & m) | ((m >>>= 7) ? 128 : 0)),
                              m &&
                                ((v.buf[v.pos++] =
                                  (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                m &&
                                  ((v.buf[v.pos++] =
                                    (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                  m &&
                                    ((v.buf[v.pos++] =
                                      (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                    m && (v.buf[v.pos++] = 127 & m)))));
                        })(p, a);
                    })(t, this)
                  : (this.realloc(4),
                    (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
                    t <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                      t <= 127 ||
                        ((this.buf[this.pos++] =
                          (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                        t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
              }
              writeSVarint(t) {
                this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
              }
              writeBoolean(t) {
                this.writeVarint(+t);
              }
              writeString(t) {
                (t = String(t)), this.realloc(4 * t.length), this.pos++;
                const r = this.pos;
                this.pos = (function (c, p, m) {
                  for (let v, b, C = 0; C < p.length; C++) {
                    if (((v = p.charCodeAt(C)), v > 55295 && v < 57344)) {
                      if (!b) {
                        v > 56319 || C + 1 === p.length
                          ? ((c[m++] = 239), (c[m++] = 191), (c[m++] = 189))
                          : (b = v);
                        continue;
                      }
                      if (v < 56320) {
                        (c[m++] = 239), (c[m++] = 191), (c[m++] = 189), (b = v);
                        continue;
                      }
                      (v = ((b - 55296) << 10) | (v - 56320) | 65536),
                        (b = null);
                    } else
                      b &&
                        ((c[m++] = 239),
                        (c[m++] = 191),
                        (c[m++] = 189),
                        (b = null));
                    v < 128
                      ? (c[m++] = v)
                      : (v < 2048
                          ? (c[m++] = (v >> 6) | 192)
                          : (v < 65536
                              ? (c[m++] = (v >> 12) | 224)
                              : ((c[m++] = (v >> 18) | 240),
                                (c[m++] = ((v >> 12) & 63) | 128)),
                            (c[m++] = ((v >> 6) & 63) | 128)),
                        (c[m++] = (63 & v) | 128));
                  }
                  return m;
                })(this.buf, t, this.pos);
                const a = this.pos - r;
                a >= 128 && Ag(r, a, this),
                  (this.pos = r - 1),
                  this.writeVarint(a),
                  (this.pos += a);
              }
              writeFloat(t) {
                this.realloc(4),
                  this.dataView.setFloat32(this.pos, t, !0),
                  (this.pos += 4);
              }
              writeDouble(t) {
                this.realloc(8),
                  this.dataView.setFloat64(this.pos, t, !0),
                  (this.pos += 8);
              }
              writeBytes(t) {
                const r = t.length;
                this.writeVarint(r), this.realloc(r);
                for (let a = 0; a < r; a++) this.buf[this.pos++] = t[a];
              }
              writeRawMessage(t, r) {
                this.pos++;
                const a = this.pos;
                t(r, this);
                const c = this.pos - a;
                c >= 128 && Ag(a, c, this),
                  (this.pos = a - 1),
                  this.writeVarint(c),
                  (this.pos += c);
              }
              writeMessage(t, r, a) {
                this.writeTag(t, 2), this.writeRawMessage(r, a);
              }
              writePackedVarint(t, r) {
                r.length && this.writeMessage(t, Y1, r);
              }
              writePackedSVarint(t, r) {
                r.length && this.writeMessage(t, K1, r);
              }
              writePackedBoolean(t, r) {
                r.length && this.writeMessage(t, ex, r);
              }
              writePackedFloat(t, r) {
                r.length && this.writeMessage(t, J1, r);
              }
              writePackedDouble(t, r) {
                r.length && this.writeMessage(t, Q1, r);
              }
              writePackedFixed32(t, r) {
                r.length && this.writeMessage(t, tx, r);
              }
              writePackedSFixed32(t, r) {
                r.length && this.writeMessage(t, rx, r);
              }
              writePackedFixed64(t, r) {
                r.length && this.writeMessage(t, nx, r);
              }
              writePackedSFixed64(t, r) {
                r.length && this.writeMessage(t, ix, r);
              }
              writeBytesField(t, r) {
                this.writeTag(t, 2), this.writeBytes(r);
              }
              writeFixed32Field(t, r) {
                this.writeTag(t, 5), this.writeFixed32(r);
              }
              writeSFixed32Field(t, r) {
                this.writeTag(t, 5), this.writeSFixed32(r);
              }
              writeFixed64Field(t, r) {
                this.writeTag(t, 1), this.writeFixed64(r);
              }
              writeSFixed64Field(t, r) {
                this.writeTag(t, 1), this.writeSFixed64(r);
              }
              writeVarintField(t, r) {
                this.writeTag(t, 0), this.writeVarint(r);
              }
              writeSVarintField(t, r) {
                this.writeTag(t, 0), this.writeSVarint(r);
              }
              writeStringField(t, r) {
                this.writeTag(t, 2), this.writeString(r);
              }
              writeFloatField(t, r) {
                this.writeTag(t, 5), this.writeFloat(r);
              }
              writeDoubleField(t, r) {
                this.writeTag(t, 1), this.writeDouble(r);
              }
              writeBooleanField(t, r) {
                this.writeVarintField(t, +r);
              }
            }
            function dc(n, t, r) {
              return r
                ? 4294967296 * t + (n >>> 0)
                : 4294967296 * (t >>> 0) + (n >>> 0);
            }
            function Ag(n, t, r) {
              const a =
                t <= 16383
                  ? 1
                  : t <= 2097151
                  ? 2
                  : t <= 268435455
                  ? 3
                  : Math.floor(Math.log(t) / (7 * Math.LN2));
              r.realloc(a);
              for (let c = r.pos - 1; c >= n; c--) r.buf[c + a] = r.buf[c];
            }
            function Y1(n, t) {
              for (let r = 0; r < n.length; r++) t.writeVarint(n[r]);
            }
            function K1(n, t) {
              for (let r = 0; r < n.length; r++) t.writeSVarint(n[r]);
            }
            function J1(n, t) {
              for (let r = 0; r < n.length; r++) t.writeFloat(n[r]);
            }
            function Q1(n, t) {
              for (let r = 0; r < n.length; r++) t.writeDouble(n[r]);
            }
            function ex(n, t) {
              for (let r = 0; r < n.length; r++) t.writeBoolean(n[r]);
            }
            function tx(n, t) {
              for (let r = 0; r < n.length; r++) t.writeFixed32(n[r]);
            }
            function rx(n, t) {
              for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r]);
            }
            function nx(n, t) {
              for (let r = 0; r < n.length; r++) t.writeFixed64(n[r]);
            }
            function ix(n, t) {
              for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r]);
            }
            function ax(n, t, r) {
              n === 1 && r.readMessage(ox, t);
            }
            function ox(n, t, r) {
              if (n === 3) {
                const {
                  id: a,
                  bitmap: c,
                  width: p,
                  height: m,
                  left: v,
                  top: b,
                  advance: C,
                } = r.readMessage(sx, {});
                t.push({
                  id: a,
                  bitmap: new Eu({ width: p + 6, height: m + 6 }, c),
                  metrics: { width: p, height: m, left: v, top: b, advance: C },
                });
              }
            }
            function sx(n, t, r) {
              n === 1
                ? (t.id = r.readVarint())
                : n === 2
                ? (t.bitmap = r.readBytes())
                : n === 3
                ? (t.width = r.readVarint())
                : n === 4
                ? (t.height = r.readVarint())
                : n === 5
                ? (t.left = r.readSVarint())
                : n === 6
                ? (t.top = r.readSVarint())
                : n === 7 && (t.advance = r.readVarint());
            }
            function kg(n) {
              let t = 0,
                r = 0;
              for (const m of n) (t += m.w * m.h), (r = Math.max(r, m.w));
              n.sort((m, v) => v.h - m.h);
              const a = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), r),
                  h: 1 / 0,
                },
              ];
              let c = 0,
                p = 0;
              for (const m of n)
                for (let v = a.length - 1; v >= 0; v--) {
                  const b = a[v];
                  if (!(m.w > b.w || m.h > b.h)) {
                    if (
                      ((m.x = b.x),
                      (m.y = b.y),
                      (p = Math.max(p, m.y + m.h)),
                      (c = Math.max(c, m.x + m.w)),
                      m.w === b.w && m.h === b.h)
                    ) {
                      const C = a.pop();
                      C && v < a.length && (a[v] = C);
                    } else
                      m.h === b.h
                        ? ((b.x += m.w), (b.w -= m.w))
                        : m.w === b.w
                        ? ((b.y += m.h), (b.h -= m.h))
                        : (a.push({
                            x: b.x + m.w,
                            y: b.y,
                            w: b.w - m.w,
                            h: m.h,
                          }),
                          (b.y += m.h),
                          (b.h -= m.h));
                    break;
                  }
                }
              return { w: c, h: p, fill: t / (c * p) || 0 };
            }
            class Vf {
              constructor(
                t,
                {
                  pixelRatio: r,
                  version: a,
                  stretchX: c,
                  stretchY: p,
                  content: m,
                  textFitWidth: v,
                  textFitHeight: b,
                }
              ) {
                (this.paddedRect = t),
                  (this.pixelRatio = r),
                  (this.stretchX = c),
                  (this.stretchY = p),
                  (this.content = m),
                  (this.version = a),
                  (this.textFitWidth = v),
                  (this.textFitHeight = b);
              }
              get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - 1,
                  this.paddedRect.y + this.paddedRect.h - 1,
                ];
              }
              get tlbr() {
                return this.tl.concat(this.br);
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2) / this.pixelRatio,
                  (this.paddedRect.h - 2) / this.pixelRatio,
                ];
              }
            }
            class Eg {
              constructor(t, r) {
                const a = {},
                  c = {};
                this.haveRenderCallbacks = [];
                const p = [];
                this.addImages(t, a, p), this.addImages(r, c, p);
                const { w: m, h: v } = kg(p),
                  b = new la({ width: m || 1, height: v || 1 });
                for (const C in t) {
                  const I = t[C],
                    R = a[C].paddedRect;
                  la.copy(
                    I.data,
                    b,
                    { x: 0, y: 0 },
                    { x: R.x + 1, y: R.y + 1 },
                    I.data
                  );
                }
                for (const C in r) {
                  const I = r[C],
                    R = c[C].paddedRect,
                    U = R.x + 1,
                    Z = R.y + 1,
                    X = I.data.width,
                    Q = I.data.height;
                  la.copy(I.data, b, { x: 0, y: 0 }, { x: U, y: Z }, I.data),
                    la.copy(
                      I.data,
                      b,
                      { x: 0, y: Q - 1 },
                      { x: U, y: Z - 1 },
                      { width: X, height: 1 }
                    ),
                    la.copy(
                      I.data,
                      b,
                      { x: 0, y: 0 },
                      { x: U, y: Z + Q },
                      { width: X, height: 1 }
                    ),
                    la.copy(
                      I.data,
                      b,
                      { x: X - 1, y: 0 },
                      { x: U - 1, y: Z },
                      { width: 1, height: Q }
                    ),
                    la.copy(
                      I.data,
                      b,
                      { x: 0, y: 0 },
                      { x: U + X, y: Z },
                      { width: 1, height: Q }
                    );
                }
                (this.image = b),
                  (this.iconPositions = a),
                  (this.patternPositions = c);
              }
              addImages(t, r, a) {
                for (const c in t) {
                  const p = t[c],
                    m = {
                      x: 0,
                      y: 0,
                      w: p.data.width + 2,
                      h: p.data.height + 2,
                    };
                  a.push(m),
                    (r[c] = new Vf(m, p)),
                    p.hasRenderCallback && this.haveRenderCallbacks.push(c);
                }
              }
              patchUpdatedImages(t, r) {
                t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const a in t.updatedImages)
                  this.patchUpdatedImage(
                    this.iconPositions[a],
                    t.getImage(a),
                    r
                  ),
                    this.patchUpdatedImage(
                      this.patternPositions[a],
                      t.getImage(a),
                      r
                    );
              }
              patchUpdatedImage(t, r, a) {
                if (!t || !r || t.version === r.version) return;
                t.version = r.version;
                const [c, p] = t.tl;
                a.update(r.data, void 0, { x: c, y: p });
              }
            }
            var Is;
            hr("ImagePosition", Vf),
              hr("ImageAtlas", Eg),
              (T.as = void 0),
              ((Is = T.as || (T.as = {}))[(Is.none = 0)] = "none"),
              (Is[(Is.horizontal = 1)] = "horizontal"),
              (Is[(Is.vertical = 2)] = "vertical"),
              (Is[(Is.horizontalOnly = 3)] = "horizontalOnly");
            class Vu {
              constructor() {
                (this.scale = 1),
                  (this.fontStack = ""),
                  (this.imageName = null),
                  (this.verticalAlign = "bottom");
              }
              static forText(t, r, a) {
                const c = new Vu();
                return (
                  (c.scale = t || 1),
                  (c.fontStack = r),
                  (c.verticalAlign = a || "bottom"),
                  c
                );
              }
              static forImage(t, r) {
                const a = new Vu();
                return (a.imageName = t), (a.verticalAlign = r || "bottom"), a;
              }
            }
            class pc {
              constructor() {
                (this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null);
              }
              static fromFeature(t, r) {
                const a = new pc();
                for (let c = 0; c < t.sections.length; c++) {
                  const p = t.sections[c];
                  p.image ? a.addImageSection(p) : a.addTextSection(p, r);
                }
                return a;
              }
              length() {
                return this.text.length;
              }
              getSection(t) {
                return this.sections[this.sectionIndex[t]];
              }
              getSectionIndex(t) {
                return this.sectionIndex[t];
              }
              getCharCode(t) {
                return this.text.charCodeAt(t);
              }
              verticalizePunctuation() {
                this.text = (function (t) {
                  let r = "";
                  for (let a = 0; a < t.length; a++) {
                    const c = t.charCodeAt(a + 1) || null,
                      p = t.charCodeAt(a - 1) || null;
                    r +=
                      (c && Kl(c) && !ju[t[a + 1]]) ||
                      (p && Kl(p) && !ju[t[a - 1]]) ||
                      !ju[t[a]]
                        ? t[a]
                        : ju[t[a]];
                  }
                  return r;
                })(this.text);
              }
              trim() {
                let t = 0;
                for (
                  let a = 0;
                  a < this.text.length && op[this.text.charCodeAt(a)];
                  a++
                )
                  t++;
                let r = this.text.length;
                for (
                  let a = this.text.length - 1;
                  a >= 0 && a >= t && op[this.text.charCodeAt(a)];
                  a--
                )
                  r--;
                (this.text = this.text.substring(t, r)),
                  (this.sectionIndex = this.sectionIndex.slice(t, r));
              }
              substring(t, r) {
                const a = new pc();
                return (
                  (a.text = this.text.substring(t, r)),
                  (a.sectionIndex = this.sectionIndex.slice(t, r)),
                  (a.sections = this.sections),
                  a
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (t, r) => Math.max(t, this.sections[r].scale),
                  0
                );
              }
              getMaxImageSize(t) {
                let r = 0,
                  a = 0;
                for (let c = 0; c < this.length(); c++) {
                  const p = this.getSection(c);
                  if (p.imageName) {
                    const m = t[p.imageName];
                    if (!m) continue;
                    const v = m.displaySize;
                    (r = Math.max(r, v[0])), (a = Math.max(a, v[1]));
                  }
                }
                return { maxImageWidth: r, maxImageHeight: a };
              }
              addTextSection(t, r) {
                (this.text += t.text),
                  this.sections.push(
                    Vu.forText(t.scale, t.fontStack || r, t.verticalAlign)
                  );
                const a = this.sections.length - 1;
                for (let c = 0; c < t.text.length; ++c)
                  this.sectionIndex.push(a);
              }
              addImageSection(t) {
                const r = t.image ? t.image.name : "";
                if (r.length === 0)
                  return void Bt(
                    "Can't add FormattedSection with an empty image."
                  );
                const a = this.getNextImageSectionCharCode();
                a
                  ? ((this.text += String.fromCharCode(a)),
                    this.sections.push(Vu.forImage(r, t.verticalAlign)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : Bt("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function ap(n, t, r, a, c, p, m, v, b, C, I, R, U, Z, X) {
              const Q = pc.fromFeature(n, c);
              let ie;
              R === T.as.vertical && Q.verticalizePunctuation();
              const {
                processBidirectionalText: he,
                processStyledBidirectionalText: Oe,
              } = no;
              if (he && Q.sections.length === 1) {
                ie = [];
                const et = he(Q.toString(), qf(Q, C, p, t, a, Z));
                for (const ht of et) {
                  const Rt = new pc();
                  (Rt.text = ht), (Rt.sections = Q.sections);
                  for (let or = 0; or < ht.length; or++)
                    Rt.sectionIndex.push(0);
                  ie.push(Rt);
                }
              } else if (Oe) {
                ie = [];
                const et = Oe(Q.text, Q.sectionIndex, qf(Q, C, p, t, a, Z));
                for (const ht of et) {
                  const Rt = new pc();
                  (Rt.text = ht[0]),
                    (Rt.sectionIndex = ht[1]),
                    (Rt.sections = Q.sections),
                    ie.push(Rt);
                }
              } else
                ie = (function (et, ht) {
                  const Rt = [],
                    or = et.text;
                  let Yt = 0;
                  for (const rr of ht) Rt.push(et.substring(Yt, rr)), (Yt = rr);
                  return (
                    Yt < or.length && Rt.push(et.substring(Yt, or.length)), Rt
                  );
                })(Q, qf(Q, C, p, t, a, Z));
              const ye = [],
                Ce = {
                  positionedLines: ye,
                  text: Q.toString(),
                  top: I[1],
                  bottom: I[1],
                  left: I[0],
                  right: I[0],
                  writingMode: R,
                  iconsInText: !1,
                  verticalizable: !1,
                };
              return (
                (function (et, ht, Rt, or, Yt, rr, Fr, er, nr, St, Hr, Kr) {
                  let Vr = 0,
                    kr = 0,
                    bn = 0,
                    ai = 0;
                  const bi = er === "right" ? 1 : er === "left" ? 0 : 0.5,
                    Gi = Ai / Kr;
                  let za = 0;
                  for (const ni of Yt) {
                    ni.trim();
                    const ki = ni.getMaxScale(),
                      Fi = { positionedGlyphs: [], lineOffset: 0 };
                    et.positionedLines[za] = Fi;
                    const Bi = Fi.positionedGlyphs;
                    let aa = 0;
                    if (!ni.length()) {
                      (kr += rr), ++za;
                      continue;
                    }
                    const La = hx(or, ni, Gi);
                    for (let ua = 0; ua < ni.length(); ua++) {
                      const wi = ni.getSection(ua),
                        zi = ni.getSectionIndex(ua),
                        Li = ni.getCharCode(ua),
                        vi = dx(nr, Hr, Li);
                      let Wn;
                      if (wi.imageName) {
                        if (
                          ((et.iconsInText = !0),
                          (wi.scale = wi.scale * Gi),
                          (Wn = fx(wi, vi, ki, La, or)),
                          !Wn)
                        )
                          continue;
                        aa = Math.max(aa, Wn.imageOffset);
                      } else if (((Wn = px(wi, Li, vi, La, ht, Rt)), !Wn))
                        continue;
                      const { rect: lo, metrics: gc, baselineOffset: co } = Wn;
                      Bi.push({
                        glyph: Li,
                        imageName: wi.imageName,
                        x: Vr,
                        y: kr + co + -17,
                        vertical: vi,
                        scale: wi.scale,
                        fontStack: wi.fontStack,
                        sectionIndex: zi,
                        metrics: gc,
                        rect: lo,
                      }),
                        vi
                          ? ((et.verticalizable = !0),
                            (Vr +=
                              (wi.imageName ? gc.advance : Ai) * wi.scale + St))
                          : (Vr += gc.advance * wi.scale + St);
                    }
                    Bi.length !== 0 &&
                      ((bn = Math.max(Vr - St, bn)),
                      mx(Bi, 0, Bi.length - 1, bi)),
                      (Vr = 0),
                      (Fi.lineOffset = Math.max(aa, (ki - 1) * Ai));
                    const Ei = rr * ki + aa;
                    (kr += Ei), (ai = Math.max(Ei, ai)), ++za;
                  }
                  const { horizontalAlign: ca, verticalAlign: Ri } = Uf(Fr);
                  (function (ni, ki, Fi, Bi, aa, La, Ei, ua, wi) {
                    const zi = (ki - Fi) * aa;
                    let Li = 0;
                    Li = La !== Ei ? -ua * Bi - -17 : -Bi * wi * Ei + 0.5 * Ei;
                    for (const vi of ni)
                      for (const Wn of vi.positionedGlyphs)
                        (Wn.x += zi), (Wn.y += Li);
                  })(et.positionedLines, bi, ca, Ri, bn, ai, rr, kr, Yt.length),
                    (et.top += -Ri * kr),
                    (et.bottom = et.top + kr),
                    (et.left += -ca * bn),
                    (et.right = et.left + bn);
                })(Ce, t, r, a, ie, m, v, b, R, C, U, X),
                !(function (et) {
                  for (const ht of et)
                    if (ht.positionedGlyphs.length !== 0) return !1;
                  return !0;
                })(ye) && Ce
              );
            }
            const op = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              lx = {
                10: !0,
                32: !0,
                38: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              },
              cx = { 40: !0 };
            function zg(n, t, r, a, c, p) {
              if (t.imageName) {
                const m = a[t.imageName];
                return m ? (m.displaySize[0] * t.scale * Ai) / p + c : 0;
              }
              {
                const m = r[t.fontStack],
                  v = m && m[n];
                return v ? v.metrics.advance * t.scale + c : 0;
              }
            }
            function Lg(n, t, r, a) {
              const c = Math.pow(n - t, 2);
              return a ? (n < t ? c / 2 : 2 * c) : c + Math.abs(r) * r;
            }
            function ux(n, t, r) {
              let a = 0;
              return (
                n === 10 && (a -= 1e4),
                r && (a += 150),
                (n !== 40 && n !== 65288) || (a += 50),
                (t !== 41 && t !== 65289) || (a += 50),
                a
              );
            }
            function Dg(n, t, r, a, c, p) {
              let m = null,
                v = Lg(t, r, c, p);
              for (const b of a) {
                const C = Lg(t - b.x, r, c, p) + b.badness;
                C <= v && ((m = b), (v = C));
              }
              return { index: n, x: t, priorBreak: m, badness: v };
            }
            function Rg(n) {
              return n ? Rg(n.priorBreak).concat(n.index) : [];
            }
            function qf(n, t, r, a, c, p) {
              if (!n) return [];
              const m = [],
                v = (function (R, U, Z, X, Q, ie) {
                  let he = 0;
                  for (let Oe = 0; Oe < R.length(); Oe++) {
                    const ye = R.getSection(Oe);
                    he += zg(R.getCharCode(Oe), ye, X, Q, U, ie);
                  }
                  return he / Math.max(1, Math.ceil(he / Z));
                })(n, t, r, a, c, p),
                b = n.text.indexOf("‚Äã") >= 0;
              let C = 0;
              for (let R = 0; R < n.length(); R++) {
                const U = n.getSection(R),
                  Z = n.getCharCode(R);
                if (
                  (op[Z] || (C += zg(Z, U, a, c, t, p)), R < n.length() - 1)
                ) {
                  const X =
                    !((I = Z) < 11904) &&
                    (!!mn["CJK Compatibility Forms"](I) ||
                      !!mn["CJK Compatibility"](I) ||
                      !!mn["CJK Strokes"](I) ||
                      !!mn["CJK Symbols and Punctuation"](I) ||
                      !!mn["Enclosed CJK Letters and Months"](I) ||
                      !!mn["Halfwidth and Fullwidth Forms"](I) ||
                      !!mn["Ideographic Description Characters"](I) ||
                      !!mn["Vertical Forms"](I) ||
                      yu.test(String.fromCodePoint(I)));
                  (lx[Z] ||
                    X ||
                    U.imageName ||
                    (R !== n.length() - 2 && cx[n.getCharCode(R + 1)])) &&
                    m.push(
                      Dg(
                        R + 1,
                        C,
                        v,
                        m,
                        ux(Z, n.getCharCode(R + 1), X && b),
                        !1
                      )
                    );
                }
              }
              var I;
              return Rg(Dg(n.length(), C, v, m, 0, !0));
            }
            function Uf(n) {
              let t = 0.5,
                r = 0.5;
              switch (n) {
                case "right":
                case "top-right":
                case "bottom-right":
                  t = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  t = 0;
              }
              switch (n) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  r = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  r = 0;
              }
              return { horizontalAlign: t, verticalAlign: r };
            }
            function hx(n, t, r) {
              const a = t.getMaxScale() * Ai,
                { maxImageWidth: c, maxImageHeight: p } = t.getMaxImageSize(n),
                m = Math.max(a, p * r);
              return {
                verticalLineContentWidth: Math.max(a, c * r),
                horizontalLineContentHeight: m,
              };
            }
            function Fg(n) {
              switch (n) {
                case "top":
                  return 0;
                case "center":
                  return 0.5;
                default:
                  return 1;
              }
            }
            function dx(n, t, r) {
              return !(
                n === T.as.horizontal ||
                (!t && !Yl(r)) ||
                (t &&
                  (op[r] ||
                    ((a = r),
                    new RegExp("\\p{sc=Arab}", "u").test(
                      String.fromCodePoint(a)
                    ))))
              );
              var a;
            }
            function px(n, t, r, a, c, p) {
              const m = p[n.fontStack],
                v = (function (C, I, R, U) {
                  if (C && C.rect) return C;
                  const Z = I[R.fontStack],
                    X = Z && Z[U];
                  return X ? { rect: null, metrics: X.metrics } : null;
                })(m && m[t], c, n, t);
              if (v === null) return null;
              let b;
              if (r) b = a.verticalLineContentWidth - n.scale * Ai;
              else {
                const C = Fg(n.verticalAlign);
                b = (a.horizontalLineContentHeight - n.scale * Ai) * C;
              }
              return { rect: v.rect, metrics: v.metrics, baselineOffset: b };
            }
            function fx(n, t, r, a, c) {
              const p = c[n.imageName];
              if (!p) return null;
              const m = p.paddedRect,
                v = p.displaySize,
                b = {
                  width: v[0],
                  height: v[1],
                  left: 1,
                  top: -3,
                  advance: t ? v[1] : v[0],
                };
              let C;
              if (t) C = a.verticalLineContentWidth - v[1] * n.scale;
              else {
                const I = Fg(n.verticalAlign);
                C = (a.horizontalLineContentHeight - v[1] * n.scale) * I;
              }
              return {
                rect: m,
                metrics: b,
                baselineOffset: C,
                imageOffset: (t ? v[0] : v[1]) * n.scale - Ai * r,
              };
            }
            function mx(n, t, r, a) {
              if (a === 0) return;
              const c = n[r],
                p = (n[r].x + c.metrics.advance * c.scale) * a;
              for (let m = t; m <= r; m++) n[m].x -= p;
            }
            function _x(n, t, r) {
              const { horizontalAlign: a, verticalAlign: c } = Uf(r),
                p = t[0] - n.displaySize[0] * a,
                m = t[1] - n.displaySize[1] * c;
              return {
                image: n,
                top: m,
                bottom: m + n.displaySize[1],
                left: p,
                right: p + n.displaySize[0],
              };
            }
            function Bg(n) {
              var t, r;
              let a = n.left,
                c = n.top,
                p = n.right - a,
                m = n.bottom - c;
              const v =
                  (t = n.image.textFitWidth) !== null && t !== void 0
                    ? t
                    : "stretchOrShrink",
                b =
                  (r = n.image.textFitHeight) !== null && r !== void 0
                    ? r
                    : "stretchOrShrink",
                C =
                  (n.image.content[2] - n.image.content[0]) /
                  (n.image.content[3] - n.image.content[1]);
              if (b === "proportional") {
                if (
                  (v === "stretchOnly" && p / m < C) ||
                  v === "proportional"
                ) {
                  const I = Math.ceil(m * C);
                  (a *= I / p), (p = I);
                }
              } else if (
                v === "proportional" &&
                b === "stretchOnly" &&
                C !== 0 &&
                p / m > C
              ) {
                const I = Math.ceil(p / C);
                (c *= I / m), (m = I);
              }
              return { x1: a, y1: c, x2: a + p, y2: c + m };
            }
            function Og(n, t, r, a, c, p) {
              const m = n.image;
              let v;
              if (m.content) {
                const ie = m.content,
                  he = m.pixelRatio || 1;
                v = [
                  ie[0] / he,
                  ie[1] / he,
                  m.displaySize[0] - ie[2] / he,
                  m.displaySize[1] - ie[3] / he,
                ];
              }
              const b = t.left * p,
                C = t.right * p;
              let I, R, U, Z;
              r === "width" || r === "both"
                ? ((Z = c[0] + b - a[3]), (R = c[0] + C + a[1]))
                : ((Z = c[0] + (b + C - m.displaySize[0]) / 2),
                  (R = Z + m.displaySize[0]));
              const X = t.top * p,
                Q = t.bottom * p;
              return (
                r === "height" || r === "both"
                  ? ((I = c[1] + X - a[0]), (U = c[1] + Q + a[2]))
                  : ((I = c[1] + (X + Q - m.displaySize[1]) / 2),
                    (U = I + m.displaySize[1])),
                {
                  image: m,
                  top: I,
                  right: R,
                  bottom: U,
                  left: Z,
                  collisionPadding: v,
                }
              );
            }
            const rs = 128,
              Ms = 32640;
            function Ng(n, t) {
              const { expression: r } = t;
              if (r.kind === "constant")
                return {
                  kind: "constant",
                  layoutSize: r.evaluate(new On(n + 1)),
                };
              if (r.kind === "source") return { kind: "source" };
              {
                const { zoomStops: a, interpolationType: c } = r;
                let p = 0;
                for (; p < a.length && a[p] <= n; ) p++;
                p = Math.max(0, p - 1);
                let m = p;
                for (; m < a.length && a[m] < n + 1; ) m++;
                m = Math.min(a.length - 1, m);
                const v = a[p],
                  b = a[m];
                return r.kind === "composite"
                  ? {
                      kind: "composite",
                      minZoom: v,
                      maxZoom: b,
                      interpolationType: c,
                    }
                  : {
                      kind: "camera",
                      minZoom: v,
                      maxZoom: b,
                      minSize: r.evaluate(new On(v)),
                      maxSize: r.evaluate(new On(b)),
                      interpolationType: c,
                    };
              }
            }
            function Zf(n, t, r) {
              let a = "never";
              const c = n.get(t);
              return c ? (a = c) : n.get(r) && (a = "always"), a;
            }
            const gx = [
              {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0,
              },
            ];
            function sp(n, t, r, a, c, p, m, v, b, C, I, R, U) {
              const Z = v ? Math.min(Ms, Math.round(v[0])) : 0,
                X = v ? Math.min(Ms, Math.round(v[1])) : 0;
              n.emplaceBack(
                t,
                r,
                Math.round(32 * a),
                Math.round(32 * c),
                p,
                m,
                (Z << 1) + (b ? 1 : 0),
                X,
                16 * C,
                16 * I,
                256 * R,
                256 * U
              );
            }
            function Gf(n, t, r) {
              n.emplaceBack(t.x, t.y, r),
                n.emplaceBack(t.x, t.y, r),
                n.emplaceBack(t.x, t.y, r),
                n.emplaceBack(t.x, t.y, r);
            }
            function vx(n) {
              for (const t of n.sections) if (xf(t.text)) return !0;
              return !1;
            }
            class $f {
              constructor(t) {
                (this.layoutVertexArray = new Qe()),
                  (this.indexArray = new Pt()),
                  (this.programConfigurations = t),
                  (this.segments = new cn()),
                  (this.dynamicLayoutVertexArray = new tt()),
                  (this.opacityVertexArray = new ot()),
                  (this.hasVisibleVertices = !1),
                  (this.placedSymbolArray = new k());
              }
              isEmpty() {
                return (
                  this.layoutVertexArray.length === 0 &&
                  this.indexArray.length === 0 &&
                  this.dynamicLayoutVertexArray.length === 0 &&
                  this.opacityVertexArray.length === 0
                );
              }
              upload(t, r, a, c) {
                this.isEmpty() ||
                  (a &&
                    ((this.layoutVertexBuffer = t.createVertexBuffer(
                      this.layoutVertexArray,
                      G1.members
                    )),
                    (this.indexBuffer = t.createIndexBuffer(
                      this.indexArray,
                      r
                    )),
                    (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      $1.members,
                      !0
                    )),
                    (this.opacityVertexBuffer = t.createVertexBuffer(
                      this.opacityVertexArray,
                      gx,
                      !0
                    )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (a || c) && this.programConfigurations.upload(t));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy());
              }
            }
            hr("SymbolBuffers", $f);
            class Hf {
              constructor(t, r, a) {
                (this.layoutVertexArray = new t()),
                  (this.layoutAttributes = r),
                  (this.indexArray = new a()),
                  (this.segments = new cn()),
                  (this.collisionVertexArray = new Ht());
              }
              upload(t) {
                (this.layoutVertexBuffer = t.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes
                )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = t.createVertexBuffer(
                    this.collisionVertexArray,
                    H1.members,
                    !0
                  ));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy());
              }
            }
            hr("CollisionBuffers", Hf);
            class fc {
              constructor(t) {
                (this.collisionBoxArray = t.collisionBoxArray),
                  (this.zoom = t.zoom),
                  (this.overscaling = Lt(globalThis)
                    ? Math.min(t.overscaling, 128)
                    : t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((m) => m.id)),
                  (this.index = t.index),
                  (this.pixelRatio = t.pixelRatio),
                  (this.sourceLayerIndex = t.sourceLayerIndex),
                  (this.hasDependencies = !1),
                  (this.hasRTLText = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []);
                const r = this.layers[0]._unevaluatedLayout._values;
                (this.textSizeData = Ng(this.zoom, r["text-size"])),
                  (this.iconSizeData = Ng(this.zoom, r["icon-size"]));
                const a = this.layers[0].layout,
                  c = a.get("symbol-sort-key"),
                  p = a.get("symbol-z-order");
                (this.canOverlap =
                  Zf(a, "text-overlap", "text-allow-overlap") !== "never" ||
                  Zf(a, "icon-overlap", "icon-allow-overlap") !== "never" ||
                  a.get("text-ignore-placement") ||
                  a.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    p !== "viewport-y" && !c.isConstant()),
                  (this.sortFeaturesByY =
                    (p === "viewport-y" ||
                      (p === "auto" && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  a.get("symbol-placement") === "point" &&
                    (this.writingModes = a
                      .get("text-writing-mode")
                      .map((m) => T.as[m])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((m) => m.isStateDependent())
                    .map((m) => m.id)),
                  (this.sourceID = t.sourceID);
              }
              createArrays() {
                (this.text = new $f(
                  new es(this.layers, this.zoom, (t) => /^text/.test(t))
                )),
                  (this.icon = new $f(
                    new es(this.layers, this.zoom, (t) => /^icon/.test(t))
                  )),
                  (this.glyphOffsetArray = new F()),
                  (this.lineVertexArray = new $()),
                  (this.symbolInstances = new V()),
                  (this.textAnchorOffsets = new ae());
              }
              calculateGlyphDependencies(t, r, a, c, p) {
                for (let m = 0; m < t.length; m++)
                  if (((r[t.charCodeAt(m)] = !0), (a || c) && p)) {
                    const v = ju[t.charAt(m)];
                    v && (r[v.charCodeAt(0)] = !0);
                  }
              }
              populate(t, r, a) {
                const c = this.layers[0],
                  p = c.layout,
                  m = p.get("text-font"),
                  v = p.get("text-field"),
                  b = p.get("icon-image"),
                  C =
                    (v.value.kind !== "constant" ||
                      (v.value.value instanceof kn &&
                        !v.value.value.isEmpty()) ||
                      v.value.value.toString().length > 0) &&
                    (m.value.kind !== "constant" || m.value.value.length > 0),
                  I =
                    b.value.kind !== "constant" ||
                    !!b.value.value ||
                    Object.keys(b.parameters).length > 0,
                  R = p.get("symbol-sort-key");
                if (((this.features = []), !C && !I)) return;
                const U = r.iconDependencies,
                  Z = r.glyphDependencies,
                  X = r.availableImages,
                  Q = new On(this.zoom);
                for (const {
                  feature: ie,
                  id: he,
                  index: Oe,
                  sourceLayerIndex: ye,
                } of t) {
                  const Ce = c._featureFilter.needGeometry,
                    et = Co(ie, Ce);
                  if (!c._featureFilter.filter(Q, et, a)) continue;
                  let ht, Rt;
                  if ((Ce || (et.geometry = so(ie)), C)) {
                    const Yt = c.getValueAndResolveTokens(
                        "text-field",
                        et,
                        a,
                        X
                      ),
                      rr = kn.factory(Yt),
                      Fr = (this.hasRTLText = this.hasRTLText || vx(rr));
                    (!Fr ||
                      no.getRTLTextPluginStatus() === "unavailable" ||
                      (Fr && no.isParsed())) &&
                      (ht = X1(rr, c, et));
                  }
                  if (I) {
                    const Yt = c.getValueAndResolveTokens(
                      "icon-image",
                      et,
                      a,
                      X
                    );
                    Rt = Yt instanceof En ? Yt : En.fromString(Yt);
                  }
                  if (!ht && !Rt) continue;
                  const or = this.sortFeaturesByKey
                    ? R.evaluate(et, {}, a)
                    : void 0;
                  if (
                    (this.features.push({
                      id: he,
                      text: ht,
                      icon: Rt,
                      index: Oe,
                      sourceLayerIndex: ye,
                      geometry: et.geometry,
                      properties: ie.properties,
                      type: hc.types[ie.type],
                      sortKey: or,
                    }),
                    Rt && (U[Rt.name] = !0),
                    ht)
                  ) {
                    const Yt = m.evaluate(et, {}, a).join(","),
                      rr =
                        p.get("text-rotation-alignment") !== "viewport" &&
                        p.get("symbol-placement") !== "point";
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(T.as.vertical) >= 0;
                    for (const Fr of ht.sections)
                      if (Fr.image) U[Fr.image.name] = !0;
                      else {
                        const er = gu(ht.toString()),
                          nr = Fr.fontStack || Yt,
                          St = (Z[nr] = Z[nr] || {});
                        this.calculateGlyphDependencies(
                          Fr.text,
                          St,
                          rr,
                          this.allowVerticalPlacement,
                          er
                        );
                      }
                  }
                }
                p.get("symbol-placement") === "line" &&
                  (this.features = (function (ie) {
                    const he = {},
                      Oe = {},
                      ye = [];
                    let Ce = 0;
                    function et(Yt) {
                      ye.push(ie[Yt]), Ce++;
                    }
                    function ht(Yt, rr, Fr) {
                      const er = Oe[Yt];
                      return (
                        delete Oe[Yt],
                        (Oe[rr] = er),
                        ye[er].geometry[0].pop(),
                        (ye[er].geometry[0] = ye[er].geometry[0].concat(Fr[0])),
                        er
                      );
                    }
                    function Rt(Yt, rr, Fr) {
                      const er = he[rr];
                      return (
                        delete he[rr],
                        (he[Yt] = er),
                        ye[er].geometry[0].shift(),
                        (ye[er].geometry[0] = Fr[0].concat(ye[er].geometry[0])),
                        er
                      );
                    }
                    function or(Yt, rr, Fr) {
                      const er = Fr ? rr[0][rr[0].length - 1] : rr[0][0];
                      return `${Yt}:${er.x}:${er.y}`;
                    }
                    for (let Yt = 0; Yt < ie.length; Yt++) {
                      const rr = ie[Yt],
                        Fr = rr.geometry,
                        er = rr.text ? rr.text.toString() : null;
                      if (!er) {
                        et(Yt);
                        continue;
                      }
                      const nr = or(er, Fr),
                        St = or(er, Fr, !0);
                      if (nr in Oe && St in he && Oe[nr] !== he[St]) {
                        const Hr = Rt(nr, St, Fr),
                          Kr = ht(nr, St, ye[Hr].geometry);
                        delete he[nr],
                          delete Oe[St],
                          (Oe[or(er, ye[Kr].geometry, !0)] = Kr),
                          (ye[Hr].geometry = null);
                      } else
                        nr in Oe
                          ? ht(nr, St, Fr)
                          : St in he
                          ? Rt(nr, St, Fr)
                          : (et(Yt), (he[nr] = Ce - 1), (Oe[St] = Ce - 1));
                    }
                    return ye.filter((Yt) => Yt.geometry);
                  })(this.features)),
                  this.sortFeaturesByKey &&
                    this.features.sort((ie, he) => ie.sortKey - he.sortKey);
              }
              update(t, r, a) {
                this.stateDependentLayers.length &&
                  (this.text.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.layers,
                    { imagePositions: a }
                  ),
                  this.icon.programConfigurations.updatePaintArrays(
                    t,
                    r,
                    this.layers,
                    { imagePositions: a }
                  ));
              }
              isEmpty() {
                return this.symbolInstances.length === 0 && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(t) {
                !this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(t),
                  this.iconCollisionBox.upload(t)),
                  this.text.upload(
                    t,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload
                  ),
                  this.icon.upload(
                    t,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload
                  ),
                  (this.uploaded = !0);
              }
              destroyDebugData() {
                this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy();
              }
              destroy() {
                this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData();
              }
              addToLineVertexArray(t, r) {
                const a = this.lineVertexArray.length;
                if (t.segment !== void 0) {
                  let c = t.dist(r[t.segment + 1]),
                    p = t.dist(r[t.segment]);
                  const m = {};
                  for (let v = t.segment + 1; v < r.length; v++)
                    (m[v] = {
                      x: r[v].x,
                      y: r[v].y,
                      tileUnitDistanceFromAnchor: c,
                    }),
                      v < r.length - 1 && (c += r[v + 1].dist(r[v]));
                  for (let v = t.segment || 0; v >= 0; v--)
                    (m[v] = {
                      x: r[v].x,
                      y: r[v].y,
                      tileUnitDistanceFromAnchor: p,
                    }),
                      v > 0 && (p += r[v - 1].dist(r[v]));
                  for (let v = 0; v < r.length; v++) {
                    const b = m[v];
                    this.lineVertexArray.emplaceBack(
                      b.x,
                      b.y,
                      b.tileUnitDistanceFromAnchor
                    );
                  }
                }
                return {
                  lineStartIndex: a,
                  lineLength: this.lineVertexArray.length - a,
                };
              }
              addSymbols(t, r, a, c, p, m, v, b, C, I, R, U) {
                const Z = t.indexArray,
                  X = t.layoutVertexArray,
                  Q = t.segments.prepareSegment(
                    4 * r.length,
                    X,
                    Z,
                    this.canOverlap ? m.sortKey : void 0
                  ),
                  ie = this.glyphOffsetArray.length,
                  he = Q.vertexLength,
                  Oe =
                    this.allowVerticalPlacement && v === T.as.vertical
                      ? Math.PI / 2
                      : 0,
                  ye = m.text && m.text.sections;
                for (let Ce = 0; Ce < r.length; Ce++) {
                  const {
                      tl: et,
                      tr: ht,
                      bl: Rt,
                      br: or,
                      tex: Yt,
                      pixelOffsetTL: rr,
                      pixelOffsetBR: Fr,
                      minFontScaleX: er,
                      minFontScaleY: nr,
                      glyphOffset: St,
                      isSDF: Hr,
                      sectionIndex: Kr,
                    } = r[Ce],
                    Vr = Q.vertexLength,
                    kr = St[1];
                  sp(
                    X,
                    b.x,
                    b.y,
                    et.x,
                    kr + et.y,
                    Yt.x,
                    Yt.y,
                    a,
                    Hr,
                    rr.x,
                    rr.y,
                    er,
                    nr
                  ),
                    sp(
                      X,
                      b.x,
                      b.y,
                      ht.x,
                      kr + ht.y,
                      Yt.x + Yt.w,
                      Yt.y,
                      a,
                      Hr,
                      Fr.x,
                      rr.y,
                      er,
                      nr
                    ),
                    sp(
                      X,
                      b.x,
                      b.y,
                      Rt.x,
                      kr + Rt.y,
                      Yt.x,
                      Yt.y + Yt.h,
                      a,
                      Hr,
                      rr.x,
                      Fr.y,
                      er,
                      nr
                    ),
                    sp(
                      X,
                      b.x,
                      b.y,
                      or.x,
                      kr + or.y,
                      Yt.x + Yt.w,
                      Yt.y + Yt.h,
                      a,
                      Hr,
                      Fr.x,
                      Fr.y,
                      er,
                      nr
                    ),
                    Gf(t.dynamicLayoutVertexArray, b, Oe),
                    Z.emplaceBack(Vr, Vr + 2, Vr + 1),
                    Z.emplaceBack(Vr + 1, Vr + 2, Vr + 3),
                    (Q.vertexLength += 4),
                    (Q.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(St[0]),
                    (Ce !== r.length - 1 && Kr === r[Ce + 1].sectionIndex) ||
                      t.programConfigurations.populatePaintArrays(
                        X.length,
                        m,
                        m.index,
                        {
                          imagePositions: {},
                          canonical: U,
                          formattedSection: ye && ye[Kr],
                        }
                      );
                }
                t.placedSymbolArray.emplaceBack(
                  b.x,
                  b.y,
                  ie,
                  this.glyphOffsetArray.length - ie,
                  he,
                  C,
                  I,
                  b.segment,
                  a ? a[0] : 0,
                  a ? a[1] : 0,
                  c[0],
                  c[1],
                  v,
                  0,
                  !1,
                  0,
                  R
                );
              }
              _addCollisionDebugVertex(t, r, a, c, p, m) {
                return (
                  r.emplaceBack(0, 0),
                  t.emplaceBack(
                    a.x,
                    a.y,
                    c,
                    p,
                    Math.round(m.x),
                    Math.round(m.y)
                  )
                );
              }
              addCollisionDebugVertices(t, r, a, c, p, m, v) {
                const b = p.segments.prepareSegment(
                    4,
                    p.layoutVertexArray,
                    p.indexArray
                  ),
                  C = b.vertexLength,
                  I = p.layoutVertexArray,
                  R = p.collisionVertexArray,
                  U = v.anchorX,
                  Z = v.anchorY;
                this._addCollisionDebugVertex(I, R, m, U, Z, new B(t, r)),
                  this._addCollisionDebugVertex(I, R, m, U, Z, new B(a, r)),
                  this._addCollisionDebugVertex(I, R, m, U, Z, new B(a, c)),
                  this._addCollisionDebugVertex(I, R, m, U, Z, new B(t, c)),
                  (b.vertexLength += 4);
                const X = p.indexArray;
                X.emplaceBack(C, C + 1),
                  X.emplaceBack(C + 1, C + 2),
                  X.emplaceBack(C + 2, C + 3),
                  X.emplaceBack(C + 3, C),
                  (b.primitiveLength += 4);
              }
              addDebugCollisionBoxes(t, r, a, c) {
                for (let p = t; p < r; p++) {
                  const m = this.collisionBoxArray.get(p);
                  this.addCollisionDebugVertices(
                    m.x1,
                    m.y1,
                    m.x2,
                    m.y2,
                    c ? this.textCollisionBox : this.iconCollisionBox,
                    m.anchorPoint,
                    a
                  );
                }
              }
              generateCollisionDebugBuffers() {
                this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new Hf(Zt, Pg.members, yr)),
                  (this.iconCollisionBox = new Hf(Zt, Pg.members, yr));
                for (let t = 0; t < this.symbolInstances.length; t++) {
                  const r = this.symbolInstances.get(t);
                  this.addDebugCollisionBoxes(
                    r.textBoxStartIndex,
                    r.textBoxEndIndex,
                    r,
                    !0
                  ),
                    this.addDebugCollisionBoxes(
                      r.verticalTextBoxStartIndex,
                      r.verticalTextBoxEndIndex,
                      r,
                      !0
                    ),
                    this.addDebugCollisionBoxes(
                      r.iconBoxStartIndex,
                      r.iconBoxEndIndex,
                      r,
                      !1
                    ),
                    this.addDebugCollisionBoxes(
                      r.verticalIconBoxStartIndex,
                      r.verticalIconBoxEndIndex,
                      r,
                      !1
                    );
                }
              }
              _deserializeCollisionBoxesForSymbol(t, r, a, c, p, m, v, b, C) {
                const I = {};
                for (let R = r; R < a; R++) {
                  const U = t.get(R);
                  (I.textBox = {
                    x1: U.x1,
                    y1: U.y1,
                    x2: U.x2,
                    y2: U.y2,
                    anchorPointX: U.anchorPointX,
                    anchorPointY: U.anchorPointY,
                  }),
                    (I.textFeatureIndex = U.featureIndex);
                  break;
                }
                for (let R = c; R < p; R++) {
                  const U = t.get(R);
                  (I.verticalTextBox = {
                    x1: U.x1,
                    y1: U.y1,
                    x2: U.x2,
                    y2: U.y2,
                    anchorPointX: U.anchorPointX,
                    anchorPointY: U.anchorPointY,
                  }),
                    (I.verticalTextFeatureIndex = U.featureIndex);
                  break;
                }
                for (let R = m; R < v; R++) {
                  const U = t.get(R);
                  (I.iconBox = {
                    x1: U.x1,
                    y1: U.y1,
                    x2: U.x2,
                    y2: U.y2,
                    anchorPointX: U.anchorPointX,
                    anchorPointY: U.anchorPointY,
                  }),
                    (I.iconFeatureIndex = U.featureIndex);
                  break;
                }
                for (let R = b; R < C; R++) {
                  const U = t.get(R);
                  (I.verticalIconBox = {
                    x1: U.x1,
                    y1: U.y1,
                    x2: U.x2,
                    y2: U.y2,
                    anchorPointX: U.anchorPointX,
                    anchorPointY: U.anchorPointY,
                  }),
                    (I.verticalIconFeatureIndex = U.featureIndex);
                  break;
                }
                return I;
              }
              deserializeCollisionBoxes(t) {
                this.collisionArrays = [];
                for (let r = 0; r < this.symbolInstances.length; r++) {
                  const a = this.symbolInstances.get(r);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      t,
                      a.textBoxStartIndex,
                      a.textBoxEndIndex,
                      a.verticalTextBoxStartIndex,
                      a.verticalTextBoxEndIndex,
                      a.iconBoxStartIndex,
                      a.iconBoxEndIndex,
                      a.verticalIconBoxStartIndex,
                      a.verticalIconBoxEndIndex
                    )
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              addIndicesForPlacedSymbol(t, r) {
                const a = t.placedSymbolArray.get(r),
                  c = a.vertexStartIndex + 4 * a.numGlyphs;
                for (let p = a.vertexStartIndex; p < c; p += 4)
                  t.indexArray.emplaceBack(p, p + 2, p + 1),
                    t.indexArray.emplaceBack(p + 1, p + 2, p + 3);
              }
              getSortedSymbolIndexes(t) {
                if (
                  this.sortedAngle === t &&
                  this.symbolInstanceIndexes !== void 0
                )
                  return this.symbolInstanceIndexes;
                const r = Math.sin(t),
                  a = Math.cos(t),
                  c = [],
                  p = [],
                  m = [];
                for (let v = 0; v < this.symbolInstances.length; ++v) {
                  m.push(v);
                  const b = this.symbolInstances.get(v);
                  c.push(0 | Math.round(r * b.anchorX + a * b.anchorY)),
                    p.push(b.featureIndex);
                }
                return m.sort((v, b) => c[v] - c[b] || p[b] - p[v]), m;
              }
              addToSortKeyRanges(t, r) {
                const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                a && a.sortKey === r
                  ? (a.symbolInstanceEnd = t + 1)
                  : this.sortKeyRanges.push({
                      sortKey: r,
                      symbolInstanceStart: t,
                      symbolInstanceEnd: t + 1,
                    });
              }
              sortFeatures(t) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== t &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
                    (this.sortedAngle = t),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []);
                  for (const r of this.symbolInstanceIndexes) {
                    const a = this.symbolInstances.get(r);
                    this.featureSortOrder.push(a.featureIndex),
                      [
                        a.rightJustifiedTextSymbolIndex,
                        a.centerJustifiedTextSymbolIndex,
                        a.leftJustifiedTextSymbolIndex,
                      ].forEach((c, p, m) => {
                        c >= 0 &&
                          m.indexOf(c) === p &&
                          this.addIndicesForPlacedSymbol(this.text, c);
                      }),
                      a.verticalPlacedTextSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.text,
                          a.verticalPlacedTextSymbolIndex
                        ),
                      a.placedIconSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.icon,
                          a.placedIconSymbolIndex
                        ),
                      a.verticalPlacedIconSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.icon,
                          a.verticalPlacedIconSymbolIndex
                        );
                  }
                  this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
              }
            }
            let jg, Vg;
            hr("SymbolBucket", fc, {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (fc.MAX_GLYPHS = 65535),
              (fc.addDynamicAttributes = Gf);
            var Wf = {
              get paint() {
                return (Vg =
                  Vg ||
                  new Ui({
                    "icon-opacity": new Gr(_e.paint_symbol["icon-opacity"]),
                    "icon-color": new Gr(_e.paint_symbol["icon-color"]),
                    "icon-halo-color": new Gr(
                      _e.paint_symbol["icon-halo-color"]
                    ),
                    "icon-halo-width": new Gr(
                      _e.paint_symbol["icon-halo-width"]
                    ),
                    "icon-halo-blur": new Gr(_e.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new zr(_e.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new zr(
                      _e.paint_symbol["icon-translate-anchor"]
                    ),
                    "text-opacity": new Gr(_e.paint_symbol["text-opacity"]),
                    "text-color": new Gr(_e.paint_symbol["text-color"], {
                      runtimeType: gt,
                      getOverride: (n) => n.textColor,
                      hasOverride: (n) => !!n.textColor,
                    }),
                    "text-halo-color": new Gr(
                      _e.paint_symbol["text-halo-color"]
                    ),
                    "text-halo-width": new Gr(
                      _e.paint_symbol["text-halo-width"]
                    ),
                    "text-halo-blur": new Gr(_e.paint_symbol["text-halo-blur"]),
                    "text-translate": new zr(_e.paint_symbol["text-translate"]),
                    "text-translate-anchor": new zr(
                      _e.paint_symbol["text-translate-anchor"]
                    ),
                  }));
              },
              get layout() {
                return (jg =
                  jg ||
                  new Ui({
                    "symbol-placement": new zr(
                      _e.layout_symbol["symbol-placement"]
                    ),
                    "symbol-spacing": new zr(
                      _e.layout_symbol["symbol-spacing"]
                    ),
                    "symbol-avoid-edges": new zr(
                      _e.layout_symbol["symbol-avoid-edges"]
                    ),
                    "symbol-sort-key": new Gr(
                      _e.layout_symbol["symbol-sort-key"]
                    ),
                    "symbol-z-order": new zr(
                      _e.layout_symbol["symbol-z-order"]
                    ),
                    "icon-allow-overlap": new zr(
                      _e.layout_symbol["icon-allow-overlap"]
                    ),
                    "icon-overlap": new zr(_e.layout_symbol["icon-overlap"]),
                    "icon-ignore-placement": new zr(
                      _e.layout_symbol["icon-ignore-placement"]
                    ),
                    "icon-optional": new zr(_e.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new zr(
                      _e.layout_symbol["icon-rotation-alignment"]
                    ),
                    "icon-size": new Gr(_e.layout_symbol["icon-size"]),
                    "icon-text-fit": new zr(_e.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new zr(
                      _e.layout_symbol["icon-text-fit-padding"]
                    ),
                    "icon-image": new Gr(_e.layout_symbol["icon-image"]),
                    "icon-rotate": new Gr(_e.layout_symbol["icon-rotate"]),
                    "icon-padding": new Gr(_e.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new zr(
                      _e.layout_symbol["icon-keep-upright"]
                    ),
                    "icon-offset": new Gr(_e.layout_symbol["icon-offset"]),
                    "icon-anchor": new Gr(_e.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new zr(
                      _e.layout_symbol["icon-pitch-alignment"]
                    ),
                    "text-pitch-alignment": new zr(
                      _e.layout_symbol["text-pitch-alignment"]
                    ),
                    "text-rotation-alignment": new zr(
                      _e.layout_symbol["text-rotation-alignment"]
                    ),
                    "text-field": new Gr(_e.layout_symbol["text-field"]),
                    "text-font": new Gr(_e.layout_symbol["text-font"]),
                    "text-size": new Gr(_e.layout_symbol["text-size"]),
                    "text-max-width": new Gr(
                      _e.layout_symbol["text-max-width"]
                    ),
                    "text-line-height": new zr(
                      _e.layout_symbol["text-line-height"]
                    ),
                    "text-letter-spacing": new Gr(
                      _e.layout_symbol["text-letter-spacing"]
                    ),
                    "text-justify": new Gr(_e.layout_symbol["text-justify"]),
                    "text-radial-offset": new Gr(
                      _e.layout_symbol["text-radial-offset"]
                    ),
                    "text-variable-anchor": new zr(
                      _e.layout_symbol["text-variable-anchor"]
                    ),
                    "text-variable-anchor-offset": new Gr(
                      _e.layout_symbol["text-variable-anchor-offset"]
                    ),
                    "text-anchor": new Gr(_e.layout_symbol["text-anchor"]),
                    "text-max-angle": new zr(
                      _e.layout_symbol["text-max-angle"]
                    ),
                    "text-writing-mode": new zr(
                      _e.layout_symbol["text-writing-mode"]
                    ),
                    "text-rotate": new Gr(_e.layout_symbol["text-rotate"]),
                    "text-padding": new zr(_e.layout_symbol["text-padding"]),
                    "text-keep-upright": new zr(
                      _e.layout_symbol["text-keep-upright"]
                    ),
                    "text-transform": new Gr(
                      _e.layout_symbol["text-transform"]
                    ),
                    "text-offset": new Gr(_e.layout_symbol["text-offset"]),
                    "text-allow-overlap": new zr(
                      _e.layout_symbol["text-allow-overlap"]
                    ),
                    "text-overlap": new zr(_e.layout_symbol["text-overlap"]),
                    "text-ignore-placement": new zr(
                      _e.layout_symbol["text-ignore-placement"]
                    ),
                    "text-optional": new zr(_e.layout_symbol["text-optional"]),
                  }));
              },
            };
            class qg {
              constructor(t) {
                if (t.property.overrides === void 0)
                  throw new Error(
                    "overrides must be provided to instantiate FormatSectionOverride class"
                  );
                (this.type = t.property.overrides
                  ? t.property.overrides.runtimeType
                  : Qt),
                  (this.defaultValue = t);
              }
              evaluate(t) {
                if (t.formattedSection) {
                  const r = this.defaultValue.property.overrides;
                  if (r && r.hasOverride(t.formattedSection))
                    return r.getOverride(t.formattedSection);
                }
                return t.feature && t.featureState
                  ? this.defaultValue.evaluate(t.feature, t.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(t) {
                this.defaultValue.isConstant() ||
                  t(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            hr("FormatSectionOverride", qg, { omit: ["defaultValue"] });
            class lp extends Aa {
              constructor(t, r) {
                super(t, Wf, r);
              }
              recalculate(t, r) {
                if (
                  (super.recalculate(t, r),
                  this.layout.get("icon-rotation-alignment") === "auto" &&
                    (this.layout._values["icon-rotation-alignment"] =
                      this.layout.get("symbol-placement") !== "point"
                        ? "map"
                        : "viewport"),
                  this.layout.get("text-rotation-alignment") === "auto" &&
                    (this.layout._values["text-rotation-alignment"] =
                      this.layout.get("symbol-placement") !== "point"
                        ? "map"
                        : "viewport"),
                  this.layout.get("text-pitch-alignment") === "auto" &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment") === "map"
                        ? "map"
                        : "viewport"),
                  this.layout.get("icon-pitch-alignment") === "auto" &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment")),
                  this.layout.get("symbol-placement") === "point")
                ) {
                  const a = this.layout.get("text-writing-mode");
                  if (a) {
                    const c = [];
                    for (const p of a) c.indexOf(p) < 0 && c.push(p);
                    this.layout._values["text-writing-mode"] = c;
                  } else
                    this.layout._values["text-writing-mode"] = ["horizontal"];
                }
                this._setPaintOverrides();
              }
              getValueAndResolveTokens(t, r, a, c) {
                const p = this.layout.get(t).evaluate(r, {}, a, c),
                  m = this._unevaluatedLayout._values[t];
                return m.isDataDriven() || jl(m.value) || !p
                  ? p
                  : (function (v, b) {
                      return b.replace(/{([^{}]+)}/g, (C, I) =>
                        v && I in v ? String(v[I]) : ""
                      );
                    })(r.properties, p);
              }
              createBucket(t) {
                return new fc(t);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                throw new Error("Should take a different path in FeatureIndex");
              }
              _setPaintOverrides() {
                for (const t of Wf.paint.overridableProperties) {
                  if (!lp.hasPaintOverride(this.layout, t)) continue;
                  const r = this.paint.get(t),
                    a = new qg(r),
                    c = new nu(a, r.property.specification);
                  let p = null;
                  (p =
                    r.value.kind === "constant" || r.value.kind === "source"
                      ? new Xs("source", c)
                      : new iu("composite", c, r.value.zoomStops)),
                    (this.paint._values[t] = new Ma(
                      r.property,
                      p,
                      r.parameters
                    ));
                }
              }
              _handleOverridablePaintPropertyUpdate(t, r, a) {
                return (
                  !(!this.layout || r.isDataDriven() || a.isDataDriven()) &&
                  lp.hasPaintOverride(this.layout, t)
                );
              }
              static hasPaintOverride(t, r) {
                const a = t.get("text-field"),
                  c = Wf.paint.properties[r];
                let p = !1;
                const m = (v) => {
                  for (const b of v)
                    if (c.overrides && c.overrides.hasOverride(b))
                      return void (p = !0);
                };
                if (a.value.kind === "constant" && a.value.value instanceof kn)
                  m(a.value.value.sections);
                else if (
                  a.value.kind === "source" ||
                  a.value.kind === "composite"
                ) {
                  const v = (C) => {
                      p ||
                        (C instanceof ta && Dn(C.value) === wr
                          ? m(C.value.sections)
                          : C instanceof Al
                          ? m(C.sections)
                          : C.eachChild(v));
                    },
                    b = a.value;
                  b._styleExpression && v(b._styleExpression.expression);
                }
                return p;
              }
            }
            let Ug;
            var yx = {
              get paint() {
                return (Ug =
                  Ug ||
                  new Ui({
                    "background-color": new zr(
                      _e.paint_background["background-color"]
                    ),
                    "background-pattern": new Gd(
                      _e.paint_background["background-pattern"]
                    ),
                    "background-opacity": new zr(
                      _e.paint_background["background-opacity"]
                    ),
                  }));
              },
            };
            class xx extends Aa {
              constructor(t, r) {
                super(t, yx, r);
              }
            }
            class bx extends Aa {
              constructor(t, r) {
                super(t, {}, r),
                  (this.onAdd = (a) => {
                    this.implementation.onAdd &&
                      this.implementation.onAdd(a, a.painter.context.gl);
                  }),
                  (this.onRemove = (a) => {
                    this.implementation.onRemove &&
                      this.implementation.onRemove(a, a.painter.context.gl);
                  }),
                  (this.implementation = t);
              }
              is3D() {
                return this.implementation.renderingMode === "3d";
              }
              hasOffscreenPass() {
                return this.implementation.prerender !== void 0;
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {
                return !1;
              }
              serialize() {
                throw new Error("Custom layers cannot be serialized");
              }
            }
            class wx {
              constructor(t) {
                (this._methodToThrottle = t),
                  (this._triggered = !1),
                  typeof MessageChannel < "u" &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      (this._triggered = !1), this._methodToThrottle();
                    }));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        (this._triggered = !1), this._methodToThrottle();
                      }, 0));
              }
              remove() {
                delete this._channel, (this._methodToThrottle = () => {});
              }
            }
            const Tx = { once: !0 },
              Xf = 63710088e-1;
            class As {
              constructor(t, r) {
                if (isNaN(t) || isNaN(r))
                  throw new Error(`Invalid LngLat object: (${t}, ${r})`);
                if (
                  ((this.lng = +t),
                  (this.lat = +r),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90"
                  );
              }
              wrap() {
                return new As(Ye(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(t) {
                const r = Math.PI / 180,
                  a = this.lat * r,
                  c = t.lat * r,
                  p =
                    Math.sin(a) * Math.sin(c) +
                    Math.cos(a) *
                      Math.cos(c) *
                      Math.cos((t.lng - this.lng) * r);
                return Xf * Math.acos(Math.min(p, 1));
              }
              static convert(t) {
                if (t instanceof As) return t;
                if (Array.isArray(t) && (t.length === 2 || t.length === 3))
                  return new As(Number(t[0]), Number(t[1]));
                if (!Array.isArray(t) && typeof t == "object" && t !== null)
                  return new As(
                    Number("lng" in t ? t.lng : t.lon),
                    Number(t.lat)
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
                );
              }
            }
            const Zg = 2 * Math.PI * Xf;
            function Gg(n) {
              return Zg * Math.cos((n * Math.PI) / 180);
            }
            function $g(n) {
              return (180 + n) / 360;
            }
            function Hg(n) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (n * Math.PI) / 360))) /
                360
              );
            }
            function Wg(n, t) {
              return n / Gg(t);
            }
            function Xg(n) {
              return 360 * n - 180;
            }
            function cp(n) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * n) * Math.PI) / 180)) -
                90
              );
            }
            function Yg(n, t) {
              return n * Gg(cp(t));
            }
            class qu {
              constructor(t, r, a = 0) {
                (this.x = +t), (this.y = +r), (this.z = +a);
              }
              static fromLngLat(t, r = 0) {
                const a = As.convert(t);
                return new qu($g(a.lng), Hg(a.lat), Wg(r, a.lat));
              }
              toLngLat() {
                return new As(Xg(this.x), cp(this.y));
              }
              toAltitude() {
                return Yg(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (
                  (1 / Zg) *
                  ((t = cp(this.y)), 1 / Math.cos((t * Math.PI) / 180))
                );
                var t;
              }
            }
            function Kg(n, t, r) {
              var a = (2 * Math.PI * 6378137) / 256 / Math.pow(2, r);
              return [
                n * a - (2 * Math.PI * 6378137) / 2,
                t * a - (2 * Math.PI * 6378137) / 2,
              ];
            }
            class Yf {
              constructor(t, r, a) {
                if (
                  !(function (c, p, m) {
                    return !(
                      c < 0 ||
                      c > 25 ||
                      m < 0 ||
                      m >= Math.pow(2, c) ||
                      p < 0 ||
                      p >= Math.pow(2, c)
                    );
                  })(t, r, a)
                )
                  throw new Error(
                    `x=${r}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(
                      2,
                      t
                    )}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `
                  );
                (this.z = t),
                  (this.x = r),
                  (this.y = a),
                  (this.key = mc(0, t, t, r, a));
              }
              equals(t) {
                return this.z === t.z && this.x === t.x && this.y === t.y;
              }
              url(t, r, a) {
                const c =
                  ((m = this.y),
                  (v = this.z),
                  (b = Kg(
                    256 * (p = this.x),
                    256 * (m = Math.pow(2, v) - m - 1),
                    v
                  )),
                  (C = Kg(256 * (p + 1), 256 * (m + 1), v)),
                  b[0] + "," + b[1] + "," + C[0] + "," + C[1]);
                var p, m, v, b, C;
                const I = (function (R, U, Z) {
                  let X,
                    Q = "";
                  for (let ie = R; ie > 0; ie--)
                    (X = 1 << (ie - 1)),
                      (Q += (U & X ? 1 : 0) + (Z & X ? 2 : 0));
                  return Q;
                })(this.z, this.x, this.y);
                return t[(this.x + this.y) % t.length]
                  .replace(
                    /{prefix}/g,
                    (this.x % 16).toString(16) + (this.y % 16).toString(16)
                  )
                  .replace(/{z}/g, String(this.z))
                  .replace(/{x}/g, String(this.x))
                  .replace(
                    /{y}/g,
                    String(
                      a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y
                    )
                  )
                  .replace(/{ratio}/g, r > 1 ? "@2x" : "")
                  .replace(/{quadkey}/g, I)
                  .replace(/{bbox-epsg-3857}/g, c);
              }
              isChildOf(t) {
                const r = this.z - t.z;
                return r > 0 && t.x === this.x >> r && t.y === this.y >> r;
              }
              getTilePoint(t) {
                const r = Math.pow(2, this.z);
                return new B((t.x * r - this.x) * Fe, (t.y * r - this.y) * Fe);
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class Jg {
              constructor(t, r) {
                (this.wrap = t),
                  (this.canonical = r),
                  (this.key = mc(t, r.z, r.z, r.x, r.y));
              }
            }
            class Ea {
              constructor(t, r, a, c, p) {
                if (((this.terrainRttPosMatrix32f = null), t < a))
                  throw new Error(
                    `overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`
                  );
                (this.overscaledZ = t),
                  (this.wrap = r),
                  (this.canonical = new Yf(a, +c, +p)),
                  (this.key = mc(r, t, a, c, p));
              }
              clone() {
                return new Ea(
                  this.overscaledZ,
                  this.wrap,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              equals(t) {
                return (
                  this.overscaledZ === t.overscaledZ &&
                  this.wrap === t.wrap &&
                  this.canonical.equals(t.canonical)
                );
              }
              scaledTo(t) {
                if (t > this.overscaledZ)
                  throw new Error(
                    `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
                  );
                const r = this.canonical.z - t;
                return t > this.canonical.z
                  ? new Ea(
                      t,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    )
                  : new Ea(
                      t,
                      this.wrap,
                      t,
                      this.canonical.x >> r,
                      this.canonical.y >> r
                    );
              }
              isOverscaled() {
                return this.overscaledZ > this.canonical.z;
              }
              calculateScaledKey(t, r) {
                if (t > this.overscaledZ)
                  throw new Error(
                    `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
                  );
                const a = this.canonical.z - t;
                return t > this.canonical.z
                  ? mc(
                      this.wrap * +r,
                      t,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    )
                  : mc(
                      this.wrap * +r,
                      t,
                      t,
                      this.canonical.x >> a,
                      this.canonical.y >> a
                    );
              }
              isChildOf(t) {
                if (
                  t.wrap !== this.wrap ||
                  this.overscaledZ - t.overscaledZ <= 0
                )
                  return !1;
                if (t.overscaledZ === 0) return this.overscaledZ > 0;
                const r = this.canonical.z - t.canonical.z;
                return (
                  !(r < 0) &&
                  t.canonical.x === this.canonical.x >> r &&
                  t.canonical.y === this.canonical.y >> r
                );
              }
              children(t) {
                if (this.overscaledZ >= t)
                  return [
                    new Ea(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    ),
                  ];
                const r = this.canonical.z + 1,
                  a = 2 * this.canonical.x,
                  c = 2 * this.canonical.y;
                return [
                  new Ea(r, this.wrap, r, a, c),
                  new Ea(r, this.wrap, r, a + 1, c),
                  new Ea(r, this.wrap, r, a, c + 1),
                  new Ea(r, this.wrap, r, a + 1, c + 1),
                ];
              }
              isLessThan(t) {
                return (
                  this.wrap < t.wrap ||
                  (!(this.wrap > t.wrap) &&
                    (this.overscaledZ < t.overscaledZ ||
                      (!(this.overscaledZ > t.overscaledZ) &&
                        (this.canonical.x < t.canonical.x ||
                          (!(this.canonical.x > t.canonical.x) &&
                            this.canonical.y < t.canonical.y)))))
                );
              }
              wrapped() {
                return new Ea(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              unwrapTo(t) {
                return new Ea(
                  this.overscaledZ,
                  t,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new Jg(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
              getTilePoint(t) {
                return this.canonical.getTilePoint(
                  new qu(t.x - this.wrap, t.y)
                );
              }
            }
            function mc(n, t, r, a, c) {
              (n *= 2) < 0 && (n = -1 * n - 1);
              const p = 1 << r;
              return (
                (p * p * n + p * c + a).toString(36) +
                r.toString(36) +
                t.toString(36)
              );
            }
            function Uu(n, t) {
              return t ? n.properties[t] : n.id;
            }
            hr("CanonicalTileID", Yf),
              hr("OverscaledTileID", Ea, { omit: ["terrainRttPosMatrix32f"] });
            class cl {
              constructor() {
                (this.minX = 1 / 0),
                  (this.maxX = -1 / 0),
                  (this.minY = 1 / 0),
                  (this.maxY = -1 / 0);
              }
              extend(t) {
                return (
                  (this.minX = Math.min(this.minX, t.x)),
                  (this.minY = Math.min(this.minY, t.y)),
                  (this.maxX = Math.max(this.maxX, t.x)),
                  (this.maxY = Math.max(this.maxY, t.y)),
                  this
                );
              }
              expandBy(t) {
                return (
                  (this.minX -= t),
                  (this.minY -= t),
                  (this.maxX += t),
                  (this.maxY += t),
                  (this.minX > this.maxX || this.minY > this.maxY) &&
                    ((this.minX = 1 / 0),
                    (this.maxX = -1 / 0),
                    (this.minY = 1 / 0),
                    (this.maxY = -1 / 0)),
                  this
                );
              }
              shrinkBy(t) {
                return this.expandBy(-t);
              }
              map(t) {
                const r = new cl();
                return (
                  r.extend(t(new B(this.minX, this.minY))),
                  r.extend(t(new B(this.maxX, this.minY))),
                  r.extend(t(new B(this.minX, this.maxY))),
                  r.extend(t(new B(this.maxX, this.maxY))),
                  r
                );
              }
              static fromPoints(t) {
                const r = new cl();
                for (const a of t) r.extend(a);
                return r;
              }
              contains(t) {
                return (
                  t.x >= this.minX &&
                  t.x <= this.maxX &&
                  t.y >= this.minY &&
                  t.y <= this.maxY
                );
              }
              empty() {
                return this.minX > this.maxX;
              }
              width() {
                return this.maxX - this.minX;
              }
              height() {
                return this.maxY - this.minY;
              }
              covers(t) {
                return (
                  !this.empty() &&
                  !t.empty() &&
                  t.minX >= this.minX &&
                  t.maxX <= this.maxX &&
                  t.minY >= this.minY &&
                  t.maxY <= this.maxY
                );
              }
              intersects(t) {
                return (
                  !this.empty() &&
                  !t.empty() &&
                  t.minX <= this.maxX &&
                  t.maxX >= this.minX &&
                  t.minY <= this.maxY &&
                  t.maxY >= this.minY
                );
              }
            }
            class Qg {
              constructor(t) {
                (this._stringToNumber = {}), (this._numberToString = []);
                for (let r = 0; r < t.length; r++) {
                  const a = t[r];
                  (this._stringToNumber[a] = r), (this._numberToString[r] = a);
                }
              }
              encode(t) {
                return this._stringToNumber[t];
              }
              decode(t) {
                if (t >= this._numberToString.length)
                  throw new Error(
                    `Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`
                  );
                return this._numberToString[t];
              }
            }
            class ev {
              constructor(t, r, a, c, p) {
                (this.type = "Feature"),
                  (this._vectorTileFeature = t),
                  (t._z = r),
                  (t._x = a),
                  (t._y = c),
                  (this.properties = t.properties),
                  (this.id = p);
              }
              get geometry() {
                return (
                  this._geometry === void 0 &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._vectorTileFeature._x,
                      this._vectorTileFeature._y,
                      this._vectorTileFeature._z
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(t) {
                this._geometry = t;
              }
              toJSON() {
                const t = { geometry: this.geometry };
                for (const r in this)
                  r !== "_geometry" &&
                    r !== "_vectorTileFeature" &&
                    (t[r] = this[r]);
                return t;
              }
            }
            class tv {
              constructor(t, r) {
                (this.tileID = t),
                  (this.x = t.canonical.x),
                  (this.y = t.canonical.y),
                  (this.z = t.canonical.z),
                  (this.grid = new $o(Fe, 16, 0)),
                  (this.grid3D = new $o(Fe, 16, 0)),
                  (this.featureIndexArray = new se()),
                  (this.promoteId = r);
              }
              insert(t, r, a, c, p, m) {
                const v = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(a, c, p);
                const b = m ? this.grid3D : this.grid;
                for (let C = 0; C < r.length; C++) {
                  const I = r[C],
                    R = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let U = 0; U < I.length; U++) {
                    const Z = I[U];
                    (R[0] = Math.min(R[0], Z.x)),
                      (R[1] = Math.min(R[1], Z.y)),
                      (R[2] = Math.max(R[2], Z.x)),
                      (R[3] = Math.max(R[3], Z.y));
                  }
                  R[0] < Fe &&
                    R[1] < Fe &&
                    R[2] >= 0 &&
                    R[3] >= 0 &&
                    b.insert(v, R[0], R[1], R[2], R[3]);
                }
              }
              loadVTLayers() {
                return (
                  this.vtLayers ||
                    ((this.vtLayers = new gg(new jf(this.rawTileData)).layers),
                    (this.sourceLayerCoder = new Qg(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"]
                    ))),
                  this.vtLayers
                );
              }
              query(t, r, a, c) {
                this.loadVTLayers();
                const p = t.params,
                  m = Fe / t.tileSize / t.scale,
                  v = Ys(p.filter, p.globalState),
                  b = t.queryGeometry,
                  C = t.queryPadding * m,
                  I = cl.fromPoints(b),
                  R = this.grid.query(
                    I.minX - C,
                    I.minY - C,
                    I.maxX + C,
                    I.maxY + C
                  ),
                  U = cl.fromPoints(t.cameraQueryGeometry).expandBy(C),
                  Z = this.grid3D.query(
                    U.minX,
                    U.minY,
                    U.maxX,
                    U.maxY,
                    (ie, he, Oe, ye) =>
                      (function (Ce, et, ht, Rt, or) {
                        for (const rr of Ce)
                          if (
                            et <= rr.x &&
                            ht <= rr.y &&
                            Rt >= rr.x &&
                            or >= rr.y
                          )
                            return !0;
                        const Yt = [
                          new B(et, ht),
                          new B(et, or),
                          new B(Rt, or),
                          new B(Rt, ht),
                        ];
                        if (Ce.length > 2) {
                          for (const rr of Yt) if (oc(Ce, rr)) return !0;
                        }
                        for (let rr = 0; rr < Ce.length - 1; rr++)
                          if (Qy(Ce[rr], Ce[rr + 1], Yt)) return !0;
                        return !1;
                      })(t.cameraQueryGeometry, ie - C, he - C, Oe + C, ye + C)
                  );
                for (const ie of Z) R.push(ie);
                R.sort(Sx);
                const X = {};
                let Q;
                for (let ie = 0; ie < R.length; ie++) {
                  const he = R[ie];
                  if (he === Q) continue;
                  Q = he;
                  const Oe = this.featureIndexArray.get(he);
                  let ye = null;
                  this.loadMatchingFeature(
                    X,
                    Oe.bucketIndex,
                    Oe.sourceLayerIndex,
                    Oe.featureIndex,
                    v,
                    p.layers,
                    p.availableImages,
                    r,
                    a,
                    c,
                    (Ce, et, ht) => (
                      ye || (ye = so(Ce)),
                      et.queryIntersectsFeature({
                        queryGeometry: b,
                        feature: Ce,
                        featureState: ht,
                        geometry: ye,
                        zoom: this.z,
                        transform: t.transform,
                        pixelsToTileUnits: m,
                        pixelPosMatrix: t.pixelPosMatrix,
                        unwrappedTileID: this.tileID.toUnwrapped(),
                        getElevation: t.getElevation,
                      })
                    )
                  );
                }
                return X;
              }
              loadMatchingFeature(t, r, a, c, p, m, v, b, C, I, R) {
                const U = this.bucketLayerIDs[r];
                if (m && !U.some((ie) => m.has(ie))) return;
                const Z = this.sourceLayerCoder.decode(a),
                  X = this.vtLayers[Z].feature(c);
                if (p.needGeometry) {
                  const ie = Co(X, !0);
                  if (
                    !p.filter(
                      new On(this.tileID.overscaledZ),
                      ie,
                      this.tileID.canonical
                    )
                  )
                    return;
                } else if (!p.filter(new On(this.tileID.overscaledZ), X)) return;
                const Q = this.getId(X, Z);
                for (let ie = 0; ie < U.length; ie++) {
                  const he = U[ie];
                  if (m && !m.has(he)) continue;
                  const Oe = b[he];
                  if (!Oe) continue;
                  let ye = {};
                  Q &&
                    I &&
                    (ye = I.getState(Oe.sourceLayer || "_geojsonTileLayer", Q));
                  const Ce = at({}, C[he]);
                  (Ce.paint = rv(Ce.paint, Oe.paint, X, ye, v)),
                    (Ce.layout = rv(Ce.layout, Oe.layout, X, ye, v));
                  const et = !R || R(X, Oe, ye);
                  if (!et) continue;
                  const ht = new ev(X, this.z, this.x, this.y, Q);
                  ht.layer = Ce;
                  let Rt = t[he];
                  Rt === void 0 && (Rt = t[he] = []),
                    Rt.push({
                      featureIndex: c,
                      feature: ht,
                      intersectionZ: et,
                    });
                }
              }
              lookupSymbolFeatures(t, r, a, c, p, m, v, b) {
                const C = {};
                this.loadVTLayers();
                const I = Ys(p.filterSpec, p.globalState);
                for (const R of t)
                  this.loadMatchingFeature(C, a, c, R, I, m, v, b, r);
                return C;
              }
              hasLayer(t) {
                for (const r of this.bucketLayerIDs)
                  for (const a of r) if (t === a) return !0;
                return !1;
              }
              getId(t, r) {
                var a;
                let c = t.id;
                return (
                  this.promoteId &&
                    ((c =
                      t.properties[
                        typeof this.promoteId == "string"
                          ? this.promoteId
                          : this.promoteId[r]
                      ]),
                    typeof c == "boolean" && (c = Number(c)),
                    c === void 0 &&
                      !((a = t.properties) === null || a === void 0) &&
                      a.cluster &&
                      this.promoteId &&
                      (c = Number(t.properties.cluster_id))),
                  c
                );
              }
            }
            function rv(n, t, r, a, c) {
              return It(n, (p, m) => {
                const v = t instanceof Ho ? t.get(m) : null;
                return v && v.evaluate ? v.evaluate(r, a, c) : v;
              });
            }
            function Sx(n, t) {
              return t - n;
            }
            function nv(n, t, r, a, c) {
              const p = [];
              for (let m = 0; m < n.length; m++) {
                const v = n[m];
                let b;
                for (let C = 0; C < v.length - 1; C++) {
                  let I = v[C],
                    R = v[C + 1];
                  (I.x < t && R.x < t) ||
                    (I.x < t
                      ? (I = new B(
                          t,
                          I.y + ((t - I.x) / (R.x - I.x)) * (R.y - I.y)
                        )._round())
                      : R.x < t &&
                        (R = new B(
                          t,
                          I.y + ((t - I.x) / (R.x - I.x)) * (R.y - I.y)
                        )._round()),
                    (I.y < r && R.y < r) ||
                      (I.y < r
                        ? (I = new B(
                            I.x + ((r - I.y) / (R.y - I.y)) * (R.x - I.x),
                            r
                          )._round())
                        : R.y < r &&
                          (R = new B(
                            I.x + ((r - I.y) / (R.y - I.y)) * (R.x - I.x),
                            r
                          )._round()),
                      (I.x >= a && R.x >= a) ||
                        (I.x >= a
                          ? (I = new B(
                              a,
                              I.y + ((a - I.x) / (R.x - I.x)) * (R.y - I.y)
                            )._round())
                          : R.x >= a &&
                            (R = new B(
                              a,
                              I.y + ((a - I.x) / (R.x - I.x)) * (R.y - I.y)
                            )._round()),
                        (I.y >= c && R.y >= c) ||
                          (I.y >= c
                            ? (I = new B(
                                I.x + ((c - I.y) / (R.y - I.y)) * (R.x - I.x),
                                c
                              )._round())
                            : R.y >= c &&
                              (R = new B(
                                I.x + ((c - I.y) / (R.y - I.y)) * (R.x - I.x),
                                c
                              )._round()),
                          (b && I.equals(b[b.length - 1])) ||
                            ((b = [I]), p.push(b)),
                          b.push(R)))));
                }
              }
              return p;
            }
            hr("FeatureIndex", tv, {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            class ks extends B {
              constructor(t, r, a, c) {
                super(t, r),
                  (this.angle = a),
                  c !== void 0 && (this.segment = c);
              }
              clone() {
                return new ks(this.x, this.y, this.angle, this.segment);
              }
            }
            function iv(n, t, r, a, c) {
              if (t.segment === void 0 || r === 0) return !0;
              let p = t,
                m = t.segment + 1,
                v = 0;
              for (; v > -r / 2; ) {
                if ((m--, m < 0)) return !1;
                (v -= n[m].dist(p)), (p = n[m]);
              }
              (v += n[m].dist(n[m + 1])), m++;
              const b = [];
              let C = 0;
              for (; v < r / 2; ) {
                const I = n[m],
                  R = n[m + 1];
                if (!R) return !1;
                let U = n[m - 1].angleTo(I) - I.angleTo(R);
                for (
                  U = Math.abs(((U + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    b.push({ distance: v, angleDelta: U }),
                    C += U;
                  v - b[0].distance > a;

                )
                  C -= b.shift().angleDelta;
                if (C > c) return !1;
                m++, (v += I.dist(R));
              }
              return !0;
            }
            function av(n) {
              let t = 0;
              for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
              return t;
            }
            function ov(n, t, r) {
              return n ? 0.6 * t * r : 0;
            }
            function sv(n, t) {
              return Math.max(
                n ? n.right - n.left : 0,
                t ? t.right - t.left : 0
              );
            }
            function Cx(n, t, r, a, c, p) {
              const m = ov(r, c, p),
                v = sv(r, a) * p;
              let b = 0;
              const C = av(n) / 2;
              for (let I = 0; I < n.length - 1; I++) {
                const R = n[I],
                  U = n[I + 1],
                  Z = R.dist(U);
                if (b + Z > C) {
                  const X = (C - b) / Z,
                    Q = ya.number(R.x, U.x, X),
                    ie = ya.number(R.y, U.y, X),
                    he = new ks(Q, ie, U.angleTo(R), I);
                  return he._round(), !m || iv(n, he, v, m, t) ? he : void 0;
                }
                b += Z;
              }
            }
            function Px(n, t, r, a, c, p, m, v, b) {
              const C = ov(a, p, m),
                I = sv(a, c),
                R = I * m,
                U =
                  n[0].x === 0 || n[0].x === b || n[0].y === 0 || n[0].y === b;
              return (
                t - R < t / 4 && (t = R + t / 4),
                lv(
                  n,
                  U ? ((t / 2) * v) % t : ((I / 2 + 2 * p) * m * v) % t,
                  t,
                  C,
                  r,
                  R,
                  U,
                  !1,
                  b
                )
              );
            }
            function lv(n, t, r, a, c, p, m, v, b) {
              const C = p / 2,
                I = av(n);
              let R = 0,
                U = t - r,
                Z = [];
              for (let X = 0; X < n.length - 1; X++) {
                const Q = n[X],
                  ie = n[X + 1],
                  he = Q.dist(ie),
                  Oe = ie.angleTo(Q);
                for (; U + r < R + he; ) {
                  U += r;
                  const ye = (U - R) / he,
                    Ce = ya.number(Q.x, ie.x, ye),
                    et = ya.number(Q.y, ie.y, ye);
                  if (
                    Ce >= 0 &&
                    Ce < b &&
                    et >= 0 &&
                    et < b &&
                    U - C >= 0 &&
                    U + C <= I
                  ) {
                    const ht = new ks(Ce, et, Oe, X);
                    ht._round(), (a && !iv(n, ht, p, a, c)) || Z.push(ht);
                  }
                }
                R += he;
              }
              return (
                v || Z.length || m || (Z = lv(n, R / 2, r, a, c, p, m, !0, b)),
                Z
              );
            }
            function cv(n, t, r, a) {
              const c = [],
                p = n.image,
                m = p.pixelRatio,
                v = p.paddedRect.w - 2,
                b = p.paddedRect.h - 2;
              let C = { x1: n.left, y1: n.top, x2: n.right, y2: n.bottom };
              const I = p.stretchX || [[0, v]],
                R = p.stretchY || [[0, b]],
                U = (St, Hr) => St + Hr[1] - Hr[0],
                Z = I.reduce(U, 0),
                X = R.reduce(U, 0),
                Q = v - Z,
                ie = b - X;
              let he = 0,
                Oe = Z,
                ye = 0,
                Ce = X,
                et = 0,
                ht = Q,
                Rt = 0,
                or = ie;
              if (p.content && a) {
                const St = p.content,
                  Hr = St[2] - St[0],
                  Kr = St[3] - St[1];
                (p.textFitWidth || p.textFitHeight) && (C = Bg(n)),
                  (he = up(I, 0, St[0])),
                  (ye = up(R, 0, St[1])),
                  (Oe = up(I, St[0], St[2])),
                  (Ce = up(R, St[1], St[3])),
                  (et = St[0] - he),
                  (Rt = St[1] - ye),
                  (ht = Hr - Oe),
                  (or = Kr - Ce);
              }
              const Yt = C.x1,
                rr = C.y1,
                Fr = C.x2 - Yt,
                er = C.y2 - rr,
                nr = (St, Hr, Kr, Vr) => {
                  const kr = hp(St.stretch - he, Oe, Fr, Yt),
                    bn = dp(St.fixed - et, ht, St.stretch, Z),
                    ai = hp(Hr.stretch - ye, Ce, er, rr),
                    bi = dp(Hr.fixed - Rt, or, Hr.stretch, X),
                    Gi = hp(Kr.stretch - he, Oe, Fr, Yt),
                    za = dp(Kr.fixed - et, ht, Kr.stretch, Z),
                    ca = hp(Vr.stretch - ye, Ce, er, rr),
                    Ri = dp(Vr.fixed - Rt, or, Vr.stretch, X),
                    ni = new B(kr, ai),
                    ki = new B(Gi, ai),
                    Fi = new B(Gi, ca),
                    Bi = new B(kr, ca),
                    aa = new B(bn / m, bi / m),
                    La = new B(za / m, Ri / m),
                    Ei = (t * Math.PI) / 180;
                  if (Ei) {
                    const zi = Math.sin(Ei),
                      Li = Math.cos(Ei),
                      vi = [Li, -zi, zi, Li];
                    ni._matMult(vi),
                      ki._matMult(vi),
                      Bi._matMult(vi),
                      Fi._matMult(vi);
                  }
                  const ua = St.stretch + St.fixed,
                    wi = Hr.stretch + Hr.fixed;
                  return {
                    tl: ni,
                    tr: ki,
                    bl: Bi,
                    br: Fi,
                    tex: {
                      x: p.paddedRect.x + 1 + ua,
                      y: p.paddedRect.y + 1 + wi,
                      w: Kr.stretch + Kr.fixed - ua,
                      h: Vr.stretch + Vr.fixed - wi,
                    },
                    writingMode: void 0,
                    glyphOffset: [0, 0],
                    sectionIndex: 0,
                    pixelOffsetTL: aa,
                    pixelOffsetBR: La,
                    minFontScaleX: ht / m / Fr,
                    minFontScaleY: or / m / er,
                    isSDF: r,
                  };
                };
              if (a && (p.stretchX || p.stretchY)) {
                const St = uv(I, Q, Z),
                  Hr = uv(R, ie, X);
                for (let Kr = 0; Kr < St.length - 1; Kr++) {
                  const Vr = St[Kr],
                    kr = St[Kr + 1];
                  for (let bn = 0; bn < Hr.length - 1; bn++)
                    c.push(nr(Vr, Hr[bn], kr, Hr[bn + 1]));
                }
              } else c.push(nr({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: v + 1 }, { fixed: 0, stretch: b + 1 }));
              return c;
            }
            function up(n, t, r) {
              let a = 0;
              for (const c of n)
                a +=
                  Math.max(t, Math.min(r, c[1])) -
                  Math.max(t, Math.min(r, c[0]));
              return a;
            }
            function uv(n, t, r) {
              const a = [{ fixed: -1, stretch: 0 }];
              for (const [c, p] of n) {
                const m = a[a.length - 1];
                a.push({ fixed: c - m.stretch, stretch: m.stretch }),
                  a.push({
                    fixed: c - m.stretch,
                    stretch: m.stretch + (p - c),
                  });
              }
              return a.push({ fixed: t + 1, stretch: r }), a;
            }
            function hp(n, t, r, a) {
              return (n / t) * r + a;
            }
            function dp(n, t, r, a) {
              return n - (t * r) / a;
            }
            hr("Anchor", ks);
            class pp {
              constructor(t, r, a, c, p, m, v, b, C, I) {
                var R;
                if (((this.boxStartIndex = t.length), C)) {
                  let U = m.top,
                    Z = m.bottom;
                  const X = m.collisionPadding;
                  X && ((U -= X[1]), (Z += X[3]));
                  let Q = Z - U;
                  Q > 0 && ((Q = Math.max(10, Q)), (this.circleDiameter = Q));
                } else {
                  const U =
                    !((R = m.image) === null || R === void 0) &&
                    R.content &&
                    (m.image.textFitWidth || m.image.textFitHeight)
                      ? Bg(m)
                      : { x1: m.left, y1: m.top, x2: m.right, y2: m.bottom };
                  (U.y1 = U.y1 * v - b[0]),
                    (U.y2 = U.y2 * v + b[2]),
                    (U.x1 = U.x1 * v - b[3]),
                    (U.x2 = U.x2 * v + b[1]);
                  const Z = m.collisionPadding;
                  if (
                    (Z &&
                      ((U.x1 -= Z[0] * v),
                      (U.y1 -= Z[1] * v),
                      (U.x2 += Z[2] * v),
                      (U.y2 += Z[3] * v)),
                    I)
                  ) {
                    const X = new B(U.x1, U.y1),
                      Q = new B(U.x2, U.y1),
                      ie = new B(U.x1, U.y2),
                      he = new B(U.x2, U.y2),
                      Oe = (I * Math.PI) / 180;
                    X._rotate(Oe),
                      Q._rotate(Oe),
                      ie._rotate(Oe),
                      he._rotate(Oe),
                      (U.x1 = Math.min(X.x, Q.x, ie.x, he.x)),
                      (U.x2 = Math.max(X.x, Q.x, ie.x, he.x)),
                      (U.y1 = Math.min(X.y, Q.y, ie.y, he.y)),
                      (U.y2 = Math.max(X.y, Q.y, ie.y, he.y));
                  }
                  t.emplaceBack(r.x, r.y, U.x1, U.y1, U.x2, U.y2, a, c, p);
                }
                this.boxEndIndex = t.length;
              }
            }
            class Ix {
              constructor(t = [], r = (a, c) => (a < c ? -1 : a > c ? 1 : 0)) {
                if (
                  ((this.data = t),
                  (this.length = this.data.length),
                  (this.compare = r),
                  this.length > 0)
                )
                  for (let a = (this.length >> 1) - 1; a >= 0; a--)
                    this._down(a);
              }
              push(t) {
                this.data.push(t), this._up(this.length++);
              }
              pop() {
                if (this.length === 0) return;
                const t = this.data[0],
                  r = this.data.pop();
                return (
                  --this.length > 0 && ((this.data[0] = r), this._down(0)), t
                );
              }
              peek() {
                return this.data[0];
              }
              _up(t) {
                const { data: r, compare: a } = this,
                  c = r[t];
                for (; t > 0; ) {
                  const p = (t - 1) >> 1,
                    m = r[p];
                  if (a(c, m) >= 0) break;
                  (r[t] = m), (t = p);
                }
                r[t] = c;
              }
              _down(t) {
                const { data: r, compare: a } = this,
                  c = this.length >> 1,
                  p = r[t];
                for (; t < c; ) {
                  let m = 1 + (t << 1);
                  const v = m + 1;
                  if (
                    (v < this.length && a(r[v], r[m]) < 0 && (m = v),
                    a(r[m], p) >= 0)
                  )
                    break;
                  (r[t] = r[m]), (t = m);
                }
                r[t] = p;
              }
            }
            function Mx(n, t = 1, r = !1) {
              const a = cl.fromPoints(n[0]),
                c = Math.min(a.width(), a.height());
              let p = c / 2;
              const m = new Ix([], Ax),
                { minX: v, minY: b, maxX: C, maxY: I } = a;
              if (c === 0) return new B(v, b);
              for (let Z = v; Z < C; Z += c)
                for (let X = b; X < I; X += c)
                  m.push(new _c(Z + p, X + p, p, n));
              let R = (function (Z) {
                  let X = 0,
                    Q = 0,
                    ie = 0;
                  const he = Z[0];
                  for (
                    let Oe = 0, ye = he.length, Ce = ye - 1;
                    Oe < ye;
                    Ce = Oe++
                  ) {
                    const et = he[Oe],
                      ht = he[Ce],
                      Rt = et.x * ht.y - ht.x * et.y;
                    (Q += (et.x + ht.x) * Rt),
                      (ie += (et.y + ht.y) * Rt),
                      (X += 3 * Rt);
                  }
                  return new _c(Q / X, ie / X, 0, Z);
                })(n),
                U = m.length;
              for (; m.length; ) {
                const Z = m.pop();
                (Z.d > R.d || !R.d) &&
                  ((R = Z),
                  r &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * Z.d) / 1e4,
                      U
                    )),
                  Z.max - R.d <= t ||
                    ((p = Z.h / 2),
                    m.push(new _c(Z.p.x - p, Z.p.y - p, p, n)),
                    m.push(new _c(Z.p.x + p, Z.p.y - p, p, n)),
                    m.push(new _c(Z.p.x - p, Z.p.y + p, p, n)),
                    m.push(new _c(Z.p.x + p, Z.p.y + p, p, n)),
                    (U += 4));
              }
              return (
                r &&
                  (console.log(`num probes: ${U}`),
                  console.log(`best distance: ${R.d}`)),
                R.p
              );
            }
            function Ax(n, t) {
              return t.max - n.max;
            }
            function _c(n, t, r, a) {
              (this.p = new B(n, t)),
                (this.h = r),
                (this.d = (function (c, p) {
                  let m = !1,
                    v = 1 / 0;
                  for (let b = 0; b < p.length; b++) {
                    const C = p[b];
                    for (let I = 0, R = C.length, U = R - 1; I < R; U = I++) {
                      const Z = C[I],
                        X = C[U];
                      Z.y > c.y != X.y > c.y &&
                        c.x < ((X.x - Z.x) * (c.y - Z.y)) / (X.y - Z.y) + Z.x &&
                        (m = !m),
                        (v = Math.min(v, W_(c, Z, X)));
                    }
                  }
                  return (m ? 1 : -1) * Math.sqrt(v);
                })(this.p, a)),
                (this.max = this.d + this.h * Math.SQRT2);
            }
            var Zi;
            (T.aI = void 0),
              ((Zi = T.aI || (T.aI = {}))[(Zi.center = 1)] = "center"),
              (Zi[(Zi.left = 2)] = "left"),
              (Zi[(Zi.right = 3)] = "right"),
              (Zi[(Zi.top = 4)] = "top"),
              (Zi[(Zi.bottom = 5)] = "bottom"),
              (Zi[(Zi["top-left"] = 6)] = "top-left"),
              (Zi[(Zi["top-right"] = 7)] = "top-right"),
              (Zi[(Zi["bottom-left"] = 8)] = "bottom-left"),
              (Zi[(Zi["bottom-right"] = 9)] = "bottom-right");
            const Kf = Number.POSITIVE_INFINITY;
            function hv(n, t) {
              return t[1] !== Kf
                ? (function (r, a, c) {
                    let p = 0,
                      m = 0;
                    switch (((a = Math.abs(a)), (c = Math.abs(c)), r)) {
                      case "top-right":
                      case "top-left":
                      case "top":
                        m = c - 7;
                        break;
                      case "bottom-right":
                      case "bottom-left":
                      case "bottom":
                        m = 7 - c;
                    }
                    switch (r) {
                      case "top-right":
                      case "bottom-right":
                      case "right":
                        p = -a;
                        break;
                      case "top-left":
                      case "bottom-left":
                      case "left":
                        p = a;
                    }
                    return [p, m];
                  })(n, t[0], t[1])
                : (function (r, a) {
                    let c = 0,
                      p = 0;
                    a < 0 && (a = 0);
                    const m = a / Math.SQRT2;
                    switch (r) {
                      case "top-right":
                      case "top-left":
                        p = m - 7;
                        break;
                      case "bottom-right":
                      case "bottom-left":
                        p = 7 - m;
                        break;
                      case "bottom":
                        p = 7 - a;
                        break;
                      case "top":
                        p = a - 7;
                    }
                    switch (r) {
                      case "top-right":
                      case "bottom-right":
                        c = -m;
                        break;
                      case "top-left":
                      case "bottom-left":
                        c = m;
                        break;
                      case "left":
                        c = a;
                        break;
                      case "right":
                        c = -a;
                    }
                    return [c, p];
                  })(n, t[0]);
            }
            function dv(n, t, r) {
              var a;
              const c = n.layout,
                p =
                  (a = c.get("text-variable-anchor-offset")) === null ||
                  a === void 0
                    ? void 0
                    : a.evaluate(t, {}, r);
              if (p) {
                const v = p.values,
                  b = [];
                for (let C = 0; C < v.length; C += 2) {
                  const I = (b[C] = v[C]),
                    R = v[C + 1].map((U) => U * Ai);
                  I.startsWith("top")
                    ? (R[1] -= 7)
                    : I.startsWith("bottom") && (R[1] += 7),
                    (b[C + 1] = R);
                }
                return new pn(b);
              }
              const m = c.get("text-variable-anchor");
              if (m) {
                let v;
                v =
                  n._unevaluatedLayout.getValue("text-radial-offset") !== void 0
                    ? [c.get("text-radial-offset").evaluate(t, {}, r) * Ai, Kf]
                    : c
                        .get("text-offset")
                        .evaluate(t, {}, r)
                        .map((C) => C * Ai);
                const b = [];
                for (const C of m) b.push(C, hv(C, v));
                return new pn(b);
              }
              return null;
            }
            function Jf(n) {
              switch (n) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function kx(n, t, r, a, c, p, m, v, b, C, I, R) {
              let U = p.textMaxSize.evaluate(t, {});
              U === void 0 && (U = m);
              const Z = n.layers[0].layout,
                X = Z.get("icon-offset").evaluate(t, {}, I),
                Q = fv(r.horizontal),
                ie = m / 24,
                he = n.tilePixelRatio * ie,
                Oe = (n.tilePixelRatio * U) / 24,
                ye = n.tilePixelRatio * v,
                Ce = n.tilePixelRatio * Z.get("symbol-spacing"),
                et = Z.get("text-padding") * n.tilePixelRatio,
                ht = (function (Kr, Vr, kr, bn = 1) {
                  const ai = Kr.get("icon-padding").evaluate(Vr, {}, kr),
                    bi = ai && ai.values;
                  return [bi[0] * bn, bi[1] * bn, bi[2] * bn, bi[3] * bn];
                })(Z, t, I, n.tilePixelRatio),
                Rt = (Z.get("text-max-angle") / 180) * Math.PI,
                or =
                  Z.get("text-rotation-alignment") !== "viewport" &&
                  Z.get("symbol-placement") !== "point",
                Yt =
                  Z.get("icon-rotation-alignment") === "map" &&
                  Z.get("symbol-placement") !== "point",
                rr = Z.get("symbol-placement"),
                Fr = Ce / 2,
                er = Z.get("icon-text-fit");
              let nr;
              a &&
                er !== "none" &&
                (n.allowVerticalPlacement &&
                  r.vertical &&
                  (nr = Og(
                    a,
                    r.vertical,
                    er,
                    Z.get("icon-text-fit-padding"),
                    X,
                    ie
                  )),
                Q && (a = Og(a, Q, er, Z.get("icon-text-fit-padding"), X, ie)));
              const St = I ? R.line.getGranularityForZoomLevel(I.z) : 1,
                Hr = (Kr, Vr) => {
                  Vr.x < 0 ||
                    Vr.x >= Fe ||
                    Vr.y < 0 ||
                    Vr.y >= Fe ||
                    (function (
                      kr,
                      bn,
                      ai,
                      bi,
                      Gi,
                      za,
                      ca,
                      Ri,
                      ni,
                      ki,
                      Fi,
                      Bi,
                      aa,
                      La,
                      Ei,
                      ua,
                      wi,
                      zi,
                      Li,
                      vi,
                      Wn,
                      lo,
                      gc,
                      co,
                      Lx
                    ) {
                      const vc = kr.addToLineVertexArray(bn, ai);
                      let ul,
                        yc,
                        xc,
                        bc,
                        vv = 0,
                        yv = 0,
                        xv = 0,
                        bv = 0,
                        om = -1,
                        sm = -1;
                      const ns = {};
                      let wv = ao("");
                      if (kr.allowVerticalPlacement && bi.vertical) {
                        const Ji =
                          Ri.layout.get("text-rotate").evaluate(Wn, {}, co) +
                          90;
                        (xc = new pp(
                          ni,
                          bn,
                          ki,
                          Fi,
                          Bi,
                          bi.vertical,
                          aa,
                          La,
                          Ei,
                          Ji
                        )),
                          ca &&
                            (bc = new pp(
                              ni,
                              bn,
                              ki,
                              Fi,
                              Bi,
                              ca,
                              wi,
                              zi,
                              Ei,
                              Ji
                            ));
                      }
                      if (Gi) {
                        const Ji = Ri.layout
                            .get("icon-rotate")
                            .evaluate(Wn, {}),
                          Da = Ri.layout.get("icon-text-fit") !== "none",
                          hl = cv(Gi, Ji, gc, Da),
                          ho = ca ? cv(ca, Ji, gc, Da) : void 0;
                        (yc = new pp(ni, bn, ki, Fi, Bi, Gi, wi, zi, !1, Ji)),
                          (vv = 4 * hl.length);
                        const dl = kr.iconSizeData;
                        let Po = null;
                        dl.kind === "source"
                          ? ((Po = [
                              rs * Ri.layout.get("icon-size").evaluate(Wn, {}),
                            ]),
                            Po[0] > Ms &&
                              Bt(
                                `${kr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                              ))
                          : dl.kind === "composite" &&
                            ((Po = [
                              rs *
                                lo.compositeIconSizes[0].evaluate(Wn, {}, co),
                              rs *
                                lo.compositeIconSizes[1].evaluate(Wn, {}, co),
                            ]),
                            (Po[0] > Ms || Po[1] > Ms) &&
                              Bt(
                                `${kr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                              )),
                          kr.addSymbols(
                            kr.icon,
                            hl,
                            Po,
                            vi,
                            Li,
                            Wn,
                            T.as.none,
                            bn,
                            vc.lineStartIndex,
                            vc.lineLength,
                            -1,
                            co
                          ),
                          (om = kr.icon.placedSymbolArray.length - 1),
                          ho &&
                            ((yv = 4 * ho.length),
                            kr.addSymbols(
                              kr.icon,
                              ho,
                              Po,
                              vi,
                              Li,
                              Wn,
                              T.as.vertical,
                              bn,
                              vc.lineStartIndex,
                              vc.lineLength,
                              -1,
                              co
                            ),
                            (sm = kr.icon.placedSymbolArray.length - 1));
                      }
                      const Tv = Object.keys(bi.horizontal);
                      for (const Ji of Tv) {
                        const Da = bi.horizontal[Ji];
                        if (!ul) {
                          wv = ao(Da.text);
                          const ho = Ri.layout
                            .get("text-rotate")
                            .evaluate(Wn, {}, co);
                          ul = new pp(ni, bn, ki, Fi, Bi, Da, aa, La, Ei, ho);
                        }
                        const hl = Da.positionedLines.length === 1;
                        if (
                          ((xv += pv(
                            kr,
                            bn,
                            Da,
                            za,
                            Ri,
                            Ei,
                            Wn,
                            ua,
                            vc,
                            bi.vertical ? T.as.horizontal : T.as.horizontalOnly,
                            hl ? Tv : [Ji],
                            ns,
                            om,
                            lo,
                            co
                          )),
                          hl)
                        )
                          break;
                      }
                      bi.vertical &&
                        (bv += pv(
                          kr,
                          bn,
                          bi.vertical,
                          za,
                          Ri,
                          Ei,
                          Wn,
                          ua,
                          vc,
                          T.as.vertical,
                          ["vertical"],
                          ns,
                          sm,
                          lo,
                          co
                        ));
                      const Dx = ul
                          ? ul.boxStartIndex
                          : kr.collisionBoxArray.length,
                        Rx = ul ? ul.boxEndIndex : kr.collisionBoxArray.length,
                        Fx = xc
                          ? xc.boxStartIndex
                          : kr.collisionBoxArray.length,
                        Bx = xc ? xc.boxEndIndex : kr.collisionBoxArray.length,
                        Ox = yc
                          ? yc.boxStartIndex
                          : kr.collisionBoxArray.length,
                        Nx = yc ? yc.boxEndIndex : kr.collisionBoxArray.length,
                        jx = bc
                          ? bc.boxStartIndex
                          : kr.collisionBoxArray.length,
                        Vx = bc ? bc.boxEndIndex : kr.collisionBoxArray.length;
                      let uo = -1;
                      const mp = (Ji, Da) =>
                        Ji && Ji.circleDiameter
                          ? Math.max(Ji.circleDiameter, Da)
                          : Da;
                      (uo = mp(ul, uo)),
                        (uo = mp(xc, uo)),
                        (uo = mp(yc, uo)),
                        (uo = mp(bc, uo));
                      const Sv = uo > -1 ? 1 : 0;
                      Sv && (uo *= Lx / Ai),
                        kr.glyphOffsetArray.length >= fc.MAX_GLYPHS &&
                          Bt(
                            "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"
                          ),
                        Wn.sortKey !== void 0 &&
                          kr.addToSortKeyRanges(
                            kr.symbolInstances.length,
                            Wn.sortKey
                          );
                      const qx = dv(Ri, Wn, co),
                        [Ux, Zx] = (function (Ji, Da) {
                          const hl = Ji.length,
                            ho = Da == null ? void 0 : Da.values;
                          if ((ho == null ? void 0 : ho.length) > 0)
                            for (let dl = 0; dl < ho.length; dl += 2) {
                              const Po = ho[dl + 1];
                              Ji.emplaceBack(T.aI[ho[dl]], Po[0], Po[1]);
                            }
                          return [hl, Ji.length];
                        })(kr.textAnchorOffsets, qx);
                      kr.symbolInstances.emplaceBack(
                        bn.x,
                        bn.y,
                        ns.right >= 0 ? ns.right : -1,
                        ns.center >= 0 ? ns.center : -1,
                        ns.left >= 0 ? ns.left : -1,
                        ns.vertical || -1,
                        om,
                        sm,
                        wv,
                        Dx,
                        Rx,
                        Fx,
                        Bx,
                        Ox,
                        Nx,
                        jx,
                        Vx,
                        ki,
                        xv,
                        bv,
                        vv,
                        yv,
                        Sv,
                        0,
                        aa,
                        uo,
                        Ux,
                        Zx
                      );
                    })(
                      n,
                      Vr,
                      Kr,
                      r,
                      a,
                      c,
                      nr,
                      n.layers[0],
                      n.collisionBoxArray,
                      t.index,
                      t.sourceLayerIndex,
                      n.index,
                      he,
                      [et, et, et, et],
                      or,
                      b,
                      ye,
                      ht,
                      Yt,
                      X,
                      t,
                      p,
                      C,
                      I,
                      m
                    );
                };
              if (rr === "line")
                for (const Kr of nv(t.geometry, 0, 0, Fe, Fe)) {
                  const Vr = ll(Kr, St),
                    kr = Px(
                      Vr,
                      Ce,
                      Rt,
                      r.vertical || Q,
                      a,
                      24,
                      Oe,
                      n.overscaling,
                      Fe
                    );
                  for (const bn of kr)
                    (Q && Ex(n, Q.text, Fr, bn)) || Hr(Vr, bn);
                }
              else if (rr === "line-center") {
                for (const Kr of t.geometry)
                  if (Kr.length > 1) {
                    const Vr = ll(Kr, St),
                      kr = Cx(Vr, Rt, r.vertical || Q, a, 24, Oe);
                    kr && Hr(Vr, kr);
                  }
              } else if (t.type === "Polygon")
                for (const Kr of kl(t.geometry, 0)) {
                  const Vr = Mx(Kr, 16);
                  Hr(ll(Kr[0], St, !0), new ks(Vr.x, Vr.y, 0));
                }
              else if (t.type === "LineString")
                for (const Kr of t.geometry) {
                  const Vr = ll(Kr, St);
                  Hr(Vr, new ks(Vr[0].x, Vr[0].y, 0));
                }
              else if (t.type === "Point")
                for (const Kr of t.geometry)
                  for (const Vr of Kr) Hr([Vr], new ks(Vr.x, Vr.y, 0));
            }
            function pv(n, t, r, a, c, p, m, v, b, C, I, R, U, Z, X) {
              const Q = (function (Oe, ye, Ce, et, ht, Rt, or, Yt) {
                  const rr =
                      (et.layout.get("text-rotate").evaluate(Rt, {}) *
                        Math.PI) /
                      180,
                    Fr = [];
                  for (const er of ye.positionedLines)
                    for (const nr of er.positionedGlyphs) {
                      if (!nr.rect) continue;
                      const St = nr.rect || {};
                      let Hr = 4,
                        Kr = !0,
                        Vr = 1,
                        kr = 0;
                      const bn = (ht || Yt) && nr.vertical,
                        ai = (nr.metrics.advance * nr.scale) / 2;
                      if (
                        (Yt &&
                          ye.verticalizable &&
                          (kr =
                            er.lineOffset / 2 -
                            (nr.imageName
                              ? -(Ai - nr.metrics.width * nr.scale) / 2
                              : (nr.scale - 1) * Ai)),
                        nr.imageName)
                      ) {
                        const zi = or[nr.imageName];
                        (Kr = zi.sdf), (Vr = zi.pixelRatio), (Hr = 1 / Vr);
                      }
                      const bi = ht ? [nr.x + ai, nr.y] : [0, 0];
                      let Gi = ht
                          ? [0, 0]
                          : [nr.x + ai + Ce[0], nr.y + Ce[1] - kr],
                        za = [0, 0];
                      bn && ((za = Gi), (Gi = [0, 0]));
                      const ca = nr.metrics.isDoubleResolution ? 2 : 1,
                        Ri = (nr.metrics.left - Hr) * nr.scale - ai + Gi[0],
                        ni = (-nr.metrics.top - Hr) * nr.scale + Gi[1],
                        ki = Ri + ((St.w / ca) * nr.scale) / Vr,
                        Fi = ni + ((St.h / ca) * nr.scale) / Vr,
                        Bi = new B(Ri, ni),
                        aa = new B(ki, ni),
                        La = new B(Ri, Fi),
                        Ei = new B(ki, Fi);
                      if (bn) {
                        const zi = new B(-ai, ai - -17),
                          Li = -Math.PI / 2,
                          vi = 12 - ai,
                          Wn = new B(22 - vi, -(nr.imageName ? vi : 0)),
                          lo = new B(...za);
                        Bi._rotateAround(Li, zi)._add(Wn)._add(lo),
                          aa._rotateAround(Li, zi)._add(Wn)._add(lo),
                          La._rotateAround(Li, zi)._add(Wn)._add(lo),
                          Ei._rotateAround(Li, zi)._add(Wn)._add(lo);
                      }
                      if (rr) {
                        const zi = Math.sin(rr),
                          Li = Math.cos(rr),
                          vi = [Li, -zi, zi, Li];
                        Bi._matMult(vi),
                          aa._matMult(vi),
                          La._matMult(vi),
                          Ei._matMult(vi);
                      }
                      const ua = new B(0, 0),
                        wi = new B(0, 0);
                      Fr.push({
                        tl: Bi,
                        tr: aa,
                        bl: La,
                        br: Ei,
                        tex: St,
                        writingMode: ye.writingMode,
                        glyphOffset: bi,
                        sectionIndex: nr.sectionIndex,
                        isSDF: Kr,
                        pixelOffsetTL: ua,
                        pixelOffsetBR: wi,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  return Fr;
                })(0, r, v, c, p, m, a, n.allowVerticalPlacement),
                ie = n.textSizeData;
              let he = null;
              ie.kind === "source"
                ? ((he = [rs * c.layout.get("text-size").evaluate(m, {})]),
                  he[0] > Ms &&
                    Bt(
                      `${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
                    ))
                : ie.kind === "composite" &&
                  ((he = [
                    rs * Z.compositeTextSizes[0].evaluate(m, {}, X),
                    rs * Z.compositeTextSizes[1].evaluate(m, {}, X),
                  ]),
                  (he[0] > Ms || he[1] > Ms) &&
                    Bt(
                      `${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
                    )),
                n.addSymbols(
                  n.text,
                  Q,
                  he,
                  v,
                  p,
                  m,
                  C,
                  t,
                  b.lineStartIndex,
                  b.lineLength,
                  U,
                  X
                );
              for (const Oe of I) R[Oe] = n.text.placedSymbolArray.length - 1;
              return 4 * Q.length;
            }
            function fv(n) {
              for (const t in n) return n[t];
              return null;
            }
            function Ex(n, t, r, a) {
              const c = n.compareText;
              if (t in c) {
                const p = c[t];
                for (let m = p.length - 1; m >= 0; m--)
                  if (a.dist(p[m]) < r) return !0;
              } else c[t] = [];
              return c[t].push(a), !1;
            }
            const mv = [
              Int8Array,
              Uint8Array,
              Uint8ClampedArray,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ];
            class Qf {
              static from(t) {
                if (!(t instanceof ArrayBuffer))
                  throw new Error("Data must be an instance of ArrayBuffer.");
                const [r, a] = new Uint8Array(t, 0, 2);
                if (r !== 219)
                  throw new Error(
                    "Data does not appear to be in a KDBush format."
                  );
                const c = a >> 4;
                if (c !== 1)
                  throw new Error(`Got v${c} data when expected v1.`);
                const p = mv[15 & a];
                if (!p) throw new Error("Unrecognized array type.");
                const [m] = new Uint16Array(t, 2, 1),
                  [v] = new Uint32Array(t, 4, 1);
                return new Qf(v, m, p, t);
              }
              constructor(t, r = 64, a = Float64Array, c) {
                if (isNaN(t) || t < 0)
                  throw new Error(`Unpexpected numItems value: ${t}.`);
                (this.numItems = +t),
                  (this.nodeSize = Math.min(Math.max(+r, 2), 65535)),
                  (this.ArrayType = a),
                  (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array);
                const p = mv.indexOf(this.ArrayType),
                  m = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
                  v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
                  b = (8 - (v % 8)) % 8;
                if (p < 0)
                  throw new Error(`Unexpected typed array class: ${a}.`);
                c && c instanceof ArrayBuffer
                  ? ((this.data = c),
                    (this.ids = new this.IndexArrayType(this.data, 8, t)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + v + b,
                      2 * t
                    )),
                    (this._pos = 2 * t),
                    (this._finished = !0))
                  : ((this.data = new ArrayBuffer(8 + m + v + b)),
                    (this.ids = new this.IndexArrayType(this.data, 8, t)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + v + b,
                      2 * t
                    )),
                    (this._pos = 0),
                    (this._finished = !1),
                    new Uint8Array(this.data, 0, 2).set([219, 16 + p]),
                    (new Uint16Array(this.data, 2, 1)[0] = r),
                    (new Uint32Array(this.data, 4, 1)[0] = t));
              }
              add(t, r) {
                const a = this._pos >> 1;
                return (
                  (this.ids[a] = a),
                  (this.coords[this._pos++] = t),
                  (this.coords[this._pos++] = r),
                  a
                );
              }
              finish() {
                const t = this._pos >> 1;
                if (t !== this.numItems)
                  throw new Error(
                    `Added ${t} items when expected ${this.numItems}.`
                  );
                return (
                  em(
                    this.ids,
                    this.coords,
                    this.nodeSize,
                    0,
                    this.numItems - 1,
                    0
                  ),
                  (this._finished = !0),
                  this
                );
              }
              range(t, r, a, c) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: p, coords: m, nodeSize: v } = this,
                  b = [0, p.length - 1, 0],
                  C = [];
                for (; b.length; ) {
                  const I = b.pop() || 0,
                    R = b.pop() || 0,
                    U = b.pop() || 0;
                  if (R - U <= v) {
                    for (let ie = U; ie <= R; ie++) {
                      const he = m[2 * ie],
                        Oe = m[2 * ie + 1];
                      he >= t && he <= a && Oe >= r && Oe <= c && C.push(p[ie]);
                    }
                    continue;
                  }
                  const Z = (U + R) >> 1,
                    X = m[2 * Z],
                    Q = m[2 * Z + 1];
                  X >= t && X <= a && Q >= r && Q <= c && C.push(p[Z]),
                    (I === 0 ? t <= X : r <= Q) &&
                      (b.push(U), b.push(Z - 1), b.push(1 - I)),
                    (I === 0 ? a >= X : c >= Q) &&
                      (b.push(Z + 1), b.push(R), b.push(1 - I));
                }
                return C;
              }
              within(t, r, a) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: c, coords: p, nodeSize: m } = this,
                  v = [0, c.length - 1, 0],
                  b = [],
                  C = a * a;
                for (; v.length; ) {
                  const I = v.pop() || 0,
                    R = v.pop() || 0,
                    U = v.pop() || 0;
                  if (R - U <= m) {
                    for (let ie = U; ie <= R; ie++)
                      gv(p[2 * ie], p[2 * ie + 1], t, r) <= C && b.push(c[ie]);
                    continue;
                  }
                  const Z = (U + R) >> 1,
                    X = p[2 * Z],
                    Q = p[2 * Z + 1];
                  gv(X, Q, t, r) <= C && b.push(c[Z]),
                    (I === 0 ? t - a <= X : r - a <= Q) &&
                      (v.push(U), v.push(Z - 1), v.push(1 - I)),
                    (I === 0 ? t + a >= X : r + a >= Q) &&
                      (v.push(Z + 1), v.push(R), v.push(1 - I));
                }
                return b;
              }
            }
            function em(n, t, r, a, c, p) {
              if (c - a <= r) return;
              const m = (a + c) >> 1;
              _v(n, t, m, a, c, p),
                em(n, t, r, a, m - 1, 1 - p),
                em(n, t, r, m + 1, c, 1 - p);
            }
            function _v(n, t, r, a, c, p) {
              for (; c > a; ) {
                if (c - a > 600) {
                  const C = c - a + 1,
                    I = r - a + 1,
                    R = Math.log(C),
                    U = 0.5 * Math.exp((2 * R) / 3),
                    Z =
                      0.5 *
                      Math.sqrt((R * U * (C - U)) / C) *
                      (I - C / 2 < 0 ? -1 : 1);
                  _v(
                    n,
                    t,
                    r,
                    Math.max(a, Math.floor(r - (I * U) / C + Z)),
                    Math.min(c, Math.floor(r + ((C - I) * U) / C + Z)),
                    p
                  );
                }
                const m = t[2 * r + p];
                let v = a,
                  b = c;
                for (
                  Zu(n, t, a, r), t[2 * c + p] > m && Zu(n, t, a, c);
                  v < b;

                ) {
                  for (Zu(n, t, v, b), v++, b--; t[2 * v + p] < m; ) v++;
                  for (; t[2 * b + p] > m; ) b--;
                }
                t[2 * a + p] === m ? Zu(n, t, a, b) : (b++, Zu(n, t, b, c)),
                  b <= r && (a = b + 1),
                  r <= b && (c = b - 1);
              }
            }
            function Zu(n, t, r, a) {
              tm(n, r, a), tm(t, 2 * r, 2 * a), tm(t, 2 * r + 1, 2 * a + 1);
            }
            function tm(n, t, r) {
              const a = n[t];
              (n[t] = n[r]), (n[r] = a);
            }
            function gv(n, t, r, a) {
              const c = n - r,
                p = t - a;
              return c * c + p * p;
            }
            var rm;
            (T.cA = void 0),
              ((rm = T.cA || (T.cA = {})).create = "create"),
              (rm.load = "load"),
              (rm.fullLoad = "fullLoad");
            let fp = null,
              Gu = [];
            const nm = 1e3 / 60,
              im = "loadTime",
              am = "fullLoadTime",
              zx = {
                mark(n) {
                  performance.mark(n);
                },
                frame(n) {
                  const t = n;
                  fp != null && Gu.push(t - fp), (fp = t);
                },
                clearMetrics() {
                  (fp = null),
                    (Gu = []),
                    performance.clearMeasures(im),
                    performance.clearMeasures(am);
                  for (const n in T.cA) performance.clearMarks(T.cA[n]);
                },
                getPerformanceMetrics() {
                  performance.measure(im, T.cA.create, T.cA.load),
                    performance.measure(am, T.cA.create, T.cA.fullLoad);
                  const n = performance.getEntriesByName(im)[0].duration,
                    t = performance.getEntriesByName(am)[0].duration,
                    r = Gu.length,
                    a = 1 / (Gu.reduce((p, m) => p + m, 0) / r / 1e3),
                    c = Gu.filter((p) => p > nm).reduce(
                      (p, m) => p + (m - nm) / nm,
                      0
                    );
                  return {
                    loadTime: n,
                    fullLoadTime: t,
                    fps: a,
                    percentDroppedFrames: (c / (r + c)) * 100,
                    totalFrames: r,
                  };
                },
              };
            (T.$ = mr),
              (T.A = De),
              (T.B = ws),
              (T.C = function ([n, t, r]) {
                return (
                  (t += 90),
                  (t *= Math.PI / 180),
                  (r *= Math.PI / 180),
                  {
                    x: n * Math.cos(t) * Math.sin(r),
                    y: n * Math.sin(t) * Math.sin(r),
                    z: n * Math.cos(r),
                  }
                );
              }),
              (T.D = zr),
              (T.E = Ct),
              (T.F = ya),
              (T.G = On),
              (T.H = el),
              (T.I = Vf),
              (T.J = Lt),
              (T.K = class {
                constructor(n, t) {
                  (this.target = n),
                    (this.mapId = t),
                    (this.resolveRejects = {}),
                    (this.tasks = {}),
                    (this.taskQueue = []),
                    (this.abortControllers = {}),
                    (this.messageHandlers = {}),
                    (this.invoker = new wx(() => this.process())),
                    (this.subscription = ar(
                      this.target,
                      "message",
                      (r) => this.receive(r),
                      !1
                    )),
                    (this.globalScope = At(self) ? n : window);
                }
                registerMessageHandler(n, t) {
                  this.messageHandlers[n] = t;
                }
                sendAsync(n, t) {
                  return new Promise((r, a) => {
                    const c = Math.round(1e18 * Math.random())
                        .toString(36)
                        .substring(0, 10),
                      p = t
                        ? ar(
                            t.signal,
                            "abort",
                            () => {
                              p == null || p.unsubscribe(),
                                delete this.resolveRejects[c];
                              const b = {
                                id: c,
                                type: "<cancel>",
                                origin: location.origin,
                                targetMapId: n.targetMapId,
                                sourceMapId: this.mapId,
                              };
                              this.target.postMessage(b);
                            },
                            Tx
                          )
                        : null;
                    this.resolveRejects[c] = {
                      resolve: (b) => {
                        p == null || p.unsubscribe(), r(b);
                      },
                      reject: (b) => {
                        p == null || p.unsubscribe(), a(b);
                      },
                    };
                    const m = [],
                      v = Object.assign(Object.assign({}, n), {
                        id: c,
                        sourceMapId: this.mapId,
                        origin: location.origin,
                        data: ro(n.data, m),
                      });
                    this.target.postMessage(v, { transfer: m });
                  });
                }
                receive(n) {
                  const t = n.data,
                    r = t.id;
                  if (
                    !(
                      (t.origin !== "file://" &&
                        location.origin !== "file://" &&
                        t.origin !== "resource://android" &&
                        location.origin !== "resource://android" &&
                        t.origin !== location.origin) ||
                      (t.targetMapId && this.mapId !== t.targetMapId)
                    )
                  ) {
                    if (t.type === "<cancel>") {
                      delete this.tasks[r];
                      const a = this.abortControllers[r];
                      return (
                        delete this.abortControllers[r], void (a && a.abort())
                      );
                    }
                    if (At(self) || t.mustQueue)
                      return (
                        (this.tasks[r] = t),
                        this.taskQueue.push(r),
                        void this.invoker.trigger()
                      );
                    this.processTask(r, t);
                  }
                }
                process() {
                  if (this.taskQueue.length === 0) return;
                  const n = this.taskQueue.shift(),
                    t = this.tasks[n];
                  delete this.tasks[n],
                    this.taskQueue.length > 0 && this.invoker.trigger(),
                    t && this.processTask(n, t);
                }
                processTask(n, t) {
                  return s(this, void 0, void 0, function* () {
                    if (t.type === "<response>") {
                      const c = this.resolveRejects[n];
                      return (
                        delete this.resolveRejects[n],
                        c
                          ? void (t.error
                              ? c.reject(tl(t.error))
                              : c.resolve(tl(t.data)))
                          : void 0
                      );
                    }
                    if (!this.messageHandlers[t.type])
                      return void this.completeTask(
                        n,
                        new Error(
                          `Could not find a registered handler for ${
                            t.type
                          }, map ID: ${
                            this.mapId
                          }, available handlers: ${Object.keys(
                            this.messageHandlers
                          ).join(", ")}`
                        )
                      );
                    const r = tl(t.data),
                      a = new AbortController();
                    this.abortControllers[n] = a;
                    try {
                      const c = yield this.messageHandlers[t.type](
                        t.sourceMapId,
                        r,
                        a
                      );
                      this.completeTask(n, null, c);
                    } catch (c) {
                      this.completeTask(n, c);
                    }
                  });
                }
                completeTask(n, t, r) {
                  const a = [];
                  delete this.abortControllers[n];
                  const c = {
                    id: n,
                    type: "<response>",
                    sourceMapId: this.mapId,
                    origin: location.origin,
                    error: t ? ro(t) : null,
                    data: ro(r, a),
                  };
                  this.target.postMessage(c, { transfer: a });
                }
                remove() {
                  this.invoker.remove(), this.subscription.unsubscribe();
                }
              }),
              (T.L = j),
              (T.M = function () {
                var n = new De(16);
                return (
                  De != Float32Array &&
                    ((n[1] = 0),
                    (n[2] = 0),
                    (n[3] = 0),
                    (n[4] = 0),
                    (n[6] = 0),
                    (n[7] = 0),
                    (n[8] = 0),
                    (n[9] = 0),
                    (n[11] = 0),
                    (n[12] = 0),
                    (n[13] = 0),
                    (n[14] = 0)),
                  (n[0] = 1),
                  (n[5] = 1),
                  (n[10] = 1),
                  (n[15] = 1),
                  n
                );
              }),
              (T.N = function (n, t, r) {
                var a,
                  c,
                  p,
                  m,
                  v,
                  b,
                  C,
                  I,
                  R,
                  U,
                  Z,
                  X,
                  Q = r[0],
                  ie = r[1],
                  he = r[2];
                return (
                  t === n
                    ? ((n[12] = t[0] * Q + t[4] * ie + t[8] * he + t[12]),
                      (n[13] = t[1] * Q + t[5] * ie + t[9] * he + t[13]),
                      (n[14] = t[2] * Q + t[6] * ie + t[10] * he + t[14]),
                      (n[15] = t[3] * Q + t[7] * ie + t[11] * he + t[15]))
                    : ((c = t[1]),
                      (p = t[2]),
                      (m = t[3]),
                      (v = t[4]),
                      (b = t[5]),
                      (C = t[6]),
                      (I = t[7]),
                      (R = t[8]),
                      (U = t[9]),
                      (Z = t[10]),
                      (X = t[11]),
                      (n[0] = a = t[0]),
                      (n[1] = c),
                      (n[2] = p),
                      (n[3] = m),
                      (n[4] = v),
                      (n[5] = b),
                      (n[6] = C),
                      (n[7] = I),
                      (n[8] = R),
                      (n[9] = U),
                      (n[10] = Z),
                      (n[11] = X),
                      (n[12] = a * Q + v * ie + R * he + t[12]),
                      (n[13] = c * Q + b * ie + U * he + t[13]),
                      (n[14] = p * Q + C * ie + Z * he + t[14]),
                      (n[15] = m * Q + I * ie + X * he + t[15])),
                  n
                );
              }),
              (T.O = function (n, t, r) {
                var a = r[0],
                  c = r[1],
                  p = r[2];
                return (
                  (n[0] = t[0] * a),
                  (n[1] = t[1] * a),
                  (n[2] = t[2] * a),
                  (n[3] = t[3] * a),
                  (n[4] = t[4] * c),
                  (n[5] = t[5] * c),
                  (n[6] = t[6] * c),
                  (n[7] = t[7] * c),
                  (n[8] = t[8] * p),
                  (n[9] = t[9] * p),
                  (n[10] = t[10] * p),
                  (n[11] = t[11] * p),
                  (n[12] = t[12]),
                  (n[13] = t[13]),
                  (n[14] = t[14]),
                  (n[15] = t[15]),
                  n
                );
              }),
              (T.P = B),
              (T.Q = function (n, t, r) {
                var a = t[0],
                  c = t[1],
                  p = t[2],
                  m = t[3],
                  v = t[4],
                  b = t[5],
                  C = t[6],
                  I = t[7],
                  R = t[8],
                  U = t[9],
                  Z = t[10],
                  X = t[11],
                  Q = t[12],
                  ie = t[13],
                  he = t[14],
                  Oe = t[15],
                  ye = r[0],
                  Ce = r[1],
                  et = r[2],
                  ht = r[3];
                return (
                  (n[0] = ye * a + Ce * v + et * R + ht * Q),
                  (n[1] = ye * c + Ce * b + et * U + ht * ie),
                  (n[2] = ye * p + Ce * C + et * Z + ht * he),
                  (n[3] = ye * m + Ce * I + et * X + ht * Oe),
                  (n[4] =
                    (ye = r[4]) * a +
                    (Ce = r[5]) * v +
                    (et = r[6]) * R +
                    (ht = r[7]) * Q),
                  (n[5] = ye * c + Ce * b + et * U + ht * ie),
                  (n[6] = ye * p + Ce * C + et * Z + ht * he),
                  (n[7] = ye * m + Ce * I + et * X + ht * Oe),
                  (n[8] =
                    (ye = r[8]) * a +
                    (Ce = r[9]) * v +
                    (et = r[10]) * R +
                    (ht = r[11]) * Q),
                  (n[9] = ye * c + Ce * b + et * U + ht * ie),
                  (n[10] = ye * p + Ce * C + et * Z + ht * he),
                  (n[11] = ye * m + Ce * I + et * X + ht * Oe),
                  (n[12] =
                    (ye = r[12]) * a +
                    (Ce = r[13]) * v +
                    (et = r[14]) * R +
                    (ht = r[15]) * Q),
                  (n[13] = ye * c + Ce * b + et * U + ht * ie),
                  (n[14] = ye * p + Ce * C + et * Z + ht * he),
                  (n[15] = ye * m + Ce * I + et * X + ht * Oe),
                  n
                );
              }),
              (T.R = la),
              (T.S = function (n, t) {
                const r = {};
                for (let a = 0; a < t.length; a++) {
                  const c = t[a];
                  c in n && (r[c] = n[c]);
                }
                return r;
              }),
              (T.T = Ef),
              (T.U = As),
              (T.V = Ye),
              (T.W = Hg),
              (T.X = $g),
              (T.Y = xe),
              (T.Z = Ie),
              (T._ = s),
              (T.a = E),
              (T.a$ = function (n, t, r) {
                return (
                  (n[0] = t[0] * r[0]),
                  (n[1] = t[1] * r[1]),
                  (n[2] = t[2] * r[2]),
                  (n[3] = t[3] * r[3]),
                  n
                );
              }),
              (T.a0 = Ea),
              (T.a1 = Xg),
              (T.a2 = cp),
              (T.a3 = Fe),
              (T.a4 = function (n, t) {
                var r, a, c, p, m;
                if (!n) return t ?? {};
                if (!t) return n;
                let v = Object.assign({}, n);
                if ((t.removeAll && (v = { removeAll: !0 }), t.remove)) {
                  const b = new Set(t.remove);
                  v.add && (v.add = v.add.filter((I) => !b.has(I.id))),
                    v.update &&
                      (v.update = v.update.filter((I) => !b.has(I.id)));
                  const C = new Set(
                    ((r = n.add) !== null && r !== void 0 ? r : []).map(
                      (I) => I.id
                    )
                  );
                  t.remove = t.remove.filter((I) => !C.has(I));
                }
                if (t.remove) {
                  const b = new Set(
                    v.remove ? v.remove.concat(t.remove) : t.remove
                  );
                  v.remove = Array.from(b.values());
                }
                if (t.add) {
                  const b = v.add ? v.add.concat(t.add) : t.add,
                    C = new Map(b.map((I) => [I.id, I]));
                  v.add = Array.from(C.values());
                }
                if (t.update) {
                  const b = new Map(
                    (a = v.update) === null || a === void 0
                      ? void 0
                      : a.map((C) => [C.id, C])
                  );
                  for (const C of t.update) {
                    const I =
                      (c = b.get(C.id)) !== null && c !== void 0
                        ? c
                        : { id: C.id };
                    C.newGeometry && (I.newGeometry = C.newGeometry),
                      C.addOrUpdateProperties &&
                        (I.addOrUpdateProperties = (
                          (p = I.addOrUpdateProperties) !== null && p !== void 0
                            ? p
                            : []
                        ).concat(C.addOrUpdateProperties)),
                      C.removeProperties &&
                        (I.removeProperties = (
                          (m = I.removeProperties) !== null && m !== void 0
                            ? m
                            : []
                        ).concat(C.removeProperties)),
                      C.removeAllProperties && (I.removeAllProperties = !0),
                      b.set(C.id, I);
                  }
                  v.update = Array.from(b.values());
                }
                return (
                  v.remove &&
                    v.add &&
                    (v.remove = v.remove.filter(
                      (b) => v.add.findIndex((C) => C.id === b) === -1
                    )),
                  v
                );
              }),
              (T.a5 = qu),
              (T.a6 = cl),
              (T.a7 = 25),
              (T.a8 = Yf),
              (T.a9 = (n) => {
                const t = window.document.createElement("video");
                return (
                  (t.muted = !0),
                  new Promise((r) => {
                    t.onloadstart = () => {
                      r(t);
                    };
                    for (const a of n) {
                      const c = window.document.createElement("source");
                      ge(a) || (t.crossOrigin = "Anonymous"),
                        (c.src = a),
                        t.appendChild(c);
                    }
                  })
                );
              }),
              (T.aA = Ge),
              (T.aB = function (n, t, r, a) {
                const c = t.y - n.y,
                  p = t.x - n.x,
                  m = a.y - r.y,
                  v = a.x - r.x,
                  b = m * p - v * c;
                if (b === 0) return null;
                const C = (v * (n.y - r.y) - m * (n.x - r.x)) / b;
                return new B(n.x + C * p, n.y + C * c);
              }),
              (T.aC = nv),
              (T.aD = $_),
              (T.aE = function (n) {
                let t = 1 / 0,
                  r = 1 / 0,
                  a = -1 / 0,
                  c = -1 / 0;
                for (const p of n)
                  (t = Math.min(t, p.x)),
                    (r = Math.min(r, p.y)),
                    (a = Math.max(a, p.x)),
                    (c = Math.max(c, p.y));
                return [t, r, a, c];
              }),
              (T.aF = Ai),
              (T.aG = ft),
              (T.aH = function (n, t, r, a, c = !1) {
                if (!r[0] && !r[1]) return [0, 0];
                const p = c
                  ? a === "map"
                    ? -n.bearingInRadians
                    : 0
                  : a === "viewport"
                  ? n.bearingInRadians
                  : 0;
                if (p) {
                  const m = Math.sin(p),
                    v = Math.cos(p);
                  r = [r[0] * v - r[1] * m, r[0] * m + r[1] * v];
                }
                return [
                  c ? r[0] : ft(t, r[0], n.zoom),
                  c ? r[1] : ft(t, r[1], n.zoom),
                ];
              }),
              (T.aJ = Zf),
              (T.aK = Jf),
              (T.aL = Uf),
              (T.aM = Qf),
              (T.aN = ci),
              (T.aO = np),
              (T.aP = fe),
              (T.aQ = cn),
              (T.aR = Pt),
              (T.aS = tr),
              (T.aT = Yg),
              (T.aU = Le),
              (T.aV = $e),
              (T.aW = function (n) {
                var t = new De(3);
                return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), t;
              }),
              (T.aX = function (n, t, r) {
                return (
                  (n[0] = t[0] - r[0]),
                  (n[1] = t[1] - r[1]),
                  (n[2] = t[2] - r[2]),
                  n
                );
              }),
              (T.aY = function (n, t) {
                var r = t[0],
                  a = t[1],
                  c = t[2],
                  p = r * r + a * a + c * c;
                return (
                  p > 0 && (p = 1 / Math.sqrt(p)),
                  (n[0] = t[0] * p),
                  (n[1] = t[1] * p),
                  (n[2] = t[2] * p),
                  n
                );
              }),
              (T.aZ = nt),
              (T.a_ = function (n, t) {
                return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
              }),
              (T.aa = pt),
              (T.ab = function () {
                return xt++;
              }),
              (T.ac = w),
              (T.ad = fc),
              (T.ae = Ys),
              (T.af = Co),
              (T.ag = ev),
              (T.ah = function (n) {
                const t = {};
                if (
                  (n.replace(
                    /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                    (r, a, c, p) => {
                      const m = c || p;
                      return (t[a] = !m || m.toLowerCase()), "";
                    }
                  ),
                  t["max-age"])
                ) {
                  const r = parseInt(t["max-age"], 10);
                  isNaN(r) ? delete t["max-age"] : (t["max-age"] = r);
                }
                return t;
              }),
              (T.ai = Ft),
              (T.aj = 85.051129),
              (T.ak = pr),
              (T.al = function (n) {
                return Math.pow(2, n);
              }),
              (T.am = qe),
              (T.an = Wg),
              (T.ao = function (n) {
                return Math.log(n) / Math.LN2;
              }),
              (T.ap = function (n) {
                var t = n[0],
                  r = n[1];
                return t * t + r * r;
              }),
              (T.aq = function (n) {
                if (!n.length) return new Set();
                const t = Math.max(...n.map((b) => b.canonical.z));
                let r = 1 / 0,
                  a = -1 / 0,
                  c = 1 / 0,
                  p = -1 / 0;
                const m = [];
                for (const b of n) {
                  const { x: C, y: I, z: R } = b.canonical,
                    U = Math.pow(2, t - R),
                    Z = C * U,
                    X = I * U;
                  m.push({ id: b, x: Z, y: X }),
                    Z < r && (r = Z),
                    Z > a && (a = Z),
                    X < c && (c = X),
                    X > p && (p = X);
                }
                const v = new Set();
                for (const b of m)
                  (b.x !== r && b.x !== a && b.y !== c && b.y !== p) ||
                    v.add(b.id);
                return v;
              }),
              (T.ar = function (n, t) {
                let r = 0,
                  a = 0;
                if (n.kind === "constant") a = n.layoutSize;
                else if (n.kind !== "source") {
                  const { interpolationType: c, minZoom: p, maxZoom: m } = n,
                    v = c ? Ft(zn.interpolationFactor(c, t, p, m), 0, 1) : 0;
                  n.kind === "camera"
                    ? (a = ya.number(n.minSize, n.maxSize, v))
                    : (r = v);
                }
                return { uSizeT: r, uSize: a };
              }),
              (T.at = function (
                n,
                { uSize: t, uSizeT: r },
                { lowerSize: a, upperSize: c }
              ) {
                return n.kind === "source"
                  ? a / rs
                  : n.kind === "composite"
                  ? ya.number(a / rs, c / rs, r)
                  : t;
              }),
              (T.au = function (n, t) {
                var r = t[0],
                  a = t[1],
                  c = t[2],
                  p = t[3],
                  m = t[4],
                  v = t[5],
                  b = t[6],
                  C = t[7],
                  I = t[8],
                  R = t[9],
                  U = t[10],
                  Z = t[11],
                  X = t[12],
                  Q = t[13],
                  ie = t[14],
                  he = t[15],
                  Oe = r * v - a * m,
                  ye = r * b - c * m,
                  Ce = r * C - p * m,
                  et = a * b - c * v,
                  ht = a * C - p * v,
                  Rt = c * C - p * b,
                  or = I * Q - R * X,
                  Yt = I * ie - U * X,
                  rr = I * he - Z * X,
                  Fr = R * ie - U * Q,
                  er = R * he - Z * Q,
                  nr = U * he - Z * ie,
                  St =
                    Oe * nr - ye * er + Ce * Fr + et * rr - ht * Yt + Rt * or;
                return St
                  ? ((n[0] = (v * nr - b * er + C * Fr) * (St = 1 / St)),
                    (n[1] = (c * er - a * nr - p * Fr) * St),
                    (n[2] = (Q * Rt - ie * ht + he * et) * St),
                    (n[3] = (U * ht - R * Rt - Z * et) * St),
                    (n[4] = (b * rr - m * nr - C * Yt) * St),
                    (n[5] = (r * nr - c * rr + p * Yt) * St),
                    (n[6] = (ie * Ce - X * Rt - he * ye) * St),
                    (n[7] = (I * Rt - U * Ce + Z * ye) * St),
                    (n[8] = (m * er - v * rr + C * or) * St),
                    (n[9] = (a * rr - r * er - p * or) * St),
                    (n[10] = (X * ht - Q * Ce + he * Oe) * St),
                    (n[11] = (R * Ce - I * ht - Z * Oe) * St),
                    (n[12] = (v * Yt - m * Fr - b * or) * St),
                    (n[13] = (r * Fr - a * Yt + c * or) * St),
                    (n[14] = (Q * ye - X * et - ie * Oe) * St),
                    (n[15] = (I * et - R * ye + U * Oe) * St),
                    n)
                  : null;
              }),
              (T.av = Ve),
              (T.aw = function (n) {
                var t = n[0],
                  r = n[1];
                return Math.sqrt(t * t + r * r);
              }),
              (T.ax = function (n) {
                return (n[0] = 0), (n[1] = 0), n;
              }),
              (T.ay = function (n, t, r) {
                return (n[0] = t[0] * r), (n[1] = t[1] * r), n;
              }),
              (T.az = Gf),
              (T.b = Nt),
              (T.b$ = function (n, t, r) {
                var a = t[0],
                  c = t[1],
                  p = t[2];
                return (
                  (n[0] = a * r[0] + c * r[3] + p * r[6]),
                  (n[1] = a * r[1] + c * r[4] + p * r[7]),
                  (n[2] = a * r[2] + c * r[5] + p * r[8]),
                  n
                );
              }),
              (T.b0 = Be),
              (T.b1 = function (n, t, r) {
                const a = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
                return a === 0
                  ? null
                  : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / a;
              }),
              (T.b2 = je),
              (T.b3 = function (n, t, r) {
                return (
                  (n[0] = t[0] * r),
                  (n[1] = t[1] * r),
                  (n[2] = t[2] * r),
                  (n[3] = t[3] * r),
                  n
                );
              }),
              (T.b4 = function (n, t) {
                return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3];
              }),
              (T.b5 = Jg),
              (T.b6 = mc),
              (T.b7 = function (n, t, r, a, c) {
                var p = 1 / Math.tan(t / 2);
                if (
                  ((n[0] = p / r),
                  (n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[5] = p),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[11] = -1),
                  (n[12] = 0),
                  (n[13] = 0),
                  (n[15] = 0),
                  c != null && c !== 1 / 0)
                ) {
                  var m = 1 / (a - c);
                  (n[10] = (c + a) * m), (n[14] = 2 * c * a * m);
                } else (n[10] = -1), (n[14] = -2 * a);
                return n;
              }),
              (T.b8 = function (n) {
                var t = new De(16);
                return (
                  (t[0] = n[0]),
                  (t[1] = n[1]),
                  (t[2] = n[2]),
                  (t[3] = n[3]),
                  (t[4] = n[4]),
                  (t[5] = n[5]),
                  (t[6] = n[6]),
                  (t[7] = n[7]),
                  (t[8] = n[8]),
                  (t[9] = n[9]),
                  (t[10] = n[10]),
                  (t[11] = n[11]),
                  (t[12] = n[12]),
                  (t[13] = n[13]),
                  (t[14] = n[14]),
                  (t[15] = n[15]),
                  t
                );
              }),
              (T.b9 = function (n, t, r) {
                var a = Math.sin(r),
                  c = Math.cos(r),
                  p = t[0],
                  m = t[1],
                  v = t[2],
                  b = t[3],
                  C = t[4],
                  I = t[5],
                  R = t[6],
                  U = t[7];
                return (
                  t !== n &&
                    ((n[8] = t[8]),
                    (n[9] = t[9]),
                    (n[10] = t[10]),
                    (n[11] = t[11]),
                    (n[12] = t[12]),
                    (n[13] = t[13]),
                    (n[14] = t[14]),
                    (n[15] = t[15])),
                  (n[0] = p * c + C * a),
                  (n[1] = m * c + I * a),
                  (n[2] = v * c + R * a),
                  (n[3] = b * c + U * a),
                  (n[4] = C * c - p * a),
                  (n[5] = I * c - m * a),
                  (n[6] = R * c - v * a),
                  (n[7] = U * c - b * a),
                  n
                );
              }),
              (T.bA = function (n, t, r, a) {
                var c = [],
                  p = [];
                return (
                  (c[0] = t[0] - r[0]),
                  (c[1] = t[1] - r[1]),
                  (c[2] = t[2] - r[2]),
                  (p[0] = c[0]),
                  (p[1] = c[1] * Math.cos(a) - c[2] * Math.sin(a)),
                  (p[2] = c[1] * Math.sin(a) + c[2] * Math.cos(a)),
                  (n[0] = p[0] + r[0]),
                  (n[1] = p[1] + r[1]),
                  (n[2] = p[2] + r[2]),
                  n
                );
              }),
              (T.bB = function (n, t, r, a) {
                var c = [],
                  p = [];
                return (
                  (c[0] = t[0] - r[0]),
                  (c[1] = t[1] - r[1]),
                  (c[2] = t[2] - r[2]),
                  (p[0] = c[2] * Math.sin(a) + c[0] * Math.cos(a)),
                  (p[1] = c[1]),
                  (p[2] = c[2] * Math.cos(a) - c[0] * Math.sin(a)),
                  (n[0] = p[0] + r[0]),
                  (n[1] = p[1] + r[1]),
                  (n[2] = p[2] + r[2]),
                  n
                );
              }),
              (T.bC = function (n, t, r) {
                var a = Math.sin(r),
                  c = Math.cos(r),
                  p = t[0],
                  m = t[1],
                  v = t[2],
                  b = t[3],
                  C = t[8],
                  I = t[9],
                  R = t[10],
                  U = t[11];
                return (
                  t !== n &&
                    ((n[4] = t[4]),
                    (n[5] = t[5]),
                    (n[6] = t[6]),
                    (n[7] = t[7]),
                    (n[12] = t[12]),
                    (n[13] = t[13]),
                    (n[14] = t[14]),
                    (n[15] = t[15])),
                  (n[0] = p * c - C * a),
                  (n[1] = m * c - I * a),
                  (n[2] = v * c - R * a),
                  (n[3] = b * c - U * a),
                  (n[8] = p * a + C * c),
                  (n[9] = m * a + I * c),
                  (n[10] = v * a + R * c),
                  (n[11] = b * a + U * c),
                  n
                );
              }),
              (T.bD = function (n, t) {
                const r = lt(n, 360),
                  a = lt(t, 360),
                  c = a - r,
                  p = a > r ? c - 360 : c + 360;
                return Math.abs(c) < Math.abs(p) ? c : p;
              }),
              (T.bE = function (n) {
                return (n[0] = 0), (n[1] = 0), (n[2] = 0), n;
              }),
              (T.bF = function (n, t, r, a) {
                const c = Math.sqrt(n * n + t * t),
                  p = Math.sqrt(r * r + a * a);
                (n /= c), (t /= c), (r /= p), (a /= p);
                const m = Math.acos(n * r + t * a);
                return -t * r + n * a > 0 ? m : -m;
              }),
              (T.bG = function (n, t) {
                const r = lt(n, 2 * Math.PI),
                  a = lt(t, 2 * Math.PI);
                return Math.min(
                  Math.abs(r - a),
                  Math.abs(r - a + 2 * Math.PI),
                  Math.abs(r - a - 2 * Math.PI)
                );
              }),
              (T.bH = function () {
                const n = {},
                  t = _e.$version;
                for (const r in _e.$root) {
                  const a = _e.$root[r];
                  if (a.required) {
                    let c = null;
                    (c = r === "version" ? t : a.type === "array" ? [] : {}),
                      c != null && (n[r] = c);
                  }
                }
                return n;
              }),
              (T.bI = _u),
              (T.bJ = W),
              (T.bK = function n(t, r) {
                if (Array.isArray(t)) {
                  if (!Array.isArray(r) || t.length !== r.length) return !1;
                  for (let a = 0; a < t.length; a++)
                    if (!n(t[a], r[a])) return !1;
                  return !0;
                }
                if (typeof t == "object" && t !== null && r !== null) {
                  if (
                    typeof r != "object" ||
                    Object.keys(t).length !== Object.keys(r).length
                  )
                    return !1;
                  for (const a in t) if (!n(t[a], r[a])) return !1;
                  return !0;
                }
                return t === r;
              }),
              (T.bL = function (n) {
                n = n.slice();
                const t = Object.create(null);
                for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
                for (let r = 0; r < n.length; r++)
                  "ref" in n[r] && (n[r] = cr(n[r], t[n[r].ref]));
                return n;
              }),
              (T.bM = function (n, t) {
                if (n.type === "custom") return new bx(n, t);
                switch (n.type) {
                  case "background":
                    return new xx(n, t);
                  case "circle":
                    return new a1(n, t);
                  case "color-relief":
                    return new h1(n, t);
                  case "fill":
                    return new P1(n, t);
                  case "fill-extrusion":
                    return new B1(n, t);
                  case "heatmap":
                    return new s1(n, t);
                  case "hillshade":
                    return new c1(n, t);
                  case "line":
                    return new Z1(n, t);
                  case "raster":
                    return new wf(n, t);
                  case "symbol":
                    return new lp(n, t);
                }
              }),
              (T.bN = (n) => n.type === "raster"),
              (T.bO = Mt),
              (T.bP = function (n, t) {
                if (!n) return [{ command: "setStyle", args: [t] }];
                let r = [];
                try {
                  if (!Ot(n.version, t.version))
                    return [{ command: "setStyle", args: [t] }];
                  Ot(n.center, t.center) ||
                    r.push({ command: "setCenter", args: [t.center] }),
                    Ot(n.state, t.state) ||
                      r.push({ command: "setGlobalState", args: [t.state] }),
                    Ot(n.centerAltitude, t.centerAltitude) ||
                      r.push({
                        command: "setCenterAltitude",
                        args: [t.centerAltitude],
                      }),
                    Ot(n.zoom, t.zoom) ||
                      r.push({ command: "setZoom", args: [t.zoom] }),
                    Ot(n.bearing, t.bearing) ||
                      r.push({ command: "setBearing", args: [t.bearing] }),
                    Ot(n.pitch, t.pitch) ||
                      r.push({ command: "setPitch", args: [t.pitch] }),
                    Ot(n.roll, t.roll) ||
                      r.push({ command: "setRoll", args: [t.roll] }),
                    Ot(n.sprite, t.sprite) ||
                      r.push({ command: "setSprite", args: [t.sprite] }),
                    Ot(n.glyphs, t.glyphs) ||
                      r.push({ command: "setGlyphs", args: [t.glyphs] }),
                    Ot(n.transition, t.transition) ||
                      r.push({
                        command: "setTransition",
                        args: [t.transition],
                      }),
                    Ot(n.light, t.light) ||
                      r.push({ command: "setLight", args: [t.light] }),
                    Ot(n.terrain, t.terrain) ||
                      r.push({ command: "setTerrain", args: [t.terrain] }),
                    Ot(n.sky, t.sky) ||
                      r.push({ command: "setSky", args: [t.sky] }),
                    Ot(n.projection, t.projection) ||
                      r.push({
                        command: "setProjection",
                        args: [t.projection],
                      });
                  const a = {},
                    c = [];
                  (function (m, v, b, C) {
                    let I;
                    for (I in ((v = v || {}), (m = m || {})))
                      Object.prototype.hasOwnProperty.call(m, I) &&
                        (Object.prototype.hasOwnProperty.call(v, I) ||
                          Ur(I, b, C));
                    for (I in v)
                      Object.prototype.hasOwnProperty.call(v, I) &&
                        (Object.prototype.hasOwnProperty.call(m, I)
                          ? Ot(m[I], v[I]) ||
                            (m[I].type === "geojson" &&
                            v[I].type === "geojson" &&
                            un(m, v, I)
                              ? ur(b, {
                                  command: "setGeoJSONSourceData",
                                  args: [I, v[I].data],
                                })
                              : Wr(I, v, b, C))
                          : Nr(I, v, b));
                  })(n.sources, t.sources, c, a);
                  const p = [];
                  n.layers &&
                    n.layers.forEach((m) => {
                      "source" in m && a[m.source]
                        ? r.push({ command: "removeLayer", args: [m.id] })
                        : p.push(m);
                    }),
                    (r = r.concat(c)),
                    (function (m, v, b) {
                      v = v || [];
                      const C = (m = m || []).map(fn),
                        I = v.map(fn),
                        R = m.reduce(rn, {}),
                        U = v.reduce(rn, {}),
                        Z = C.slice(),
                        X = Object.create(null);
                      let Q, ie, he, Oe, ye;
                      for (let Ce = 0, et = 0; Ce < C.length; Ce++)
                        (Q = C[Ce]),
                          Object.prototype.hasOwnProperty.call(U, Q)
                            ? et++
                            : (ur(b, { command: "removeLayer", args: [Q] }),
                              Z.splice(Z.indexOf(Q, et), 1));
                      for (let Ce = 0, et = 0; Ce < I.length; Ce++)
                        (Q = I[I.length - 1 - Ce]),
                          Z[Z.length - 1 - Ce] !== Q &&
                            (Object.prototype.hasOwnProperty.call(R, Q)
                              ? (ur(b, { command: "removeLayer", args: [Q] }),
                                Z.splice(Z.lastIndexOf(Q, Z.length - et), 1))
                              : et++,
                            (Oe = Z[Z.length - Ce]),
                            ur(b, { command: "addLayer", args: [U[Q], Oe] }),
                            Z.splice(Z.length - Ce, 0, Q),
                            (X[Q] = !0));
                      for (let Ce = 0; Ce < I.length; Ce++)
                        if (
                          ((Q = I[Ce]),
                          (ie = R[Q]),
                          (he = U[Q]),
                          !X[Q] && !Ot(ie, he))
                        )
                          if (
                            Ot(ie.source, he.source) &&
                            Ot(ie["source-layer"], he["source-layer"]) &&
                            Ot(ie.type, he.type)
                          ) {
                            for (ye in (an(
                              ie.layout,
                              he.layout,
                              b,
                              Q,
                              null,
                              "setLayoutProperty"
                            ),
                            an(
                              ie.paint,
                              he.paint,
                              b,
                              Q,
                              null,
                              "setPaintProperty"
                            ),
                            Ot(ie.filter, he.filter) ||
                              ur(b, {
                                command: "setFilter",
                                args: [Q, he.filter],
                              }),
                            (Ot(ie.minzoom, he.minzoom) &&
                              Ot(ie.maxzoom, he.maxzoom)) ||
                              ur(b, {
                                command: "setLayerZoomRange",
                                args: [Q, he.minzoom, he.maxzoom],
                              }),
                            ie))
                              Object.prototype.hasOwnProperty.call(ie, ye) &&
                                ye !== "layout" &&
                                ye !== "paint" &&
                                ye !== "filter" &&
                                ye !== "metadata" &&
                                ye !== "minzoom" &&
                                ye !== "maxzoom" &&
                                (ye.indexOf("paint.") === 0
                                  ? an(
                                      ie[ye],
                                      he[ye],
                                      b,
                                      Q,
                                      ye.slice(6),
                                      "setPaintProperty"
                                    )
                                  : Ot(ie[ye], he[ye]) ||
                                    ur(b, {
                                      command: "setLayerProperty",
                                      args: [Q, ye, he[ye]],
                                    }));
                            for (ye in he)
                              Object.prototype.hasOwnProperty.call(he, ye) &&
                                !Object.prototype.hasOwnProperty.call(ie, ye) &&
                                ye !== "layout" &&
                                ye !== "paint" &&
                                ye !== "filter" &&
                                ye !== "metadata" &&
                                ye !== "minzoom" &&
                                ye !== "maxzoom" &&
                                (ye.indexOf("paint.") === 0
                                  ? an(
                                      ie[ye],
                                      he[ye],
                                      b,
                                      Q,
                                      ye.slice(6),
                                      "setPaintProperty"
                                    )
                                  : Ot(ie[ye], he[ye]) ||
                                    ur(b, {
                                      command: "setLayerProperty",
                                      args: [Q, ye, he[ye]],
                                    }));
                          } else
                            ur(b, { command: "removeLayer", args: [Q] }),
                              (Oe = Z[Z.lastIndexOf(Q) + 1]),
                              ur(b, { command: "addLayer", args: [he, Oe] });
                    })(p, t.layers, r);
                } catch (a) {
                  console.warn("Unable to compute style diff:", a),
                    (r = [{ command: "setStyle", args: [t] }]);
                }
                return r;
              }),
              (T.bQ = function (n) {
                const t = [],
                  r = n.id;
                return (
                  r === void 0 &&
                    t.push({
                      message: `layers.${r}: missing required property "id"`,
                    }),
                  n.render === void 0 &&
                    t.push({
                      message: `layers.${r}: missing required method "render"`,
                    }),
                  n.renderingMode &&
                    n.renderingMode !== "2d" &&
                    n.renderingMode !== "3d" &&
                    t.push({
                      message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`,
                    }),
                  t
                );
              }),
              (T.bR = It),
              (T.bS = Tt),
              (T.bT = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = 0);
                }
                set(n) {
                  this.current !== n &&
                    ((this.current = n), this.gl.uniform1i(this.location, n));
                }
              }),
              (T.bU = To),
              (T.bV = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = ol);
                }
                set(n) {
                  if (n[12] !== this.current[12] || n[0] !== this.current[0])
                    return (
                      (this.current = n),
                      void this.gl.uniformMatrix4fv(this.location, !1, n)
                    );
                  for (let t = 1; t < 16; t++)
                    if (n[t] !== this.current[t]) {
                      (this.current = n),
                        this.gl.uniformMatrix4fv(this.location, !1, n);
                      break;
                    }
                }
              }),
              (T.bW = oo),
              (T.bX = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = [0, 0, 0]);
                }
                set(n) {
                  (n[0] === this.current[0] &&
                    n[1] === this.current[1] &&
                    n[2] === this.current[2]) ||
                    ((this.current = n),
                    this.gl.uniform3f(this.location, n[0], n[1], n[2]));
                }
              }),
              (T.bY = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = [0, 0]);
                }
                set(n) {
                  (n[0] === this.current[0] && n[1] === this.current[1]) ||
                    ((this.current = n),
                    this.gl.uniform2f(this.location, n[0], n[1]));
                }
              }),
              (T.bZ = Ae),
              (T.b_ = function (n, t) {
                var r = Math.sin(t),
                  a = Math.cos(t);
                return (
                  (n[0] = a),
                  (n[1] = r),
                  (n[2] = 0),
                  (n[3] = -r),
                  (n[4] = a),
                  (n[5] = 0),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 1),
                  n
                );
              }),
              (T.ba = function (n, t, r) {
                var a = Math.sin(r),
                  c = Math.cos(r),
                  p = t[4],
                  m = t[5],
                  v = t[6],
                  b = t[7],
                  C = t[8],
                  I = t[9],
                  R = t[10],
                  U = t[11];
                return (
                  t !== n &&
                    ((n[0] = t[0]),
                    (n[1] = t[1]),
                    (n[2] = t[2]),
                    (n[3] = t[3]),
                    (n[12] = t[12]),
                    (n[13] = t[13]),
                    (n[14] = t[14]),
                    (n[15] = t[15])),
                  (n[4] = p * c + C * a),
                  (n[5] = m * c + I * a),
                  (n[6] = v * c + R * a),
                  (n[7] = b * c + U * a),
                  (n[8] = C * c - p * a),
                  (n[9] = I * c - m * a),
                  (n[10] = R * c - v * a),
                  (n[11] = U * c - b * a),
                  n
                );
              }),
              (T.bb = function () {
                const n = new Float32Array(16);
                return qe(n), n;
              }),
              (T.bc = function () {
                const n = new Float64Array(16);
                return qe(n), n;
              }),
              (T.bd = function () {
                return new Float64Array(16);
              }),
              (T.be = function (n, t, r) {
                const a = new Float64Array(4);
                return Xe(a, n, t - 90, r), a;
              }),
              (T.bf = function (n, t, r, a) {
                var c,
                  p,
                  m,
                  v,
                  b,
                  C = t[0],
                  I = t[1],
                  R = t[2],
                  U = t[3],
                  Z = r[0],
                  X = r[1],
                  Q = r[2],
                  ie = r[3];
                return (
                  (p = C * Z + I * X + R * Q + U * ie) < 0 &&
                    ((p = -p), (Z = -Z), (X = -X), (Q = -Q), (ie = -ie)),
                  1 - p > Ee
                    ? ((c = Math.acos(p)),
                      (m = Math.sin(c)),
                      (v = Math.sin((1 - a) * c) / m),
                      (b = Math.sin(a * c) / m))
                    : ((v = 1 - a), (b = a)),
                  (n[0] = v * C + b * Z),
                  (n[1] = v * I + b * X),
                  (n[2] = v * R + b * Q),
                  (n[3] = v * U + b * ie),
                  n
                );
              }),
              (T.bg = function (n) {
                const t = new Float64Array(9);
                var r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, he, Oe, ye;
                (R = (c = (a = n)[0]) * (b = c + c)),
                  (U = (p = a[1]) * b),
                  (X = (m = a[2]) * b),
                  (Q = m * (C = p + p)),
                  (he = (v = a[3]) * b),
                  (Oe = v * C),
                  (ye = v * (I = m + m)),
                  ((r = t)[0] = 1 - (Z = p * C) - (ie = m * I)),
                  (r[3] = U - ye),
                  (r[6] = X + Oe),
                  (r[1] = U + ye),
                  (r[4] = 1 - R - ie),
                  (r[7] = Q - he),
                  (r[2] = X - Oe),
                  (r[5] = Q + he),
                  (r[8] = 1 - R - Z);
                const Ce = tr(-Math.asin(Ft(t[2], -1, 1)));
                let et, ht;
                return (
                  Math.hypot(t[5], t[8]) < 0.001
                    ? ((et = 0), (ht = -tr(Math.atan2(t[3], t[4]))))
                    : ((et = tr(
                        t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])
                      )),
                      (ht = tr(
                        t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0])
                      ))),
                  { roll: et, pitch: Ce + 90, bearing: ht }
                );
              }),
              (T.bh = function (n, t) {
                return (
                  n.roll == t.roll &&
                  n.pitch == t.pitch &&
                  n.bearing == t.bearing
                );
              }),
              (T.bi = Cr),
              (T.bj = Ki),
              (T.bk = uc),
              (T.bl = Fu),
              (T.bm = cc),
              (T.bn = yt),
              (T.bo = mt),
              (T.bp = Yn),
              (T.bq = function (n, t, r, a, c) {
                return yt(a, c, Ft((n - t) / (r - t), 0, 1));
              }),
              (T.br = lt),
              (T.bs = function () {
                return new Float64Array(3);
              }),
              (T.bt = function (n, t, r, a) {
                return (
                  (n[0] = t[0] + r[0] * a),
                  (n[1] = t[1] + r[1] * a),
                  (n[2] = t[2] + r[2] * a),
                  n
                );
              }),
              (T.bu = Xe),
              (T.bv = function (n, t, r) {
                var a = r[0],
                  c = r[1],
                  p = r[2],
                  m = r[3],
                  v = t[0],
                  b = t[1],
                  C = t[2],
                  I = c * C - p * b,
                  R = p * v - a * C,
                  U = a * b - c * v;
                return (
                  (n[0] = v + m * (I += I) + c * (U += U) - p * (R += R)),
                  (n[1] = b + m * R + p * I - a * U),
                  (n[2] = C + m * U + a * R - c * I),
                  n
                );
              }),
              (T.bw = function (n, t, r) {
                const a =
                  (c = [
                    n[0],
                    n[1],
                    n[2],
                    t[0],
                    t[1],
                    t[2],
                    r[0],
                    r[1],
                    r[2],
                  ])[0] *
                    ((I = c[8]) * (m = c[4]) - (v = c[5]) * (C = c[7])) +
                  c[1] * (-I * (p = c[3]) + v * (b = c[6])) +
                  c[2] * (C * p - m * b);
                var c, p, m, v, b, C, I;
                if (a === 0) return null;
                const R = nt([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
                  U = nt([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
                  Z = nt([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
                  X = Le([], R, -n[3]);
                return (
                  $e(X, X, Le([], U, -t[3])),
                  $e(X, X, Le([], Z, -r[3])),
                  Le(X, X, 1 / a),
                  X
                );
              }),
              (T.bx = Xf),
              (T.by = function () {
                return new Float64Array(4);
              }),
              (T.bz = function (n, t, r, a) {
                var c = [],
                  p = [];
                return (
                  (c[0] = t[0] - r[0]),
                  (c[1] = t[1] - r[1]),
                  (c[2] = t[2] - r[2]),
                  (p[0] = c[0] * Math.cos(a) - c[1] * Math.sin(a)),
                  (p[1] = c[0] * Math.sin(a) + c[1] * Math.cos(a)),
                  (p[2] = c[2]),
                  (n[0] = p[0] + r[0]),
                  (n[1] = p[1] + r[1]),
                  (n[2] = p[2] + r[2]),
                  n
                );
              }),
              (T.c = O),
              (T.c0 = function (n, t, r, a, c, p, m) {
                var v = 1 / (t - r),
                  b = 1 / (a - c),
                  C = 1 / (p - m);
                return (
                  (n[0] = -2 * v),
                  (n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[5] = -2 * b),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[10] = 2 * C),
                  (n[11] = 0),
                  (n[12] = (t + r) * v),
                  (n[13] = (c + a) * b),
                  (n[14] = (m + p) * C),
                  (n[15] = 1),
                  n
                );
              }),
              (T.c1 = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = new Array());
                }
                set(n) {
                  if (n != this.current) {
                    this.current = n;
                    const t = new Float32Array(4 * n.length);
                    for (let r = 0; r < n.length; r++)
                      (t[4 * r] = n[r].r),
                        (t[4 * r + 1] = n[r].g),
                        (t[4 * r + 2] = n[r].b),
                        (t[4 * r + 3] = n[r].a);
                    this.gl.uniform4fv(this.location, t);
                  }
                }
              }),
              (T.c2 = class extends ia {
                constructor(n, t) {
                  super(n, t), (this.current = new Array());
                }
                set(n) {
                  if (n != this.current) {
                    this.current = n;
                    const t = new Float32Array(n);
                    this.gl.uniform1fv(this.location, t);
                  }
                }
              }),
              (T.c3 = class extends Yo {}),
              (T.c4 = W1),
              (T.c5 = class extends rc {}),
              (T.c6 = kf),
              (T.c7 = function (n) {
                return n <= 1
                  ? 1
                  : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
              }),
              (T.c8 = rg),
              (T.c9 = function (n, t, r) {
                var a = t[0],
                  c = t[1],
                  p = t[2],
                  m = r[3] * a + r[7] * c + r[11] * p + r[15];
                return (
                  (n[0] =
                    (r[0] * a + r[4] * c + r[8] * p + r[12]) / (m = m || 1)),
                  (n[1] = (r[1] * a + r[5] * c + r[9] * p + r[13]) / m),
                  (n[2] = (r[2] * a + r[6] * c + r[10] * p + r[14]) / m),
                  n
                );
              }),
              (T.cB = function (n) {
                return n.message === Te;
              }),
              (T.cC = H),
              (T.cD = function (n, t) {
                E.REGISTERED_PROTOCOLS[n] = t;
              }),
              (T.cE = function (n) {
                delete E.REGISTERED_PROTOCOLS[n];
              }),
              (T.cF = function (n, t) {
                const r = {};
                for (let c = 0; c < n.length; c++) {
                  const p = (t && t[n[c].id]) || Td(n[c]);
                  t && (t[n[c].id] = p);
                  let m = r[p];
                  m || (m = r[p] = []), m.push(n[c]);
                }
                const a = [];
                for (const c in r) a.push(r[c]);
                return a;
              }),
              (T.cG = hr),
              (T.cH = Qg),
              (T.cI = tv),
              (T.cJ = Eg),
              (T.cK = function (n) {
                n.bucket.createArrays(),
                  (n.bucket.tilePixelRatio = Fe / (512 * n.bucket.overscaling)),
                  (n.bucket.compareText = {}),
                  (n.bucket.iconsNeedLinear = !1);
                const t = n.bucket.layers[0],
                  r = t.layout,
                  a = t._unevaluatedLayout._values,
                  c = {
                    layoutIconSize: a["icon-size"].possiblyEvaluate(
                      new On(n.bucket.zoom + 1),
                      n.canonical
                    ),
                    layoutTextSize: a["text-size"].possiblyEvaluate(
                      new On(n.bucket.zoom + 1),
                      n.canonical
                    ),
                    textMaxSize: a["text-size"].possiblyEvaluate(new On(18)),
                  };
                if (n.bucket.textSizeData.kind === "composite") {
                  const { minZoom: C, maxZoom: I } = n.bucket.textSizeData;
                  c.compositeTextSizes = [
                    a["text-size"].possiblyEvaluate(new On(C), n.canonical),
                    a["text-size"].possiblyEvaluate(new On(I), n.canonical),
                  ];
                }
                if (n.bucket.iconSizeData.kind === "composite") {
                  const { minZoom: C, maxZoom: I } = n.bucket.iconSizeData;
                  c.compositeIconSizes = [
                    a["icon-size"].possiblyEvaluate(new On(C), n.canonical),
                    a["icon-size"].possiblyEvaluate(new On(I), n.canonical),
                  ];
                }
                const p = r.get("text-line-height") * Ai,
                  m =
                    r.get("text-rotation-alignment") !== "viewport" &&
                    r.get("symbol-placement") !== "point",
                  v = r.get("text-keep-upright"),
                  b = r.get("text-size");
                for (const C of n.bucket.features) {
                  const I = r
                      .get("text-font")
                      .evaluate(C, {}, n.canonical)
                      .join(","),
                    R = b.evaluate(C, {}, n.canonical),
                    U = c.layoutTextSize.evaluate(C, {}, n.canonical),
                    Z = c.layoutIconSize.evaluate(C, {}, n.canonical),
                    X = { horizontal: {}, vertical: void 0 },
                    Q = C.text;
                  let ie,
                    he = [0, 0];
                  if (Q) {
                    const Ce = Q.toString(),
                      et =
                        r
                          .get("text-letter-spacing")
                          .evaluate(C, {}, n.canonical) * Ai,
                      ht = vu(Ce) ? et : 0,
                      Rt = r.get("text-anchor").evaluate(C, {}, n.canonical),
                      or = dv(t, C, n.canonical);
                    if (!or) {
                      const er = r
                        .get("text-radial-offset")
                        .evaluate(C, {}, n.canonical);
                      he = er
                        ? hv(Rt, [er * Ai, Kf])
                        : r
                            .get("text-offset")
                            .evaluate(C, {}, n.canonical)
                            .map((nr) => nr * Ai);
                    }
                    let Yt = m
                      ? "center"
                      : r.get("text-justify").evaluate(C, {}, n.canonical);
                    const rr =
                        r.get("symbol-placement") === "point"
                          ? r
                              .get("text-max-width")
                              .evaluate(C, {}, n.canonical) * Ai
                          : 1 / 0,
                      Fr = () => {
                        n.bucket.allowVerticalPlacement &&
                          gu(Ce) &&
                          (X.vertical = ap(
                            Q,
                            n.glyphMap,
                            n.glyphPositions,
                            n.imagePositions,
                            I,
                            rr,
                            p,
                            Rt,
                            "left",
                            ht,
                            he,
                            T.as.vertical,
                            !0,
                            U,
                            R
                          ));
                      };
                    if (!m && or) {
                      const er = new Set();
                      if (Yt === "auto")
                        for (let St = 0; St < or.values.length; St += 2)
                          er.add(Jf(or.values[St]));
                      else er.add(Yt);
                      let nr = !1;
                      for (const St of er)
                        if (!X.horizontal[St])
                          if (nr) X.horizontal[St] = X.horizontal[0];
                          else {
                            const Hr = ap(
                              Q,
                              n.glyphMap,
                              n.glyphPositions,
                              n.imagePositions,
                              I,
                              rr,
                              p,
                              "center",
                              St,
                              ht,
                              he,
                              T.as.horizontal,
                              !1,
                              U,
                              R
                            );
                            Hr &&
                              ((X.horizontal[St] = Hr),
                              (nr = Hr.positionedLines.length === 1));
                          }
                      Fr();
                    } else {
                      Yt === "auto" && (Yt = Jf(Rt));
                      const er = ap(
                        Q,
                        n.glyphMap,
                        n.glyphPositions,
                        n.imagePositions,
                        I,
                        rr,
                        p,
                        Rt,
                        Yt,
                        ht,
                        he,
                        T.as.horizontal,
                        !1,
                        U,
                        R
                      );
                      er && (X.horizontal[Yt] = er),
                        Fr(),
                        gu(Ce) &&
                          m &&
                          v &&
                          (X.vertical = ap(
                            Q,
                            n.glyphMap,
                            n.glyphPositions,
                            n.imagePositions,
                            I,
                            rr,
                            p,
                            Rt,
                            Yt,
                            ht,
                            he,
                            T.as.vertical,
                            !1,
                            U,
                            R
                          ));
                    }
                  }
                  let Oe = !1;
                  if (C.icon && C.icon.name) {
                    const Ce = n.imageMap[C.icon.name];
                    Ce &&
                      ((ie = _x(
                        n.imagePositions[C.icon.name],
                        r.get("icon-offset").evaluate(C, {}, n.canonical),
                        r.get("icon-anchor").evaluate(C, {}, n.canonical)
                      )),
                      (Oe = !!Ce.sdf),
                      n.bucket.sdfIcons === void 0
                        ? (n.bucket.sdfIcons = Oe)
                        : n.bucket.sdfIcons !== Oe &&
                          Bt(
                            "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"
                          ),
                      (Ce.pixelRatio !== n.bucket.pixelRatio ||
                        r.get("icon-rotate").constantOr(1) !== 0) &&
                        (n.bucket.iconsNeedLinear = !0));
                  }
                  const ye = fv(X.horizontal) || X.vertical;
                  (n.bucket.iconsInText = !!ye && ye.iconsInText),
                    (ye || ie) &&
                      kx(
                        n.bucket,
                        C,
                        X,
                        ie,
                        n.imageMap,
                        c,
                        U,
                        Z,
                        he,
                        Oe,
                        n.canonical,
                        n.subdivisionGranularity
                      );
                }
                n.showCollisionBoxes &&
                  n.bucket.generateCollisionDebugBuffers();
              }),
              (T.cL = Rf),
              (T.cM = Bf),
              (T.cN = Of),
              (T.cO = gg),
              (T.cP = jf),
              (T.cQ = class {
                constructor(n) {
                  (this._marks = {
                    start: [n.url, "start"].join("#"),
                    end: [n.url, "end"].join("#"),
                    measure: n.url.toString(),
                  }),
                    performance.mark(this._marks.start);
                }
                finish() {
                  performance.mark(this._marks.end);
                  let n = performance.getEntriesByName(this._marks.measure);
                  return (
                    n.length === 0 &&
                      (performance.measure(
                        this._marks.measure,
                        this._marks.start,
                        this._marks.end
                      ),
                      (n = performance.getEntriesByName(this._marks.measure)),
                      performance.clearMarks(this._marks.start),
                      performance.clearMarks(this._marks.end),
                      performance.clearMeasures(this._marks.measure)),
                    n
                  );
                }
              }),
              (T.cR = function (n, t, r, a, c) {
                return s(this, void 0, void 0, function* () {
                  if (Ie())
                    try {
                      return yield mr(n, t, r, a, c);
                    } catch {}
                  return (function (p, m, v, b, C) {
                    const I = p.width,
                      R = p.height;
                    (ir && vr) ||
                      ((ir = new OffscreenCanvas(I, R)),
                      (vr = ir.getContext("2d", { willReadFrequently: !0 }))),
                      (ir.width = I),
                      (ir.height = R),
                      vr.drawImage(p, 0, 0, I, R);
                    const U = vr.getImageData(m, v, b, C);
                    return vr.clearRect(0, 0, I, R), U.data;
                  })(n, t, r, a, c);
                });
              }),
              (T.cS = ag),
              (T.cT = N),
              (T.cU = _g),
              (T.cV = hc),
              (T.cW = Zo),
              (T.cX = function (n, t) {
                const r = new Map();
                if (n != null)
                  if (n.type === "Feature") r.set(Uu(n, t), n);
                  else for (const a of n.features) r.set(Uu(a, t), a);
                return r;
              }),
              (T.cY = function (n, t) {
                if (n == null) return !0;
                if (n.type === "Feature") return Uu(n, t) != null;
                if (n.type === "FeatureCollection") {
                  const r = new Set();
                  for (const a of n.features) {
                    const c = Uu(a, t);
                    if (c == null || r.has(c)) return !1;
                    r.add(c);
                  }
                  return !0;
                }
                return !1;
              }),
              (T.cZ = function (n, t, r) {
                var a, c, p, m;
                if ((t.removeAll && n.clear(), t.remove))
                  for (const v of t.remove) n.delete(v);
                if (t.add)
                  for (const v of t.add) {
                    const b = Uu(v, r);
                    b != null && n.set(b, v);
                  }
                if (t.update)
                  for (const v of t.update) {
                    let b = n.get(v.id);
                    if (b == null) continue;
                    const C =
                      !v.removeAllProperties &&
                      (((a = v.removeProperties) === null || a === void 0
                        ? void 0
                        : a.length) > 0 ||
                        ((c = v.addOrUpdateProperties) === null || c === void 0
                          ? void 0
                          : c.length) > 0);
                    if (
                      ((v.newGeometry || v.removeAllProperties || C) &&
                        ((b = Object.assign({}, b)),
                        n.set(v.id, b),
                        C && (b.properties = Object.assign({}, b.properties))),
                      v.newGeometry && (b.geometry = v.newGeometry),
                      v.removeAllProperties)
                    )
                      b.properties = {};
                    else if (
                      ((p = v.removeProperties) === null || p === void 0
                        ? void 0
                        : p.length) > 0
                    )
                      for (const I of v.removeProperties)
                        Object.prototype.hasOwnProperty.call(b.properties, I) &&
                          delete b.properties[I];
                    if (
                      ((m = v.addOrUpdateProperties) === null || m === void 0
                        ? void 0
                        : m.length) > 0
                    )
                      for (const {
                        key: I,
                        value: R,
                      } of v.addOrUpdateProperties)
                        b.properties[I] = R;
                  }
              }),
              (T.c_ = no),
              (T.ca = class extends Su {}),
              (T.cb = class extends u {}),
              (T.cc = function (n, t) {
                return (
                  n[0] === t[0] &&
                  n[1] === t[1] &&
                  n[2] === t[2] &&
                  n[3] === t[3] &&
                  n[4] === t[4] &&
                  n[5] === t[5] &&
                  n[6] === t[6] &&
                  n[7] === t[7] &&
                  n[8] === t[8] &&
                  n[9] === t[9] &&
                  n[10] === t[10] &&
                  n[11] === t[11] &&
                  n[12] === t[12] &&
                  n[13] === t[13] &&
                  n[14] === t[14] &&
                  n[15] === t[15]
                );
              }),
              (T.cd = function (n, t) {
                var r = n[0],
                  a = n[1],
                  c = n[2],
                  p = n[3],
                  m = n[4],
                  v = n[5],
                  b = n[6],
                  C = n[7],
                  I = n[8],
                  R = n[9],
                  U = n[10],
                  Z = n[11],
                  X = n[12],
                  Q = n[13],
                  ie = n[14],
                  he = n[15],
                  Oe = t[0],
                  ye = t[1],
                  Ce = t[2],
                  et = t[3],
                  ht = t[4],
                  Rt = t[5],
                  or = t[6],
                  Yt = t[7],
                  rr = t[8],
                  Fr = t[9],
                  er = t[10],
                  nr = t[11],
                  St = t[12],
                  Hr = t[13],
                  Kr = t[14],
                  Vr = t[15];
                return (
                  Math.abs(r - Oe) <=
                    Ee * Math.max(1, Math.abs(r), Math.abs(Oe)) &&
                  Math.abs(a - ye) <=
                    Ee * Math.max(1, Math.abs(a), Math.abs(ye)) &&
                  Math.abs(c - Ce) <=
                    Ee * Math.max(1, Math.abs(c), Math.abs(Ce)) &&
                  Math.abs(p - et) <=
                    Ee * Math.max(1, Math.abs(p), Math.abs(et)) &&
                  Math.abs(m - ht) <=
                    Ee * Math.max(1, Math.abs(m), Math.abs(ht)) &&
                  Math.abs(v - Rt) <=
                    Ee * Math.max(1, Math.abs(v), Math.abs(Rt)) &&
                  Math.abs(b - or) <=
                    Ee * Math.max(1, Math.abs(b), Math.abs(or)) &&
                  Math.abs(C - Yt) <=
                    Ee * Math.max(1, Math.abs(C), Math.abs(Yt)) &&
                  Math.abs(I - rr) <=
                    Ee * Math.max(1, Math.abs(I), Math.abs(rr)) &&
                  Math.abs(R - Fr) <=
                    Ee * Math.max(1, Math.abs(R), Math.abs(Fr)) &&
                  Math.abs(U - er) <=
                    Ee * Math.max(1, Math.abs(U), Math.abs(er)) &&
                  Math.abs(Z - nr) <=
                    Ee * Math.max(1, Math.abs(Z), Math.abs(nr)) &&
                  Math.abs(X - St) <=
                    Ee * Math.max(1, Math.abs(X), Math.abs(St)) &&
                  Math.abs(Q - Hr) <=
                    Ee * Math.max(1, Math.abs(Q), Math.abs(Hr)) &&
                  Math.abs(ie - Kr) <=
                    Ee * Math.max(1, Math.abs(ie), Math.abs(Kr)) &&
                  Math.abs(he - Vr) <=
                    Ee * Math.max(1, Math.abs(he), Math.abs(Vr))
                );
              }),
              (T.ce = function (n, t) {
                return (
                  (n[0] = t[0]),
                  (n[1] = t[1]),
                  (n[2] = t[2]),
                  (n[3] = t[3]),
                  (n[4] = t[4]),
                  (n[5] = t[5]),
                  (n[6] = t[6]),
                  (n[7] = t[7]),
                  (n[8] = t[8]),
                  (n[9] = t[9]),
                  (n[10] = t[10]),
                  (n[11] = t[11]),
                  (n[12] = t[12]),
                  (n[13] = t[13]),
                  (n[14] = t[14]),
                  (n[15] = t[15]),
                  n
                );
              }),
              (T.cf = (n) => n.type === "symbol"),
              (T.cg = (n) => n.type === "circle"),
              (T.ch = (n) => n.type === "heatmap"),
              (T.ci = (n) => n.type === "line"),
              (T.cj = (n) => n.type === "fill"),
              (T.ck = (n) => n.type === "fill-extrusion"),
              (T.cl = (n) => n.type === "hillshade"),
              (T.cm = (n) => n.type === "color-relief"),
              (T.cn = (n) => n.type === "background"),
              (T.co = (n) => n.type === "custom"),
              (T.cp = ct),
              (T.cq = function (n, t, r) {
                const a = Ke(t.x - r.x, t.y - r.y),
                  c = Ke(n.x - r.x, n.y - r.y);
                var p, m;
                return tr(
                  Math.atan2(
                    a[0] * c[1] - a[1] * c[0],
                    (p = a)[0] * (m = c)[0] + p[1] * m[1]
                  )
                );
              }),
              (T.cr = qt),
              (T.cs = function (n, t) {
                return (
                  Sr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
                );
              }),
              (T.ct = function (n, t) {
                return Dt[t] && "touches" in n;
              }),
              (T.cu = function (n) {
                return Dt[n] || Sr[n];
              }),
              (T.cv = function (n, t, r) {
                var a = t[0],
                  c = t[1];
                return (
                  (n[0] = r[0] * a + r[4] * c + r[12]),
                  (n[1] = r[1] * a + r[5] * c + r[13]),
                  n
                );
              }),
              (T.cw = function (n, t) {
                const { x: r, y: a } = qu.fromLngLat(t);
                return !(n < 0 || n > 25 || a < 0 || a >= 1 || r < 0 || r >= 1);
              }),
              (T.cx = function (n, t) {
                return (
                  (n[0] = t[0]),
                  (n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[5] = t[1]),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[10] = t[2]),
                  (n[11] = 0),
                  (n[12] = 0),
                  (n[13] = 0),
                  (n[14] = 0),
                  (n[15] = 1),
                  n
                );
              }),
              (T.cy = class extends Jl {}),
              (T.cz = zx),
              (T.d = ge),
              (T.e = at),
              (T.f = (n) =>
                s(void 0, void 0, void 0, function* () {
                  if (n.byteLength === 0)
                    return createImageBitmap(new ImageData(1, 1));
                  const t = new Blob([new Uint8Array(n)], {
                    type: "image/png",
                  });
                  try {
                    return createImageBitmap(t);
                  } catch (r) {
                    throw new Error(
                      `Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
                    );
                  }
                })),
              (T.g = D),
              (T.h = (n) =>
                new Promise((t, r) => {
                  const a = new Image();
                  (a.onload = () => {
                    t(a),
                      URL.revokeObjectURL(a.src),
                      (a.onload = null),
                      window.requestAnimationFrame(() => {
                        a.src = jt;
                      });
                  }),
                    (a.onerror = () =>
                      r(
                        new Error(
                          "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
                        )
                      ));
                  const c = new Blob([new Uint8Array(n)], {
                    type: "image/png",
                  });
                  a.src = n.byteLength ? URL.createObjectURL(c) : jt;
                })),
              (T.i = At),
              (T.j = (n, t) => ce(at(n, { type: "json" }), t)),
              (T.k = Ze),
              (T.l = We),
              (T.m = ce),
              (T.n = (n, t) => ce(at(n, { type: "arrayBuffer" }), t)),
              (T.o = function (n) {
                return new jf(n).readFields(ax, []);
              }),
              (T.p = kg),
              (T.q = Eu),
              (T.r = Ui),
              (T.s = ar),
              (T.t = _e),
              (T.u = mn),
              (T.v = zd),
              (T.w = Bt),
              (T.x = Ud),
              (T.y = yf),
              (T.z = Dd);
          }),
            A("worker", ["./shared"], function (T) {
              class s {
                constructor(E, D) {
                  (this.keyCache = {}), E && this.replace(E, D);
                }
                replace(E, D) {
                  (this._layerConfigs = {}),
                    (this._layers = {}),
                    this.update(E, [], D);
                }
                update(E, D, j) {
                  for (const W of E) {
                    this._layerConfigs[W.id] = W;
                    const ce = (this._layers[W.id] = T.bM(W, j));
                    (ce._featureFilter = T.ae(ce.filter, j)),
                      this.keyCache[W.id] && delete this.keyCache[W.id];
                  }
                  for (const W of D)
                    delete this.keyCache[W],
                      delete this._layerConfigs[W],
                      delete this._layers[W];
                  this.familiesBySource = {};
                  const H = T.cF(
                    Object.values(this._layerConfigs),
                    this.keyCache
                  );
                  for (const W of H) {
                    const ce = W.map((Ct) => this._layers[Ct.id]),
                      ge = ce[0];
                    if (ge.visibility === "none") continue;
                    const de = ge.source || "";
                    let Se = this.familiesBySource[de];
                    Se || (Se = this.familiesBySource[de] = {});
                    const We = ge.sourceLayer || "_geojsonTileLayer";
                    let Ze = Se[We];
                    Ze || (Ze = Se[We] = []), Ze.push(ce);
                  }
                }
              }
              class B {
                constructor(E) {
                  const D = {},
                    j = [];
                  for (const ge in E) {
                    const de = E[ge],
                      Se = (D[ge] = {});
                    for (const We in de) {
                      const Ze = de[+We];
                      if (
                        !Ze ||
                        Ze.bitmap.width === 0 ||
                        Ze.bitmap.height === 0
                      )
                        continue;
                      const Ct = {
                        x: 0,
                        y: 0,
                        w: Ze.bitmap.width + 2,
                        h: Ze.bitmap.height + 2,
                      };
                      j.push(Ct), (Se[We] = { rect: Ct, metrics: Ze.metrics });
                    }
                  }
                  const { w: H, h: W } = T.p(j),
                    ce = new T.q({ width: H || 1, height: W || 1 });
                  for (const ge in E) {
                    const de = E[ge];
                    for (const Se in de) {
                      const We = de[+Se];
                      if (
                        !We ||
                        We.bitmap.width === 0 ||
                        We.bitmap.height === 0
                      )
                        continue;
                      const Ze = D[ge][Se].rect;
                      T.q.copy(
                        We.bitmap,
                        ce,
                        { x: 0, y: 0 },
                        { x: Ze.x + 1, y: Ze.y + 1 },
                        We.bitmap
                      );
                    }
                  }
                  (this.image = ce), (this.positions = D);
                }
              }
              T.cG("GlyphAtlas", B);
              class N {
                constructor(E) {
                  (this.tileID = new T.a0(
                    E.tileID.overscaledZ,
                    E.tileID.wrap,
                    E.tileID.canonical.z,
                    E.tileID.canonical.x,
                    E.tileID.canonical.y
                  )),
                    (this.uid = E.uid),
                    (this.zoom = E.zoom),
                    (this.pixelRatio = E.pixelRatio),
                    (this.tileSize = E.tileSize),
                    (this.source = E.source),
                    (this.overscaling = this.tileID.overscaleFactor()),
                    (this.showCollisionBoxes = E.showCollisionBoxes),
                    (this.collectResourceTiming = !!E.collectResourceTiming),
                    (this.returnDependencies = !!E.returnDependencies),
                    (this.promoteId = E.promoteId),
                    (this.inFlightDependencies = []);
                }
                parse(E, D, j, H, W) {
                  return T._(this, void 0, void 0, function* () {
                    (this.status = "parsing"),
                      (this.data = E),
                      (this.collisionBoxArray = new T.ac());
                    const ce = new T.cH(Object.keys(E.layers).sort()),
                      ge = new T.cI(this.tileID, this.promoteId);
                    ge.bucketLayerIDs = [];
                    const de = {},
                      Se = {
                        featureIndex: ge,
                        iconDependencies: {},
                        patternDependencies: {},
                        glyphDependencies: {},
                        dashDependencies: {},
                        availableImages: j,
                        subdivisionGranularity: W,
                      },
                      We = D.familiesBySource[this.source];
                    for (const pt in We) {
                      const on = E.layers[pt];
                      if (!on) continue;
                      on.version === 1 &&
                        T.w(
                          `Vector tile source "${this.source}" layer "${pt}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                        );
                      const Pn = ce.encode(pt),
                        zt = [];
                      for (let Qt = 0; Qt < on.length; Qt++) {
                        const rt = on.feature(Qt),
                          $t = ge.getId(rt, pt);
                        zt.push({
                          feature: rt,
                          id: $t,
                          index: Qt,
                          sourceLayerIndex: Pn,
                        });
                      }
                      for (const Qt of We[pt]) {
                        const rt = Qt[0];
                        rt.source !== this.source &&
                          T.w(
                            `layer.source = ${rt.source} does not equal this.source = ${this.source}`
                          ),
                          rt.isHidden(this.zoom, !0) ||
                            (K(Qt, this.zoom, j),
                            (de[rt.id] = rt.createBucket({
                              index: ge.bucketLayerIDs.length,
                              layers: Qt,
                              zoom: this.zoom,
                              pixelRatio: this.pixelRatio,
                              overscaling: this.overscaling,
                              collisionBoxArray: this.collisionBoxArray,
                              sourceLayerIndex: Pn,
                              sourceID: this.source,
                            })).populate(zt, Se, this.tileID.canonical),
                            ge.bucketLayerIDs.push(Qt.map(($t) => $t.id)));
                      }
                    }
                    const Ze = T.bR(Se.glyphDependencies, (pt) =>
                      Object.keys(pt).map(Number)
                    );
                    this.inFlightDependencies.forEach((pt) =>
                      pt == null ? void 0 : pt.abort()
                    ),
                      (this.inFlightDependencies = []);
                    let Ct = Promise.resolve({});
                    if (Object.keys(Ze).length) {
                      const pt = new AbortController();
                      this.inFlightDependencies.push(pt),
                        (Ct = H.sendAsync(
                          {
                            type: "GG",
                            data: {
                              stacks: Ze,
                              source: this.source,
                              tileID: this.tileID,
                              type: "glyphs",
                            },
                          },
                          pt
                        ));
                    }
                    const _e = Object.keys(Se.iconDependencies);
                    let Vt = Promise.resolve({});
                    if (_e.length) {
                      const pt = new AbortController();
                      this.inFlightDependencies.push(pt),
                        (Vt = H.sendAsync(
                          {
                            type: "GI",
                            data: {
                              icons: _e,
                              source: this.source,
                              tileID: this.tileID,
                              type: "icons",
                            },
                          },
                          pt
                        ));
                    }
                    const cr = Object.keys(Se.patternDependencies);
                    let Ot = Promise.resolve({});
                    if (cr.length) {
                      const pt = new AbortController();
                      this.inFlightDependencies.push(pt),
                        (Ot = H.sendAsync(
                          {
                            type: "GI",
                            data: {
                              icons: cr,
                              source: this.source,
                              tileID: this.tileID,
                              type: "patterns",
                            },
                          },
                          pt
                        ));
                    }
                    const ur = Se.dashDependencies;
                    let Nr = Promise.resolve({});
                    if (Object.keys(ur).length) {
                      const pt = new AbortController();
                      this.inFlightDependencies.push(pt),
                        (Nr = H.sendAsync(
                          { type: "GDA", data: { dashes: ur } },
                          pt
                        ));
                    }
                    const [Ur, Wr, un, an] = yield Promise.all([
                        Ct,
                        Vt,
                        Ot,
                        Nr,
                      ]),
                      fn = new B(Ur),
                      rn = new T.cJ(Wr, un);
                    for (const pt in de) {
                      const on = de[pt];
                      on instanceof T.ad
                        ? (K(on.layers, this.zoom, j),
                          T.cK({
                            bucket: on,
                            glyphMap: Ur,
                            glyphPositions: fn.positions,
                            imageMap: Wr,
                            imagePositions: rn.iconPositions,
                            showCollisionBoxes: this.showCollisionBoxes,
                            canonical: this.tileID.canonical,
                            subdivisionGranularity: Se.subdivisionGranularity,
                          }))
                        : on.hasDependencies &&
                          (on instanceof T.cL ||
                            on instanceof T.cM ||
                            on instanceof T.cN) &&
                          (K(on.layers, this.zoom, j),
                          on.addFeatures(
                            Se,
                            this.tileID.canonical,
                            rn.patternPositions,
                            an
                          ));
                    }
                    return (
                      (this.status = "done"),
                      {
                        buckets: Object.values(de).filter(
                          (pt) => !pt.isEmpty()
                        ),
                        featureIndex: ge,
                        collisionBoxArray: this.collisionBoxArray,
                        glyphAtlasImage: fn.image,
                        imageAtlas: rn,
                        dashPositions: an,
                        glyphMap: this.returnDependencies ? Ur : null,
                        iconMap: this.returnDependencies ? Wr : null,
                        glyphPositions: this.returnDependencies
                          ? fn.positions
                          : null,
                      }
                    );
                  });
                }
              }
              function K(O, E, D) {
                const j = new T.G(E);
                for (const H of O) H.recalculate(j, D);
              }
              class ee {
                constructor(E, D, j) {
                  (this.actor = E),
                    (this.layerIndex = D),
                    (this.availableImages = j),
                    (this.fetching = {}),
                    (this.loading = {}),
                    (this.loaded = {});
                }
                loadVectorTile(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    const j = yield T.n(E.request, D);
                    try {
                      return {
                        vectorTile: new T.cO(new T.cP(j.data)),
                        rawData: j.data,
                        cacheControl: j.cacheControl,
                        expires: j.expires,
                      };
                    } catch (H) {
                      const W = new Uint8Array(j.data);
                      let ce = `Unable to parse the tile at ${E.request.url}, `;
                      throw (
                        ((ce +=
                          W[0] === 31 && W[1] === 139
                            ? "please make sure the data is not gzipped and that you have configured the relevant header in the server"
                            : `got error: ${H.message}`),
                        new Error(ce))
                      );
                    }
                  });
                }
                loadTile(E) {
                  return T._(this, void 0, void 0, function* () {
                    const D = E.uid,
                      j =
                        !!(E && E.request && E.request.collectResourceTiming) &&
                        new T.cQ(E.request),
                      H = new N(E);
                    this.loading[D] = H;
                    const W = new AbortController();
                    H.abort = W;
                    try {
                      const ce = yield this.loadVectorTile(E, W);
                      if ((delete this.loading[D], !ce)) return null;
                      const ge = ce.rawData,
                        de = {};
                      ce.expires && (de.expires = ce.expires),
                        ce.cacheControl && (de.cacheControl = ce.cacheControl);
                      const Se = {};
                      if (j) {
                        const Ze = j.finish();
                        Ze &&
                          (Se.resourceTiming = JSON.parse(JSON.stringify(Ze)));
                      }
                      H.vectorTile = ce.vectorTile;
                      const We = H.parse(
                        ce.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        E.subdivisionGranularity
                      );
                      (this.loaded[D] = H),
                        (this.fetching[D] = {
                          rawTileData: ge,
                          cacheControl: de,
                          resourceTiming: Se,
                        });
                      try {
                        const Ze = yield We;
                        return T.e({ rawTileData: ge.slice(0) }, Ze, de, Se);
                      } finally {
                        delete this.fetching[D];
                      }
                    } catch (ce) {
                      throw (
                        (delete this.loading[D],
                        (H.status = "done"),
                        (this.loaded[D] = H),
                        ce)
                      );
                    }
                  });
                }
                reloadTile(E) {
                  return T._(this, void 0, void 0, function* () {
                    const D = E.uid;
                    if (!this.loaded || !this.loaded[D])
                      throw new Error(
                        "Should not be trying to reload a tile that was never loaded or has been removed"
                      );
                    const j = this.loaded[D];
                    if (
                      ((j.showCollisionBoxes = E.showCollisionBoxes),
                      j.status === "parsing")
                    ) {
                      const H = yield j.parse(
                        j.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        E.subdivisionGranularity
                      );
                      let W;
                      if (this.fetching[D]) {
                        const {
                          rawTileData: ce,
                          cacheControl: ge,
                          resourceTiming: de,
                        } = this.fetching[D];
                        delete this.fetching[D],
                          (W = T.e({ rawTileData: ce.slice(0) }, H, ge, de));
                      } else W = H;
                      return W;
                    }
                    if (j.status === "done" && j.vectorTile)
                      return j.parse(
                        j.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        E.subdivisionGranularity
                      );
                  });
                }
                abortTile(E) {
                  return T._(this, void 0, void 0, function* () {
                    const D = this.loading,
                      j = E.uid;
                    D &&
                      D[j] &&
                      D[j].abort &&
                      (D[j].abort.abort(), delete D[j]);
                  });
                }
                removeTile(E) {
                  return T._(this, void 0, void 0, function* () {
                    this.loaded &&
                      this.loaded[E.uid] &&
                      delete this.loaded[E.uid];
                  });
                }
              }
              class re {
                constructor() {
                  this.loaded = {};
                }
                loadTile(E) {
                  return T._(this, void 0, void 0, function* () {
                    const {
                        uid: D,
                        encoding: j,
                        rawImageData: H,
                        redFactor: W,
                        greenFactor: ce,
                        blueFactor: ge,
                        baseShift: de,
                      } = E,
                      Se = H.width + 2,
                      We = H.height + 2,
                      Ze = T.b(H)
                        ? new T.R(
                            { width: Se, height: We },
                            yield T.cR(H, -1, -1, Se, We)
                          )
                        : H,
                      Ct = new T.cS(D, Ze, j, W, ce, ge, de);
                    return (
                      (this.loaded = this.loaded || {}),
                      (this.loaded[D] = Ct),
                      Ct
                    );
                  });
                }
                removeTile(E) {
                  const D = this.loaded,
                    j = E.uid;
                  D && D[j] && delete D[j];
                }
              }
              var ue,
                ne,
                Y = (function () {
                  if (ne) return ue;
                  function O(D, j) {
                    if (D.length !== 0) {
                      E(D[0], j);
                      for (var H = 1; H < D.length; H++) E(D[H], !j);
                    }
                  }
                  function E(D, j) {
                    for (
                      var H = 0, W = 0, ce = 0, ge = D.length, de = ge - 1;
                      ce < ge;
                      de = ce++
                    ) {
                      var Se = (D[ce][0] - D[de][0]) * (D[de][1] + D[ce][1]),
                        We = H + Se;
                      (W +=
                        Math.abs(H) >= Math.abs(Se)
                          ? H - We + Se
                          : Se - We + H),
                        (H = We);
                    }
                    H + W >= 0 != !!j && D.reverse();
                  }
                  return (
                    (ne = 1),
                    (ue = function D(j, H) {
                      var W,
                        ce = j && j.type;
                      if (ce === "FeatureCollection")
                        for (W = 0; W < j.features.length; W++)
                          D(j.features[W], H);
                      else if (ce === "GeometryCollection")
                        for (W = 0; W < j.geometries.length; W++)
                          D(j.geometries[W], H);
                      else if (ce === "Feature") D(j.geometry, H);
                      else if (ce === "Polygon") O(j.coordinates, H);
                      else if (ce === "MultiPolygon")
                        for (W = 0; W < j.coordinates.length; W++)
                          O(j.coordinates[W], H);
                      return j;
                    })
                  );
                })(),
                xe = T.cT(Y);
              class Ie extends T.cV {
                constructor(E, D) {
                  super(new T.cP(), 0, D, [], []),
                    (this.feature = E),
                    (this.type = E.type),
                    (this.properties = E.tags ? E.tags : {}),
                    "id" in E &&
                      (typeof E.id == "string"
                        ? (this.id = parseInt(E.id, 10))
                        : typeof E.id != "number" ||
                          isNaN(E.id) ||
                          (this.id = E.id));
                }
                loadGeometry() {
                  const E = [],
                    D =
                      this.feature.type === 1
                        ? [this.feature.geometry]
                        : this.feature.geometry;
                  for (const j of D) {
                    const H = [];
                    for (const W of j) H.push(new T.P(W[0], W[1]));
                    E.push(H);
                  }
                  return E;
                }
              }
              class Ee extends T.cU {
                constructor(E, D) {
                  super(new T.cP()),
                    (this.layers = { _geojsonTileLayer: this }),
                    (this.name = "_geojsonTileLayer"),
                    (this.version = D ? D.version : 1),
                    (this.extent = D ? D.extent : 4096),
                    (this.length = E.length),
                    (this.features = E);
                }
                feature(E) {
                  return new Ie(this.features[E], this.extent);
                }
              }
              function De(O, E) {
                E.writeVarintField(15, O.version || 1),
                  E.writeStringField(1, O.name || ""),
                  E.writeVarintField(5, O.extent || 4096);
                const D = {
                  keys: [],
                  values: [],
                  keycache: {},
                  valuecache: {},
                };
                for (let W = 0; W < O.length; W++)
                  (D.feature = O.feature(W)), E.writeMessage(2, Ae, D);
                const j = D.keys;
                for (const W of j) E.writeStringField(3, W);
                const H = D.values;
                for (const W of H) E.writeMessage(4, $e, W);
              }
              function Ae(O, E) {
                if (!O.feature) return;
                const D = O.feature;
                D.id !== void 0 && E.writeVarintField(1, D.id),
                  E.writeMessage(2, qe, O),
                  E.writeVarintField(3, D.type),
                  E.writeMessage(4, ke, D);
              }
              function qe(O, E) {
                var D;
                for (const j in (D = O.feature) == null
                  ? void 0
                  : D.properties) {
                  let H = O.feature.properties[j],
                    W = O.keycache[j];
                  if (H === null) continue;
                  W === void 0 &&
                    (O.keys.push(j),
                    (W = O.keys.length - 1),
                    (O.keycache[j] = W)),
                    E.writeVarint(W),
                    typeof H != "string" &&
                      typeof H != "boolean" &&
                      typeof H != "number" &&
                      (H = JSON.stringify(H));
                  const ce = typeof H + ":" + H;
                  let ge = O.valuecache[ce];
                  ge === void 0 &&
                    (O.values.push(H),
                    (ge = O.values.length - 1),
                    (O.valuecache[ce] = ge)),
                    E.writeVarint(ge);
                }
              }
              function Ue(O, E) {
                return (E << 3) + (7 & O);
              }
              function Be(O) {
                return (O << 1) ^ (O >> 31);
              }
              function ke(O, E) {
                const D = O.loadGeometry(),
                  j = O.type;
                let H = 0,
                  W = 0;
                for (const ce of D) {
                  let ge = 1;
                  j === 1 && (ge = ce.length), E.writeVarint(Ue(1, ge));
                  const de = j === 3 ? ce.length - 1 : ce.length;
                  for (let Se = 0; Se < de; Se++) {
                    Se === 1 && j !== 1 && E.writeVarint(Ue(2, de - 1));
                    const We = ce[Se].x - H,
                      Ze = ce[Se].y - W;
                    E.writeVarint(Be(We)),
                      E.writeVarint(Be(Ze)),
                      (H += We),
                      (W += Ze);
                  }
                  O.type === 3 && E.writeVarint(Ue(7, 1));
                }
              }
              function $e(O, E) {
                const D = typeof O;
                D === "string"
                  ? E.writeStringField(1, O)
                  : D === "boolean"
                  ? E.writeBooleanField(7, O)
                  : D === "number" &&
                    (O % 1 != 0
                      ? E.writeDoubleField(3, O)
                      : O < 0
                      ? E.writeSVarintField(6, O)
                      : E.writeVarintField(5, O));
              }
              const Le = {
                  minZoom: 0,
                  maxZoom: 16,
                  minPoints: 2,
                  radius: 40,
                  extent: 512,
                  nodeSize: 64,
                  log: !1,
                  generateId: !1,
                  reduce: null,
                  map: (O) => O,
                },
                nt =
                  Math.fround ||
                  ((dt = new Float32Array(1)), (O) => ((dt[0] = +O), dt[0]));
              var dt;
              class je {
                constructor(E) {
                  (this.options = Object.assign(Object.create(Le), E)),
                    (this.trees = new Array(this.options.maxZoom + 1)),
                    (this.stride = this.options.reduce ? 7 : 6),
                    (this.clusterProps = []);
                }
                load(E) {
                  const { log: D, minZoom: j, maxZoom: H } = this.options;
                  D && console.time("total time");
                  const W = `prepare ${E.length} points`;
                  D && console.time(W), (this.points = E);
                  const ce = [];
                  for (let de = 0; de < E.length; de++) {
                    const Se = E[de];
                    if (!Se.geometry) continue;
                    const [We, Ze] = Se.geometry.coordinates,
                      Ct = nt(Xe(We)),
                      _e = nt(Ve(Ze));
                    ce.push(Ct, _e, 1 / 0, de, -1, 1),
                      this.options.reduce && ce.push(0);
                  }
                  let ge = (this.trees[H + 1] = this._createTree(ce));
                  D && console.timeEnd(W);
                  for (let de = H; de >= j; de--) {
                    const Se = +Date.now();
                    (ge = this.trees[de] =
                      this._createTree(this._cluster(ge, de))),
                      D &&
                        console.log(
                          "z%d: %d clusters in %dms",
                          de,
                          ge.numItems,
                          +Date.now() - Se
                        );
                  }
                  return D && console.timeEnd("total time"), this;
                }
                getClusters(E, D) {
                  let j = ((((E[0] + 180) % 360) + 360) % 360) - 180;
                  const H = Math.max(-90, Math.min(90, E[1]));
                  let W =
                    E[2] === 180
                      ? 180
                      : ((((E[2] + 180) % 360) + 360) % 360) - 180;
                  const ce = Math.max(-90, Math.min(90, E[3]));
                  if (E[2] - E[0] >= 360) (j = -180), (W = 180);
                  else if (j > W) {
                    const Ze = this.getClusters([j, H, 180, ce], D),
                      Ct = this.getClusters([-180, H, W, ce], D);
                    return Ze.concat(Ct);
                  }
                  const ge = this.trees[this._limitZoom(D)],
                    de = ge.range(Xe(j), Ve(ce), Xe(W), Ve(H)),
                    Se = ge.data,
                    We = [];
                  for (const Ze of de) {
                    const Ct = this.stride * Ze;
                    We.push(
                      Se[Ct + 5] > 1
                        ? Ge(Se, Ct, this.clusterProps)
                        : this.points[Se[Ct + 3]]
                    );
                  }
                  return We;
                }
                getChildren(E) {
                  const D = this._getOriginId(E),
                    j = this._getOriginZoom(E),
                    H = "No cluster with the specified id.",
                    W = this.trees[j];
                  if (!W) throw new Error(H);
                  const ce = W.data;
                  if (D * this.stride >= ce.length) throw new Error(H);
                  const ge =
                      this.options.radius /
                      (this.options.extent * Math.pow(2, j - 1)),
                    de = W.within(
                      ce[D * this.stride],
                      ce[D * this.stride + 1],
                      ge
                    ),
                    Se = [];
                  for (const We of de) {
                    const Ze = We * this.stride;
                    ce[Ze + 4] === E &&
                      Se.push(
                        ce[Ze + 5] > 1
                          ? Ge(ce, Ze, this.clusterProps)
                          : this.points[ce[Ze + 3]]
                      );
                  }
                  if (Se.length === 0) throw new Error(H);
                  return Se;
                }
                getLeaves(E, D, j) {
                  const H = [];
                  return (
                    this._appendLeaves(H, E, (D = D || 10), (j = j || 0), 0), H
                  );
                }
                getTile(E, D, j) {
                  const H = this.trees[this._limitZoom(E)],
                    W = Math.pow(2, E),
                    { extent: ce, radius: ge } = this.options,
                    de = ge / ce,
                    Se = (j - de) / W,
                    We = (j + 1 + de) / W,
                    Ze = { features: [] };
                  return (
                    this._addTileFeatures(
                      H.range((D - de) / W, Se, (D + 1 + de) / W, We),
                      H.data,
                      D,
                      j,
                      W,
                      Ze
                    ),
                    D === 0 &&
                      this._addTileFeatures(
                        H.range(1 - de / W, Se, 1, We),
                        H.data,
                        W,
                        j,
                        W,
                        Ze
                      ),
                    D === W - 1 &&
                      this._addTileFeatures(
                        H.range(0, Se, de / W, We),
                        H.data,
                        -1,
                        j,
                        W,
                        Ze
                      ),
                    Ze.features.length ? Ze : null
                  );
                }
                getClusterExpansionZoom(E) {
                  let D = this._getOriginZoom(E) - 1;
                  for (; D <= this.options.maxZoom; ) {
                    const j = this.getChildren(E);
                    if ((D++, j.length !== 1)) break;
                    E = j[0].properties.cluster_id;
                  }
                  return D;
                }
                _appendLeaves(E, D, j, H, W) {
                  const ce = this.getChildren(D);
                  for (const ge of ce) {
                    const de = ge.properties;
                    if (
                      (de && de.cluster
                        ? W + de.point_count <= H
                          ? (W += de.point_count)
                          : (W = this._appendLeaves(E, de.cluster_id, j, H, W))
                        : W < H
                        ? W++
                        : E.push(ge),
                      E.length === j)
                    )
                      break;
                  }
                  return W;
                }
                _createTree(E) {
                  const D = new T.aM(
                    (E.length / this.stride) | 0,
                    this.options.nodeSize,
                    Float32Array
                  );
                  for (let j = 0; j < E.length; j += this.stride)
                    D.add(E[j], E[j + 1]);
                  return D.finish(), (D.data = E), D;
                }
                _addTileFeatures(E, D, j, H, W, ce) {
                  for (const ge of E) {
                    const de = ge * this.stride,
                      Se = D[de + 5] > 1;
                    let We, Ze, Ct;
                    if (Se)
                      (We = bt(D, de, this.clusterProps)),
                        (Ze = D[de]),
                        (Ct = D[de + 1]);
                    else {
                      const cr = this.points[D[de + 3]];
                      We = cr.properties;
                      const [Ot, ur] = cr.geometry.coordinates;
                      (Ze = Xe(Ot)), (Ct = Ve(ur));
                    }
                    const _e = {
                      type: 1,
                      geometry: [
                        [
                          Math.round(this.options.extent * (Ze * W - j)),
                          Math.round(this.options.extent * (Ct * W - H)),
                        ],
                      ],
                      tags: We,
                    };
                    let Vt;
                    (Vt =
                      Se || this.options.generateId
                        ? D[de + 3]
                        : this.points[D[de + 3]].id),
                      Vt !== void 0 && (_e.id = Vt),
                      ce.features.push(_e);
                  }
                }
                _limitZoom(E) {
                  return Math.max(
                    this.options.minZoom,
                    Math.min(Math.floor(+E), this.options.maxZoom + 1)
                  );
                }
                _cluster(E, D) {
                  const {
                      radius: j,
                      extent: H,
                      reduce: W,
                      minPoints: ce,
                    } = this.options,
                    ge = j / (H * Math.pow(2, D)),
                    de = E.data,
                    Se = [],
                    We = this.stride;
                  for (let Ze = 0; Ze < de.length; Ze += We) {
                    if (de[Ze + 2] <= D) continue;
                    de[Ze + 2] = D;
                    const Ct = de[Ze],
                      _e = de[Ze + 1],
                      Vt = E.within(de[Ze], de[Ze + 1], ge),
                      cr = de[Ze + 5];
                    let Ot = cr;
                    for (const ur of Vt) {
                      const Nr = ur * We;
                      de[Nr + 2] > D && (Ot += de[Nr + 5]);
                    }
                    if (Ot > cr && Ot >= ce) {
                      let ur,
                        Nr = Ct * cr,
                        Ur = _e * cr,
                        Wr = -1;
                      const un =
                        ((Ze / We) << 5) + (D + 1) + this.points.length;
                      for (const an of Vt) {
                        const fn = an * We;
                        if (de[fn + 2] <= D) continue;
                        de[fn + 2] = D;
                        const rn = de[fn + 5];
                        (Nr += de[fn] * rn),
                          (Ur += de[fn + 1] * rn),
                          (de[fn + 4] = un),
                          W &&
                            (ur ||
                              ((ur = this._map(de, Ze, !0)),
                              (Wr = this.clusterProps.length),
                              this.clusterProps.push(ur)),
                            W(ur, this._map(de, fn)));
                      }
                      (de[Ze + 4] = un),
                        Se.push(Nr / Ot, Ur / Ot, 1 / 0, un, -1, Ot),
                        W && Se.push(Wr);
                    } else {
                      for (let ur = 0; ur < We; ur++) Se.push(de[Ze + ur]);
                      if (Ot > 1)
                        for (const ur of Vt) {
                          const Nr = ur * We;
                          if (!(de[Nr + 2] <= D)) {
                            de[Nr + 2] = D;
                            for (let Ur = 0; Ur < We; Ur++)
                              Se.push(de[Nr + Ur]);
                          }
                        }
                    }
                  }
                  return Se;
                }
                _getOriginId(E) {
                  return (E - this.points.length) >> 5;
                }
                _getOriginZoom(E) {
                  return (E - this.points.length) % 32;
                }
                _map(E, D, j) {
                  if (E[D + 5] > 1) {
                    const ce = this.clusterProps[E[D + 6]];
                    return j ? Object.assign({}, ce) : ce;
                  }
                  const H = this.points[E[D + 3]].properties,
                    W = this.options.map(H);
                  return j && W === H ? Object.assign({}, W) : W;
                }
              }
              function Ge(O, E, D) {
                return {
                  type: "Feature",
                  id: O[E + 3],
                  properties: bt(O, E, D),
                  geometry: {
                    type: "Point",
                    coordinates: [((j = O[E]), 360 * (j - 0.5)), Ke(O[E + 1])],
                  },
                };
                var j;
              }
              function bt(O, E, D) {
                const j = O[E + 5],
                  H =
                    j >= 1e4
                      ? `${Math.round(j / 1e3)}k`
                      : j >= 1e3
                      ? Math.round(j / 100) / 10 + "k"
                      : j,
                  W = O[E + 6],
                  ce = W === -1 ? {} : Object.assign({}, D[W]);
                return Object.assign(ce, {
                  cluster: !0,
                  cluster_id: O[E + 3],
                  point_count: j,
                  point_count_abbreviated: H,
                });
              }
              function Xe(O) {
                return O / 360 + 0.5;
              }
              function Ve(O) {
                const E = Math.sin((O * Math.PI) / 180),
                  D = 0.5 - (0.25 * Math.log((1 + E) / (1 - E))) / Math.PI;
                return D < 0 ? 0 : D > 1 ? 1 : D;
              }
              function Ke(O) {
                const E = ((180 - 360 * O) * Math.PI) / 180;
                return (360 * Math.atan(Math.exp(E))) / Math.PI - 90;
              }
              function Fe(O, E, D, j) {
                let H = j;
                const W = E + ((D - E) >> 1);
                let ce,
                  ge = D - E;
                const de = O[E],
                  Se = O[E + 1],
                  We = O[D],
                  Ze = O[D + 1];
                for (let Ct = E + 3; Ct < D; Ct += 3) {
                  const _e = ft(O[Ct], O[Ct + 1], de, Se, We, Ze);
                  if (_e > H) (ce = Ct), (H = _e);
                  else if (_e === H) {
                    const Vt = Math.abs(Ct - W);
                    Vt < ge && ((ce = Ct), (ge = Vt));
                  }
                }
                H > j &&
                  (ce - E > 3 && Fe(O, E, ce, j),
                  (O[ce + 2] = H),
                  D - ce > 3 && Fe(O, ce, D, j));
              }
              function ft(O, E, D, j, H, W) {
                let ce = H - D,
                  ge = W - j;
                if (ce !== 0 || ge !== 0) {
                  const de =
                    ((O - D) * ce + (E - j) * ge) / (ce * ce + ge * ge);
                  de > 1
                    ? ((D = H), (j = W))
                    : de > 0 && ((D += ce * de), (j += ge * de));
                }
                return (ce = O - D), (ge = E - j), ce * ce + ge * ge;
              }
              function lt(O, E, D, j) {
                const H = {
                  id: O ?? null,
                  type: E,
                  geometry: D,
                  tags: j,
                  minX: 1 / 0,
                  minY: 1 / 0,
                  maxX: -1 / 0,
                  maxY: -1 / 0,
                };
                if (E === "Point" || E === "MultiPoint" || E === "LineString")
                  yt(H, D);
                else if (E === "Polygon") yt(H, D[0]);
                else if (E === "MultiLineString") for (const W of D) yt(H, W);
                else if (E === "MultiPolygon") for (const W of D) yt(H, W[0]);
                return H;
              }
              function yt(O, E) {
                for (let D = 0; D < E.length; D += 3)
                  (O.minX = Math.min(O.minX, E[D])),
                    (O.minY = Math.min(O.minY, E[D + 1])),
                    (O.maxX = Math.max(O.maxX, E[D])),
                    (O.maxY = Math.max(O.maxY, E[D + 1]));
              }
              function mt(O, E, D, j) {
                if (!E.geometry) return;
                const H = E.geometry.coordinates;
                if (H && H.length === 0) return;
                const W = E.geometry.type,
                  ce = Math.pow(D.tolerance / ((1 << D.maxZoom) * D.extent), 2);
                let ge = [],
                  de = E.id;
                if (
                  (D.promoteId
                    ? (de = E.properties[D.promoteId])
                    : D.generateId && (de = j || 0),
                  W === "Point")
                )
                  ct(H, ge);
                else if (W === "MultiPoint") for (const Se of H) ct(Se, ge);
                else if (W === "LineString") qt(H, ge, ce, !1);
                else if (W === "MultiLineString") {
                  if (D.lineMetrics) {
                    for (const Se of H)
                      (ge = []),
                        qt(Se, ge, ce, !1),
                        O.push(lt(de, "LineString", ge, E.properties));
                    return;
                  }
                  Ft(H, ge, ce, !1);
                } else if (W === "Polygon") Ft(H, ge, ce, !0);
                else {
                  if (W !== "MultiPolygon") {
                    if (W === "GeometryCollection") {
                      for (const Se of E.geometry.geometries)
                        mt(
                          O,
                          { id: de, geometry: Se, properties: E.properties },
                          D,
                          j
                        );
                      return;
                    }
                    throw new Error(
                      "Input data is not a valid GeoJSON object."
                    );
                  }
                  for (const Se of H) {
                    const We = [];
                    Ft(Se, We, ce, !0), ge.push(We);
                  }
                }
                O.push(lt(de, W, ge, E.properties));
              }
              function ct(O, E) {
                E.push(Ye(O[0]), at(O[1]), 0);
              }
              function qt(O, E, D, j) {
                let H,
                  W,
                  ce = 0;
                for (let de = 0; de < O.length; de++) {
                  const Se = Ye(O[de][0]),
                    We = at(O[de][1]);
                  E.push(Se, We, 0),
                    de > 0 &&
                      (ce += j
                        ? (H * We - Se * W) / 2
                        : Math.sqrt(Math.pow(Se - H, 2) + Math.pow(We - W, 2))),
                    (H = Se),
                    (W = We);
                }
                const ge = E.length - 3;
                (E[2] = 1),
                  Fe(E, 0, ge, D),
                  (E[ge + 2] = 1),
                  (E.size = Math.abs(ce)),
                  (E.start = 0),
                  (E.end = E.size);
              }
              function Ft(O, E, D, j) {
                for (let H = 0; H < O.length; H++) {
                  const W = [];
                  qt(O[H], W, D, j), E.push(W);
                }
              }
              function Ye(O) {
                return O / 360 + 0.5;
              }
              function at(O) {
                const E = Math.sin((O * Math.PI) / 180),
                  D = 0.5 - (0.25 * Math.log((1 + E) / (1 - E))) / Math.PI;
                return D < 0 ? 0 : D > 1 ? 1 : D;
              }
              function xt(O, E, D, j, H, W, ce, ge) {
                if (((j /= E), W >= (D /= E) && ce < j)) return O;
                if (ce < D || W >= j) return null;
                const de = [];
                for (const Se of O) {
                  const We = Se.geometry;
                  let Ze = Se.type;
                  const Ct = H === 0 ? Se.minX : Se.minY,
                    _e = H === 0 ? Se.maxX : Se.maxY;
                  if (Ct >= D && _e < j) {
                    de.push(Se);
                    continue;
                  }
                  if (_e < D || Ct >= j) continue;
                  let Vt = [];
                  if (Ze === "Point" || Ze === "MultiPoint")
                    It(We, Vt, D, j, H);
                  else if (Ze === "LineString")
                    Tt(We, Vt, D, j, H, !1, ge.lineMetrics);
                  else if (Ze === "MultiLineString") Wt(We, Vt, D, j, H, !1);
                  else if (Ze === "Polygon") Wt(We, Vt, D, j, H, !0);
                  else if (Ze === "MultiPolygon")
                    for (const cr of We) {
                      const Ot = [];
                      Wt(cr, Ot, D, j, H, !0), Ot.length && Vt.push(Ot);
                    }
                  if (Vt.length) {
                    if (ge.lineMetrics && Ze === "LineString") {
                      for (const cr of Vt) de.push(lt(Se.id, Ze, cr, Se.tags));
                      continue;
                    }
                    (Ze !== "LineString" && Ze !== "MultiLineString") ||
                      (Vt.length === 1
                        ? ((Ze = "LineString"), (Vt = Vt[0]))
                        : (Ze = "MultiLineString")),
                      (Ze !== "Point" && Ze !== "MultiPoint") ||
                        (Ze = Vt.length === 3 ? "Point" : "MultiPoint"),
                      de.push(lt(Se.id, Ze, Vt, Se.tags));
                  }
                }
                return de.length ? de : null;
              }
              function It(O, E, D, j, H) {
                for (let W = 0; W < O.length; W += 3) {
                  const ce = O[W + H];
                  ce >= D && ce <= j && Bt(E, O[W], O[W + 1], O[W + 2]);
                }
              }
              function Tt(O, E, D, j, H, W, ce) {
                let ge = Mt(O);
                const de = H === 0 ? Gt : At;
                let Se,
                  We,
                  Ze = O.start;
                for (let Ot = 0; Ot < O.length - 3; Ot += 3) {
                  const ur = O[Ot],
                    Nr = O[Ot + 1],
                    Ur = O[Ot + 2],
                    Wr = O[Ot + 3],
                    un = O[Ot + 4],
                    an = H === 0 ? ur : Nr,
                    fn = H === 0 ? Wr : un;
                  let rn = !1;
                  ce &&
                    (Se = Math.sqrt(
                      Math.pow(ur - Wr, 2) + Math.pow(Nr - un, 2)
                    )),
                    an < D
                      ? fn > D &&
                        ((We = de(ge, ur, Nr, Wr, un, D)),
                        ce && (ge.start = Ze + Se * We))
                      : an > j
                      ? fn < j &&
                        ((We = de(ge, ur, Nr, Wr, un, j)),
                        ce && (ge.start = Ze + Se * We))
                      : Bt(ge, ur, Nr, Ur),
                    fn < D &&
                      an >= D &&
                      ((We = de(ge, ur, Nr, Wr, un, D)), (rn = !0)),
                    fn > j &&
                      an <= j &&
                      ((We = de(ge, ur, Nr, Wr, un, j)), (rn = !0)),
                    !W &&
                      rn &&
                      (ce && (ge.end = Ze + Se * We), E.push(ge), (ge = Mt(O))),
                    ce && (Ze += Se);
                }
                let Ct = O.length - 3;
                const _e = O[Ct],
                  Vt = O[Ct + 1],
                  cr = H === 0 ? _e : Vt;
                cr >= D && cr <= j && Bt(ge, _e, Vt, O[Ct + 2]),
                  (Ct = ge.length - 3),
                  W &&
                    Ct >= 3 &&
                    (ge[Ct] !== ge[0] || ge[Ct + 1] !== ge[1]) &&
                    Bt(ge, ge[0], ge[1], ge[2]),
                  ge.length && E.push(ge);
              }
              function Mt(O) {
                const E = [];
                return (
                  (E.size = O.size), (E.start = O.start), (E.end = O.end), E
                );
              }
              function Wt(O, E, D, j, H, W) {
                for (const ce of O) Tt(ce, E, D, j, H, W, !1);
              }
              function Bt(O, E, D, j) {
                O.push(E, D, j);
              }
              function Gt(O, E, D, j, H, W) {
                const ce = (W - E) / (j - E);
                return Bt(O, W, D + (H - D) * ce, 1), ce;
              }
              function At(O, E, D, j, H, W) {
                const ce = (W - D) / (H - D);
                return Bt(O, E + (j - E) * ce, W, 1), ce;
              }
              function Xt(O, E) {
                const D = [];
                for (let j = 0; j < O.length; j++) {
                  const H = O[j],
                    W = H.type;
                  let ce;
                  if (W === "Point" || W === "MultiPoint" || W === "LineString")
                    ce = Lt(H.geometry, E);
                  else if (W === "MultiLineString" || W === "Polygon") {
                    ce = [];
                    for (const ge of H.geometry) ce.push(Lt(ge, E));
                  } else if (W === "MultiPolygon") {
                    ce = [];
                    for (const ge of H.geometry) {
                      const de = [];
                      for (const Se of ge) de.push(Lt(Se, E));
                      ce.push(de);
                    }
                  }
                  D.push(lt(H.id, W, ce, H.tags));
                }
                return D;
              }
              function Lt(O, E) {
                const D = [];
                (D.size = O.size),
                  O.start !== void 0 && ((D.start = O.start), (D.end = O.end));
                for (let j = 0; j < O.length; j += 3)
                  D.push(O[j] + E, O[j + 1], O[j + 2]);
                return D;
              }
              function Nt(O, E) {
                if (O.transformed) return O;
                const D = 1 << O.z,
                  j = O.x,
                  H = O.y;
                for (const W of O.features) {
                  const ce = W.geometry,
                    ge = W.type;
                  if (((W.geometry = []), ge === 1))
                    for (let de = 0; de < ce.length; de += 2)
                      W.geometry.push(jt(ce[de], ce[de + 1], E, D, j, H));
                  else
                    for (let de = 0; de < ce.length; de++) {
                      const Se = [];
                      for (let We = 0; We < ce[de].length; We += 2)
                        Se.push(jt(ce[de][We], ce[de][We + 1], E, D, j, H));
                      W.geometry.push(Se);
                    }
                }
                return (O.transformed = !0), O;
              }
              function jt(O, E, D, j, H, W) {
                return [
                  Math.round(D * (O * j - H)),
                  Math.round(D * (E * j - W)),
                ];
              }
              function mr(O, E, D, j, H) {
                const W =
                    E === H.maxZoom ? 0 : H.tolerance / ((1 << E) * H.extent),
                  ce = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: O.length,
                    source: null,
                    x: D,
                    y: j,
                    z: E,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0,
                  };
                for (const ge of O) ir(ce, ge, W, H);
                return ce;
              }
              function ir(O, E, D, j) {
                const H = E.geometry,
                  W = E.type,
                  ce = [];
                if (
                  ((O.minX = Math.min(O.minX, E.minX)),
                  (O.minY = Math.min(O.minY, E.minY)),
                  (O.maxX = Math.max(O.maxX, E.maxX)),
                  (O.maxY = Math.max(O.maxY, E.maxY)),
                  W === "Point" || W === "MultiPoint")
                )
                  for (let ge = 0; ge < H.length; ge += 3)
                    ce.push(H[ge], H[ge + 1]), O.numPoints++, O.numSimplified++;
                else if (W === "LineString") vr(ce, H, O, D, !1, !1);
                else if (W === "MultiLineString" || W === "Polygon")
                  for (let ge = 0; ge < H.length; ge++)
                    vr(ce, H[ge], O, D, W === "Polygon", ge === 0);
                else if (W === "MultiPolygon")
                  for (let ge = 0; ge < H.length; ge++) {
                    const de = H[ge];
                    for (let Se = 0; Se < de.length; Se++)
                      vr(ce, de[Se], O, D, !0, Se === 0);
                  }
                if (ce.length) {
                  let ge = E.tags || null;
                  if (W === "LineString" && j.lineMetrics) {
                    ge = {};
                    for (const Se in E.tags) ge[Se] = E.tags[Se];
                    (ge.mapbox_clip_start = H.start / H.size),
                      (ge.mapbox_clip_end = H.end / H.size);
                  }
                  const de = {
                    geometry: ce,
                    type:
                      W === "Polygon" || W === "MultiPolygon"
                        ? 3
                        : W === "LineString" || W === "MultiLineString"
                        ? 2
                        : 1,
                    tags: ge,
                  };
                  E.id !== null && (de.id = E.id), O.features.push(de);
                }
              }
              function vr(O, E, D, j, H, W) {
                const ce = j * j;
                if (j > 0 && E.size < (H ? ce : j))
                  return void (D.numPoints += E.length / 3);
                const ge = [];
                for (let de = 0; de < E.length; de += 3)
                  (j === 0 || E[de + 2] > ce) &&
                    (D.numSimplified++, ge.push(E[de], E[de + 1])),
                    D.numPoints++;
                H &&
                  (function (de, Se) {
                    let We = 0;
                    for (
                      let Ze = 0, Ct = de.length, _e = Ct - 2;
                      Ze < Ct;
                      _e = Ze, Ze += 2
                    )
                      We += (de[Ze] - de[_e]) * (de[Ze + 1] + de[_e + 1]);
                    if (We > 0 === Se)
                      for (let Ze = 0, Ct = de.length; Ze < Ct / 2; Ze += 2) {
                        const _e = de[Ze],
                          Vt = de[Ze + 1];
                        (de[Ze] = de[Ct - 2 - Ze]),
                          (de[Ze + 1] = de[Ct - 1 - Ze]),
                          (de[Ct - 2 - Ze] = _e),
                          (de[Ct - 1 - Ze] = Vt);
                      }
                  })(ge, W),
                  O.push(ge);
              }
              const ar = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0,
              };
              class pr {
                constructor(E, D) {
                  const j = (D = this.options =
                    (function (W, ce) {
                      for (const ge in ce) W[ge] = ce[ge];
                      return W;
                    })(Object.create(ar), D)).debug;
                  if (
                    (j && console.time("preprocess data"),
                    D.maxZoom < 0 || D.maxZoom > 24)
                  )
                    throw new Error("maxZoom should be in the 0-24 range");
                  if (D.promoteId && D.generateId)
                    throw new Error(
                      "promoteId and generateId cannot be used together."
                    );
                  let H = (function (W, ce) {
                    const ge = [];
                    if (W.type === "FeatureCollection")
                      for (let de = 0; de < W.features.length; de++)
                        mt(ge, W.features[de], ce, de);
                    else mt(ge, W.type === "Feature" ? W : { geometry: W }, ce);
                    return ge;
                  })(E, D);
                  (this.tiles = {}),
                    (this.tileCoords = []),
                    j &&
                      (console.timeEnd("preprocess data"),
                      console.log(
                        "index: maxZoom: %d, maxPoints: %d",
                        D.indexMaxZoom,
                        D.indexMaxPoints
                      ),
                      console.time("generate tiles"),
                      (this.stats = {}),
                      (this.total = 0)),
                    (H = (function (W, ce) {
                      const ge = ce.buffer / ce.extent;
                      let de = W;
                      const Se = xt(W, 1, -1 - ge, ge, 0, -1, 2, ce),
                        We = xt(W, 1, 1 - ge, 2 + ge, 0, -1, 2, ce);
                      return (
                        (Se || We) &&
                          ((de = xt(W, 1, -ge, 1 + ge, 0, -1, 2, ce) || []),
                          Se && (de = Xt(Se, 1).concat(de)),
                          We && (de = de.concat(Xt(We, -1)))),
                        de
                      );
                    })(H, D)),
                    H.length && this.splitTile(H, 0, 0, 0),
                    j &&
                      (H.length &&
                        console.log(
                          "features: %d, points: %d",
                          this.tiles[0].numFeatures,
                          this.tiles[0].numPoints
                        ),
                      console.timeEnd("generate tiles"),
                      console.log(
                        "tiles generated:",
                        this.total,
                        JSON.stringify(this.stats)
                      ));
                }
                splitTile(E, D, j, H, W, ce, ge) {
                  const de = [E, D, j, H],
                    Se = this.options,
                    We = Se.debug;
                  for (; de.length; ) {
                    (H = de.pop()),
                      (j = de.pop()),
                      (D = de.pop()),
                      (E = de.pop());
                    const Ze = 1 << D,
                      Ct = tr(D, j, H);
                    let _e = this.tiles[Ct];
                    if (
                      !_e &&
                      (We > 1 && console.time("creation"),
                      (_e = this.tiles[Ct] = mr(E, D, j, H, Se)),
                      this.tileCoords.push({ z: D, x: j, y: H }),
                      We)
                    ) {
                      We > 1 &&
                        (console.log(
                          "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                          D,
                          j,
                          H,
                          _e.numFeatures,
                          _e.numPoints,
                          _e.numSimplified
                        ),
                        console.timeEnd("creation"));
                      const rn = `z${D}`;
                      (this.stats[rn] = (this.stats[rn] || 0) + 1),
                        this.total++;
                    }
                    if (((_e.source = E), W == null)) {
                      if (
                        D === Se.indexMaxZoom ||
                        _e.numPoints <= Se.indexMaxPoints
                      )
                        continue;
                    } else {
                      if (D === Se.maxZoom || D === W) continue;
                      if (W != null) {
                        const rn = W - D;
                        if (j !== ce >> rn || H !== ge >> rn) continue;
                      }
                    }
                    if (((_e.source = null), E.length === 0)) continue;
                    We > 1 && console.time("clipping");
                    const Vt = (0.5 * Se.buffer) / Se.extent,
                      cr = 0.5 - Vt,
                      Ot = 0.5 + Vt,
                      ur = 1 + Vt;
                    let Nr = null,
                      Ur = null,
                      Wr = null,
                      un = null,
                      an = xt(E, Ze, j - Vt, j + Ot, 0, _e.minX, _e.maxX, Se),
                      fn = xt(E, Ze, j + cr, j + ur, 0, _e.minX, _e.maxX, Se);
                    (E = null),
                      an &&
                        ((Nr = xt(
                          an,
                          Ze,
                          H - Vt,
                          H + Ot,
                          1,
                          _e.minY,
                          _e.maxY,
                          Se
                        )),
                        (Ur = xt(
                          an,
                          Ze,
                          H + cr,
                          H + ur,
                          1,
                          _e.minY,
                          _e.maxY,
                          Se
                        )),
                        (an = null)),
                      fn &&
                        ((Wr = xt(
                          fn,
                          Ze,
                          H - Vt,
                          H + Ot,
                          1,
                          _e.minY,
                          _e.maxY,
                          Se
                        )),
                        (un = xt(
                          fn,
                          Ze,
                          H + cr,
                          H + ur,
                          1,
                          _e.minY,
                          _e.maxY,
                          Se
                        )),
                        (fn = null)),
                      We > 1 && console.timeEnd("clipping"),
                      de.push(Nr || [], D + 1, 2 * j, 2 * H),
                      de.push(Ur || [], D + 1, 2 * j, 2 * H + 1),
                      de.push(Wr || [], D + 1, 2 * j + 1, 2 * H),
                      de.push(un || [], D + 1, 2 * j + 1, 2 * H + 1);
                  }
                }
                getTile(E, D, j) {
                  (E = +E), (D = +D), (j = +j);
                  const H = this.options,
                    { extent: W, debug: ce } = H;
                  if (E < 0 || E > 24) return null;
                  const ge = 1 << E,
                    de = tr(E, (D = (D + ge) & (ge - 1)), j);
                  if (this.tiles[de]) return Nt(this.tiles[de], W);
                  ce > 1 && console.log("drilling down to z%d-%d-%d", E, D, j);
                  let Se,
                    We = E,
                    Ze = D,
                    Ct = j;
                  for (; !Se && We > 0; )
                    We--,
                      (Ze >>= 1),
                      (Ct >>= 1),
                      (Se = this.tiles[tr(We, Ze, Ct)]);
                  return Se && Se.source
                    ? (ce > 1 &&
                        (console.log("found parent tile z%d-%d-%d", We, Ze, Ct),
                        console.time("drilling down")),
                      this.splitTile(Se.source, We, Ze, Ct, E, D, j),
                      ce > 1 && console.timeEnd("drilling down"),
                      this.tiles[de] ? Nt(this.tiles[de], W) : null)
                    : null;
                }
              }
              function tr(O, E, D) {
                return 32 * ((1 << O) * D + E) + O;
              }
              class Dt extends ee {
                constructor(E, D, j, H = Sr) {
                  super(E, D, j),
                    (this._dataUpdateable = new Map()),
                    (this._createGeoJSONIndex = H);
                }
                loadVectorTile(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    const j = E.tileID.canonical;
                    if (!this._geoJSONIndex)
                      throw new Error(
                        "Unable to parse the data into a cluster or geojson"
                      );
                    const H = this._geoJSONIndex.getTile(j.z, j.x, j.y);
                    if (!H) return null;
                    const W = new Ee(H.features, { version: 2, extent: T.a3 });
                    let ce = (function (ge) {
                      const de = new T.cP();
                      return (
                        (function (Se, We) {
                          for (const Ze in Se.layers)
                            We.writeMessage(3, De, Se.layers[Ze]);
                        })(ge, de),
                        de.finish()
                      );
                    })(W);
                    return (
                      (ce.byteOffset === 0 &&
                        ce.byteLength === ce.buffer.byteLength) ||
                        (ce = new Uint8Array(ce)),
                      { vectorTile: W, rawData: ce.buffer }
                    );
                  });
                }
                loadData(E) {
                  return T._(this, void 0, void 0, function* () {
                    var D;
                    (D = this._pendingRequest) === null ||
                      D === void 0 ||
                      D.abort();
                    const j =
                      !!(E && E.request && E.request.collectResourceTiming) &&
                      new T.cQ(E.request);
                    this._pendingRequest = new AbortController();
                    try {
                      (!this._pendingData ||
                        E.request ||
                        E.data ||
                        E.dataDiff) &&
                        (this._pendingData = this.loadAndProcessGeoJSON(
                          E,
                          this._pendingRequest
                        ));
                      const H = yield this._pendingData;
                      (this._geoJSONIndex = this._createGeoJSONIndex(H, E)),
                        (this.loaded = {});
                      const W = { data: H };
                      if (j) {
                        const ce = j.finish();
                        ce &&
                          ((W.resourceTiming = {}),
                          (W.resourceTiming[E.source] = JSON.parse(
                            JSON.stringify(ce)
                          )));
                      }
                      return W;
                    } catch (H) {
                      if ((delete this._pendingRequest, T.cB(H)))
                        return { abandoned: !0 };
                      throw H;
                    }
                  });
                }
                getData() {
                  return T._(this, void 0, void 0, function* () {
                    return this._pendingData;
                  });
                }
                reloadTile(E) {
                  const D = this.loaded;
                  return D && D[E.uid] ? super.reloadTile(E) : this.loadTile(E);
                }
                loadAndProcessGeoJSON(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    let j = yield this.loadGeoJSON(E, D);
                    if ((delete this._pendingRequest, typeof j != "object"))
                      throw new Error(
                        `Input data given to '${E.source}' is not a valid GeoJSON object.`
                      );
                    if ((xe(j, !0), E.filter)) {
                      const H = T.cW(E.filter, {
                        type: "boolean",
                        "property-type": "data-driven",
                        overridable: !1,
                        transition: !1,
                      });
                      if (H.result === "error")
                        throw new Error(
                          H.value
                            .map((ce) => `${ce.key}: ${ce.message}`)
                            .join(", ")
                        );
                      j = {
                        type: "FeatureCollection",
                        features: j.features.filter((ce) =>
                          H.value.evaluate({ zoom: 0 }, ce)
                        ),
                      };
                    }
                    return j;
                  });
                }
                loadGeoJSON(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    const { promoteId: j } = E;
                    if (E.request) {
                      const H = yield T.j(E.request, D);
                      return (
                        (this._dataUpdateable = T.cY(H.data, j)
                          ? T.cX(H.data, j)
                          : void 0),
                        H.data
                      );
                    }
                    if (typeof E.data == "string")
                      try {
                        const H = JSON.parse(E.data);
                        return (
                          (this._dataUpdateable = T.cY(H, j)
                            ? T.cX(H, j)
                            : void 0),
                          H
                        );
                      } catch {
                        throw new Error(
                          `Input data given to '${E.source}' is not a valid GeoJSON object.`
                        );
                      }
                    if (!E.dataDiff)
                      throw new Error(
                        `Input data given to '${E.source}' is not a valid GeoJSON object.`
                      );
                    if (!this._dataUpdateable)
                      throw new Error(
                        `Cannot update existing geojson data in ${E.source}`
                      );
                    return (
                      T.cZ(this._dataUpdateable, E.dataDiff, j),
                      {
                        type: "FeatureCollection",
                        features: Array.from(this._dataUpdateable.values()),
                      }
                    );
                  });
                }
                removeSource(E) {
                  return T._(this, void 0, void 0, function* () {
                    this._pendingRequest && this._pendingRequest.abort();
                  });
                }
                getClusterExpansionZoom(E) {
                  return this._geoJSONIndex.getClusterExpansionZoom(
                    E.clusterId
                  );
                }
                getClusterChildren(E) {
                  return this._geoJSONIndex.getChildren(E.clusterId);
                }
                getClusterLeaves(E) {
                  return this._geoJSONIndex.getLeaves(
                    E.clusterId,
                    E.limit,
                    E.offset
                  );
                }
              }
              function Sr(O, E) {
                return E.cluster
                  ? new je(
                      (function ({
                        superclusterOptions: D,
                        clusterProperties: j,
                      }) {
                        if (!j || !D) return D;
                        const H = {},
                          W = {},
                          ce = { accumulated: null, zoom: 0 },
                          ge = { properties: null },
                          de = Object.keys(j);
                        for (const Se of de) {
                          const [We, Ze] = j[Se],
                            Ct = T.cW(Ze),
                            _e = T.cW(
                              typeof We == "string"
                                ? [We, ["accumulated"], ["get", Se]]
                                : We
                            );
                          (H[Se] = Ct.value), (W[Se] = _e.value);
                        }
                        return (
                          (D.map = (Se) => {
                            ge.properties = Se;
                            const We = {};
                            for (const Ze of de)
                              We[Ze] = H[Ze].evaluate(ce, ge);
                            return We;
                          }),
                          (D.reduce = (Se, We) => {
                            ge.properties = We;
                            for (const Ze of de)
                              (ce.accumulated = Se[Ze]),
                                (Se[Ze] = W[Ze].evaluate(ce, ge));
                          }),
                          D
                        );
                      })(E)
                    ).load(O.features)
                  : (function (D, j) {
                      return new pr(D, j);
                    })(O, E.geojsonVtOptions);
              }
              class Te {
                constructor(E) {
                  (this.self = E),
                    (this.actor = new T.K(E)),
                    (this.layerIndexes = {}),
                    (this.availableImages = {}),
                    (this.workerSources = {}),
                    (this.demWorkerSources = {}),
                    (this.externalWorkerSourceTypes = {}),
                    (this.globalStates = new Map()),
                    (this.self.registerWorkerSource = (D, j) => {
                      if (this.externalWorkerSourceTypes[D])
                        throw new Error(
                          `Worker source with name "${D}" already registered.`
                        );
                      this.externalWorkerSourceTypes[D] = j;
                    }),
                    (this.self.addProtocol = T.cD),
                    (this.self.removeProtocol = T.cE),
                    (this.self.registerRTLTextPlugin = (D) => {
                      T.c_.setMethods(D);
                    }),
                    this.actor.registerMessageHandler("LDT", (D, j) =>
                      this._getDEMWorkerSource(D, j.source).loadTile(j)
                    ),
                    this.actor.registerMessageHandler("RDT", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        this._getDEMWorkerSource(D, j.source).removeTile(j);
                      })
                    ),
                    this.actor.registerMessageHandler("GCEZ", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        return this._getWorkerSource(
                          D,
                          j.type,
                          j.source
                        ).getClusterExpansionZoom(j);
                      })
                    ),
                    this.actor.registerMessageHandler("GCC", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        return this._getWorkerSource(
                          D,
                          j.type,
                          j.source
                        ).getClusterChildren(j);
                      })
                    ),
                    this.actor.registerMessageHandler("GCL", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        return this._getWorkerSource(
                          D,
                          j.type,
                          j.source
                        ).getClusterLeaves(j);
                      })
                    ),
                    this.actor.registerMessageHandler("LD", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).loadData(j)
                    ),
                    this.actor.registerMessageHandler("GD", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).getData()
                    ),
                    this.actor.registerMessageHandler("LT", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).loadTile(j)
                    ),
                    this.actor.registerMessageHandler("RT", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).reloadTile(j)
                    ),
                    this.actor.registerMessageHandler("AT", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).abortTile(j)
                    ),
                    this.actor.registerMessageHandler("RMT", (D, j) =>
                      this._getWorkerSource(D, j.type, j.source).removeTile(j)
                    ),
                    this.actor.registerMessageHandler("RS", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        if (
                          !this.workerSources[D] ||
                          !this.workerSources[D][j.type] ||
                          !this.workerSources[D][j.type][j.source]
                        )
                          return;
                        const H = this.workerSources[D][j.type][j.source];
                        delete this.workerSources[D][j.type][j.source],
                          H.removeSource !== void 0 && H.removeSource(j);
                      })
                    ),
                    this.actor.registerMessageHandler("RM", (D) =>
                      T._(this, void 0, void 0, function* () {
                        delete this.layerIndexes[D],
                          delete this.availableImages[D],
                          delete this.workerSources[D],
                          delete this.demWorkerSources[D],
                          this.globalStates.delete(D);
                      })
                    ),
                    this.actor.registerMessageHandler("SR", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        this.referrer = j;
                      })
                    ),
                    this.actor.registerMessageHandler("SRPS", (D, j) =>
                      this._syncRTLPluginState(D, j)
                    ),
                    this.actor.registerMessageHandler("IS", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        this.self.importScripts(j);
                      })
                    ),
                    this.actor.registerMessageHandler("SI", (D, j) =>
                      this._setImages(D, j)
                    ),
                    this.actor.registerMessageHandler("UL", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        this._getLayerIndex(D).update(
                          j.layers,
                          j.removedIds,
                          this._getGlobalState(D)
                        );
                      })
                    ),
                    this.actor.registerMessageHandler("UGS", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        const H = this._getGlobalState(D);
                        for (const W in j) H[W] = j[W];
                      })
                    ),
                    this.actor.registerMessageHandler("SL", (D, j) =>
                      T._(this, void 0, void 0, function* () {
                        this._getLayerIndex(D).replace(
                          j,
                          this._getGlobalState(D)
                        );
                      })
                    );
                }
                _getGlobalState(E) {
                  let D = this.globalStates.get(E);
                  return D || ((D = {}), this.globalStates.set(E, D)), D;
                }
                _setImages(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    this.availableImages[E] = D;
                    for (const j in this.workerSources[E]) {
                      const H = this.workerSources[E][j];
                      for (const W in H) H[W].availableImages = D;
                    }
                  });
                }
                _syncRTLPluginState(E, D) {
                  return T._(this, void 0, void 0, function* () {
                    return yield T.c_.syncState(D, this.self.importScripts);
                  });
                }
                _getAvailableImages(E) {
                  let D = this.availableImages[E];
                  return D || (D = []), D;
                }
                _getLayerIndex(E) {
                  let D = this.layerIndexes[E];
                  return D || (D = this.layerIndexes[E] = new s()), D;
                }
                _getWorkerSource(E, D, j) {
                  if (
                    (this.workerSources[E] || (this.workerSources[E] = {}),
                    this.workerSources[E][D] || (this.workerSources[E][D] = {}),
                    !this.workerSources[E][D][j])
                  ) {
                    const H = {
                      sendAsync: (W, ce) => (
                        (W.targetMapId = E), this.actor.sendAsync(W, ce)
                      ),
                    };
                    switch (D) {
                      case "vector":
                        this.workerSources[E][D][j] = new ee(
                          H,
                          this._getLayerIndex(E),
                          this._getAvailableImages(E)
                        );
                        break;
                      case "geojson":
                        this.workerSources[E][D][j] = new Dt(
                          H,
                          this._getLayerIndex(E),
                          this._getAvailableImages(E)
                        );
                        break;
                      default:
                        this.workerSources[E][D][j] =
                          new this.externalWorkerSourceTypes[D](
                            H,
                            this._getLayerIndex(E),
                            this._getAvailableImages(E)
                          );
                    }
                  }
                  return this.workerSources[E][D][j];
                }
                _getDEMWorkerSource(E, D) {
                  return (
                    this.demWorkerSources[E] || (this.demWorkerSources[E] = {}),
                    this.demWorkerSources[E][D] ||
                      (this.demWorkerSources[E][D] = new re()),
                    this.demWorkerSources[E][D]
                  );
                }
              }
              return T.i(self) && (self.worker = new Te(self)), Te;
            }),
            A("index", ["exports", "./shared"], function (T, s) {
              var B = "5.11.0";
              function N() {
                var h = new s.A(4);
                return (
                  s.A != Float32Array && ((h[1] = 0), (h[2] = 0)),
                  (h[0] = 1),
                  (h[3] = 1),
                  h
                );
              }
              let K, ee;
              const re = {
                  frame(h, e, i) {
                    const l = requestAnimationFrame((d) => {
                        u(), e(d);
                      }),
                      { unsubscribe: u } = s.s(
                        h.signal,
                        "abort",
                        () => {
                          u(), cancelAnimationFrame(l), i(s.c());
                        },
                        !1
                      );
                  },
                  frameAsync(h) {
                    return new Promise((e, i) => {
                      this.frame(h, e, i);
                    });
                  },
                  getImageData(h, e = 0) {
                    return this.getImageCanvasContext(h).getImageData(
                      -e,
                      -e,
                      h.width + 2 * e,
                      h.height + 2 * e
                    );
                  },
                  getImageCanvasContext(h) {
                    const e = window.document.createElement("canvas"),
                      i = e.getContext("2d", { willReadFrequently: !0 });
                    if (!i)
                      throw new Error("failed to create canvas 2d context");
                    return (
                      (e.width = h.width),
                      (e.height = h.height),
                      i.drawImage(h, 0, 0, h.width, h.height),
                      i
                    );
                  },
                  resolveURL: (h) => (
                    K || (K = document.createElement("a")), (K.href = h), K.href
                  ),
                  hardwareConcurrency:
                    (typeof navigator < "u" && navigator.hardwareConcurrency) ||
                    4,
                  get prefersReducedMotion() {
                    return (
                      !!matchMedia &&
                      (ee == null &&
                        (ee = matchMedia("(prefers-reduced-motion: reduce)")),
                      ee.matches)
                    );
                  },
                },
                ue = new (class {
                  constructor() {
                    (this._realTime =
                      typeof performance < "u" && performance && performance.now
                        ? performance.now.bind(performance)
                        : Date.now.bind(Date)),
                      (this._frozenAt = null);
                  }
                  getCurrentTime() {
                    return this._frozenAt !== null
                      ? this._frozenAt
                      : this._realTime();
                  }
                  setNow(h) {
                    this._frozenAt = h;
                  }
                  restoreNow() {
                    this._frozenAt = null;
                  }
                  isFrozen() {
                    return this._frozenAt !== null;
                  }
                })();
              function ne() {
                return ue.getCurrentTime();
              }
              class Y {
                static testProp(e) {
                  if (!Y.docStyle) return e[0];
                  for (let i = 0; i < e.length; i++)
                    if (e[i] in Y.docStyle) return e[i];
                  return e[0];
                }
                static create(e, i, l) {
                  const u = window.document.createElement(e);
                  return (
                    i !== void 0 && (u.className = i), l && l.appendChild(u), u
                  );
                }
                static createNS(e, i) {
                  return window.document.createElementNS(e, i);
                }
                static disableDrag() {
                  Y.docStyle &&
                    Y.selectProp &&
                    ((Y.userSelect = Y.docStyle[Y.selectProp]),
                    (Y.docStyle[Y.selectProp] = "none"));
                }
                static enableDrag() {
                  Y.docStyle &&
                    Y.selectProp &&
                    (Y.docStyle[Y.selectProp] = Y.userSelect);
                }
                static setTransform(e, i) {
                  e.style[Y.transformProp] = i;
                }
                static addEventListener(e, i, l, u = {}) {
                  e.addEventListener(i, l, "passive" in u ? u : u.capture);
                }
                static removeEventListener(e, i, l, u = {}) {
                  e.removeEventListener(i, l, "passive" in u ? u : u.capture);
                }
                static suppressClickInternal(e) {
                  e.preventDefault(),
                    e.stopPropagation(),
                    window.removeEventListener(
                      "click",
                      Y.suppressClickInternal,
                      !0
                    );
                }
                static suppressClick() {
                  window.addEventListener("click", Y.suppressClickInternal, !0),
                    window.setTimeout(() => {
                      window.removeEventListener(
                        "click",
                        Y.suppressClickInternal,
                        !0
                      );
                    }, 0);
                }
                static getScale(e) {
                  const i = e.getBoundingClientRect();
                  return {
                    x: i.width / e.offsetWidth || 1,
                    y: i.height / e.offsetHeight || 1,
                    boundingClientRect: i,
                  };
                }
                static getPoint(e, i, l) {
                  const u = i.boundingClientRect;
                  return new s.P(
                    (l.clientX - u.left) / i.x - e.clientLeft,
                    (l.clientY - u.top) / i.y - e.clientTop
                  );
                }
                static mousePos(e, i) {
                  const l = Y.getScale(e);
                  return Y.getPoint(e, l, i);
                }
                static touchPos(e, i) {
                  const l = [],
                    u = Y.getScale(e);
                  for (let d = 0; d < i.length; d++)
                    l.push(Y.getPoint(e, u, i[d]));
                  return l;
                }
                static mouseButton(e) {
                  return e.button;
                }
                static remove(e) {
                  e.parentNode && e.parentNode.removeChild(e);
                }
                static sanitize(e) {
                  const i =
                      new DOMParser().parseFromString(e, "text/html").body ||
                      document.createElement("body"),
                    l = i.querySelectorAll("script");
                  for (const u of l) u.remove();
                  return Y.clean(i), i.innerHTML;
                }
                static isPossiblyDangerous(e, i) {
                  const l = i.replace(/\s+/g, "").toLowerCase();
                  return (
                    !(
                      !["src", "href", "xlink:href"].includes(e) ||
                      (!l.includes("javascript:") && !l.includes("data:"))
                    ) ||
                    !!e.startsWith("on") ||
                    void 0
                  );
                }
                static clean(e) {
                  const i = e.children;
                  for (const l of i) Y.removeAttributes(l), Y.clean(l);
                }
                static removeAttributes(e) {
                  for (const { name: i, value: l } of e.attributes)
                    Y.isPossiblyDangerous(i, l) && e.removeAttribute(i);
                }
              }
              (Y.docStyle =
                typeof window < "u" &&
                window.document &&
                window.document.documentElement.style),
                (Y.selectProp = Y.testProp([
                  "userSelect",
                  "MozUserSelect",
                  "WebkitUserSelect",
                  "msUserSelect",
                ])),
                (Y.transformProp = Y.testProp([
                  "transform",
                  "WebkitTransform",
                ]));
              const xe = {
                supported: !1,
                testSupport: function (h) {
                  !De && Ee && (Ae ? qe(h) : (Ie = h));
                },
              };
              let Ie,
                Ee,
                De = !1,
                Ae = !1;
              function qe(h) {
                const e = h.createTexture();
                h.bindTexture(h.TEXTURE_2D, e);
                try {
                  if (
                    (h.texImage2D(
                      h.TEXTURE_2D,
                      0,
                      h.RGBA,
                      h.RGBA,
                      h.UNSIGNED_BYTE,
                      Ee
                    ),
                    h.isContextLost())
                  )
                    return;
                  xe.supported = !0;
                } catch {}
                h.deleteTexture(e), (De = !0);
              }
              var Ue;
              typeof document < "u" &&
                ((Ee = document.createElement("img")),
                (Ee.onload = () => {
                  Ie && qe(Ie), (Ie = null), (Ae = !0);
                }),
                (Ee.onerror = () => {
                  (De = !0), (Ie = null);
                }),
                (Ee.src =
                  "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=")),
                (function (h) {
                  let e, i, l, u;
                  (h.resetRequestQueue = () => {
                    (e = []), (i = 0), (l = 0), (u = {});
                  }),
                    (h.addThrottleControl = (S) => {
                      const k = l++;
                      return (u[k] = S), k;
                    }),
                    (h.removeThrottleControl = (S) => {
                      delete u[S], g();
                    }),
                    (h.getImage = (S, k, z = !0) =>
                      new Promise((V, F) => {
                        xe.supported &&
                          (S.headers || (S.headers = {}),
                          (S.headers.accept = "image/webp,*/*")),
                          s.e(S, { type: "image" }),
                          e.push({
                            abortController: k,
                            requestParameters: S,
                            supportImageRefresh: z,
                            state: "queued",
                            onError: ($) => {
                              F($);
                            },
                            onSuccess: ($) => {
                              V($);
                            },
                          }),
                          g();
                      }));
                  const d = (S) =>
                      s._(this, void 0, void 0, function* () {
                        S.state = "running";
                        const {
                            requestParameters: k,
                            supportImageRefresh: z,
                            onError: V,
                            onSuccess: F,
                            abortController: $,
                          } = S,
                          J =
                            z === !1 &&
                            !s.i(self) &&
                            !s.g(k.url) &&
                            (!k.headers ||
                              Object.keys(k.headers).reduce(
                                (se, fe) => se && fe === "accept",
                                !0
                              ));
                        i++;
                        const ae = J ? w(k, $) : s.m(k, $);
                        try {
                          const se = yield ae;
                          delete S.abortController,
                            (S.state = "completed"),
                            se.data instanceof HTMLImageElement || s.b(se.data)
                              ? F(se)
                              : se.data &&
                                F({
                                  data: yield ((oe = se.data),
                                  typeof createImageBitmap == "function"
                                    ? s.f(oe)
                                    : s.h(oe)),
                                  cacheControl: se.cacheControl,
                                  expires: se.expires,
                                });
                        } catch (se) {
                          delete S.abortController, V(se);
                        } finally {
                          i--, g();
                        }
                        var oe;
                      }),
                    g = () => {
                      const S = (() => {
                        for (const k of Object.keys(u)) if (u[k]()) return !0;
                        return !1;
                      })()
                        ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME
                        : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
                      for (let k = i; k < S && e.length > 0; k++) {
                        const z = e.shift();
                        z.abortController.signal.aborted ? k-- : d(z);
                      }
                    },
                    w = (S, k) =>
                      new Promise((z, V) => {
                        const F = new Image(),
                          $ = S.url,
                          J = S.credentials;
                        J && J === "include"
                          ? (F.crossOrigin = "use-credentials")
                          : ((J && J === "same-origin") || !s.d($)) &&
                            (F.crossOrigin = "anonymous"),
                          k.signal.addEventListener("abort", () => {
                            (F.src = ""), V(s.c());
                          }),
                          (F.fetchPriority = "high"),
                          (F.onload = () => {
                            (F.onerror = F.onload = null), z({ data: F });
                          }),
                          (F.onerror = () => {
                            (F.onerror = F.onload = null),
                              k.signal.aborted ||
                                V(
                                  new Error(
                                    "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
                                  )
                                );
                          }),
                          (F.src = $);
                      });
                })(Ue || (Ue = {})),
                Ue.resetRequestQueue();
              class Be {
                constructor(e) {
                  this._transformRequestFn = e ?? null;
                }
                transformRequest(e, i) {
                  return (
                    (this._transformRequestFn &&
                      this._transformRequestFn(e, i)) || { url: e }
                  );
                }
                setTransformRequest(e) {
                  this._transformRequestFn = e;
                }
              }
              function ke(h) {
                const e = [];
                if (typeof h == "string") e.push({ id: "default", url: h });
                else if (h && h.length > 0) {
                  const i = [];
                  for (const { id: l, url: u } of h) {
                    const d = `${l}${u}`;
                    i.indexOf(d) === -1 &&
                      (i.push(d), e.push({ id: l, url: u }));
                  }
                }
                return e;
              }
              function $e(h, e, i) {
                try {
                  const l = new URL(h);
                  return (l.pathname += `${e}${i}`), l.toString();
                } catch {
                  throw new Error(
                    `Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`
                  );
                }
              }
              function Le(h) {
                const { userImage: e } = h;
                return (
                  !!(e && e.render && e.render()) &&
                  (h.data.replace(new Uint8Array(e.data.buffer)), !0)
                );
              }
              class nt extends s.E {
                constructor() {
                  super(),
                    (this.images = {}),
                    (this.updatedImages = {}),
                    (this.callbackDispatchedThisFrame = {}),
                    (this.loaded = !1),
                    (this.requestors = []),
                    (this.patterns = {}),
                    (this.atlasImage = new s.R({ width: 1, height: 1 })),
                    (this.dirty = !0);
                }
                isLoaded() {
                  return this.loaded;
                }
                setLoaded(e) {
                  if (this.loaded !== e && ((this.loaded = e), e)) {
                    for (const { ids: i, promiseResolve: l } of this.requestors)
                      l(this._getImagesForIds(i));
                    this.requestors = [];
                  }
                }
                getImage(e) {
                  const i = this.images[e];
                  if (i && !i.data && i.spriteData) {
                    const l = i.spriteData;
                    (i.data = new s.R(
                      { width: l.width, height: l.height },
                      l.context.getImageData(l.x, l.y, l.width, l.height).data
                    )),
                      (i.spriteData = null);
                  }
                  return i;
                }
                addImage(e, i) {
                  if (this.images[e])
                    throw new Error(
                      `Image id ${e} already exist, use updateImage instead`
                    );
                  this._validate(e, i) && (this.images[e] = i);
                }
                _validate(e, i) {
                  let l = !0;
                  const u = i.data || i.spriteData;
                  return (
                    this._validateStretch(i.stretchX, u && u.width) ||
                      (this.fire(
                        new s.k(
                          new Error(`Image "${e}" has invalid "stretchX" value`)
                        )
                      ),
                      (l = !1)),
                    this._validateStretch(i.stretchY, u && u.height) ||
                      (this.fire(
                        new s.k(
                          new Error(`Image "${e}" has invalid "stretchY" value`)
                        )
                      ),
                      (l = !1)),
                    this._validateContent(i.content, i) ||
                      (this.fire(
                        new s.k(
                          new Error(`Image "${e}" has invalid "content" value`)
                        )
                      ),
                      (l = !1)),
                    l
                  );
                }
                _validateStretch(e, i) {
                  if (!e) return !0;
                  let l = 0;
                  for (const u of e) {
                    if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
                    l = u[1];
                  }
                  return !0;
                }
                _validateContent(e, i) {
                  if (!e) return !0;
                  if (e.length !== 4) return !1;
                  const l = i.spriteData,
                    u = (l && l.width) || i.data.width,
                    d = (l && l.height) || i.data.height;
                  return !(
                    e[0] < 0 ||
                    u < e[0] ||
                    e[1] < 0 ||
                    d < e[1] ||
                    e[2] < 0 ||
                    u < e[2] ||
                    e[3] < 0 ||
                    d < e[3] ||
                    e[2] < e[0] ||
                    e[3] < e[1]
                  );
                }
                updateImage(e, i, l = !0) {
                  const u = this.getImage(e);
                  if (
                    l &&
                    (u.data.width !== i.data.width ||
                      u.data.height !== i.data.height)
                  )
                    throw new Error(
                      `size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`
                    );
                  (i.version = u.version + 1),
                    (this.images[e] = i),
                    (this.updatedImages[e] = !0);
                }
                removeImage(e) {
                  const i = this.images[e];
                  delete this.images[e],
                    delete this.patterns[e],
                    i.userImage &&
                      i.userImage.onRemove &&
                      i.userImage.onRemove();
                }
                listImages() {
                  return Object.keys(this.images);
                }
                getImages(e) {
                  return new Promise((i, l) => {
                    let u = !0;
                    if (!this.isLoaded())
                      for (const d of e) this.images[d] || (u = !1);
                    this.isLoaded() || u
                      ? i(this._getImagesForIds(e))
                      : this.requestors.push({ ids: e, promiseResolve: i });
                  });
                }
                _getImagesForIds(e) {
                  const i = {};
                  for (const l of e) {
                    let u = this.getImage(l);
                    u ||
                      (this.fire(new s.l("styleimagemissing", { id: l })),
                      (u = this.getImage(l))),
                      u
                        ? (i[l] = {
                            data: u.data.clone(),
                            pixelRatio: u.pixelRatio,
                            sdf: u.sdf,
                            version: u.version,
                            stretchX: u.stretchX,
                            stretchY: u.stretchY,
                            content: u.content,
                            textFitWidth: u.textFitWidth,
                            textFitHeight: u.textFitHeight,
                            hasRenderCallback: !!(
                              u.userImage && u.userImage.render
                            ),
                          })
                        : s.w(
                            `Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                          );
                  }
                  return i;
                }
                getPixelSize() {
                  const { width: e, height: i } = this.atlasImage;
                  return { width: e, height: i };
                }
                getPattern(e) {
                  const i = this.patterns[e],
                    l = this.getImage(e);
                  if (!l) return null;
                  if (i && i.position.version === l.version) return i.position;
                  if (i) i.position.version = l.version;
                  else {
                    const u = {
                        w: l.data.width + 2,
                        h: l.data.height + 2,
                        x: 0,
                        y: 0,
                      },
                      d = new s.I(u, l);
                    this.patterns[e] = { bin: u, position: d };
                  }
                  return this._updatePatternAtlas(), this.patterns[e].position;
                }
                bind(e) {
                  const i = e.gl;
                  this.atlasTexture
                    ? this.dirty &&
                      (this.atlasTexture.update(this.atlasImage),
                      (this.dirty = !1))
                    : (this.atlasTexture = new s.T(e, this.atlasImage, i.RGBA)),
                    this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                }
                _updatePatternAtlas() {
                  const e = [];
                  for (const d in this.patterns) e.push(this.patterns[d].bin);
                  const { w: i, h: l } = s.p(e),
                    u = this.atlasImage;
                  u.resize({ width: i || 1, height: l || 1 });
                  for (const d in this.patterns) {
                    const { bin: g } = this.patterns[d],
                      w = g.x + 1,
                      S = g.y + 1,
                      k = this.getImage(d).data,
                      z = k.width,
                      V = k.height;
                    s.R.copy(
                      k,
                      u,
                      { x: 0, y: 0 },
                      { x: w, y: S },
                      { width: z, height: V }
                    ),
                      s.R.copy(
                        k,
                        u,
                        { x: 0, y: V - 1 },
                        { x: w, y: S - 1 },
                        { width: z, height: 1 }
                      ),
                      s.R.copy(
                        k,
                        u,
                        { x: 0, y: 0 },
                        { x: w, y: S + V },
                        { width: z, height: 1 }
                      ),
                      s.R.copy(
                        k,
                        u,
                        { x: z - 1, y: 0 },
                        { x: w - 1, y: S },
                        { width: 1, height: V }
                      ),
                      s.R.copy(
                        k,
                        u,
                        { x: 0, y: 0 },
                        { x: w + z, y: S },
                        { width: 1, height: V }
                      );
                  }
                  this.dirty = !0;
                }
                beginFrame() {
                  this.callbackDispatchedThisFrame = {};
                }
                dispatchRenderCallbacks(e) {
                  for (const i of e) {
                    if (this.callbackDispatchedThisFrame[i]) continue;
                    this.callbackDispatchedThisFrame[i] = !0;
                    const l = this.getImage(i);
                    l || s.w(`Image with ID: "${i}" was not found`),
                      Le(l) && this.updateImage(i, l);
                  }
                }
              }
              const dt = 1e20;
              function je(h, e, i, l, u, d, g, w, S) {
                for (let k = e; k < e + l; k++) Ge(h, i * d + k, d, u, g, w, S);
                for (let k = i; k < i + u; k++) Ge(h, k * d + e, 1, l, g, w, S);
              }
              function Ge(h, e, i, l, u, d, g) {
                (d[0] = 0), (g[0] = -dt), (g[1] = dt), (u[0] = h[e]);
                for (let w = 1, S = 0, k = 0; w < l; w++) {
                  u[w] = h[e + w * i];
                  const z = w * w;
                  do {
                    const V = d[S];
                    k = (u[w] - u[V] + z - V * V) / (w - V) / 2;
                  } while (k <= g[S] && --S > -1);
                  S++, (d[S] = w), (g[S] = k), (g[S + 1] = dt);
                }
                for (let w = 0, S = 0; w < l; w++) {
                  for (; g[S + 1] < w; ) S++;
                  const k = d[S],
                    z = w - k;
                  h[e + w * i] = u[k] + z * z;
                }
              }
              const bt = s.v.layout_symbol["text-font"].default.join(",");
              class Xe {
                constructor(e, i, l) {
                  (this.requestManager = e),
                    (this.localIdeographFontFamily = i),
                    (this.entries = {}),
                    (this.lang = l);
                }
                setURL(e) {
                  this.url = e;
                }
                getGlyphs(e) {
                  return s._(this, void 0, void 0, function* () {
                    const i = [];
                    for (const d in e)
                      for (const g of e[d])
                        i.push(this._getAndCacheGlyphsPromise(d, g));
                    const l = yield Promise.all(i),
                      u = {};
                    for (const { stack: d, id: g, glyph: w } of l)
                      u[d] || (u[d] = {}),
                        (u[d][g] = w && {
                          id: w.id,
                          bitmap: w.bitmap.clone(),
                          metrics: w.metrics,
                        });
                    return u;
                  });
                }
                _getAndCacheGlyphsPromise(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    let l = this.entries[e];
                    l ||
                      (l = this.entries[e] =
                        { glyphs: {}, requests: {}, ranges: {} });
                    let u = l.glyphs[i];
                    return u !== void 0
                      ? { stack: e, id: i, glyph: u }
                      : !this.url || this._charUsesLocalIdeographFontFamily(i)
                      ? ((u = l.glyphs[i] = this._drawGlyph(l, e, i)),
                        { stack: e, id: i, glyph: u })
                      : yield this._downloadAndCacheRangePromise(e, i);
                  });
                }
                _downloadAndCacheRangePromise(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    const l = Math.floor(i / 256);
                    if (256 * l > 65535)
                      throw new Error("glyphs > 65535 not supported");
                    const u = this.entries[e];
                    if (u.ranges[l]) return { stack: e, id: i, glyph: null };
                    if (!u.requests[l]) {
                      const d = Xe.loadGlyphRange(
                        e,
                        l,
                        this.url,
                        this.requestManager
                      );
                      u.requests[l] = d;
                    }
                    try {
                      const d = yield u.requests[l];
                      for (const g in d) u.glyphs[+g] = d[+g];
                      return (
                        (u.ranges[l] = !0),
                        { stack: e, id: i, glyph: d[i] || null }
                      );
                    } catch (d) {
                      const g = (u.glyphs[i] = this._drawGlyph(u, e, i));
                      return (
                        this._warnOnMissingGlyphRange(g, l, i, d),
                        { stack: e, id: i, glyph: g }
                      );
                    }
                  });
                }
                _warnOnMissingGlyphRange(e, i, l, u) {
                  const d = 256 * i,
                    g = d + 255,
                    w = l.toString(16).padStart(4, "0").toUpperCase();
                  s.w(
                    `Unable to load glyph range ${i}, ${d}-${g}. Rendering codepoint U+${w} locally instead. ${u}`
                  );
                }
                _charUsesLocalIdeographFontFamily(e) {
                  return (
                    !!this.localIdeographFontFamily &&
                    (new RegExp(
                      "\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}",
                      "u"
                    ).test(String.fromCodePoint(e)) ||
                      s.u["CJK Unified Ideographs"](e) ||
                      s.u["Hangul Syllables"](e) ||
                      s.u.Hiragana(e) ||
                      s.u.Katakana(e) ||
                      s.u["CJK Symbols and Punctuation"](e) ||
                      s.u["Halfwidth and Fullwidth Forms"](e))
                  );
                }
                _drawGlyph(e, i, l) {
                  const u =
                      i === bt &&
                      this.localIdeographFontFamily !== "" &&
                      this._charUsesLocalIdeographFontFamily(l),
                    d = u ? "ideographTinySDF" : "tinySDF";
                  e[d] ||
                    (e[d] = this._createTinySDF(
                      u ? this.localIdeographFontFamily : i
                    ));
                  const g = e[d].draw(String.fromCharCode(l));
                  return {
                    id: l,
                    bitmap: new s.q(
                      { width: g.width || 60, height: g.height || 60 },
                      g.data
                    ),
                    metrics: {
                      width: g.glyphWidth / 2 || 24,
                      height: g.glyphHeight / 2 || 24,
                      left: g.glyphLeft / 2 + 0.5 || 0,
                      top: g.glyphTop / 2 - 27.5 || -8,
                      advance: g.glyphAdvance / 2 || 24,
                      isDoubleResolution: !0,
                    },
                  };
                }
                _createTinySDF(e) {
                  const i = e ? e.split(",") : [];
                  i.push("sans-serif");
                  const l = i
                    .map((u) => (/[-\w]+/.test(u) ? u : `'${CSS.escape(u)}'`))
                    .join(",");
                  return new Xe.TinySDF({
                    fontSize: 48,
                    buffer: 6,
                    radius: 16,
                    cutoff: 0.25,
                    fontFamily: l,
                    fontWeight: this._fontWeight(i[0]),
                    fontStyle: this._fontStyle(i[0]),
                    lang: this.lang,
                  });
                }
                _fontStyle(e) {
                  return /italic/i.test(e)
                    ? "italic"
                    : /oblique/i.test(e)
                    ? "oblique"
                    : "normal";
                }
                _fontWeight(e) {
                  const i = {
                    thin: 100,
                    hairline: 100,
                    "extra light": 200,
                    "ultra light": 200,
                    light: 300,
                    normal: 400,
                    regular: 400,
                    medium: 500,
                    semibold: 600,
                    demibold: 600,
                    bold: 700,
                    "extra bold": 800,
                    "ultra bold": 800,
                    black: 900,
                    heavy: 900,
                    "extra black": 950,
                    "ultra black": 950,
                  };
                  let l;
                  for (const [u, d] of Object.entries(i))
                    new RegExp(`\\b${u}\\b`, "i").test(e) && (l = `${d}`);
                  return l;
                }
              }
              (Xe.loadGlyphRange = function (h, e, i, l) {
                return s._(this, void 0, void 0, function* () {
                  const u = 256 * e,
                    d = u + 255,
                    g = l.transformRequest(
                      i
                        .replace("{fontstack}", h)
                        .replace("{range}", `${u}-${d}`),
                      "Glyphs"
                    ),
                    w = yield s.n(g, new AbortController());
                  if (!w || !w.data)
                    throw new Error(
                      `Could not load glyph range. range: ${e}, ${u}-${d}`
                    );
                  const S = {};
                  for (const k of s.o(w.data)) S[k.id] = k;
                  return S;
                });
              }),
                (Xe.TinySDF = class {
                  constructor({
                    fontSize: h = 24,
                    buffer: e = 3,
                    radius: i = 8,
                    cutoff: l = 0.25,
                    fontFamily: u = "sans-serif",
                    fontWeight: d = "normal",
                    fontStyle: g = "normal",
                    lang: w = null,
                  } = {}) {
                    (this.buffer = e),
                      (this.cutoff = l),
                      (this.radius = i),
                      (this.lang = w);
                    const S = (this.size = h + 4 * e),
                      k = this._createCanvas(S),
                      z = (this.ctx = k.getContext("2d", {
                        willReadFrequently: !0,
                      }));
                    (z.font = `${g} ${d} ${h}px ${u}`),
                      (z.textBaseline = "alphabetic"),
                      (z.textAlign = "left"),
                      (z.fillStyle = "black"),
                      (this.gridOuter = new Float64Array(S * S)),
                      (this.gridInner = new Float64Array(S * S)),
                      (this.f = new Float64Array(S)),
                      (this.z = new Float64Array(S + 1)),
                      (this.v = new Uint16Array(S));
                  }
                  _createCanvas(h) {
                    const e = document.createElement("canvas");
                    return (e.width = e.height = h), e;
                  }
                  draw(h) {
                    const {
                        width: e,
                        actualBoundingBoxAscent: i,
                        actualBoundingBoxDescent: l,
                        actualBoundingBoxLeft: u,
                        actualBoundingBoxRight: d,
                      } = this.ctx.measureText(h),
                      g = Math.ceil(i),
                      w = Math.max(
                        0,
                        Math.min(this.size - this.buffer, Math.ceil(d - u))
                      ),
                      S = Math.min(this.size - this.buffer, g + Math.ceil(l)),
                      k = w + 2 * this.buffer,
                      z = S + 2 * this.buffer,
                      V = Math.max(k * z, 0),
                      F = new Uint8ClampedArray(V),
                      $ = {
                        data: F,
                        width: k,
                        height: z,
                        glyphWidth: w,
                        glyphHeight: S,
                        glyphTop: g,
                        glyphLeft: 0,
                        glyphAdvance: e,
                      };
                    if (w === 0 || S === 0) return $;
                    const {
                      ctx: J,
                      buffer: ae,
                      gridInner: oe,
                      gridOuter: se,
                    } = this;
                    this.lang && (J.lang = this.lang),
                      J.clearRect(ae, ae, w, S),
                      J.fillText(h, ae, ae + g);
                    const fe = J.getImageData(ae, ae, w, S);
                    se.fill(dt, 0, V), oe.fill(0, 0, V);
                    for (let be = 0; be < S; be++)
                      for (let pe = 0; pe < w; pe++) {
                        const we = fe.data[4 * (be * w + pe) + 3] / 255;
                        if (we === 0) continue;
                        const Pe = (be + ae) * k + pe + ae;
                        if (we === 1) (se[Pe] = 0), (oe[Pe] = dt);
                        else {
                          const ve = 0.5 - we;
                          (se[Pe] = ve > 0 ? ve * ve : 0),
                            (oe[Pe] = ve < 0 ? ve * ve : 0);
                        }
                      }
                    je(se, 0, 0, k, z, k, this.f, this.v, this.z),
                      je(oe, ae, ae, w, S, k, this.f, this.v, this.z);
                    for (let be = 0; be < V; be++) {
                      const pe = Math.sqrt(se[be]) - Math.sqrt(oe[be]);
                      F[be] = Math.round(
                        255 - 255 * (pe / this.radius + this.cutoff)
                      );
                    }
                    return $;
                  }
                });
              class Ve {
                constructor() {
                  this.specification = s.t.light.position;
                }
                possiblyEvaluate(e, i) {
                  return s.C(e.expression.evaluate(i));
                }
                interpolate(e, i, l) {
                  return {
                    x: s.F.number(e.x, i.x, l),
                    y: s.F.number(e.y, i.y, l),
                    z: s.F.number(e.z, i.z, l),
                  };
                }
              }
              let Ke;
              class Fe extends s.E {
                constructor(e) {
                  super(),
                    (Ke =
                      Ke ||
                      new s.r({
                        anchor: new s.D(s.t.light.anchor),
                        position: new Ve(),
                        color: new s.D(s.t.light.color),
                        intensity: new s.D(s.t.light.intensity),
                      })),
                    (this._transitionable = new s.x(Ke, void 0)),
                    this.setLight(e),
                    (this._transitioning =
                      this._transitionable.untransitioned());
                }
                getLight() {
                  return this._transitionable.serialize();
                }
                setLight(e, i = {}) {
                  if (!this._validate(s.y, e, i))
                    for (const l in e) {
                      const u = e[l];
                      l.endsWith("-transition")
                        ? this._transitionable.setTransition(l.slice(0, -11), u)
                        : this._transitionable.setValue(l, u);
                    }
                }
                updateTransitions(e) {
                  this._transitioning = this._transitionable.transitioned(
                    e,
                    this._transitioning
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(e) {
                  this.properties = this._transitioning.possiblyEvaluate(e);
                }
                _validate(e, i, l) {
                  return (
                    (!l || l.validate !== !1) &&
                    s.z(
                      this,
                      e.call(s.B, {
                        value: i,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: s.t,
                      })
                    )
                  );
                }
              }
              const ft = new s.r({
                "sky-color": new s.D(s.t.sky["sky-color"]),
                "horizon-color": new s.D(s.t.sky["horizon-color"]),
                "fog-color": new s.D(s.t.sky["fog-color"]),
                "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]),
                "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]),
                "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]),
                "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"]),
              });
              class lt extends s.E {
                constructor(e) {
                  super(),
                    (this._transitionable = new s.x(ft, void 0)),
                    this.setSky(e),
                    (this._transitioning =
                      this._transitionable.untransitioned()),
                    this.recalculate(new s.G(0));
                }
                setSky(e, i = {}) {
                  if (!this._validate(s.H, e, i)) {
                    e ||
                      (e = {
                        "sky-color": "transparent",
                        "horizon-color": "transparent",
                        "fog-color": "transparent",
                        "fog-ground-blend": 1,
                        "atmosphere-blend": 0,
                      });
                    for (const l in e) {
                      const u = e[l];
                      l.endsWith("-transition")
                        ? this._transitionable.setTransition(l.slice(0, -11), u)
                        : this._transitionable.setValue(l, u);
                    }
                  }
                }
                getSky() {
                  return this._transitionable.serialize();
                }
                updateTransitions(e) {
                  this._transitioning = this._transitionable.transitioned(
                    e,
                    this._transitioning
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(e) {
                  this.properties = this._transitioning.possiblyEvaluate(e);
                }
                _validate(e, i, l = {}) {
                  return (
                    (l == null ? void 0 : l.validate) !== !1 &&
                    s.z(
                      this,
                      e.call(
                        s.B,
                        s.e({
                          value: i,
                          style: { glyphs: !0, sprite: !0 },
                          styleSpec: s.t,
                        })
                      )
                    )
                  );
                }
                calculateFogBlendOpacity(e) {
                  return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
                }
              }
              class yt {
                constructor(e, i) {
                  (this.width = e),
                    (this.height = i),
                    (this.nextRow = 0),
                    (this.data = new Uint8Array(this.width * this.height)),
                    (this.dashEntry = {});
                }
                getDash(e, i) {
                  const l = e.join(",") + String(i);
                  return (
                    this.dashEntry[l] ||
                      (this.dashEntry[l] = this.addDash(e, i)),
                    this.dashEntry[l]
                  );
                }
                getDashRanges(e, i, l) {
                  const u = [];
                  let d = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
                    g = e[0] * l,
                    w = !0;
                  u.push({
                    left: d,
                    right: g,
                    isDash: w,
                    zeroLength: e[0] === 0,
                  });
                  let S = e[0];
                  for (let k = 1; k < e.length; k++) {
                    w = !w;
                    const z = e[k];
                    (d = S * l),
                      (S += z),
                      (g = S * l),
                      u.push({
                        left: d,
                        right: g,
                        isDash: w,
                        zeroLength: z === 0,
                      });
                  }
                  return u;
                }
                addRoundDash(e, i, l) {
                  const u = i / 2;
                  for (let d = -l; d <= l; d++) {
                    const g = this.width * (this.nextRow + l + d);
                    let w = 0,
                      S = e[w];
                    for (let k = 0; k < this.width; k++) {
                      k / S.right > 1 && (S = e[++w]);
                      const z = Math.abs(k - S.left),
                        V = Math.abs(k - S.right),
                        F = Math.min(z, V);
                      let $;
                      const J = (d / l) * (u + 1);
                      if (S.isDash) {
                        const ae = u - Math.abs(J);
                        $ = Math.sqrt(F * F + ae * ae);
                      } else $ = u - Math.sqrt(F * F + J * J);
                      this.data[g + k] = Math.max(0, Math.min(255, $ + 128));
                    }
                  }
                }
                addRegularDash(e) {
                  for (let w = e.length - 1; w >= 0; --w) {
                    const S = e[w],
                      k = e[w + 1];
                    S.zeroLength
                      ? e.splice(w, 1)
                      : k &&
                        k.isDash === S.isDash &&
                        ((k.left = S.left), e.splice(w, 1));
                  }
                  const i = e[0],
                    l = e[e.length - 1];
                  i.isDash === l.isDash &&
                    ((i.left = l.left - this.width),
                    (l.right = i.right + this.width));
                  const u = this.width * this.nextRow;
                  let d = 0,
                    g = e[d];
                  for (let w = 0; w < this.width; w++) {
                    w / g.right > 1 && (g = e[++d]);
                    const S = Math.abs(w - g.left),
                      k = Math.abs(w - g.right),
                      z = Math.min(S, k);
                    this.data[u + w] = Math.max(
                      0,
                      Math.min(255, (g.isDash ? z : -z) + 128)
                    );
                  }
                }
                addDash(e, i) {
                  const l = i ? 7 : 0,
                    u = 2 * l + 1;
                  if (this.nextRow + u > this.height)
                    return s.w("LineAtlas out of space"), null;
                  let d = 0;
                  for (let w = 0; w < e.length; w++) d += e[w];
                  if (d !== 0) {
                    const w = this.width / d,
                      S = this.getDashRanges(e, this.width, w);
                    i ? this.addRoundDash(S, w, l) : this.addRegularDash(S);
                  }
                  const g = { y: this.nextRow + l, height: 2 * l, width: d };
                  return (this.nextRow += u), (this.dirty = !0), g;
                }
                bind(e) {
                  const i = e.gl;
                  this.texture
                    ? (i.bindTexture(i.TEXTURE_2D, this.texture),
                      this.dirty &&
                        ((this.dirty = !1),
                        i.texSubImage2D(
                          i.TEXTURE_2D,
                          0,
                          0,
                          0,
                          this.width,
                          this.height,
                          i.ALPHA,
                          i.UNSIGNED_BYTE,
                          this.data
                        )))
                    : ((this.texture = i.createTexture()),
                      i.bindTexture(i.TEXTURE_2D, this.texture),
                      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT),
                      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT),
                      i.texParameteri(
                        i.TEXTURE_2D,
                        i.TEXTURE_MIN_FILTER,
                        i.LINEAR
                      ),
                      i.texParameteri(
                        i.TEXTURE_2D,
                        i.TEXTURE_MAG_FILTER,
                        i.LINEAR
                      ),
                      i.texImage2D(
                        i.TEXTURE_2D,
                        0,
                        i.ALPHA,
                        this.width,
                        this.height,
                        0,
                        i.ALPHA,
                        i.UNSIGNED_BYTE,
                        this.data
                      ));
                }
              }
              const mt = "maplibre_preloaded_worker_pool";
              class ct {
                constructor() {
                  this.active = {};
                }
                acquire(e) {
                  if (!this.workers)
                    for (
                      this.workers = [];
                      this.workers.length < ct.workerCount;

                    )
                      this.workers.push(new Worker(s.a.WORKER_URL));
                  return (this.active[e] = !0), this.workers.slice();
                }
                release(e) {
                  delete this.active[e],
                    this.numActive() === 0 &&
                      (this.workers.forEach((i) => {
                        i.terminate();
                      }),
                      (this.workers = null));
                }
                isPreloaded() {
                  return !!this.active[mt];
                }
                numActive() {
                  return Object.keys(this.active).length;
                }
              }
              const qt = Math.floor(re.hardwareConcurrency / 2);
              let Ft, Ye;
              function at() {
                return Ft || (Ft = new ct()), Ft;
              }
              ct.workerCount = s.J(globalThis)
                ? Math.max(Math.min(qt, 3), 1)
                : 1;
              class xt {
                constructor(e, i) {
                  (this.workerPool = e),
                    (this.actors = []),
                    (this.currentActor = 0),
                    (this.id = i);
                  const l = this.workerPool.acquire(i);
                  for (let u = 0; u < l.length; u++) {
                    const d = new s.K(l[u], i);
                    (d.name = `Worker ${u}`), this.actors.push(d);
                  }
                  if (!this.actors.length) throw new Error("No actors found");
                }
                broadcast(e, i) {
                  const l = [];
                  for (const u of this.actors)
                    l.push(u.sendAsync({ type: e, data: i }));
                  return Promise.all(l);
                }
                getActor() {
                  return (
                    (this.currentActor =
                      (this.currentActor + 1) % this.actors.length),
                    this.actors[this.currentActor]
                  );
                }
                remove(e = !0) {
                  this.actors.forEach((i) => {
                    i.remove();
                  }),
                    (this.actors = []),
                    e && this.workerPool.release(this.id);
                }
                registerMessageHandler(e, i) {
                  for (const l of this.actors) l.registerMessageHandler(e, i);
                }
              }
              function It() {
                return (
                  Ye ||
                    ((Ye = new xt(at(), s.L)),
                    Ye.registerMessageHandler("GR", (h, e, i) => s.m(e, i))),
                  Ye
                );
              }
              function Tt(h, e) {
                const i = s.M();
                return (
                  s.N(i, i, [1, 1, 0]),
                  s.O(i, i, [0.5 * h.width, 0.5 * h.height, 1]),
                  h.calculatePosMatrix
                    ? s.Q(i, i, h.calculatePosMatrix(e.toUnwrapped()))
                    : i
                );
              }
              function Mt(h, e, i, l, u, d, g) {
                var w;
                const S = (function (F, $, J) {
                    if (F)
                      for (const ae of F) {
                        const oe = $[ae];
                        if (
                          oe &&
                          oe.source === J &&
                          oe.type === "fill-extrusion"
                        )
                          return !0;
                      }
                    else
                      for (const ae in $) {
                        const oe = $[ae];
                        if (oe.source === J && oe.type === "fill-extrusion")
                          return !0;
                      }
                    return !1;
                  })(
                    (w = u == null ? void 0 : u.layers) !== null && w !== void 0
                      ? w
                      : null,
                    e,
                    h.id
                  ),
                  k = d.maxPitchScaleFactor(),
                  z = h.tilesIn(l, k, S);
                z.sort(Wt);
                const V = [];
                for (const F of z)
                  V.push({
                    wrappedTileID: F.tileID.wrapped().key,
                    queryResults: F.tile.queryRenderedFeatures(
                      e,
                      i,
                      h.getState(),
                      F.queryGeometry,
                      F.cameraQueryGeometry,
                      F.scale,
                      u,
                      d,
                      k,
                      Tt(d, F.tileID),
                      g ? ($, J) => g(F.tileID, $, J) : void 0
                    ),
                  });
                return (function (F, $) {
                  for (const J in F) for (const ae of F[J]) Bt(ae, $);
                  return F;
                })(
                  (function (F) {
                    const $ = {},
                      J = {};
                    for (const ae of F) {
                      const oe = ae.queryResults,
                        se = ae.wrappedTileID,
                        fe = (J[se] = J[se] || {});
                      for (const be in oe) {
                        const pe = oe[be],
                          we = (fe[be] = fe[be] || {}),
                          Pe = ($[be] = $[be] || []);
                        for (const ve of pe)
                          we[ve.featureIndex] ||
                            ((we[ve.featureIndex] = !0), Pe.push(ve));
                      }
                    }
                    return $;
                  })(V),
                  h
                );
              }
              function Wt(h, e) {
                const i = h.tileID,
                  l = e.tileID;
                return (
                  i.overscaledZ - l.overscaledZ ||
                  i.canonical.y - l.canonical.y ||
                  i.wrap - l.wrap ||
                  i.canonical.x - l.canonical.x
                );
              }
              function Bt(h, e) {
                const i = h.feature,
                  l = e.getFeatureState(i.layer["source-layer"], i.id);
                (i.source = i.layer.source),
                  i.layer["source-layer"] &&
                    (i.sourceLayer = i.layer["source-layer"]),
                  (i.state = l);
              }
              function Gt(h, e, i) {
                return s._(this, void 0, void 0, function* () {
                  let l = h;
                  if (
                    (h.url
                      ? (l = (yield s.j(e.transformRequest(h.url, "Source"), i))
                          .data)
                      : yield re.frameAsync(i),
                    !l)
                  )
                    return null;
                  const u = s.S(s.e(l, h), [
                    "tiles",
                    "minzoom",
                    "maxzoom",
                    "attribution",
                    "bounds",
                    "scheme",
                    "tileSize",
                    "encoding",
                  ]);
                  return (
                    "vector_layers" in l &&
                      l.vector_layers &&
                      (u.vectorLayerIds = l.vector_layers.map((d) => d.id)),
                    u
                  );
                });
              }
              class At {
                constructor(e, i) {
                  e &&
                    (i
                      ? this.setSouthWest(e).setNorthEast(i)
                      : Array.isArray(e) &&
                        (e.length === 4
                          ? this.setSouthWest([e[0], e[1]]).setNorthEast([
                              e[2],
                              e[3],
                            ])
                          : this.setSouthWest(e[0]).setNorthEast(e[1])));
                }
                setNorthEast(e) {
                  return (
                    (this._ne =
                      e instanceof s.U
                        ? new s.U(e.lng, e.lat)
                        : s.U.convert(e)),
                    this
                  );
                }
                setSouthWest(e) {
                  return (
                    (this._sw =
                      e instanceof s.U
                        ? new s.U(e.lng, e.lat)
                        : s.U.convert(e)),
                    this
                  );
                }
                extend(e) {
                  const i = this._sw,
                    l = this._ne;
                  let u, d;
                  if (e instanceof s.U) (u = e), (d = e);
                  else {
                    if (!(e instanceof At))
                      return Array.isArray(e)
                        ? e.length === 4 || e.every(Array.isArray)
                          ? this.extend(At.convert(e))
                          : this.extend(s.U.convert(e))
                        : e && ("lng" in e || "lon" in e) && "lat" in e
                        ? this.extend(s.U.convert(e))
                        : this;
                    if (((u = e._sw), (d = e._ne), !u || !d)) return this;
                  }
                  return (
                    i || l
                      ? ((i.lng = Math.min(u.lng, i.lng)),
                        (i.lat = Math.min(u.lat, i.lat)),
                        (l.lng = Math.max(d.lng, l.lng)),
                        (l.lat = Math.max(d.lat, l.lat)))
                      : ((this._sw = new s.U(u.lng, u.lat)),
                        (this._ne = new s.U(d.lng, d.lat))),
                    this
                  );
                }
                getCenter() {
                  return new s.U(
                    (this._sw.lng + this._ne.lng) / 2,
                    (this._sw.lat + this._ne.lat) / 2
                  );
                }
                getSouthWest() {
                  return this._sw;
                }
                getNorthEast() {
                  return this._ne;
                }
                getNorthWest() {
                  return new s.U(this.getWest(), this.getNorth());
                }
                getSouthEast() {
                  return new s.U(this.getEast(), this.getSouth());
                }
                getWest() {
                  return this._sw.lng;
                }
                getSouth() {
                  return this._sw.lat;
                }
                getEast() {
                  return this._ne.lng;
                }
                getNorth() {
                  return this._ne.lat;
                }
                toArray() {
                  return [this._sw.toArray(), this._ne.toArray()];
                }
                toString() {
                  return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
                }
                isEmpty() {
                  return !(this._sw && this._ne);
                }
                contains(e) {
                  const { lng: i, lat: l } = s.U.convert(e);
                  let u = this._sw.lng <= i && i <= this._ne.lng;
                  return (
                    this._sw.lng > this._ne.lng &&
                      (u = this._sw.lng >= i && i >= this._ne.lng),
                    this._sw.lat <= l && l <= this._ne.lat && u
                  );
                }
                intersects(e) {
                  if (
                    (e = At.convert(e)).getNorth() < this.getSouth() ||
                    e.getSouth() > this.getNorth()
                  )
                    return !1;
                  const i = s.V(this.getWest(), -180, 180),
                    l = s.V(this.getEast(), -180, 180),
                    u = s.V(e.getWest(), -180, 180),
                    d = s.V(e.getEast(), -180, 180),
                    g = i > l,
                    w = u > d;
                  return (
                    !(!g || !w) ||
                    (g
                      ? d >= i || u <= l
                      : w
                      ? l >= u || i <= d
                      : !(u > l || d < i))
                  );
                }
                static convert(e) {
                  return e instanceof At ? e : e && new At(e);
                }
                static fromLngLat(e, i = 0) {
                  const l = (360 * i) / 40075017,
                    u = l / Math.cos((Math.PI / 180) * e.lat);
                  return new At(
                    new s.U(e.lng - u, e.lat - l),
                    new s.U(e.lng + u, e.lat + l)
                  );
                }
                adjustAntiMeridian() {
                  const e = new s.U(this._sw.lng, this._sw.lat),
                    i = new s.U(this._ne.lng, this._ne.lat);
                  return new At(
                    e,
                    e.lng > i.lng ? new s.U(i.lng + 360, i.lat) : i
                  );
                }
              }
              class Xt {
                constructor(e, i, l) {
                  (this.bounds = At.convert(this.validateBounds(e))),
                    (this.minzoom = i || 0),
                    (this.maxzoom = l || 24);
                }
                validateBounds(e) {
                  return Array.isArray(e) && e.length === 4
                    ? [
                        Math.max(-180, e[0]),
                        Math.max(-90, e[1]),
                        Math.min(180, e[2]),
                        Math.min(90, e[3]),
                      ]
                    : [-180, -90, 180, 90];
                }
                contains(e) {
                  const i = Math.pow(2, e.z),
                    l = Math.floor(s.X(this.bounds.getWest()) * i),
                    u = Math.floor(s.W(this.bounds.getNorth()) * i),
                    d = Math.ceil(s.X(this.bounds.getEast()) * i),
                    g = Math.ceil(s.W(this.bounds.getSouth()) * i);
                  return e.x >= l && e.x < d && e.y >= u && e.y < g;
                }
              }
              class Lt extends s.E {
                constructor(e, i, l, u) {
                  if (
                    (super(),
                    (this.id = e),
                    (this.dispatcher = l),
                    (this.type = "vector"),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.scheme = "xyz"),
                    (this.tileSize = 512),
                    (this.reparseOverscaled = !0),
                    (this.isTileClipped = !0),
                    (this._loaded = !1),
                    s.e(
                      this,
                      s.S(i, ["url", "scheme", "tileSize", "promoteId"])
                    ),
                    (this._options = s.e({ type: "vector" }, i)),
                    (this._collectResourceTiming = i.collectResourceTiming),
                    this.tileSize !== 512)
                  )
                    throw new Error(
                      "vector tile sources must have a tileSize of 512"
                    );
                  this.setEventedParent(u);
                }
                load() {
                  return s._(this, void 0, void 0, function* () {
                    (this._loaded = !1),
                      this.fire(new s.l("dataloading", { dataType: "source" })),
                      (this._tileJSONRequest = new AbortController());
                    try {
                      const e = yield Gt(
                        this._options,
                        this.map._requestManager,
                        this._tileJSONRequest
                      );
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        this.map.style.tileManagers[this.id].clearTiles(),
                        e &&
                          (s.e(this, e),
                          e.bounds &&
                            (this.tileBounds = new Xt(
                              e.bounds,
                              this.minzoom,
                              this.maxzoom
                            )),
                          this.fire(
                            new s.l("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            })
                          ),
                          this.fire(
                            new s.l("data", {
                              dataType: "source",
                              sourceDataType: "content",
                            })
                          ));
                    } catch (e) {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        this.fire(new s.k(e));
                    }
                  });
                }
                loaded() {
                  return this._loaded;
                }
                hasTile(e) {
                  return (
                    !this.tileBounds || this.tileBounds.contains(e.canonical)
                  );
                }
                onAdd(e) {
                  (this.map = e), this.load();
                }
                setSourceProperty(e) {
                  this._tileJSONRequest && this._tileJSONRequest.abort(),
                    e(),
                    this.load();
                }
                setTiles(e) {
                  return (
                    this.setSourceProperty(() => {
                      this._options.tiles = e;
                    }),
                    this
                  );
                }
                setUrl(e) {
                  return (
                    this.setSourceProperty(() => {
                      (this.url = e), (this._options.url = e);
                    }),
                    this
                  );
                }
                onRemove() {
                  this._tileJSONRequest &&
                    (this._tileJSONRequest.abort(),
                    (this._tileJSONRequest = null));
                }
                serialize() {
                  return s.e({}, this._options);
                }
                loadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    const i = e.tileID.canonical.url(
                        this.tiles,
                        this.map.getPixelRatio(),
                        this.scheme
                      ),
                      l = {
                        request: this.map._requestManager.transformRequest(
                          i,
                          "Tile"
                        ),
                        uid: e.uid,
                        tileID: e.tileID,
                        zoom: e.tileID.overscaledZ,
                        tileSize: this.tileSize * e.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: this.map.getPixelRatio(),
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        subdivisionGranularity:
                          this.map.style.projection.subdivisionGranularity,
                      };
                    l.request.collectResourceTiming =
                      this._collectResourceTiming;
                    let u = "RT";
                    if (e.actor && e.state !== "expired") {
                      if (e.state === "loading")
                        return new Promise((d, g) => {
                          e.reloadPromise = { resolve: d, reject: g };
                        });
                    } else (e.actor = this.dispatcher.getActor()), (u = "LT");
                    e.abortController = new AbortController();
                    try {
                      const d = yield e.actor.sendAsync(
                        { type: u, data: l },
                        e.abortController
                      );
                      if ((delete e.abortController, e.aborted)) return;
                      this._afterTileLoadWorkerResponse(e, d);
                    } catch (d) {
                      if ((delete e.abortController, e.aborted)) return;
                      if (d && d.status !== 404) throw d;
                      this._afterTileLoadWorkerResponse(e, null);
                    }
                  });
                }
                _afterTileLoadWorkerResponse(e, i) {
                  if (
                    (i &&
                      i.resourceTiming &&
                      (e.resourceTiming = i.resourceTiming),
                    i && this.map._refreshExpiredTiles && e.setExpiryData(i),
                    e.loadVectorData(i, this.map.painter),
                    e.reloadPromise)
                  ) {
                    const l = e.reloadPromise;
                    (e.reloadPromise = null),
                      this.loadTile(e).then(l.resolve).catch(l.reject);
                  }
                }
                abortTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.abortController &&
                      (e.abortController.abort(), delete e.abortController),
                      e.actor &&
                        (yield e.actor.sendAsync({
                          type: "AT",
                          data: {
                            uid: e.uid,
                            type: this.type,
                            source: this.id,
                          },
                        }));
                  });
                }
                unloadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.unloadVectorData(),
                      e.actor &&
                        (yield e.actor.sendAsync({
                          type: "RMT",
                          data: {
                            uid: e.uid,
                            type: this.type,
                            source: this.id,
                          },
                        }));
                  });
                }
                hasTransition() {
                  return !1;
                }
              }
              class Nt extends s.E {
                constructor(e, i, l, u) {
                  super(),
                    (this.id = e),
                    (this.dispatcher = l),
                    this.setEventedParent(u),
                    (this.type = "raster"),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.roundZoom = !0),
                    (this.scheme = "xyz"),
                    (this.tileSize = 512),
                    (this._loaded = !1),
                    (this._options = s.e({ type: "raster" }, i)),
                    s.e(this, s.S(i, ["url", "scheme", "tileSize"]));
                }
                load() {
                  return s._(this, arguments, void 0, function* (e = !1) {
                    (this._loaded = !1),
                      this.fire(new s.l("dataloading", { dataType: "source" })),
                      (this._tileJSONRequest = new AbortController());
                    try {
                      const i = yield Gt(
                        this._options,
                        this.map._requestManager,
                        this._tileJSONRequest
                      );
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        i &&
                          (s.e(this, i),
                          i.bounds &&
                            (this.tileBounds = new Xt(
                              i.bounds,
                              this.minzoom,
                              this.maxzoom
                            )),
                          this.fire(
                            new s.l("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            })
                          ),
                          this.fire(
                            new s.l("data", {
                              dataType: "source",
                              sourceDataType: "content",
                              sourceDataChanged: e,
                            })
                          ));
                    } catch (i) {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        this.fire(new s.k(i));
                    }
                  });
                }
                loaded() {
                  return this._loaded;
                }
                onAdd(e) {
                  (this.map = e), this.load();
                }
                onRemove() {
                  this._tileJSONRequest &&
                    (this._tileJSONRequest.abort(),
                    (this._tileJSONRequest = null));
                }
                setSourceProperty(e) {
                  this._tileJSONRequest &&
                    (this._tileJSONRequest.abort(),
                    (this._tileJSONRequest = null)),
                    e(),
                    this.load(!0);
                }
                setTiles(e) {
                  return (
                    this.setSourceProperty(() => {
                      this._options.tiles = e;
                    }),
                    this
                  );
                }
                setUrl(e) {
                  return (
                    this.setSourceProperty(() => {
                      (this.url = e), (this._options.url = e);
                    }),
                    this
                  );
                }
                serialize() {
                  return s.e({}, this._options);
                }
                hasTile(e) {
                  return (
                    !this.tileBounds || this.tileBounds.contains(e.canonical)
                  );
                }
                loadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    const i = e.tileID.canonical.url(
                      this.tiles,
                      this.map.getPixelRatio(),
                      this.scheme
                    );
                    e.abortController = new AbortController();
                    try {
                      const l = yield Ue.getImage(
                        this.map._requestManager.transformRequest(i, "Tile"),
                        e.abortController,
                        this.map._refreshExpiredTiles
                      );
                      if ((delete e.abortController, e.aborted))
                        return void (e.state = "unloaded");
                      if (l && l.data) {
                        this.map._refreshExpiredTiles &&
                          (l.cacheControl || l.expires) &&
                          e.setExpiryData({
                            cacheControl: l.cacheControl,
                            expires: l.expires,
                          });
                        const u = this.map.painter.context,
                          d = u.gl,
                          g = l.data;
                        (e.texture = this.map.painter.getTileTexture(g.width)),
                          e.texture
                            ? e.texture.update(g, { useMipmap: !0 })
                            : ((e.texture = new s.T(u, g, d.RGBA, {
                                useMipmap: !0,
                              })),
                              e.texture.bind(
                                d.LINEAR,
                                d.CLAMP_TO_EDGE,
                                d.LINEAR_MIPMAP_NEAREST
                              )),
                          (e.state = "loaded");
                      }
                    } catch (l) {
                      if ((delete e.abortController, e.aborted))
                        e.state = "unloaded";
                      else if (l) throw ((e.state = "errored"), l);
                    }
                  });
                }
                abortTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.abortController &&
                      (e.abortController.abort(), delete e.abortController);
                  });
                }
                unloadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.texture && this.map.painter.saveTileTexture(e.texture);
                  });
                }
                hasTransition() {
                  return !1;
                }
              }
              class jt extends Nt {
                constructor(e, i, l, u) {
                  super(e, i, l, u),
                    (this.type = "raster-dem"),
                    (this.maxzoom = 22),
                    (this._options = s.e({ type: "raster-dem" }, i)),
                    (this.encoding = i.encoding || "mapbox"),
                    (this.redFactor = i.redFactor),
                    (this.greenFactor = i.greenFactor),
                    (this.blueFactor = i.blueFactor),
                    (this.baseShift = i.baseShift);
                }
                loadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    const i = e.tileID.canonical.url(
                        this.tiles,
                        this.map.getPixelRatio(),
                        this.scheme
                      ),
                      l = this.map._requestManager.transformRequest(i, "Tile");
                    (e.neighboringTiles = this._getNeighboringTiles(e.tileID)),
                      (e.abortController = new AbortController());
                    try {
                      const u = yield Ue.getImage(
                        l,
                        e.abortController,
                        this.map._refreshExpiredTiles
                      );
                      if ((delete e.abortController, e.aborted))
                        return void (e.state = "unloaded");
                      if (u && u.data) {
                        const d = u.data;
                        this.map._refreshExpiredTiles &&
                          (u.cacheControl || u.expires) &&
                          e.setExpiryData({
                            cacheControl: u.cacheControl,
                            expires: u.expires,
                          });
                        const g =
                            s.b(d) && s.Y() ? d : yield this.readImageNow(d),
                          w = {
                            type: this.type,
                            uid: e.uid,
                            source: this.id,
                            rawImageData: g,
                            encoding: this.encoding,
                            redFactor: this.redFactor,
                            greenFactor: this.greenFactor,
                            blueFactor: this.blueFactor,
                            baseShift: this.baseShift,
                          };
                        if (!e.actor || e.state === "expired") {
                          e.actor = this.dispatcher.getActor();
                          const S = yield e.actor.sendAsync({
                            type: "LDT",
                            data: w,
                          });
                          (e.dem = S),
                            (e.needsHillshadePrepare = !0),
                            (e.needsTerrainPrepare = !0),
                            (e.state = "loaded");
                        }
                      }
                    } catch (u) {
                      if ((delete e.abortController, e.aborted))
                        e.state = "unloaded";
                      else if (u) throw ((e.state = "errored"), u);
                    }
                  });
                }
                readImageNow(e) {
                  return s._(this, void 0, void 0, function* () {
                    if (typeof VideoFrame < "u" && s.Z()) {
                      const i = e.width + 2,
                        l = e.height + 2;
                      try {
                        return new s.R(
                          { width: i, height: l },
                          yield s.$(e, -1, -1, i, l)
                        );
                      } catch {}
                    }
                    return re.getImageData(e, 1);
                  });
                }
                _getNeighboringTiles(e) {
                  const i = e.canonical,
                    l = Math.pow(2, i.z),
                    u = (i.x - 1 + l) % l,
                    d = i.x === 0 ? e.wrap - 1 : e.wrap,
                    g = (i.x + 1 + l) % l,
                    w = i.x + 1 === l ? e.wrap + 1 : e.wrap,
                    S = {};
                  return (
                    (S[new s.a0(e.overscaledZ, d, i.z, u, i.y).key] = {
                      backfilled: !1,
                    }),
                    (S[new s.a0(e.overscaledZ, w, i.z, g, i.y).key] = {
                      backfilled: !1,
                    }),
                    i.y > 0 &&
                      ((S[new s.a0(e.overscaledZ, d, i.z, u, i.y - 1).key] = {
                        backfilled: !1,
                      }),
                      (S[
                        new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key
                      ] = { backfilled: !1 }),
                      (S[new s.a0(e.overscaledZ, w, i.z, g, i.y - 1).key] = {
                        backfilled: !1,
                      })),
                    i.y + 1 < l &&
                      ((S[new s.a0(e.overscaledZ, d, i.z, u, i.y + 1).key] = {
                        backfilled: !1,
                      }),
                      (S[
                        new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key
                      ] = { backfilled: !1 }),
                      (S[new s.a0(e.overscaledZ, w, i.z, g, i.y + 1).key] = {
                        backfilled: !1,
                      })),
                    S
                  );
                }
                unloadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.demTexture &&
                      this.map.painter.saveTileTexture(e.demTexture),
                      e.fbo && (e.fbo.destroy(), delete e.fbo),
                      e.dem && delete e.dem,
                      delete e.neighboringTiles,
                      (e.state = "unloaded"),
                      e.actor &&
                        (yield e.actor.sendAsync({
                          type: "RDT",
                          data: {
                            type: this.type,
                            uid: e.uid,
                            source: this.id,
                          },
                        }));
                  });
                }
              }
              function mr(h) {
                return h.type === "GeometryCollection"
                  ? h.geometries.map((e) => e.coordinates).flat(1 / 0)
                  : h.coordinates.flat(1 / 0);
              }
              function ir(h) {
                const e = new At();
                let i;
                switch (h.type) {
                  case "FeatureCollection":
                    i = h.features.map((l) => mr(l.geometry)).flat(1 / 0);
                    break;
                  case "Feature":
                    i = mr(h.geometry);
                    break;
                  default:
                    i = mr(h);
                }
                if (i.length == 0) return e;
                for (let l = 0; l < i.length - 1; l += 2)
                  e.extend([i[l], i[l + 1]]);
                return e;
              }
              class vr extends s.E {
                constructor(e, i, l, u) {
                  super(),
                    (this.id = e),
                    (this.type = "geojson"),
                    (this.minzoom = 0),
                    (this.maxzoom = 18),
                    (this.tileSize = 512),
                    (this.isTileClipped = !0),
                    (this.reparseOverscaled = !0),
                    (this._removed = !1),
                    (this._isUpdatingWorker = !1),
                    (this._pendingWorkerUpdate = { data: i.data }),
                    (this.actor = l.getActor()),
                    this.setEventedParent(u),
                    (this._data = i.data),
                    (this._options = s.e({}, i)),
                    (this._collectResourceTiming = i.collectResourceTiming),
                    i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom),
                    i.type && (this.type = i.type),
                    i.attribution && (this.attribution = i.attribution),
                    (this.promoteId = i.promoteId),
                    i.clusterMaxZoom !== void 0 &&
                      this.maxzoom <= i.clusterMaxZoom &&
                      s.w(
                        `The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`
                      ),
                    (this.workerOptions = s.e(
                      {
                        source: this.id,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                          buffer: this._pixelsToTileUnits(
                            i.buffer !== void 0 ? i.buffer : 128
                          ),
                          tolerance: this._pixelsToTileUnits(
                            i.tolerance !== void 0 ? i.tolerance : 0.375
                          ),
                          extent: s.a3,
                          maxZoom: this.maxzoom,
                          lineMetrics: i.lineMetrics || !1,
                          generateId: i.generateId || !1,
                        },
                        superclusterOptions: {
                          maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                          minPoints: Math.max(2, i.clusterMinPoints || 2),
                          extent: s.a3,
                          radius: this._pixelsToTileUnits(
                            i.clusterRadius || 50
                          ),
                          log: !1,
                          generateId: i.generateId || !1,
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter,
                      },
                      i.workerOptions
                    )),
                    typeof this.promoteId == "string" &&
                      (this.workerOptions.promoteId = this.promoteId);
                }
                _hasPendingWorkerUpdate() {
                  return (
                    this._pendingWorkerUpdate.data !== void 0 ||
                    this._pendingWorkerUpdate.diff !== void 0 ||
                    this._pendingWorkerUpdate.optionsChanged
                  );
                }
                _pixelsToTileUnits(e) {
                  return e * (s.a3 / this.tileSize);
                }
                _getClusterMaxZoom(e) {
                  const i = e ? Math.round(e) : this.maxzoom - 1;
                  return (
                    Number.isInteger(e) ||
                      e === void 0 ||
                      s.w(
                        `Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`
                      ),
                    i
                  );
                }
                load() {
                  return s._(this, void 0, void 0, function* () {
                    yield this._updateWorkerData();
                  });
                }
                onAdd(e) {
                  (this.map = e), this.load();
                }
                setData(e) {
                  return (
                    (this._data = e),
                    (this._pendingWorkerUpdate = { data: e }),
                    this._updateWorkerData(),
                    this
                  );
                }
                updateData(e) {
                  return (
                    (this._pendingWorkerUpdate.diff = s.a4(
                      this._pendingWorkerUpdate.diff,
                      e
                    )),
                    this._updateWorkerData(),
                    this
                  );
                }
                getData() {
                  return s._(this, void 0, void 0, function* () {
                    const e = s.e({ type: this.type }, this.workerOptions);
                    return this.actor.sendAsync({ type: "GD", data: e });
                  });
                }
                getBounds() {
                  return s._(this, void 0, void 0, function* () {
                    return ir(yield this.getData());
                  });
                }
                setClusterOptions(e) {
                  return (
                    (this.workerOptions.cluster = e.cluster),
                    e.clusterRadius !== void 0 &&
                      (this.workerOptions.superclusterOptions.radius =
                        this._pixelsToTileUnits(e.clusterRadius)),
                    e.clusterMaxZoom !== void 0 &&
                      (this.workerOptions.superclusterOptions.maxZoom =
                        this._getClusterMaxZoom(e.clusterMaxZoom)),
                    (this._pendingWorkerUpdate.optionsChanged = !0),
                    this._updateWorkerData(),
                    this
                  );
                }
                getClusterExpansionZoom(e) {
                  return this.actor.sendAsync({
                    type: "GCEZ",
                    data: { type: this.type, clusterId: e, source: this.id },
                  });
                }
                getClusterChildren(e) {
                  return this.actor.sendAsync({
                    type: "GCC",
                    data: { type: this.type, clusterId: e, source: this.id },
                  });
                }
                getClusterLeaves(e, i, l) {
                  return this.actor.sendAsync({
                    type: "GCL",
                    data: {
                      type: this.type,
                      source: this.id,
                      clusterId: e,
                      limit: i,
                      offset: l,
                    },
                  });
                }
                _updateWorkerData() {
                  return s._(this, void 0, void 0, function* () {
                    if (this._isUpdatingWorker) return;
                    if (!this._hasPendingWorkerUpdate())
                      return void s.w(
                        `No pending worker updates for GeoJSONSource ${this.id}.`
                      );
                    const { data: e, diff: i } = this._pendingWorkerUpdate,
                      l = s.e({ type: this.type }, this.workerOptions);
                    e
                      ? (typeof e == "string"
                          ? ((l.request =
                              this.map._requestManager.transformRequest(
                                re.resolveURL(e),
                                "Source"
                              )),
                            (l.request.collectResourceTiming =
                              this._collectResourceTiming))
                          : (l.data = JSON.stringify(e)),
                        (this._pendingWorkerUpdate.data = void 0))
                      : i &&
                        ((l.dataDiff = i),
                        (this._pendingWorkerUpdate.diff = void 0)),
                      (this._pendingWorkerUpdate.optionsChanged = void 0),
                      (this._isUpdatingWorker = !0),
                      this.fire(new s.l("dataloading", { dataType: "source" }));
                    try {
                      const u = yield this.actor.sendAsync({
                        type: "LD",
                        data: l,
                      });
                      if (
                        ((this._isUpdatingWorker = !1),
                        this._removed || u.abandoned)
                      )
                        return void this.fire(
                          new s.l("dataabort", { dataType: "source" })
                        );
                      this._data = u.data;
                      let d = null;
                      u.resourceTiming &&
                        u.resourceTiming[this.id] &&
                        (d = u.resourceTiming[this.id].slice(0));
                      const g = { dataType: "source" };
                      this._collectResourceTiming &&
                        d &&
                        d.length > 0 &&
                        s.e(g, { resourceTiming: d }),
                        this.fire(
                          new s.l(
                            "data",
                            Object.assign(Object.assign({}, g), {
                              sourceDataType: "metadata",
                            })
                          )
                        ),
                        this.fire(
                          new s.l(
                            "data",
                            Object.assign(Object.assign({}, g), {
                              sourceDataType: "content",
                              shouldReloadTileOptions:
                                this._getShouldReloadTileOptions(i),
                            })
                          )
                        );
                    } catch (u) {
                      if (((this._isUpdatingWorker = !1), this._removed))
                        return void this.fire(
                          new s.l("dataabort", { dataType: "source" })
                        );
                      this.fire(new s.k(u));
                    } finally {
                      this._hasPendingWorkerUpdate() &&
                        this._updateWorkerData();
                    }
                  });
                }
                _getShouldReloadTileOptions(e) {
                  if (!e || e.removeAll) return;
                  const {
                      add: i = [],
                      update: l = [],
                      remove: u = [],
                    } = e || {},
                    d = new Set([...l.map((g) => g.id), ...u]);
                  return {
                    nextBounds: [
                      ...l.map((g) => g.newGeometry),
                      ...i.map((g) => g.geometry),
                    ].map((g) => ir(g)),
                    prevIds: d,
                  };
                }
                shouldReloadTile(e, { nextBounds: i, prevIds: l }) {
                  const u = e.latestFeatureIndex.loadVTLayers();
                  for (
                    let S = 0;
                    S < e.latestFeatureIndex.featureIndexArray.length;
                    S++
                  ) {
                    const k = e.latestFeatureIndex.featureIndexArray.get(S),
                      z = u._geojsonTileLayer.feature(k.featureIndex);
                    if (l.has(z.id)) return !0;
                  }
                  const { buffer: d, extent: g } =
                      this.workerOptions.geojsonVtOptions,
                    w = (function ({ x: S, y: k, z }, V = 0) {
                      const F = s.a1((S - V) / Math.pow(2, z)),
                        $ = s.a2((k + 1 + V) / Math.pow(2, z)),
                        J = s.a1((S + 1 + V) / Math.pow(2, z)),
                        ae = s.a2((k - V) / Math.pow(2, z));
                      return new At([F, $], [J, ae]);
                    })(e.tileID.canonical, d / g);
                  for (const S of i) if (w.intersects(S)) return !0;
                  return !1;
                }
                loaded() {
                  return (
                    !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
                  );
                }
                loadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    const i = e.actor ? "RT" : "LT";
                    e.actor = this.actor;
                    const l = {
                      type: this.type,
                      uid: e.uid,
                      tileID: e.tileID,
                      zoom: e.tileID.overscaledZ,
                      maxZoom: this.maxzoom,
                      tileSize: this.tileSize,
                      source: this.id,
                      pixelRatio: this.map.getPixelRatio(),
                      showCollisionBoxes: this.map.showCollisionBoxes,
                      promoteId: this.promoteId,
                      subdivisionGranularity:
                        this.map.style.projection.subdivisionGranularity,
                    };
                    e.abortController = new AbortController();
                    const u = yield this.actor.sendAsync(
                      { type: i, data: l },
                      e.abortController
                    );
                    delete e.abortController,
                      e.unloadVectorData(),
                      e.aborted ||
                        e.loadVectorData(u, this.map.painter, i === "RT");
                  });
                }
                abortTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.abortController &&
                      (e.abortController.abort(), delete e.abortController),
                      (e.aborted = !0);
                  });
                }
                unloadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    e.unloadVectorData(),
                      yield this.actor.sendAsync({
                        type: "RMT",
                        data: { uid: e.uid, type: this.type, source: this.id },
                      });
                  });
                }
                onRemove() {
                  (this._removed = !0),
                    this.actor.sendAsync({
                      type: "RS",
                      data: { type: this.type, source: this.id },
                    });
                }
                serialize() {
                  return s.e({}, this._options, {
                    type: this.type,
                    data: this._data,
                  });
                }
                hasTransition() {
                  return !1;
                }
              }
              class ar extends s.E {
                constructor(e, i, l, u) {
                  super(),
                    (this.flippedWindingOrder = !1),
                    (this.id = e),
                    (this.dispatcher = l),
                    (this.coordinates = i.coordinates),
                    (this.type = "image"),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.tileSize = 512),
                    (this.tiles = {}),
                    (this._loaded = !1),
                    this.setEventedParent(u),
                    (this.options = i);
                }
                load(e) {
                  return s._(this, void 0, void 0, function* () {
                    (this._loaded = !1),
                      this.fire(new s.l("dataloading", { dataType: "source" })),
                      (this.url = this.options.url),
                      (this._request = new AbortController());
                    try {
                      const i = yield Ue.getImage(
                        this.map._requestManager.transformRequest(
                          this.url,
                          "Image"
                        ),
                        this._request
                      );
                      (this._request = null),
                        (this._loaded = !0),
                        i &&
                          i.data &&
                          ((this.image = i.data),
                          e && (this.coordinates = e),
                          this._finishLoading());
                    } catch (i) {
                      (this._request = null),
                        (this._loaded = !0),
                        this.fire(new s.k(i));
                    }
                  });
                }
                loaded() {
                  return this._loaded;
                }
                updateImage(e) {
                  return e.url
                    ? (this._request &&
                        (this._request.abort(), (this._request = null)),
                      (this.options.url = e.url),
                      this.load(e.coordinates).finally(() => {
                        this.texture = null;
                      }),
                      this)
                    : this;
                }
                _finishLoading() {
                  this.map &&
                    (this.setCoordinates(this.coordinates),
                    this.fire(
                      new s.l("data", {
                        dataType: "source",
                        sourceDataType: "metadata",
                      })
                    ));
                }
                onAdd(e) {
                  (this.map = e), this.load();
                }
                onRemove() {
                  this._request &&
                    (this._request.abort(), (this._request = null));
                }
                setCoordinates(e) {
                  this.coordinates = e;
                  const i = e.map(s.a5.fromLngLat);
                  var l;
                  return (
                    (this.tileID = (function (u) {
                      const d = s.a6.fromPoints(u),
                        g = d.width(),
                        w = d.height(),
                        S = Math.max(g, w),
                        k = Math.max(0, Math.floor(-Math.log(S) / Math.LN2)),
                        z = Math.pow(2, k);
                      return new s.a8(
                        k,
                        Math.floor(((d.minX + d.maxX) / 2) * z),
                        Math.floor(((d.minY + d.maxY) / 2) * z)
                      );
                    })(i)),
                    (this.terrainTileRanges =
                      this._getOverlappingTileRanges(i)),
                    (this.minzoom = this.maxzoom = this.tileID.z),
                    (this.tileCoords = i.map((u) =>
                      this.tileID.getTilePoint(u)._round()
                    )),
                    (this.flippedWindingOrder =
                      ((l = this.tileCoords)[1].x - l[0].x) *
                        (l[2].y - l[0].y) -
                        (l[1].y - l[0].y) * (l[2].x - l[0].x) <
                      0),
                    this.fire(
                      new s.l("data", {
                        dataType: "source",
                        sourceDataType: "content",
                      })
                    ),
                    this
                  );
                }
                prepare() {
                  if (Object.keys(this.tiles).length === 0 || !this.image)
                    return;
                  const e = this.map.painter.context,
                    i = e.gl;
                  this.texture ||
                    ((this.texture = new s.T(e, this.image, i.RGBA)),
                    this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                  let l = !1;
                  for (const u in this.tiles) {
                    const d = this.tiles[u];
                    d.state !== "loaded" &&
                      ((d.state = "loaded"),
                      (d.texture = this.texture),
                      (l = !0));
                  }
                  l &&
                    this.fire(
                      new s.l("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id,
                      })
                    );
                }
                loadTile(e) {
                  return s._(this, void 0, void 0, function* () {
                    this.tileID && this.tileID.equals(e.tileID.canonical)
                      ? ((this.tiles[String(e.tileID.wrap)] = e),
                        (e.buckets = {}))
                      : (e.state = "errored");
                  });
                }
                serialize() {
                  return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates,
                  };
                }
                hasTransition() {
                  return !1;
                }
                _getOverlappingTileRanges(e) {
                  const {
                      minX: i,
                      minY: l,
                      maxX: u,
                      maxY: d,
                    } = s.a6.fromPoints(e),
                    g = {};
                  for (let w = 0; w <= s.a7; w++) {
                    const S = Math.pow(2, w),
                      k = Math.floor(i * S),
                      z = Math.floor(l * S),
                      V = Math.floor(u * S),
                      F = Math.floor(d * S);
                    g[w] = {
                      minTileX: k,
                      minTileY: z,
                      maxTileX: V,
                      maxTileY: F,
                    };
                  }
                  return g;
                }
              }
              class pr extends ar {
                constructor(e, i, l, u) {
                  super(e, i, l, u),
                    (this.roundZoom = !0),
                    (this.type = "video"),
                    (this.options = i);
                }
                load() {
                  return s._(this, void 0, void 0, function* () {
                    this._loaded = !1;
                    const e = this.options;
                    this.urls = [];
                    for (const i of e.urls)
                      this.urls.push(
                        this.map._requestManager.transformRequest(i, "Source")
                          .url
                      );
                    try {
                      const i = yield s.a9(this.urls);
                      if (((this._loaded = !0), !i)) return;
                      (this.video = i),
                        (this.video.loop = !0),
                        this.video.addEventListener("playing", () => {
                          this.map.triggerRepaint();
                        }),
                        this.map && this.video.play(),
                        this._finishLoading();
                    } catch (i) {
                      this.fire(new s.k(i));
                    }
                  });
                }
                pause() {
                  this.video && this.video.pause();
                }
                play() {
                  this.video && this.video.play();
                }
                seek(e) {
                  if (this.video) {
                    const i = this.video.seekable;
                    e < i.start(0) || e > i.end(0)
                      ? this.fire(
                          new s.k(
                            new s.aa(
                              `sources.${this.id}`,
                              null,
                              `Playback for this video can be set only between the ${i.start(
                                0
                              )} and ${i.end(0)}-second mark.`
                            )
                          )
                        )
                      : (this.video.currentTime = e);
                  }
                }
                getVideo() {
                  return this.video;
                }
                onAdd(e) {
                  this.map ||
                    ((this.map = e),
                    this.load(),
                    this.video &&
                      (this.video.play(),
                      this.setCoordinates(this.coordinates)));
                }
                prepare() {
                  if (
                    Object.keys(this.tiles).length === 0 ||
                    this.video.readyState < 2
                  )
                    return;
                  const e = this.map.painter.context,
                    i = e.gl;
                  this.texture
                    ? this.video.paused ||
                      (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                      i.texSubImage2D(
                        i.TEXTURE_2D,
                        0,
                        0,
                        0,
                        i.RGBA,
                        i.UNSIGNED_BYTE,
                        this.video
                      ))
                    : ((this.texture = new s.T(e, this.video, i.RGBA)),
                      this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                  let l = !1;
                  for (const u in this.tiles) {
                    const d = this.tiles[u];
                    d.state !== "loaded" &&
                      ((d.state = "loaded"),
                      (d.texture = this.texture),
                      (l = !0));
                  }
                  l &&
                    this.fire(
                      new s.l("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id,
                      })
                    );
                }
                serialize() {
                  return {
                    type: "video",
                    urls: this.urls,
                    coordinates: this.coordinates,
                  };
                }
                hasTransition() {
                  return this.video && !this.video.paused;
                }
              }
              class tr extends ar {
                constructor(e, i, l, u) {
                  super(e, i, l, u),
                    i.coordinates
                      ? (Array.isArray(i.coordinates) &&
                          i.coordinates.length === 4 &&
                          !i.coordinates.some(
                            (d) =>
                              !Array.isArray(d) ||
                              d.length !== 2 ||
                              d.some((g) => typeof g != "number")
                          )) ||
                        this.fire(
                          new s.k(
                            new s.aa(
                              `sources.${e}`,
                              null,
                              '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                            )
                          )
                        )
                      : this.fire(
                          new s.k(
                            new s.aa(
                              `sources.${e}`,
                              null,
                              'missing required property "coordinates"'
                            )
                          )
                        ),
                    i.animate &&
                      typeof i.animate != "boolean" &&
                      this.fire(
                        new s.k(
                          new s.aa(
                            `sources.${e}`,
                            null,
                            'optional "animate" property must be a boolean value'
                          )
                        )
                      ),
                    i.canvas
                      ? typeof i.canvas == "string" ||
                        i.canvas instanceof HTMLCanvasElement ||
                        this.fire(
                          new s.k(
                            new s.aa(
                              `sources.${e}`,
                              null,
                              '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                            )
                          )
                        )
                      : this.fire(
                          new s.k(
                            new s.aa(
                              `sources.${e}`,
                              null,
                              'missing required property "canvas"'
                            )
                          )
                        ),
                    (this.options = i),
                    (this.animate = i.animate === void 0 || i.animate);
                }
                load() {
                  return s._(this, void 0, void 0, function* () {
                    (this._loaded = !0),
                      this.canvas ||
                        (this.canvas =
                          this.options.canvas instanceof HTMLCanvasElement
                            ? this.options.canvas
                            : document.getElementById(this.options.canvas)),
                      (this.width = this.canvas.width),
                      (this.height = this.canvas.height),
                      this._hasInvalidDimensions()
                        ? this.fire(
                            new s.k(
                              new Error(
                                "Canvas dimensions cannot be less than or equal to zero."
                              )
                            )
                          )
                        : ((this.play = function () {
                            (this._playing = !0), this.map.triggerRepaint();
                          }),
                          (this.pause = function () {
                            this._playing &&
                              (this.prepare(), (this._playing = !1));
                          }),
                          this._finishLoading());
                  });
                }
                getCanvas() {
                  return this.canvas;
                }
                onAdd(e) {
                  (this.map = e),
                    this.load(),
                    this.canvas && this.animate && this.play();
                }
                onRemove() {
                  this.pause();
                }
                prepare() {
                  let e = !1;
                  if (
                    (this.canvas.width !== this.width &&
                      ((this.width = this.canvas.width), (e = !0)),
                    this.canvas.height !== this.height &&
                      ((this.height = this.canvas.height), (e = !0)),
                    this._hasInvalidDimensions() ||
                      Object.keys(this.tiles).length === 0)
                  )
                    return;
                  const i = this.map.painter.context,
                    l = i.gl;
                  this.texture
                    ? (e || this._playing) &&
                      this.texture.update(this.canvas, { premultiply: !0 })
                    : (this.texture = new s.T(i, this.canvas, l.RGBA, {
                        premultiply: !0,
                      }));
                  let u = !1;
                  for (const d in this.tiles) {
                    const g = this.tiles[d];
                    g.state !== "loaded" &&
                      ((g.state = "loaded"),
                      (g.texture = this.texture),
                      (u = !0));
                  }
                  u &&
                    this.fire(
                      new s.l("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id,
                      })
                    );
                }
                serialize() {
                  return { type: "canvas", coordinates: this.coordinates };
                }
                hasTransition() {
                  return this._playing;
                }
                _hasInvalidDimensions() {
                  for (const e of [this.canvas.width, this.canvas.height])
                    if (isNaN(e) || e <= 0) return !0;
                  return !1;
                }
              }
              const Dt = {},
                Sr = (h) => {
                  switch (h) {
                    case "geojson":
                      return vr;
                    case "image":
                      return ar;
                    case "raster":
                      return Nt;
                    case "raster-dem":
                      return jt;
                    case "vector":
                      return Lt;
                    case "video":
                      return pr;
                    case "canvas":
                      return tr;
                  }
                  return Dt[h];
                },
                Te = "RTLPluginLoaded";
              class O extends s.E {
                constructor() {
                  super(...arguments),
                    (this.status = "unavailable"),
                    (this.url = null),
                    (this.dispatcher = It());
                }
                _syncState(e) {
                  return (
                    (this.status = e),
                    this.dispatcher
                      .broadcast("SRPS", {
                        pluginStatus: e,
                        pluginURL: this.url,
                      })
                      .catch((i) => {
                        throw ((this.status = "error"), i);
                      })
                  );
                }
                getRTLTextPluginStatus() {
                  return this.status;
                }
                clearRTLTextPlugin() {
                  (this.status = "unavailable"), (this.url = null);
                }
                setRTLTextPlugin(e) {
                  return s._(this, arguments, void 0, function* (i, l = !1) {
                    if (this.url)
                      throw new Error(
                        "setRTLTextPlugin cannot be called multiple times."
                      );
                    if (((this.url = re.resolveURL(i)), !this.url))
                      throw new Error(`requested url ${i} is invalid`);
                    if (this.status === "unavailable") {
                      if (!l) return this._requestImport();
                      (this.status = "deferred"), this._syncState(this.status);
                    } else if (this.status === "requested") return this._requestImport();
                  });
                }
                _requestImport() {
                  return s._(this, void 0, void 0, function* () {
                    yield this._syncState("loading"),
                      (this.status = "loaded"),
                      this.fire(new s.l(Te));
                  });
                }
                lazyLoad() {
                  this.status === "unavailable"
                    ? (this.status = "requested")
                    : this.status === "deferred" && this._requestImport();
                }
              }
              let E = null;
              function D() {
                return E || (E = new O()), E;
              }
              var j, H;
              (function (h) {
                (h[(h.Base = 0)] = "Base"), (h[(h.Parent = 1)] = "Parent");
              })(j || (j = {})),
                (function (h) {
                  (h[(h.Departing = 0)] = "Departing"),
                    (h[(h.Incoming = 1)] = "Incoming");
                })(H || (H = {}));
              class W {
                constructor(e, i) {
                  (this.timeAdded = 0),
                    (this.fadeEndTime = 0),
                    (this.fadeOpacity = 1),
                    (this.tileID = e),
                    (this.uid = s.ab()),
                    (this.uses = 0),
                    (this.tileSize = i),
                    (this.buckets = {}),
                    (this.expirationTime = null),
                    (this.queryPadding = 0),
                    (this.hasSymbolBuckets = !1),
                    (this.hasRTLText = !1),
                    (this.dependencies = {}),
                    (this.rtt = []),
                    (this.rttCoords = {}),
                    (this.expiredRequestCount = 0),
                    (this.state = "loading");
                }
                isRenderable(e) {
                  return (
                    this.hasData() &&
                    (!this.fadeEndTime || this.fadeOpacity > 0) &&
                    (e || !this.holdingForSymbolFade())
                  );
                }
                setCrossFadeLogic({
                  fadingRole: e,
                  fadingDirection: i,
                  fadingParentID: l,
                  fadeEndTime: u,
                }) {
                  this.resetFadeLogic(),
                    (this.fadingRole = e),
                    (this.fadingDirection = i),
                    (this.fadingParentID = l),
                    (this.fadeEndTime = u);
                }
                setSelfFadeLogic(e) {
                  this.resetFadeLogic(),
                    (this.selfFading = !0),
                    (this.fadeEndTime = e);
                }
                resetFadeLogic() {
                  (this.fadingRole = null),
                    (this.fadingDirection = null),
                    (this.fadingParentID = null),
                    (this.selfFading = !1),
                    (this.timeAdded = ne()),
                    (this.fadeEndTime = 0),
                    (this.fadeOpacity = 1);
                }
                wasRequested() {
                  return (
                    this.state === "errored" ||
                    this.state === "loaded" ||
                    this.state === "reloading"
                  );
                }
                clearTextures(e) {
                  this.demTexture && e.saveTileTexture(this.demTexture),
                    (this.demTexture = null);
                }
                loadVectorData(e, i, l) {
                  if (
                    (this.hasData() && this.unloadVectorData(),
                    (this.state = "loaded"),
                    e)
                  ) {
                    e.featureIndex &&
                      ((this.latestFeatureIndex = e.featureIndex),
                      e.rawTileData
                        ? ((this.latestRawTileData = e.rawTileData),
                          (this.latestFeatureIndex.rawTileData = e.rawTileData))
                        : this.latestRawTileData &&
                          (this.latestFeatureIndex.rawTileData =
                            this.latestRawTileData)),
                      (this.collisionBoxArray = e.collisionBoxArray),
                      (this.buckets = (function (u, d) {
                        const g = {};
                        if (!d) return g;
                        for (const w of u) {
                          const S = w.layerIds
                            .map((k) => d.getLayer(k))
                            .filter(Boolean);
                          if (S.length !== 0) {
                            (w.layers = S),
                              w.stateDependentLayerIds &&
                                (w.stateDependentLayers =
                                  w.stateDependentLayerIds.map(
                                    (k) => S.filter((z) => z.id === k)[0]
                                  ));
                            for (const k of S) g[k.id] = w;
                          }
                        }
                        return g;
                      })(e.buckets, i == null ? void 0 : i.style)),
                      (this.hasSymbolBuckets = !1);
                    for (const u in this.buckets) {
                      const d = this.buckets[u];
                      if (d instanceof s.ad) {
                        if (((this.hasSymbolBuckets = !0), !l)) break;
                        d.justReloaded = !0;
                      }
                    }
                    if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                      for (const u in this.buckets) {
                        const d = this.buckets[u];
                        if (d instanceof s.ad && d.hasRTLText) {
                          (this.hasRTLText = !0), D().lazyLoad();
                          break;
                        }
                      }
                    this.queryPadding = 0;
                    for (const u in this.buckets) {
                      const d = this.buckets[u];
                      this.queryPadding = Math.max(
                        this.queryPadding,
                        i.style.getLayer(u).queryRadius(d)
                      );
                    }
                    e.imageAtlas && (this.imageAtlas = e.imageAtlas),
                      e.glyphAtlasImage &&
                        (this.glyphAtlasImage = e.glyphAtlasImage),
                      (this.dashPositions = e.dashPositions);
                  } else this.collisionBoxArray = new s.ac();
                }
                unloadVectorData() {
                  for (const e in this.buckets) this.buckets[e].destroy();
                  (this.buckets = {}),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.imageAtlas && (this.imageAtlas = null),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.dashPositions && (this.dashPositions = null),
                    (this.latestFeatureIndex = null),
                    (this.state = "unloaded");
                }
                getBucket(e) {
                  return this.buckets[e.id];
                }
                upload(e) {
                  for (const l in this.buckets) {
                    const u = this.buckets[l];
                    u.uploadPending() && u.upload(e);
                  }
                  const i = e.gl;
                  this.imageAtlas &&
                    !this.imageAtlas.uploaded &&
                    ((this.imageAtlasTexture = new s.T(
                      e,
                      this.imageAtlas.image,
                      i.RGBA
                    )),
                    (this.imageAtlas.uploaded = !0)),
                    this.glyphAtlasImage &&
                      ((this.glyphAtlasTexture = new s.T(
                        e,
                        this.glyphAtlasImage,
                        i.ALPHA
                      )),
                      (this.glyphAtlasImage = null));
                }
                prepare(e) {
                  this.imageAtlas &&
                    this.imageAtlas.patchUpdatedImages(
                      e,
                      this.imageAtlasTexture
                    );
                }
                queryRenderedFeatures(e, i, l, u, d, g, w, S, k, z, V) {
                  return this.latestFeatureIndex &&
                    this.latestFeatureIndex.rawTileData
                    ? this.latestFeatureIndex.query(
                        {
                          queryGeometry: u,
                          cameraQueryGeometry: d,
                          scale: g,
                          tileSize: this.tileSize,
                          pixelPosMatrix: z,
                          transform: S,
                          params: w,
                          queryPadding: this.queryPadding * k,
                          getElevation: V,
                        },
                        e,
                        i,
                        l
                      )
                    : {};
                }
                querySourceFeatures(e, i) {
                  const l = this.latestFeatureIndex;
                  if (!l || !l.rawTileData) return;
                  const u = l.loadVTLayers(),
                    d = i && i.sourceLayer ? i.sourceLayer : "",
                    g = u._geojsonTileLayer || u[d];
                  if (!g) return;
                  const w = s.ae(
                      i == null ? void 0 : i.filter,
                      i == null ? void 0 : i.globalState
                    ),
                    { z: S, x: k, y: z } = this.tileID.canonical,
                    V = { z: S, x: k, y: z };
                  for (let F = 0; F < g.length; F++) {
                    const $ = g.feature(F);
                    if (w.needGeometry) {
                      const oe = s.af($, !0);
                      if (
                        !w.filter(
                          new s.G(this.tileID.overscaledZ),
                          oe,
                          this.tileID.canonical
                        )
                      )
                        continue;
                    } else if (!w.filter(new s.G(this.tileID.overscaledZ), $))
                      continue;
                    const J = l.getId($, d),
                      ae = new s.ag($, S, k, z, J);
                    (ae.tile = V), e.push(ae);
                  }
                }
                hasData() {
                  return (
                    this.state === "loaded" ||
                    this.state === "reloading" ||
                    this.state === "expired"
                  );
                }
                patternsLoaded() {
                  return (
                    this.imageAtlas &&
                    !!Object.keys(this.imageAtlas.patternPositions).length
                  );
                }
                setExpiryData(e) {
                  const i = this.expirationTime;
                  if (e.cacheControl) {
                    const l = s.ah(e.cacheControl);
                    l["max-age"] &&
                      (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
                  } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
                  if (this.expirationTime) {
                    const l = Date.now();
                    let u = !1;
                    if (this.expirationTime > l) u = !1;
                    else if (i)
                      if (this.expirationTime < i) u = !0;
                      else {
                        const d = this.expirationTime - i;
                        d
                          ? (this.expirationTime = l + Math.max(d, 3e4))
                          : (u = !0);
                      }
                    else u = !0;
                    u
                      ? (this.expiredRequestCount++, (this.state = "expired"))
                      : (this.expiredRequestCount = 0);
                  }
                }
                getExpiryTimeout() {
                  if (this.expirationTime)
                    return this.expiredRequestCount
                      ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                      : Math.min(
                          this.expirationTime - new Date().getTime(),
                          Math.pow(2, 31) - 1
                        );
                }
                setFeatureState(e, i) {
                  if (
                    !this.latestFeatureIndex ||
                    !this.latestFeatureIndex.rawTileData ||
                    Object.keys(e).length === 0
                  )
                    return;
                  const l = this.latestFeatureIndex.loadVTLayers();
                  for (const u in this.buckets) {
                    if (!i.style.hasLayer(u)) continue;
                    const d = this.buckets[u],
                      g = d.layers[0].sourceLayer || "_geojsonTileLayer",
                      w = l[g],
                      S = e[g];
                    if (!w || !S || Object.keys(S).length === 0) continue;
                    d.update(
                      S,
                      w,
                      (this.imageAtlas && this.imageAtlas.patternPositions) ||
                        {},
                      this.dashPositions || {}
                    );
                    const k = i && i.style && i.style.getLayer(u);
                    k &&
                      (this.queryPadding = Math.max(
                        this.queryPadding,
                        k.queryRadius(d)
                      ));
                  }
                }
                holdingForSymbolFade() {
                  return this.symbolFadeHoldUntil !== void 0;
                }
                symbolFadeFinished() {
                  return (
                    !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ne()
                  );
                }
                clearSymbolFadeHold() {
                  this.symbolFadeHoldUntil = void 0;
                }
                setSymbolHoldDuration(e) {
                  this.symbolFadeHoldUntil = ne() + e;
                }
                setDependencies(e, i) {
                  const l = {};
                  for (const u of i) l[u] = !0;
                  this.dependencies[e] = l;
                }
                hasDependency(e, i) {
                  for (const l of e) {
                    const u = this.dependencies[l];
                    if (u) {
                      for (const d of i) if (u[d]) return !0;
                    }
                  }
                  return !1;
                }
              }
              class ce {
                constructor(e, i) {
                  (this.max = e), (this.onRemove = i), this.reset();
                }
                reset() {
                  for (const e in this.data)
                    for (const i of this.data[e])
                      i.timeout && clearTimeout(i.timeout),
                        this.onRemove(i.value);
                  return (this.data = {}), (this.order = []), this;
                }
                add(e, i, l) {
                  const u = e.wrapped().key;
                  this.data[u] === void 0 && (this.data[u] = []);
                  const d = { value: i, timeout: void 0 };
                  if (
                    (l !== void 0 &&
                      (d.timeout = setTimeout(() => {
                        this.remove(e, d);
                      }, l)),
                    this.data[u].push(d),
                    this.order.push(u),
                    this.order.length > this.max)
                  ) {
                    const g = this._getAndRemoveByKey(this.order[0]);
                    g && this.onRemove(g);
                  }
                  return this;
                }
                has(e) {
                  return e.wrapped().key in this.data;
                }
                getAndRemove(e) {
                  return this.has(e)
                    ? this._getAndRemoveByKey(e.wrapped().key)
                    : null;
                }
                _getAndRemoveByKey(e) {
                  const i = this.data[e].shift();
                  return (
                    i.timeout && clearTimeout(i.timeout),
                    this.data[e].length === 0 && delete this.data[e],
                    this.order.splice(this.order.indexOf(e), 1),
                    i.value
                  );
                }
                getByKey(e) {
                  const i = this.data[e];
                  return i ? i[0].value : null;
                }
                get(e) {
                  return this.has(e)
                    ? this.data[e.wrapped().key][0].value
                    : null;
                }
                remove(e, i) {
                  if (!this.has(e)) return this;
                  const l = e.wrapped().key,
                    u = i === void 0 ? 0 : this.data[l].indexOf(i),
                    d = this.data[l][u];
                  return (
                    this.data[l].splice(u, 1),
                    d.timeout && clearTimeout(d.timeout),
                    this.data[l].length === 0 && delete this.data[l],
                    this.onRemove(d.value),
                    this.order.splice(this.order.indexOf(l), 1),
                    this
                  );
                }
                setMaxSize(e) {
                  for (this.max = e; this.order.length > this.max; ) {
                    const i = this._getAndRemoveByKey(this.order[0]);
                    i && this.onRemove(i);
                  }
                  return this;
                }
                filter(e) {
                  const i = [];
                  for (const l in this.data)
                    for (const u of this.data[l]) e(u.value) || i.push(u);
                  for (const l of i) this.remove(l.value.tileID, l);
                }
              }
              class ge {
                constructor() {
                  (this.state = {}),
                    (this.stateChanges = {}),
                    (this.deletedStates = {});
                }
                updateState(e, i, l) {
                  const u = String(i);
                  if (
                    ((this.stateChanges[e] = this.stateChanges[e] || {}),
                    (this.stateChanges[e][u] = this.stateChanges[e][u] || {}),
                    s.e(this.stateChanges[e][u], l),
                    this.deletedStates[e] === null)
                  ) {
                    this.deletedStates[e] = {};
                    for (const d in this.state[e])
                      d !== u && (this.deletedStates[e][d] = null);
                  } else if (
                    this.deletedStates[e] &&
                    this.deletedStates[e][u] === null
                  ) {
                    this.deletedStates[e][u] = {};
                    for (const d in this.state[e][u])
                      l[d] || (this.deletedStates[e][u][d] = null);
                  } else
                    for (const d in l)
                      this.deletedStates[e] &&
                        this.deletedStates[e][u] &&
                        this.deletedStates[e][u][d] === null &&
                        delete this.deletedStates[e][u][d];
                }
                removeFeatureState(e, i, l) {
                  if (this.deletedStates[e] === null) return;
                  const u = String(i);
                  if (
                    ((this.deletedStates[e] = this.deletedStates[e] || {}),
                    l && i !== void 0)
                  )
                    this.deletedStates[e][u] !== null &&
                      ((this.deletedStates[e][u] =
                        this.deletedStates[e][u] || {}),
                      (this.deletedStates[e][u][l] = null));
                  else if (i !== void 0)
                    if (this.stateChanges[e] && this.stateChanges[e][u])
                      for (l in ((this.deletedStates[e][u] = {}),
                      this.stateChanges[e][u]))
                        this.deletedStates[e][u][l] = null;
                    else this.deletedStates[e][u] = null;
                  else this.deletedStates[e] = null;
                }
                getState(e, i) {
                  const l = String(i),
                    u = s.e(
                      {},
                      (this.state[e] || {})[l],
                      (this.stateChanges[e] || {})[l]
                    );
                  if (this.deletedStates[e] === null) return {};
                  if (this.deletedStates[e]) {
                    const d = this.deletedStates[e][i];
                    if (d === null) return {};
                    for (const g in d) delete u[g];
                  }
                  return u;
                }
                initializeTileState(e, i) {
                  e.setFeatureState(this.state, i);
                }
                coalesceChanges(e, i) {
                  const l = {};
                  for (const u in this.stateChanges) {
                    this.state[u] = this.state[u] || {};
                    const d = {};
                    for (const g in this.stateChanges[u])
                      this.state[u][g] || (this.state[u][g] = {}),
                        s.e(this.state[u][g], this.stateChanges[u][g]),
                        (d[g] = this.state[u][g]);
                    l[u] = d;
                  }
                  for (const u in this.deletedStates) {
                    this.state[u] = this.state[u] || {};
                    const d = {};
                    if (this.deletedStates[u] === null)
                      for (const g in this.state[u])
                        (d[g] = {}), (this.state[u][g] = {});
                    else
                      for (const g in this.deletedStates[u]) {
                        if (this.deletedStates[u][g] === null)
                          this.state[u][g] = {};
                        else
                          for (const w of Object.keys(this.deletedStates[u][g]))
                            delete this.state[u][g][w];
                        d[g] = this.state[u][g];
                      }
                    (l[u] = l[u] || {}), s.e(l[u], d);
                  }
                  if (
                    ((this.stateChanges = {}),
                    (this.deletedStates = {}),
                    Object.keys(l).length !== 0)
                  )
                    for (const u in e) e[u].setFeatureState(l, i);
                }
              }
              const de = 89.25;
              function Se(h, e) {
                const i = s.ai(e.lat, -s.aj, s.aj);
                return new s.P(s.X(e.lng) * h, s.W(i) * h);
              }
              function We(h, e) {
                return new s.a5(e.x / h, e.y / h).toLngLat();
              }
              function Ze(h) {
                return (
                  h.cameraToCenterDistance *
                  Math.min(
                    0.85 * Math.tan(s.ak(90 - h.pitch)),
                    Math.tan(s.ak(de - h.pitch))
                  )
                );
              }
              function Ct(h, e) {
                const i = h.canonical,
                  l = e / s.al(i.z),
                  u = i.x + Math.pow(2, i.z) * h.wrap,
                  d = s.am(new Float64Array(16));
                return (
                  s.N(d, d, [u * l, i.y * l, 0]),
                  s.O(d, d, [l / s.a3, l / s.a3, 1]),
                  d
                );
              }
              function _e(h, e, i, l, u) {
                const d = s.a5.fromLngLat(h, e),
                  g = u * s.an(1, h.lat),
                  w = g * Math.cos(s.ak(i)),
                  S = Math.sqrt(g * g - w * w),
                  k = S * Math.sin(s.ak(-l)),
                  z = S * Math.cos(s.ak(-l));
                return new s.a5(d.x + k, d.y + z, d.z + w);
              }
              function Vt(h, e, i) {
                const l = e.intersectsFrustum(h);
                if (!i || l === 0) return l;
                const u = e.intersectsPlane(i);
                return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1;
              }
              function cr(h, e, i) {
                let l = 0;
                const u = (i - e) / 10;
                for (let d = 0; d < 10; d++)
                  l +=
                    u * Math.pow(Math.cos(e + ((d + 0.5) / 10) * (i - e)), h);
                return l;
              }
              function Ot(h, e) {
                return function (i, l, u, d, g) {
                  const w =
                      2 *
                      ((h - 1) /
                        s.ao(Math.cos(s.ak(de - g)) / Math.cos(s.ak(de))) -
                        1),
                    S = Math.acos(u / d),
                    k = 2 * cr(w - 1, 0, s.ak(g / 2)),
                    z = Math.min(s.ak(de), S + s.ak(g / 2)),
                    V = cr(w - 1, Math.min(z, S - s.ak(g / 2)), z),
                    F = Math.atan(l / u),
                    $ = Math.hypot(l, u);
                  let J = i;
                  return (
                    (J += s.ao(d / $ / Math.max(0.5, Math.cos(s.ak(g / 2))))),
                    (J += (w * s.ao(Math.cos(F))) / 2),
                    (J -= s.ao(Math.max(1, V / k / e)) / 2),
                    J
                  );
                };
              }
              const ur = Ot(9.314, 3);
              function Nr(h, e) {
                const i = (e.roundZoom ? Math.round : Math.floor)(
                  h.zoom + s.ao(h.tileSize / e.tileSize)
                );
                return Math.max(0, i);
              }
              function Ur(h, e) {
                const i = h.getCameraFrustum(),
                  l = h.getClippingPlane(),
                  u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
                  d = s.a5.fromLngLat(h.center, h.elevation);
                u.z =
                  d.z +
                  (Math.cos(h.pitchInRadians) * h.cameraToCenterDistance) /
                    h.worldSize;
                const g = h.getCoveringTilesDetailsProvider(),
                  w = g.allowVariableZoom(h, e),
                  S = Nr(h, e),
                  k = e.minzoom || 0,
                  z = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
                  V = Math.min(Math.max(0, S), z),
                  F = Math.pow(2, V),
                  $ = [F * u.x, F * u.y, 0],
                  J = [F * d.x, F * d.y, 0],
                  ae = Math.hypot(d.x - u.x, d.y - u.y),
                  oe = Math.abs(d.z - u.z),
                  se = Math.hypot(ae, oe),
                  fe = (we) => ({
                    zoom: 0,
                    x: 0,
                    y: 0,
                    wrap: we,
                    fullyVisible: !1,
                  }),
                  be = [],
                  pe = [];
                if (h.renderWorldCopies && g.allowWorldCopies())
                  for (let we = 1; we <= 3; we++)
                    be.push(fe(-we)), be.push(fe(we));
                for (be.push(fe(0)); be.length > 0; ) {
                  const we = be.pop(),
                    Pe = we.x,
                    ve = we.y;
                  let Re = we.fullyVisible;
                  const it = { x: Pe, y: ve, z: we.zoom },
                    Qe = g.getTileBoundingVolume(it, we.wrap, h.elevation, e);
                  if (!Re) {
                    const Ht = Vt(i, Qe, l);
                    if (Ht === 0) continue;
                    Re = Ht === 2;
                  }
                  const tt = g.distanceToTile2d(u.x, u.y, it, Qe);
                  let ot = S;
                  w &&
                    (ot = (e.calculateTileZoom || ur)(
                      h.zoom + s.ao(h.tileSize / e.tileSize),
                      tt,
                      oe,
                      se,
                      h.fov
                    )),
                    (ot = (e.roundZoom ? Math.round : Math.floor)(ot)),
                    (ot = Math.max(0, ot));
                  const Zt = Math.min(ot, z);
                  if (((we.wrap = g.getWrap(d, it, we.wrap)), we.zoom >= Zt)) {
                    if (we.zoom < k) continue;
                    const Ht = V - we.zoom,
                      Pt = $[0] - 0.5 - (Pe << Ht),
                      yr = $[1] - 0.5 - (ve << Ht),
                      tn = e.reparseOverscaled
                        ? Math.max(we.zoom, ot)
                        : we.zoom;
                    pe.push({
                      tileID: new s.a0(
                        we.zoom === z ? tn : we.zoom,
                        we.wrap,
                        we.zoom,
                        Pe,
                        ve
                      ),
                      distanceSq: s.ap([J[0] - 0.5 - Pe, J[1] - 0.5 - ve]),
                      tileDistanceToCamera: Math.sqrt(Pt * Pt + yr * yr),
                    });
                  } else
                    for (let Ht = 0; Ht < 4; Ht++)
                      be.push({
                        zoom: we.zoom + 1,
                        x: (Pe << 1) + (Ht % 2),
                        y: (ve << 1) + (Ht >> 1),
                        wrap: we.wrap,
                        fullyVisible: Re,
                      });
                }
                return pe
                  .sort((we, Pe) => we.distanceSq - Pe.distanceSq)
                  .map((we) => we.tileID);
              }
              const Wr = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
              class un extends s.E {
                constructor(e, i, l) {
                  super(),
                    (this.id = e),
                    (this.dispatcher = l),
                    this.on("data", (u) => this._dataHandler(u)),
                    this.on("dataloading", () => {
                      this._sourceErrored = !1;
                    }),
                    this.on("error", () => {
                      this._sourceErrored = this._source.loaded();
                    }),
                    (this._source = ((u, d, g, w) => {
                      const S = new (Sr(d.type))(u, d, g, w);
                      if (S.id !== u)
                        throw new Error(
                          `Expected Source id to be ${u} instead of ${S.id}`
                        );
                      return S;
                    })(e, i, l, this)),
                    (this._tiles = {}),
                    (this._cache = new ce(0, (u) => this._unloadTile(u))),
                    (this._timers = {}),
                    (this._maxTileCacheSize = null),
                    (this._maxTileCacheZoomLevels = null),
                    (this._rasterFadeDuration = 0),
                    (this._maxFadingAncestorLevels = 5),
                    (this._state = new ge()),
                    (this._didEmitContent = !1),
                    (this._updated = !1);
                }
                onAdd(e) {
                  (this.map = e),
                    (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
                    (this._maxTileCacheZoomLevels = e
                      ? e._maxTileCacheZoomLevels
                      : null),
                    this._source && this._source.onAdd && this._source.onAdd(e);
                }
                onRemove(e) {
                  this.clearTiles(),
                    this._source &&
                      this._source.onRemove &&
                      this._source.onRemove(e);
                }
                loaded() {
                  if (this._sourceErrored) return !0;
                  if (!this._sourceLoaded || !this._source.loaded()) return !1;
                  if (
                    !(
                      (this.used === void 0 &&
                        this.usedForTerrain === void 0) ||
                      this.used ||
                      this.usedForTerrain
                    )
                  )
                    return !0;
                  if (!this._updated) return !1;
                  for (const e in this._tiles) {
                    const i = this._tiles[e];
                    if (i.state !== "loaded" && i.state !== "errored")
                      return !1;
                  }
                  return !0;
                }
                getSource() {
                  return this._source;
                }
                getState() {
                  return this._state;
                }
                pause() {
                  this._paused = !0;
                }
                resume() {
                  if (!this._paused) return;
                  const e = this._shouldReloadOnResume;
                  (this._paused = !1),
                    (this._shouldReloadOnResume = !1),
                    e && this.reload(),
                    this.transform && this.update(this.transform, this.terrain);
                }
                _loadTile(e, i, l) {
                  return s._(this, void 0, void 0, function* () {
                    try {
                      yield this._source.loadTile(e), this._tileLoaded(e, i, l);
                    } catch (u) {
                      (e.state = "errored"),
                        u.status !== 404
                          ? this._source.fire(new s.k(u, { tile: e }))
                          : this.update(this.transform, this.terrain);
                    }
                  });
                }
                _unloadTile(e) {
                  this._source.unloadTile && this._source.unloadTile(e);
                }
                _abortTile(e) {
                  this._source.abortTile && this._source.abortTile(e),
                    this._source.fire(
                      new s.l("dataabort", {
                        tile: e,
                        coord: e.tileID,
                        dataType: "source",
                      })
                    );
                }
                serialize() {
                  return this._source.serialize();
                }
                prepare(e) {
                  this._source.prepare && this._source.prepare(),
                    this._state.coalesceChanges(
                      this._tiles,
                      this.map ? this.map.painter : null
                    );
                  for (const i in this._tiles) {
                    const l = this._tiles[i];
                    l.upload(e), l.prepare(this.map.style.imageManager);
                  }
                }
                getIds() {
                  return Object.values(this._tiles)
                    .map((e) => e.tileID)
                    .sort(an)
                    .map((e) => e.key);
                }
                getRenderableIds(e) {
                  const i = [];
                  for (const l in this._tiles)
                    this._isIdRenderable(l, e) && i.push(this._tiles[l]);
                  return e
                    ? i
                        .sort((l, u) => {
                          const d = l.tileID,
                            g = u.tileID,
                            w = new s.P(d.canonical.x, d.canonical.y)._rotate(
                              -this.transform.bearingInRadians
                            ),
                            S = new s.P(g.canonical.x, g.canonical.y)._rotate(
                              -this.transform.bearingInRadians
                            );
                          return (
                            d.overscaledZ - g.overscaledZ ||
                            S.y - w.y ||
                            S.x - w.x
                          );
                        })
                        .map((l) => l.tileID.key)
                    : i
                        .map((l) => l.tileID)
                        .sort(an)
                        .map((l) => l.key);
                }
                hasRenderableParent(e) {
                  const i = e.overscaledZ - 1;
                  if (i >= this._source.minzoom) {
                    const l = this.getLoadedTile(e.scaledTo(i));
                    if (l) return this._isIdRenderable(l.tileID.key);
                  }
                  return !1;
                }
                _isIdRenderable(e, i = !1) {
                  var l;
                  return (l = this._tiles[e]) === null || l === void 0
                    ? void 0
                    : l.isRenderable(i);
                }
                reload(e, i = void 0) {
                  if (this._paused) this._shouldReloadOnResume = !0;
                  else {
                    this._cache.reset();
                    for (const l in this._tiles)
                      (i &&
                        this._source.shouldReloadTile &&
                        !this._source.shouldReloadTile(this._tiles[l], i)) ||
                        (e
                          ? this._reloadTile(l, "expired")
                          : this._tiles[l].state !== "errored" &&
                            this._reloadTile(l, "reloading"));
                  }
                }
                _reloadTile(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    const l = this._tiles[e];
                    l &&
                      (l.state !== "loading" && (l.state = i),
                      yield this._loadTile(l, e, i));
                  });
                }
                _tileLoaded(e, i, l) {
                  (e.timeAdded = ne()),
                    e.selfFading &&
                      (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration),
                    l === "expired" && (e.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(i, e),
                    this.getSource().type === "raster-dem" &&
                      e.dem &&
                      this._backfillDEM(e),
                    this._state.initializeTileState(
                      e,
                      this.map ? this.map.painter : null
                    ),
                    e.aborted ||
                      this._source.fire(
                        new s.l("data", {
                          dataType: "source",
                          tile: e,
                          coord: e.tileID,
                        })
                      );
                }
                _backfillDEM(e) {
                  const i = this.getRenderableIds();
                  for (let u = 0; u < i.length; u++) {
                    const d = i[u];
                    if (e.neighboringTiles && e.neighboringTiles[d]) {
                      const g = this.getTileByID(d);
                      l(e, g), l(g, e);
                    }
                  }
                  function l(u, d) {
                    (u.needsHillshadePrepare = !0),
                      (u.needsTerrainPrepare = !0);
                    let g = d.tileID.canonical.x - u.tileID.canonical.x;
                    const w = d.tileID.canonical.y - u.tileID.canonical.y,
                      S = Math.pow(2, u.tileID.canonical.z),
                      k = d.tileID.key;
                    (g === 0 && w === 0) ||
                      Math.abs(w) > 1 ||
                      (Math.abs(g) > 1 &&
                        (Math.abs(g + S) === 1
                          ? (g += S)
                          : Math.abs(g - S) === 1 && (g -= S)),
                      d.dem &&
                        u.dem &&
                        (u.dem.backfillBorder(d.dem, g, w),
                        u.neighboringTiles &&
                          u.neighboringTiles[k] &&
                          (u.neighboringTiles[k].backfilled = !0)));
                  }
                }
                getTile(e) {
                  return this.getTileByID(e.key);
                }
                getTileByID(e) {
                  return this._tiles[e];
                }
                _retainLoadedChildren(e, i) {
                  const l = Object.values(e),
                    u = this._getLoadedDescendents(l),
                    d = {};
                  for (const g of l) {
                    const w = u[g.key];
                    if (!(w != null && w.length)) {
                      d[g.key] = g;
                      continue;
                    }
                    const S = g.overscaledZ + un.maxUnderzooming,
                      k = w.filter((F) => F.tileID.overscaledZ <= S);
                    if (!k.length) {
                      d[g.key] = g;
                      continue;
                    }
                    const z = Math.min(...k.map((F) => F.tileID.overscaledZ)),
                      V = k
                        .filter((F) => F.tileID.overscaledZ === z)
                        .map((F) => F.tileID);
                    for (const F of V) i[F.key] = F;
                    this._areDescendentsComplete(V, z, g.overscaledZ) ||
                      (d[g.key] = g);
                  }
                  return d;
                }
                _getLoadedDescendents(e) {
                  var i;
                  const l = {};
                  for (const u in this._tiles) {
                    const d = this._tiles[u];
                    if (d.hasData())
                      for (const g of e)
                        d.tileID.isChildOf(g) &&
                          (l[(i = g.key)] || (l[i] = [])).push(d);
                  }
                  return l;
                }
                _areDescendentsComplete(e, i, l) {
                  return e.length === 1 && e[0].isOverscaled()
                    ? e[0].overscaledZ === i
                    : Math.pow(4, i - l) === e.length;
                }
                getLoadedTile(e) {
                  const i = this._tiles[e.key];
                  return i != null && i.hasData() ? i : null;
                }
                updateCacheSize(e) {
                  const i = Math.ceil(e.width / this._source.tileSize) + 1,
                    l = Math.ceil(e.height / this._source.tileSize) + 1,
                    u = Math.floor(
                      i *
                        l *
                        (this._maxTileCacheZoomLevels === null
                          ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS
                          : this._maxTileCacheZoomLevels)
                    ),
                    d =
                      typeof this._maxTileCacheSize == "number"
                        ? Math.min(this._maxTileCacheSize, u)
                        : u;
                  this._cache.setMaxSize(d);
                }
                handleWrapJump(e) {
                  const i = Math.round(
                    (e - (this._prevLng === void 0 ? e : this._prevLng)) / 360
                  );
                  if (((this._prevLng = e), i)) {
                    const l = {};
                    for (const u in this._tiles) {
                      const d = this._tiles[u];
                      (d.tileID = d.tileID.unwrapTo(d.tileID.wrap + i)),
                        (l[d.tileID.key] = d);
                    }
                    (this._tiles = l), this._resetTileReloadTimers();
                  }
                }
                update(e, i) {
                  if (!this._sourceLoaded || this._paused) return;
                  let l;
                  (this.transform = e),
                    (this.terrain = i),
                    this.updateCacheSize(e),
                    this.handleWrapJump(this.transform.center.lng),
                    this.used || this.usedForTerrain
                      ? this._source.tileID
                        ? (l = e
                            .getVisibleUnwrappedCoordinates(this._source.tileID)
                            .map(
                              (S) =>
                                new s.a0(
                                  S.canonical.z,
                                  S.wrap,
                                  S.canonical.z,
                                  S.canonical.x,
                                  S.canonical.y
                                )
                            ))
                        : ((l = Ur(e, {
                            tileSize: this.usedForTerrain
                              ? this.tileSize
                              : this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom:
                              !this.usedForTerrain && this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled,
                            terrain: i,
                            calculateTileZoom: this._source.calculateTileZoom,
                          })),
                          this._source.hasTile &&
                            (l = l.filter((S) => this._source.hasTile(S))))
                      : (l = []),
                    this.usedForTerrain && (l = this._addTerrainIdealTiles(l));
                  const u =
                    l.length === 0 && !this._updated && this._didEmitContent;
                  (this._updated = !0),
                    u &&
                      this.fire(
                        new s.l("data", {
                          sourceDataType: "idle",
                          dataType: "source",
                          sourceId: this.id,
                        })
                      );
                  const d = Nr(e, this._source),
                    g = this._updateRetainedTiles(l, d),
                    w = fn(this._source.type);
                  w &&
                    this._rasterFadeDuration > 0 &&
                    !i &&
                    this._updateFadingTiles(l, g),
                    w
                      ? this._cleanUpRasterTiles(g)
                      : this._cleanUpVectorTiles(g);
                }
                _cleanUpRasterTiles(e) {
                  for (const i in this._tiles) e[i] || this._removeTile(i);
                }
                _cleanUpVectorTiles(e) {
                  for (const i in this._tiles) {
                    const l = this._tiles[i];
                    e[i]
                      ? l.clearSymbolFadeHold()
                      : l.hasSymbolBuckets
                      ? l.holdingForSymbolFade()
                        ? l.symbolFadeFinished() && this._removeTile(i)
                        : l.setSymbolHoldDuration(this.map._fadeDuration)
                      : this._removeTile(i);
                  }
                }
                _addTerrainIdealTiles(e) {
                  const i = [];
                  for (const l of e)
                    if (l.canonical.z > this._source.minzoom) {
                      const u = l.scaledTo(l.canonical.z - 1);
                      i.push(u);
                      const d = l.scaledTo(
                        Math.max(
                          this._source.minzoom,
                          Math.min(l.canonical.z, 5)
                        )
                      );
                      i.push(d);
                    }
                  return e.concat(i);
                }
                releaseSymbolFadeTiles() {
                  for (const e in this._tiles)
                    this._tiles[e].holdingForSymbolFade() &&
                      this._removeTile(e);
                }
                _updateRetainedTiles(e, i) {
                  var l;
                  const u = {},
                    d = {},
                    g = Math.max(i - un.maxOverzooming, this._source.minzoom);
                  let w = {};
                  for (const S of e) {
                    const k = this._addTile(S);
                    (u[S.key] = S), k.hasData() || (w[S.key] = S);
                  }
                  w = this._retainLoadedChildren(w, u);
                  for (const S in w) {
                    const k = w[S];
                    let z = this._tiles[S],
                      V = z == null ? void 0 : z.wasRequested();
                    for (let F = k.overscaledZ - 1; F >= g; --F) {
                      const $ = k.scaledTo(F);
                      if (d[$.key]) break;
                      if (
                        ((d[$.key] = !0),
                        (z = this.getTile($)),
                        !z && V && (z = this._addTile($)),
                        z)
                      ) {
                        const J = z.hasData();
                        if (
                          ((J ||
                            !(
                              !((l = this.map) === null || l === void 0) &&
                              l.cancelPendingTileRequestsWhileZooming
                            ) ||
                            V) &&
                            (u[$.key] = $),
                          (V = z.wasRequested()),
                          J)
                        )
                          break;
                      }
                    }
                  }
                  return u;
                }
                _updateFadingTiles(e, i) {
                  const l = ne(),
                    u = s.aq(e);
                  for (const d of e) {
                    const g = this._tiles[d.key];
                    (g.fadingDirection !== H.Departing &&
                      g.fadeOpacity !== 0) ||
                      g.resetFadeLogic(),
                      this._updateFadingAncestor(g, i, l) ||
                        this._updateFadingDescendents(g, i, l) ||
                        this._updateFadingEdge(g, u, l) ||
                        g.resetFadeLogic();
                  }
                }
                _updateFadingAncestor(e, i, l) {
                  if (!e.hasData()) return !1;
                  const {
                    tileID: u,
                    fadingRole: d,
                    fadingDirection: g,
                    fadingParentID: w,
                  } = e;
                  if (d === j.Base && g === H.Incoming && w)
                    return (i[w.key] = w), !0;
                  const S = Math.max(
                    u.overscaledZ - this._maxFadingAncestorLevels,
                    this._source.minzoom
                  );
                  for (let k = u.overscaledZ - 1; k >= S; k--) {
                    const z = u.scaledTo(k),
                      V = this.getLoadedTile(z);
                    if (V)
                      return (
                        e.setCrossFadeLogic({
                          fadingRole: j.Base,
                          fadingDirection: H.Incoming,
                          fadingParentID: V.tileID,
                          fadeEndTime: l + this._rasterFadeDuration,
                        }),
                        V.setCrossFadeLogic({
                          fadingRole: j.Parent,
                          fadingDirection: H.Departing,
                          fadeEndTime: l + this._rasterFadeDuration,
                        }),
                        (i[z.key] = z),
                        !0
                      );
                  }
                  return !1;
                }
                _updateFadingDescendents(e, i, l) {
                  if (!e.hasData()) return !1;
                  const u = e.tileID.children(this._source.maxzoom);
                  let d = this._updateFadingChildren(e, u, i, l);
                  if (d) return !0;
                  for (const g of u) {
                    const w = g.children(this._source.maxzoom);
                    this._updateFadingChildren(e, w, i, l) && (d = !0);
                  }
                  return d;
                }
                _updateFadingChildren(e, i, l, u) {
                  if (i[0].overscaledZ >= this._source.maxzoom) return !1;
                  let d = !1;
                  for (const g of i) {
                    const w = this.getLoadedTile(g);
                    if (!w) continue;
                    const {
                      fadingRole: S,
                      fadingDirection: k,
                      fadingParentID: z,
                    } = w;
                    (S === j.Base && k === H.Departing && z) ||
                      (w.setCrossFadeLogic({
                        fadingRole: j.Base,
                        fadingDirection: H.Departing,
                        fadingParentID: e.tileID,
                        fadeEndTime: u + this._rasterFadeDuration,
                      }),
                      e.setCrossFadeLogic({
                        fadingRole: j.Parent,
                        fadingDirection: H.Incoming,
                        fadeEndTime: u + this._rasterFadeDuration,
                      })),
                      (l[g.key] = g),
                      (d = !0);
                  }
                  return d;
                }
                _updateFadingEdge(e, i, l) {
                  const u = e.tileID;
                  return (
                    !!e.selfFading ||
                    (!e.hasData() &&
                      !!i.has(u) &&
                      (e.setSelfFadeLogic(l + this._rasterFadeDuration), !0))
                  );
                }
                _addTile(e) {
                  let i = this._tiles[e.key];
                  if (i) return i;
                  (i = this._cache.getAndRemove(e)),
                    i &&
                      (i.resetFadeLogic(),
                      this._setTileReloadTimer(e.key, i),
                      (i.tileID = e),
                      this._state.initializeTileState(
                        i,
                        this.map ? this.map.painter : null
                      ));
                  const l = i;
                  return (
                    i ||
                      ((i = new W(
                        e,
                        this._source.tileSize * e.overscaleFactor()
                      )),
                      this._loadTile(i, e.key, i.state)),
                    i.uses++,
                    (this._tiles[e.key] = i),
                    l ||
                      this._source.fire(
                        new s.l("dataloading", {
                          tile: i,
                          coord: i.tileID,
                          dataType: "source",
                        })
                      ),
                    i
                  );
                }
                _setTileReloadTimer(e, i) {
                  this._clearTileReloadTimer(e);
                  const l = i.getExpiryTimeout();
                  l &&
                    (this._timers[e] = setTimeout(() => {
                      this._reloadTile(e, "expired"), delete this._timers[e];
                    }, l));
                }
                _clearTileReloadTimer(e) {
                  const i = this._timers[e];
                  i && (clearTimeout(i), delete this._timers[e]);
                }
                _resetTileReloadTimers() {
                  for (const e in this._timers)
                    clearTimeout(this._timers[e]), delete this._timers[e];
                  for (const e in this._tiles)
                    this._setTileReloadTimer(e, this._tiles[e]);
                }
                refreshTiles(e) {
                  for (const i in this._tiles)
                    (this._isIdRenderable(i) ||
                      this._tiles[i].state == "errored") &&
                      e.some((l) =>
                        l.equals(this._tiles[i].tileID.canonical)
                      ) &&
                      this._reloadTile(i, "expired");
                }
                _removeTile(e) {
                  const i = this._tiles[e];
                  i &&
                    (i.uses--,
                    delete this._tiles[e],
                    this._clearTileReloadTimer(e),
                    i.uses > 0 ||
                      (i.hasData() && i.state !== "reloading"
                        ? this._cache.add(i.tileID, i, i.getExpiryTimeout())
                        : ((i.aborted = !0),
                          this._abortTile(i),
                          this._unloadTile(i))));
                }
                _dataHandler(e) {
                  e.dataType === "source" &&
                    (e.sourceDataType !== "metadata"
                      ? e.sourceDataType === "content" &&
                        this._sourceLoaded &&
                        !this._paused &&
                        (this.reload(
                          e.sourceDataChanged,
                          e.shouldReloadTileOptions
                        ),
                        this.transform &&
                          this.update(this.transform, this.terrain),
                        (this._didEmitContent = !0))
                      : (this._sourceLoaded = !0));
                }
                clearTiles() {
                  (this._shouldReloadOnResume = !1), (this._paused = !1);
                  for (const e in this._tiles) this._removeTile(e);
                  this._cache.reset();
                }
                tilesIn(e, i, l) {
                  const u = [],
                    d = this.transform;
                  if (!d) return u;
                  const g = d
                      .getCoveringTilesDetailsProvider()
                      .allowWorldCopies(),
                    w = l ? d.getCameraQueryGeometry(e) : e,
                    S = ($) =>
                      d.screenPointToMercatorCoordinate($, this.terrain),
                    k = this.transformBbox(e, S, !g),
                    z = this.transformBbox(w, S, !g),
                    V = this.getIds(),
                    F = s.a6.fromPoints(z);
                  for (let $ = 0; $ < V.length; $++) {
                    const J = this._tiles[V[$]];
                    if (J.holdingForSymbolFade()) continue;
                    const ae = g
                        ? [J.tileID]
                        : [J.tileID.unwrapTo(-1), J.tileID.unwrapTo(0)],
                      oe = Math.pow(2, d.zoom - J.tileID.overscaledZ),
                      se = (i * J.queryPadding * s.a3) / J.tileSize / oe;
                    for (const fe of ae) {
                      const be = F.map((pe) =>
                        fe.getTilePoint(new s.a5(pe.x, pe.y))
                      );
                      if ((be.expandBy(se), be.intersects(Wr))) {
                        const pe = k.map((Pe) => fe.getTilePoint(Pe)),
                          we = z.map((Pe) => fe.getTilePoint(Pe));
                        u.push({
                          tile: J,
                          tileID: g ? fe : fe.unwrapTo(0),
                          queryGeometry: pe,
                          cameraQueryGeometry: we,
                          scale: oe,
                        });
                      }
                    }
                  }
                  return u;
                }
                transformBbox(e, i, l) {
                  let u = e.map(i);
                  if (l) {
                    const d = s.a6.fromPoints(e);
                    d.shrinkBy(0.001 * Math.min(d.width(), d.height()));
                    const g = d.map(i);
                    s.a6.fromPoints(u).covers(g) ||
                      (u = u.map((w) =>
                        w.x > 0.5 ? new s.a5(w.x - 1, w.y, w.z) : w
                      ));
                  }
                  return u;
                }
                getVisibleCoordinates(e) {
                  const i = this.getRenderableIds(e).map(
                    (l) => this._tiles[l].tileID
                  );
                  return this.transform && this.transform.populateCache(i), i;
                }
                hasTransition() {
                  if (this._source.hasTransition()) return !0;
                  if (fn(this._source.type) && this._rasterFadeDuration > 0) {
                    const e = ne();
                    for (const i in this._tiles)
                      if (this._tiles[i].fadeEndTime >= e) return !0;
                  }
                  return !1;
                }
                setRasterFadeDuration(e) {
                  this._rasterFadeDuration = e;
                }
                setFeatureState(e, i, l) {
                  this._state.updateState((e = e || "_geojsonTileLayer"), i, l);
                }
                removeFeatureState(e, i, l) {
                  this._state.removeFeatureState(
                    (e = e || "_geojsonTileLayer"),
                    i,
                    l
                  );
                }
                getFeatureState(e, i) {
                  return this._state.getState(
                    (e = e || "_geojsonTileLayer"),
                    i
                  );
                }
                setDependencies(e, i, l) {
                  const u = this._tiles[e];
                  u && u.setDependencies(i, l);
                }
                reloadTilesForDependencies(e, i) {
                  for (const l in this._tiles)
                    this._tiles[l].hasDependency(e, i) &&
                      this._reloadTile(l, "reloading");
                  this._cache.filter((l) => !l.hasDependency(e, i));
                }
              }
              function an(h, e) {
                const i = Math.abs(2 * h.wrap) - +(h.wrap < 0),
                  l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                return (
                  h.overscaledZ - e.overscaledZ ||
                  l - i ||
                  e.canonical.y - h.canonical.y ||
                  e.canonical.x - h.canonical.x
                );
              }
              function fn(h) {
                return h === "raster" || h === "image" || h === "video";
              }
              (un.maxOverzooming = 10), (un.maxUnderzooming = 3);
              class rn {
                constructor(e, i) {
                  this.reset(e, i);
                }
                reset(e, i) {
                  (this.points = e || []), (this._distances = [0]);
                  for (let l = 1; l < this.points.length; l++)
                    this._distances[l] =
                      this._distances[l - 1] +
                      this.points[l].dist(this.points[l - 1]);
                  (this.length = this._distances[this._distances.length - 1]),
                    (this.padding = Math.min(i || 0, 0.5 * this.length)),
                    (this.paddedLength = this.length - 2 * this.padding);
                }
                lerp(e) {
                  if (this.points.length === 1) return this.points[0];
                  e = s.ai(e, 0, 1);
                  let i = 1,
                    l = this._distances[i];
                  const u = e * this.paddedLength + this.padding;
                  for (; l < u && i < this._distances.length; )
                    l = this._distances[++i];
                  const d = i - 1,
                    g = this._distances[d],
                    w = l - g,
                    S = w > 0 ? (u - g) / w : 0;
                  return this.points[d].mult(1 - S).add(this.points[i].mult(S));
                }
              }
              function pt(h, e) {
                let i = !0;
                return (
                  h === "always" ||
                    (h !== "never" && e !== "never") ||
                    (i = !1),
                  i
                );
              }
              class on {
                constructor(e, i, l) {
                  const u = (this.boxCells = []),
                    d = (this.circleCells = []);
                  (this.xCellCount = Math.ceil(e / l)),
                    (this.yCellCount = Math.ceil(i / l));
                  for (let g = 0; g < this.xCellCount * this.yCellCount; g++)
                    u.push([]), d.push([]);
                  (this.circleKeys = []),
                    (this.boxKeys = []),
                    (this.bboxes = []),
                    (this.circles = []),
                    (this.width = e),
                    (this.height = i),
                    (this.xScale = this.xCellCount / e),
                    (this.yScale = this.yCellCount / i),
                    (this.boxUid = 0),
                    (this.circleUid = 0);
                }
                keysLength() {
                  return this.boxKeys.length + this.circleKeys.length;
                }
                insert(e, i, l, u, d) {
                  this._forEachCell(
                    i,
                    l,
                    u,
                    d,
                    this._insertBoxCell,
                    this.boxUid++
                  ),
                    this.boxKeys.push(e),
                    this.bboxes.push(i),
                    this.bboxes.push(l),
                    this.bboxes.push(u),
                    this.bboxes.push(d);
                }
                insertCircle(e, i, l, u) {
                  this._forEachCell(
                    i - u,
                    l - u,
                    i + u,
                    l + u,
                    this._insertCircleCell,
                    this.circleUid++
                  ),
                    this.circleKeys.push(e),
                    this.circles.push(i),
                    this.circles.push(l),
                    this.circles.push(u);
                }
                _insertBoxCell(e, i, l, u, d, g) {
                  this.boxCells[d].push(g);
                }
                _insertCircleCell(e, i, l, u, d, g) {
                  this.circleCells[d].push(g);
                }
                _query(e, i, l, u, d, g, w) {
                  if (l < 0 || e > this.width || u < 0 || i > this.height)
                    return [];
                  const S = [];
                  if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
                    if (d) return [{ key: null, x1: e, y1: i, x2: l, y2: u }];
                    for (let k = 0; k < this.boxKeys.length; k++)
                      S.push({
                        key: this.boxKeys[k],
                        x1: this.bboxes[4 * k],
                        y1: this.bboxes[4 * k + 1],
                        x2: this.bboxes[4 * k + 2],
                        y2: this.bboxes[4 * k + 3],
                      });
                    for (let k = 0; k < this.circleKeys.length; k++) {
                      const z = this.circles[3 * k],
                        V = this.circles[3 * k + 1],
                        F = this.circles[3 * k + 2];
                      S.push({
                        key: this.circleKeys[k],
                        x1: z - F,
                        y1: V - F,
                        x2: z + F,
                        y2: V + F,
                      });
                    }
                  } else this._forEachCell(e, i, l, u, this._queryCell, S, { hitTest: d, overlapMode: g, seenUids: { box: {}, circle: {} } }, w);
                  return S;
                }
                query(e, i, l, u) {
                  return this._query(e, i, l, u, !1, null);
                }
                hitTest(e, i, l, u, d, g) {
                  return this._query(e, i, l, u, !0, d, g).length > 0;
                }
                hitTestCircle(e, i, l, u, d) {
                  const g = e - l,
                    w = e + l,
                    S = i - l,
                    k = i + l;
                  if (w < 0 || g > this.width || k < 0 || S > this.height)
                    return !1;
                  const z = [];
                  return (
                    this._forEachCell(
                      g,
                      S,
                      w,
                      k,
                      this._queryCellCircle,
                      z,
                      {
                        hitTest: !0,
                        overlapMode: u,
                        circle: { x: e, y: i, radius: l },
                        seenUids: { box: {}, circle: {} },
                      },
                      d
                    ),
                    z.length > 0
                  );
                }
                _queryCell(e, i, l, u, d, g, w, S) {
                  const { seenUids: k, hitTest: z, overlapMode: V } = w,
                    F = this.boxCells[d];
                  if (F !== null) {
                    const J = this.bboxes;
                    for (const ae of F)
                      if (!k.box[ae]) {
                        k.box[ae] = !0;
                        const oe = 4 * ae,
                          se = this.boxKeys[ae];
                        if (
                          e <= J[oe + 2] &&
                          i <= J[oe + 3] &&
                          l >= J[oe + 0] &&
                          u >= J[oe + 1] &&
                          (!S || S(se)) &&
                          (!z || !pt(V, se.overlapMode)) &&
                          (g.push({
                            key: se,
                            x1: J[oe],
                            y1: J[oe + 1],
                            x2: J[oe + 2],
                            y2: J[oe + 3],
                          }),
                          z)
                        )
                          return !0;
                      }
                  }
                  const $ = this.circleCells[d];
                  if ($ !== null) {
                    const J = this.circles;
                    for (const ae of $)
                      if (!k.circle[ae]) {
                        k.circle[ae] = !0;
                        const oe = 3 * ae,
                          se = this.circleKeys[ae];
                        if (
                          this._circleAndRectCollide(
                            J[oe],
                            J[oe + 1],
                            J[oe + 2],
                            e,
                            i,
                            l,
                            u
                          ) &&
                          (!S || S(se)) &&
                          (!z || !pt(V, se.overlapMode))
                        ) {
                          const fe = J[oe],
                            be = J[oe + 1],
                            pe = J[oe + 2];
                          if (
                            (g.push({
                              key: se,
                              x1: fe - pe,
                              y1: be - pe,
                              x2: fe + pe,
                              y2: be + pe,
                            }),
                            z)
                          )
                            return !0;
                        }
                      }
                  }
                  return !1;
                }
                _queryCellCircle(e, i, l, u, d, g, w, S) {
                  const { circle: k, seenUids: z, overlapMode: V } = w,
                    F = this.boxCells[d];
                  if (F !== null) {
                    const J = this.bboxes;
                    for (const ae of F)
                      if (!z.box[ae]) {
                        z.box[ae] = !0;
                        const oe = 4 * ae,
                          se = this.boxKeys[ae];
                        if (
                          this._circleAndRectCollide(
                            k.x,
                            k.y,
                            k.radius,
                            J[oe + 0],
                            J[oe + 1],
                            J[oe + 2],
                            J[oe + 3]
                          ) &&
                          (!S || S(se)) &&
                          !pt(V, se.overlapMode)
                        )
                          return g.push(!0), !0;
                      }
                  }
                  const $ = this.circleCells[d];
                  if ($ !== null) {
                    const J = this.circles;
                    for (const ae of $)
                      if (!z.circle[ae]) {
                        z.circle[ae] = !0;
                        const oe = 3 * ae,
                          se = this.circleKeys[ae];
                        if (
                          this._circlesCollide(
                            J[oe],
                            J[oe + 1],
                            J[oe + 2],
                            k.x,
                            k.y,
                            k.radius
                          ) &&
                          (!S || S(se)) &&
                          !pt(V, se.overlapMode)
                        )
                          return g.push(!0), !0;
                      }
                  }
                }
                _forEachCell(e, i, l, u, d, g, w, S) {
                  const k = this._convertToXCellCoord(e),
                    z = this._convertToYCellCoord(i),
                    V = this._convertToXCellCoord(l),
                    F = this._convertToYCellCoord(u);
                  for (let $ = k; $ <= V; $++)
                    for (let J = z; J <= F; J++)
                      if (
                        d.call(
                          this,
                          e,
                          i,
                          l,
                          u,
                          this.xCellCount * J + $,
                          g,
                          w,
                          S
                        )
                      )
                        return;
                }
                _convertToXCellCoord(e) {
                  return Math.max(
                    0,
                    Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))
                  );
                }
                _convertToYCellCoord(e) {
                  return Math.max(
                    0,
                    Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))
                  );
                }
                _circlesCollide(e, i, l, u, d, g) {
                  const w = u - e,
                    S = d - i,
                    k = l + g;
                  return k * k > w * w + S * S;
                }
                _circleAndRectCollide(e, i, l, u, d, g, w) {
                  const S = (g - u) / 2,
                    k = Math.abs(e - (u + S));
                  if (k > S + l) return !1;
                  const z = (w - d) / 2,
                    V = Math.abs(i - (d + z));
                  if (V > z + l) return !1;
                  if (k <= S || V <= z) return !0;
                  const F = k - S,
                    $ = V - z;
                  return F * F + $ * $ <= l * l;
                }
              }
              function Pn(h, e, i) {
                const l = s.M();
                if (!h) {
                  const { vecSouth: V, vecEast: F } = Qt(e),
                    $ = N();
                  ($[0] = F[0]),
                    ($[1] = F[1]),
                    ($[2] = V[0]),
                    ($[3] = V[1]),
                    (u = $),
                    (z =
                      (g = (d = $)[0]) * (k = d[3]) -
                      (S = d[2]) * (w = d[1])) &&
                      ((u[0] = k * (z = 1 / z)),
                      (u[1] = -w * z),
                      (u[2] = -S * z),
                      (u[3] = g * z)),
                    (l[0] = $[0]),
                    (l[1] = $[1]),
                    (l[4] = $[2]),
                    (l[5] = $[3]);
                }
                var u, d, g, w, S, k, z;
                return s.O(l, l, [1 / i, 1 / i, 1]), l;
              }
              function zt(h, e, i, l) {
                if (h) {
                  const u = s.M();
                  if (!e) {
                    const { vecSouth: d, vecEast: g } = Qt(i);
                    (u[0] = g[0]), (u[1] = g[1]), (u[4] = d[0]), (u[5] = d[1]);
                  }
                  return s.O(u, u, [l, l, 1]), u;
                }
                return i.pixelsToClipSpaceMatrix;
              }
              function Qt(h) {
                const e = Math.cos(h.rollInRadians),
                  i = Math.sin(h.rollInRadians),
                  l = Math.cos(h.pitchInRadians),
                  u = Math.cos(h.bearingInRadians),
                  d = Math.sin(h.bearingInRadians),
                  g = s.av();
                (g[0] = -u * l * i - d * e), (g[1] = -d * l * i + u * e);
                const w = s.aw(g);
                w < 1e-9 ? s.ax(g) : s.ay(g, g, 1 / w);
                const S = s.av();
                (S[0] = u * l * e - d * i), (S[1] = d * l * e + u * i);
                const k = s.aw(S);
                return (
                  k < 1e-9 ? s.ax(S) : s.ay(S, S, 1 / k),
                  { vecEast: S, vecSouth: g }
                );
              }
              function rt(h, e, i, l) {
                let u;
                l
                  ? ((u = [h, e, l(h, e), 1]), s.aA(u, u, i))
                  : ((u = [h, e, 0, 1]), Rn(u, u, i));
                const d = u[3];
                return {
                  point: new s.P(u[0] / d, u[1] / d),
                  signedDistanceFromCamera: d,
                  isOccluded: !1,
                };
              }
              function $t(h, e) {
                return 0.5 + (h / e) * 0.5;
              }
              function st(h, e) {
                return (
                  h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
                );
              }
              function gt(h, e, i, l, u, d, g, w, S, k, z, V, F) {
                const $ = i ? h.textSizeData : h.iconSizeData,
                  J = s.ar($, e.transform.zoom),
                  ae = [(256 / e.width) * 2 + 1, (256 / e.height) * 2 + 1],
                  oe = i
                    ? h.text.dynamicLayoutVertexArray
                    : h.icon.dynamicLayoutVertexArray;
                oe.clear();
                const se = h.lineVertexArray,
                  fe = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
                  be = e.transform.width / e.transform.height;
                let pe = !1;
                for (let we = 0; we < fe.length; we++) {
                  const Pe = fe.get(we);
                  if (Pe.hidden || (Pe.writingMode === s.as.vertical && !pe)) {
                    Gn(Pe.numGlyphs, oe);
                    continue;
                  }
                  pe = !1;
                  const ve = new s.P(Pe.anchorX, Pe.anchorY),
                    Re = {
                      getElevation: F,
                      pitchedLabelPlaneMatrix: l,
                      lineVertexArray: se,
                      pitchWithMap: d,
                      projectionCache: {
                        projections: {},
                        offsets: {},
                        cachedAnchorPoint: void 0,
                        anyProjectionOccluded: !1,
                      },
                      transform: e.transform,
                      tileAnchorPoint: ve,
                      unwrappedTileID: S,
                      width: k,
                      height: z,
                      translation: V,
                    },
                    it = fr(Pe.anchorX, Pe.anchorY, Re);
                  if (!st(it.point, ae)) {
                    Gn(Pe.numGlyphs, oe);
                    continue;
                  }
                  const Qe = $t(
                      e.transform.cameraToCenterDistance,
                      it.signedDistanceFromCamera
                    ),
                    tt = s.at($, J, Pe),
                    ot = d
                      ? (tt *
                          e.transform.getPitchedTextCorrection(
                            Pe.anchorX,
                            Pe.anchorY,
                            S
                          )) /
                        Qe
                      : tt * Qe,
                    Zt = wt({
                      projectionContext: Re,
                      pitchedLabelPlaneMatrixInverse: u,
                      symbol: Pe,
                      fontSize: ot,
                      flip: !1,
                      keepUpright: g,
                      glyphOffsetArray: h.glyphOffsetArray,
                      dynamicLayoutVertexArray: oe,
                      aspectRatio: be,
                      rotateToLine: w,
                    });
                  (pe = Zt.useVertical),
                    (Zt.notEnoughRoom ||
                      pe ||
                      (Zt.needsFlipping &&
                        wt({
                          projectionContext: Re,
                          pitchedLabelPlaneMatrixInverse: u,
                          symbol: Pe,
                          fontSize: ot,
                          flip: !0,
                          keepUpright: g,
                          glyphOffsetArray: h.glyphOffsetArray,
                          dynamicLayoutVertexArray: oe,
                          aspectRatio: be,
                          rotateToLine: w,
                        }).notEnoughRoom)) &&
                      Gn(Pe.numGlyphs, oe);
                }
                i
                  ? h.text.dynamicLayoutVertexBuffer.updateData(oe)
                  : h.icon.dynamicLayoutVertexBuffer.updateData(oe);
              }
              function Ut(h, e, i, l, u, d, g, w) {
                const S = d.glyphStartIndex + d.numGlyphs,
                  k = d.lineStartIndex,
                  z = d.lineStartIndex + d.lineLength,
                  V = e.getoffsetX(d.glyphStartIndex),
                  F = e.getoffsetX(S - 1),
                  $ = Tn(h * V, i, l, u, d.segment, k, z, w, g);
                if (!$) return null;
                const J = Tn(h * F, i, l, u, d.segment, k, z, w, g);
                return J
                  ? w.projectionCache.anyProjectionOccluded
                    ? null
                    : { first: $, last: J }
                  : null;
              }
              function br(h, e, i, l) {
                return h === s.as.horizontal &&
                  Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l
                  ? { useVertical: !0 }
                  : (h === s.as.vertical ? e.y < i.y : e.x > i.x)
                  ? { needsFlipping: !0 }
                  : null;
              }
              function wt(h) {
                const {
                    projectionContext: e,
                    pitchedLabelPlaneMatrixInverse: i,
                    symbol: l,
                    fontSize: u,
                    flip: d,
                    keepUpright: g,
                    glyphOffsetArray: w,
                    dynamicLayoutVertexArray: S,
                    aspectRatio: k,
                    rotateToLine: z,
                  } = h,
                  V = u / 24,
                  F = l.lineOffsetX * V,
                  $ = l.lineOffsetY * V;
                let J;
                if (l.numGlyphs > 1) {
                  const ae = l.glyphStartIndex + l.numGlyphs,
                    oe = l.lineStartIndex,
                    se = l.lineStartIndex + l.lineLength,
                    fe = Ut(V, w, F, $, d, l, z, e);
                  if (!fe) return { notEnoughRoom: !0 };
                  const be = Yr(fe.first.point.x, fe.first.point.y, e, i),
                    pe = Yr(fe.last.point.x, fe.last.point.y, e, i);
                  if (g && !d) {
                    const we = br(l.writingMode, be, pe, k);
                    if (we) return we;
                  }
                  J = [fe.first];
                  for (let we = l.glyphStartIndex + 1; we < ae - 1; we++) {
                    const Pe = Tn(
                      V * w.getoffsetX(we),
                      F,
                      $,
                      d,
                      l.segment,
                      oe,
                      se,
                      e,
                      z
                    );
                    if (!Pe) return { notEnoughRoom: !0 };
                    J.push(Pe);
                  }
                  J.push(fe.last);
                } else {
                  if (g && !d) {
                    const oe = jr(
                        e.tileAnchorPoint.x,
                        e.tileAnchorPoint.y,
                        e
                      ).point,
                      se = l.lineStartIndex + l.segment + 1,
                      fe = new s.P(
                        e.lineVertexArray.getx(se),
                        e.lineVertexArray.gety(se)
                      ),
                      be = jr(fe.x, fe.y, e),
                      pe =
                        be.signedDistanceFromCamera > 0
                          ? be.point
                          : sr(e.tileAnchorPoint, fe, oe, 1, e),
                      we = Yr(oe.x, oe.y, e, i),
                      Pe = Yr(pe.x, pe.y, e, i),
                      ve = br(l.writingMode, we, Pe, k);
                    if (ve) return ve;
                  }
                  const ae = Tn(
                    V * w.getoffsetX(l.glyphStartIndex),
                    F,
                    $,
                    d,
                    l.segment,
                    l.lineStartIndex,
                    l.lineStartIndex + l.lineLength,
                    e,
                    z
                  );
                  if (!ae || e.projectionCache.anyProjectionOccluded)
                    return { notEnoughRoom: !0 };
                  J = [ae];
                }
                for (const ae of J) s.az(S, ae.point, ae.angle);
                return {};
              }
              function sr(h, e, i, l, u) {
                const d = h.add(h.sub(e)._unit()),
                  g = jr(d.x, d.y, u).point,
                  w = i.sub(g);
                return i.add(w._mult(l / w.mag()));
              }
              function wr(h, e, i) {
                const l = e.projectionCache;
                if (l.projections[h]) return l.projections[h];
                const u = new s.P(
                    e.lineVertexArray.getx(h),
                    e.lineVertexArray.gety(h)
                  ),
                  d = jr(u.x, u.y, e);
                if (d.signedDistanceFromCamera > 0)
                  return (
                    (l.projections[h] = d.point),
                    (l.anyProjectionOccluded =
                      l.anyProjectionOccluded || d.isOccluded),
                    d.point
                  );
                const g = h - i.direction;
                return sr(
                  i.distanceFromAnchor === 0
                    ? e.tileAnchorPoint
                    : new s.P(
                        e.lineVertexArray.getx(g),
                        e.lineVertexArray.gety(g)
                      ),
                  u,
                  i.previousVertex,
                  i.absOffsetX - i.distanceFromAnchor + 1,
                  e
                );
              }
              function jr(h, e, i) {
                const l = h + i.translation[0],
                  u = e + i.translation[1];
                let d;
                return (
                  i.pitchWithMap
                    ? ((d = rt(
                        l,
                        u,
                        i.pitchedLabelPlaneMatrix,
                        i.getElevation
                      )),
                      (d.isOccluded = !1))
                    : ((d = i.transform.projectTileCoordinates(
                        l,
                        u,
                        i.unwrappedTileID,
                        i.getElevation
                      )),
                      (d.point.x = (0.5 * d.point.x + 0.5) * i.width),
                      (d.point.y = (0.5 * -d.point.y + 0.5) * i.height)),
                  d
                );
              }
              function Yr(h, e, i, l) {
                if (i.pitchWithMap) {
                  const u = [h, e, 0, 1];
                  return (
                    s.aA(u, u, l),
                    i.transform.projectTileCoordinates(
                      u[0] / u[3],
                      u[1] / u[3],
                      i.unwrappedTileID,
                      i.getElevation
                    ).point
                  );
                }
                return { x: (h / i.width) * 2 - 1, y: 1 - (e / i.height) * 2 };
              }
              function fr(h, e, i) {
                return i.transform.projectTileCoordinates(
                  h,
                  e,
                  i.unwrappedTileID,
                  i.getElevation
                );
              }
              function Zr(h, e, i) {
                return h
                  ._unit()
                  ._perp()
                  ._mult(e * i);
              }
              function nn(h, e, i, l, u, d, g, w, S) {
                if (w.projectionCache.offsets[h])
                  return w.projectionCache.offsets[h];
                const k = i.add(e);
                if (h + S.direction < l || h + S.direction >= u)
                  return (w.projectionCache.offsets[h] = k), k;
                const z = wr(h + S.direction, w, S),
                  V = Zr(z.sub(i), g, S.direction),
                  F = i.add(V),
                  $ = z.add(V);
                return (
                  (w.projectionCache.offsets[h] = s.aB(d, k, F, $) || k),
                  w.projectionCache.offsets[h]
                );
              }
              function Tn(h, e, i, l, u, d, g, w, S) {
                const k = l ? h - e : h + e;
                let z = k > 0 ? 1 : -1,
                  V = 0;
                l && ((z *= -1), (V = Math.PI)), z < 0 && (V += Math.PI);
                let F,
                  $ = z > 0 ? d + u : d + u + 1;
                w.projectionCache.cachedAnchorPoint
                  ? (F = w.projectionCache.cachedAnchorPoint)
                  : ((F = jr(
                      w.tileAnchorPoint.x,
                      w.tileAnchorPoint.y,
                      w
                    ).point),
                    (w.projectionCache.cachedAnchorPoint = F));
                let J,
                  ae,
                  oe = F,
                  se = F,
                  fe = 0,
                  be = 0;
                const pe = Math.abs(k),
                  we = [];
                let Pe;
                for (; fe + be <= pe; ) {
                  if ((($ += z), $ < d || $ >= g)) return null;
                  (fe += be), (se = oe), (ae = J);
                  const it = {
                    absOffsetX: pe,
                    direction: z,
                    distanceFromAnchor: fe,
                    previousVertex: se,
                  };
                  if (((oe = wr($, w, it)), i === 0))
                    we.push(se), (Pe = oe.sub(se));
                  else {
                    let Qe;
                    const tt = oe.sub(se);
                    (Qe =
                      tt.mag() === 0
                        ? Zr(wr($ + z, w, it).sub(oe), i, z)
                        : Zr(tt, i, z)),
                      ae || (ae = se.add(Qe)),
                      (J = nn($, Qe, oe, d, g, ae, i, w, it)),
                      we.push(ae),
                      (Pe = J.sub(ae));
                  }
                  be = Pe.mag();
                }
                const ve = Pe._mult((pe - fe) / be)._add(ae || se),
                  Re = V + Math.atan2(oe.y - se.y, oe.x - se.x);
                return we.push(ve), { point: ve, angle: S ? Re : 0, path: we };
              }
              const gn = new Float32Array([
                -1 / 0,
                -1 / 0,
                0,
                -1 / 0,
                -1 / 0,
                0,
                -1 / 0,
                -1 / 0,
                0,
                -1 / 0,
                -1 / 0,
                0,
              ]);
              function Gn(h, e) {
                for (let i = 0; i < h; i++) {
                  const l = e.length;
                  e.resize(l + 4), e.float32.set(gn, 3 * l);
                }
              }
              function Rn(h, e, i) {
                const l = e[0],
                  u = e[1];
                return (
                  (h[0] = i[0] * l + i[4] * u + i[12]),
                  (h[1] = i[1] * l + i[5] * u + i[13]),
                  (h[3] = i[3] * l + i[7] * u + i[15]),
                  h
                );
              }
              const hn = 100;
              class Qn {
                constructor(
                  e,
                  i = new on(e.width + 200, e.height + 200, 25),
                  l = new on(e.width + 200, e.height + 200, 25)
                ) {
                  (this.transform = e),
                    (this.grid = i),
                    (this.ignoredGrid = l),
                    (this.pitchFactor =
                      Math.cos((e.pitch * Math.PI) / 180) *
                      e.cameraToCenterDistance),
                    (this.screenRightBoundary = e.width + hn),
                    (this.screenBottomBoundary = e.height + hn),
                    (this.gridRightBoundary = e.width + 200),
                    (this.gridBottomBoundary = e.height + 200),
                    (this.perspectiveRatioCutoff = 0.6);
                }
                placeCollisionBox(e, i, l, u, d, g, w, S, k, z, V, F) {
                  const $ = this.projectAndGetPerspectiveRatio(
                      e.anchorPointX + S[0],
                      e.anchorPointY + S[1],
                      d,
                      z,
                      F
                    ),
                    J = l * $.perspectiveRatio;
                  let ae;
                  if (g || w)
                    ae = this._projectCollisionBox(
                      e,
                      J,
                      u,
                      d,
                      g,
                      w,
                      S,
                      $,
                      z,
                      V,
                      F
                    );
                  else {
                    const Pe = $.x + (V ? V.x * J : 0),
                      ve = $.y + (V ? V.y * J : 0);
                    ae = {
                      allPointsOccluded: !1,
                      box: [
                        Pe + e.x1 * J,
                        ve + e.y1 * J,
                        Pe + e.x2 * J,
                        ve + e.y2 * J,
                      ],
                    };
                  }
                  const [oe, se, fe, be] = ae.box,
                    pe = g ? ae.allPointsOccluded : $.isOccluded;
                  let we = pe;
                  return (
                    we ||
                      (we = $.perspectiveRatio < this.perspectiveRatioCutoff),
                    we || (we = !this.isInsideGrid(oe, se, fe, be)),
                    we ||
                    (i !== "always" && this.grid.hitTest(oe, se, fe, be, i, k))
                      ? {
                          box: [oe, se, fe, be],
                          placeable: !1,
                          offscreen: !1,
                          occluded: pe,
                        }
                      : {
                          box: [oe, se, fe, be],
                          placeable: !0,
                          offscreen: this.isOffscreen(oe, se, fe, be),
                          occluded: pe,
                        }
                  );
                }
                placeCollisionCircles(
                  e,
                  i,
                  l,
                  u,
                  d,
                  g,
                  w,
                  S,
                  k,
                  z,
                  V,
                  F,
                  $,
                  J
                ) {
                  const ae = [],
                    oe = new s.P(i.anchorX, i.anchorY),
                    se = this.getPerspectiveRatio(oe.x, oe.y, g, J),
                    fe =
                      (k
                        ? (d *
                            this.transform.getPitchedTextCorrection(
                              i.anchorX,
                              i.anchorY,
                              g
                            )) /
                          se
                        : d * se) / s.aF,
                    be = {
                      getElevation: J,
                      pitchedLabelPlaneMatrix: w,
                      lineVertexArray: l,
                      pitchWithMap: k,
                      projectionCache: {
                        projections: {},
                        offsets: {},
                        cachedAnchorPoint: void 0,
                        anyProjectionOccluded: !1,
                      },
                      transform: this.transform,
                      tileAnchorPoint: oe,
                      unwrappedTileID: g,
                      width: this.transform.width,
                      height: this.transform.height,
                      translation: $,
                    },
                    pe = Ut(
                      fe,
                      u,
                      i.lineOffsetX * fe,
                      i.lineOffsetY * fe,
                      !1,
                      i,
                      !1,
                      be
                    );
                  let we = !1,
                    Pe = !1,
                    ve = !0;
                  if (pe) {
                    const Re = 0.5 * V * se + F,
                      it = new s.P(-100, -100),
                      Qe = new s.P(
                        this.screenRightBoundary,
                        this.screenBottomBoundary
                      ),
                      tt = new rn(),
                      ot = pe.first,
                      Zt = pe.last;
                    let Ht = [];
                    for (let tn = ot.path.length - 1; tn >= 1; tn--)
                      Ht.push(ot.path[tn]);
                    for (let tn = 1; tn < Zt.path.length; tn++)
                      Ht.push(Zt.path[tn]);
                    const Pt = 2.5 * Re;
                    if (k) {
                      const tn = this.projectPathToScreenSpace(Ht, be);
                      Ht = tn.some((Ln) => Ln.signedDistanceFromCamera <= 0)
                        ? []
                        : tn.map((Ln) => Ln.point);
                    }
                    let yr = [];
                    if (Ht.length > 0) {
                      const tn = Ht[0].clone(),
                        Ln = Ht[0].clone();
                      for (let cn = 1; cn < Ht.length; cn++)
                        (tn.x = Math.min(tn.x, Ht[cn].x)),
                          (tn.y = Math.min(tn.y, Ht[cn].y)),
                          (Ln.x = Math.max(Ln.x, Ht[cn].x)),
                          (Ln.y = Math.max(Ln.y, Ht[cn].y));
                      yr =
                        tn.x >= it.x &&
                        Ln.x <= Qe.x &&
                        tn.y >= it.y &&
                        Ln.y <= Qe.y
                          ? [Ht]
                          : Ln.x < it.x ||
                            tn.x > Qe.x ||
                            Ln.y < it.y ||
                            tn.y > Qe.y
                          ? []
                          : s.aC([Ht], it.x, it.y, Qe.x, Qe.y);
                    }
                    for (const tn of yr) {
                      tt.reset(tn, 0.25 * Re);
                      let Ln = 0;
                      Ln =
                        tt.length <= 0.5 * Re
                          ? 1
                          : Math.ceil(tt.paddedLength / Pt) + 1;
                      for (let cn = 0; cn < Ln; cn++) {
                        const Nn = cn / Math.max(Ln - 1, 1),
                          ri = tt.lerp(Nn),
                          Un = ri.x + hn,
                          gi = ri.y + hn;
                        ae.push(Un, gi, Re, 0);
                        const Kn = Un - Re,
                          Ii = gi - Re,
                          Jn = Un + Re,
                          fi = gi + Re;
                        if (
                          ((ve = ve && this.isOffscreen(Kn, Ii, Jn, fi)),
                          (Pe = Pe || this.isInsideGrid(Kn, Ii, Jn, fi)),
                          e !== "always" &&
                            this.grid.hitTestCircle(Un, gi, Re, e, z) &&
                            ((we = !0), !S))
                        )
                          return {
                            circles: [],
                            offscreen: !1,
                            collisionDetected: we,
                          };
                      }
                    }
                  }
                  return {
                    circles:
                      (!S && we) || !Pe || se < this.perspectiveRatioCutoff
                        ? []
                        : ae,
                    offscreen: ve,
                    collisionDetected: we,
                  };
                }
                projectPathToScreenSpace(e, i) {
                  const l = (function (u, d) {
                    const g = s.M();
                    return (
                      s.au(g, d.pitchedLabelPlaneMatrix),
                      u.map((w) => {
                        const S = rt(w.x, w.y, g, d.getElevation),
                          k = d.transform.projectTileCoordinates(
                            S.point.x,
                            S.point.y,
                            d.unwrappedTileID,
                            d.getElevation
                          );
                        return (
                          (k.point.x = (0.5 * k.point.x + 0.5) * d.width),
                          (k.point.y = (0.5 * -k.point.y + 0.5) * d.height),
                          k
                        );
                      })
                    );
                  })(e, i);
                  return (function (u) {
                    let d = 0,
                      g = 0,
                      w = 0,
                      S = 0;
                    for (let k = 0; k < u.length; k++)
                      u[k].isOccluded
                        ? ((w = k + 1), (S = 0))
                        : (S++, S > g && ((g = S), (d = w)));
                    return u.slice(d, d + g);
                  })(l);
                }
                queryRenderedSymbols(e) {
                  if (
                    e.length === 0 ||
                    (this.grid.keysLength() === 0 &&
                      this.ignoredGrid.keysLength() === 0)
                  )
                    return {};
                  const i = [],
                    l = new s.a6();
                  for (const V of e) {
                    const F = new s.P(V.x + hn, V.y + hn);
                    l.extend(F), i.push(F);
                  }
                  const { minX: u, minY: d, maxX: g, maxY: w } = l,
                    S = this.grid
                      .query(u, d, g, w)
                      .concat(this.ignoredGrid.query(u, d, g, w)),
                    k = {},
                    z = {};
                  for (const V of S) {
                    const F = V.key;
                    if (
                      (k[F.bucketInstanceId] === void 0 &&
                        (k[F.bucketInstanceId] = {}),
                      k[F.bucketInstanceId][F.featureIndex])
                    )
                      continue;
                    const $ = [
                      new s.P(V.x1, V.y1),
                      new s.P(V.x2, V.y1),
                      new s.P(V.x2, V.y2),
                      new s.P(V.x1, V.y2),
                    ];
                    s.aD(i, $) &&
                      ((k[F.bucketInstanceId][F.featureIndex] = !0),
                      z[F.bucketInstanceId] === void 0 &&
                        (z[F.bucketInstanceId] = []),
                      z[F.bucketInstanceId].push(F.featureIndex));
                  }
                  return z;
                }
                insertCollisionBox(e, i, l, u, d, g) {
                  (l ? this.ignoredGrid : this.grid).insert(
                    {
                      bucketInstanceId: u,
                      featureIndex: d,
                      collisionGroupID: g,
                      overlapMode: i,
                    },
                    e[0],
                    e[1],
                    e[2],
                    e[3]
                  );
                }
                insertCollisionCircles(e, i, l, u, d, g) {
                  const w = l ? this.ignoredGrid : this.grid,
                    S = {
                      bucketInstanceId: u,
                      featureIndex: d,
                      collisionGroupID: g,
                      overlapMode: i,
                    };
                  for (let k = 0; k < e.length; k += 4)
                    w.insertCircle(S, e[k], e[k + 1], e[k + 2]);
                }
                projectAndGetPerspectiveRatio(e, i, l, u, d) {
                  if (d) {
                    let g;
                    u
                      ? ((g = [e, i, u(e, i), 1]), s.aA(g, g, d))
                      : ((g = [e, i, 0, 1]), Rn(g, g, d));
                    const w = g[3];
                    return {
                      x: ((g[0] / w + 1) / 2) * this.transform.width + hn,
                      y: ((-g[1] / w + 1) / 2) * this.transform.height + hn,
                      perspectiveRatio:
                        0.5 + (this.transform.cameraToCenterDistance / w) * 0.5,
                      isOccluded: !1,
                      signedDistanceFromCamera: w,
                    };
                  }
                  {
                    const g = this.transform.projectTileCoordinates(e, i, l, u);
                    return {
                      x: ((g.point.x + 1) / 2) * this.transform.width + hn,
                      y: ((1 - g.point.y) / 2) * this.transform.height + hn,
                      perspectiveRatio:
                        0.5 +
                        (this.transform.cameraToCenterDistance /
                          g.signedDistanceFromCamera) *
                          0.5,
                      isOccluded: g.isOccluded,
                      signedDistanceFromCamera: g.signedDistanceFromCamera,
                    };
                  }
                }
                getPerspectiveRatio(e, i, l, u) {
                  const d = this.transform.projectTileCoordinates(e, i, l, u);
                  return (
                    0.5 +
                    (this.transform.cameraToCenterDistance /
                      d.signedDistanceFromCamera) *
                      0.5
                  );
                }
                isOffscreen(e, i, l, u) {
                  return (
                    l < hn ||
                    e >= this.screenRightBoundary ||
                    u < hn ||
                    i > this.screenBottomBoundary
                  );
                }
                isInsideGrid(e, i, l, u) {
                  return (
                    l >= 0 &&
                    e < this.gridRightBoundary &&
                    u >= 0 &&
                    i < this.gridBottomBoundary
                  );
                }
                getViewportMatrix() {
                  const e = s.am([]);
                  return s.N(e, e, [-100, -100, 0]), e;
                }
                _projectCollisionBox(e, i, l, u, d, g, w, S, k, z, V) {
                  let F = 1,
                    $ = 0,
                    J = 0,
                    ae = 1;
                  const oe = e.anchorPointX + w[0],
                    se = e.anchorPointY + w[1];
                  if (g && !d) {
                    const Ht = this.projectAndGetPerspectiveRatio(
                        oe + 1,
                        se,
                        u,
                        k,
                        V
                      ),
                      Pt = Ht.x - S.x,
                      yr =
                        Math.atan((Ht.y - S.y) / Pt) + (Pt < 0 ? Math.PI : 0),
                      tn = Math.sin(yr),
                      Ln = Math.cos(yr);
                    (F = Ln), ($ = tn), (J = -tn), (ae = Ln);
                  } else if (!g && d) {
                    const Ht = Qt(this.transform);
                    (F = Ht.vecEast[0]),
                      ($ = Ht.vecEast[1]),
                      (J = Ht.vecSouth[0]),
                      (ae = Ht.vecSouth[1]);
                  }
                  let fe = S.x,
                    be = S.y,
                    pe = i;
                  d &&
                    ((fe = oe),
                    (be = se),
                    (pe = Math.pow(2, -(this.transform.zoom - l.overscaledZ))),
                    (pe *= this.transform.getPitchedTextCorrection(oe, se, u)),
                    z ||
                      (pe *= s.ai(
                        0.5 +
                          (S.signedDistanceFromCamera /
                            this.transform.cameraToCenterDistance) *
                            0.5,
                        0,
                        4
                      ))),
                    z &&
                      ((fe += F * z.x * pe + J * z.y * pe),
                      (be += $ * z.x * pe + ae * z.y * pe));
                  const we = e.x1 * pe,
                    Pe = e.x2 * pe,
                    ve = (we + Pe) / 2,
                    Re = e.y1 * pe,
                    it = e.y2 * pe,
                    Qe = (Re + it) / 2,
                    tt = [
                      { offsetX: we, offsetY: Re },
                      { offsetX: ve, offsetY: Re },
                      { offsetX: Pe, offsetY: Re },
                      { offsetX: Pe, offsetY: Qe },
                      { offsetX: Pe, offsetY: it },
                      { offsetX: ve, offsetY: it },
                      { offsetX: we, offsetY: it },
                      { offsetX: we, offsetY: Qe },
                    ];
                  let ot = [];
                  for (const { offsetX: Ht, offsetY: Pt } of tt)
                    ot.push(
                      new s.P(fe + F * Ht + J * Pt, be + $ * Ht + ae * Pt)
                    );
                  let Zt = !1;
                  if (d) {
                    const Ht = ot.map((Pt) =>
                      this.projectAndGetPerspectiveRatio(Pt.x, Pt.y, u, k, V)
                    );
                    (Zt = Ht.some((Pt) => !Pt.isOccluded)),
                      (ot = Ht.map((Pt) => new s.P(Pt.x, Pt.y)));
                  } else Zt = !0;
                  return { box: s.aE(ot), allPointsOccluded: !Zt };
                }
              }
              class li {
                constructor(e, i, l, u) {
                  (this.opacity = e
                    ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i)))
                    : u && l
                    ? 1
                    : 0),
                    (this.placed = l);
                }
                isHidden() {
                  return this.opacity === 0 && !this.placed;
                }
              }
              class ii {
                constructor(e, i, l, u, d) {
                  (this.text = new li(e ? e.text : null, i, l, d)),
                    (this.icon = new li(e ? e.icon : null, i, u, d));
                }
                isHidden() {
                  return this.text.isHidden() && this.icon.isHidden();
                }
              }
              class pi {
                constructor(e, i, l) {
                  (this.text = e), (this.icon = i), (this.skipFade = l);
                }
              }
              class Qi {
                constructor(e, i, l, u, d) {
                  (this.bucketInstanceId = e),
                    (this.featureIndex = i),
                    (this.sourceLayerIndex = l),
                    (this.bucketIndex = u),
                    (this.tileID = d);
                }
              }
              class xi {
                constructor(e) {
                  (this.crossSourceCollisions = e),
                    (this.maxGroupID = 0),
                    (this.collisionGroups = {});
                }
                get(e) {
                  if (this.crossSourceCollisions)
                    return { ID: 0, predicate: null };
                  if (!this.collisionGroups[e]) {
                    const i = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                      ID: i,
                      predicate: (l) => l.collisionGroupID === i,
                    };
                  }
                  return this.collisionGroups[e];
                }
              }
              function Hi(h, e, i, l, u) {
                const { horizontalAlign: d, verticalAlign: g } = s.aL(h);
                return new s.P(
                  -(d - 0.5) * e + l[0] * u,
                  -(g - 0.5) * i + l[1] * u
                );
              }
              class ma {
                constructor(e, i, l, u, d) {
                  (this.transform = e.clone()),
                    (this.terrain = i),
                    (this.collisionIndex = new Qn(this.transform)),
                    (this.placements = {}),
                    (this.opacities = {}),
                    (this.variableOffsets = {}),
                    (this.stale = !1),
                    (this.commitTime = 0),
                    (this.fadeDuration = l),
                    (this.retainedQueryData = {}),
                    (this.collisionGroups = new xi(u)),
                    (this.collisionCircleArrays = {}),
                    (this.collisionBoxArrays = new Map()),
                    (this.prevPlacement = d),
                    d && (d.prevPlacement = void 0),
                    (this.placedOrientations = {});
                }
                _getTerrainElevationFunc(e) {
                  const i = this.terrain;
                  return i ? (l, u) => i.getElevation(e, l, u) : null;
                }
                getBucketParts(e, i, l, u) {
                  const d = l.getBucket(i),
                    g = l.latestFeatureIndex;
                  if (!d || !g || i.id !== d.layerIds[0]) return;
                  const w = l.collisionBoxArray,
                    S = d.layers[0].layout,
                    k = d.layers[0].paint,
                    z = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
                    V = l.tileSize / s.a3,
                    F = l.tileID.toUnwrapped(),
                    $ = S.get("text-rotation-alignment") === "map",
                    J = s.aG(l, 1, this.transform.zoom),
                    ae = s.aH(
                      this.collisionIndex.transform,
                      l,
                      k.get("text-translate"),
                      k.get("text-translate-anchor")
                    ),
                    oe = s.aH(
                      this.collisionIndex.transform,
                      l,
                      k.get("icon-translate"),
                      k.get("icon-translate-anchor")
                    ),
                    se = Pn($, this.transform, J);
                  this.retainedQueryData[d.bucketInstanceId] = new Qi(
                    d.bucketInstanceId,
                    g,
                    d.sourceLayerIndex,
                    d.index,
                    l.tileID
                  );
                  const fe = {
                    bucket: d,
                    layout: S,
                    translationText: ae,
                    translationIcon: oe,
                    unwrappedTileID: F,
                    pitchedLabelPlaneMatrix: se,
                    scale: z,
                    textPixelRatio: V,
                    holdingForFade: l.holdingForSymbolFade(),
                    collisionBoxArray: w,
                    partiallyEvaluatedTextSize: s.ar(
                      d.textSizeData,
                      this.transform.zoom
                    ),
                    collisionGroup: this.collisionGroups.get(d.sourceID),
                  };
                  if (u)
                    for (const be of d.sortKeyRanges) {
                      const {
                        sortKey: pe,
                        symbolInstanceStart: we,
                        symbolInstanceEnd: Pe,
                      } = be;
                      e.push({
                        sortKey: pe,
                        symbolInstanceStart: we,
                        symbolInstanceEnd: Pe,
                        parameters: fe,
                      });
                    }
                  else
                    e.push({
                      symbolInstanceStart: 0,
                      symbolInstanceEnd: d.symbolInstances.length,
                      parameters: fe,
                    });
                }
                attemptAnchorPlacement(
                  e,
                  i,
                  l,
                  u,
                  d,
                  g,
                  w,
                  S,
                  k,
                  z,
                  V,
                  F,
                  $,
                  J,
                  ae,
                  oe,
                  se,
                  fe,
                  be,
                  pe
                ) {
                  const we = s.aI[e.textAnchor],
                    Pe = [e.textOffset0, e.textOffset1],
                    ve = Hi(we, l, u, Pe, d),
                    Re = this.collisionIndex.placeCollisionBox(
                      i,
                      F,
                      S,
                      k,
                      z,
                      w,
                      g,
                      oe,
                      V.predicate,
                      be,
                      ve,
                      pe
                    );
                  if (
                    (!fe ||
                      this.collisionIndex.placeCollisionBox(
                        fe,
                        F,
                        S,
                        k,
                        z,
                        w,
                        g,
                        se,
                        V.predicate,
                        be,
                        ve,
                        pe
                      ).placeable) &&
                    Re.placeable
                  ) {
                    let it;
                    if (
                      (this.prevPlacement &&
                        this.prevPlacement.variableOffsets[$.crossTileID] &&
                        this.prevPlacement.placements[$.crossTileID] &&
                        this.prevPlacement.placements[$.crossTileID].text &&
                        (it =
                          this.prevPlacement.variableOffsets[$.crossTileID]
                            .anchor),
                      $.crossTileID === 0)
                    )
                      throw new Error("symbolInstance.crossTileID can't be 0");
                    return (
                      (this.variableOffsets[$.crossTileID] = {
                        textOffset: Pe,
                        width: l,
                        height: u,
                        anchor: we,
                        textBoxScale: d,
                        prevAnchor: it,
                      }),
                      this.markUsedJustification(J, we, $, ae),
                      J.allowVerticalPlacement &&
                        (this.markUsedOrientation(J, ae, $),
                        (this.placedOrientations[$.crossTileID] = ae)),
                      { shift: ve, placedGlyphBoxes: Re }
                    );
                  }
                }
                placeLayerBucketPart(e, i, l) {
                  const {
                      bucket: u,
                      layout: d,
                      translationText: g,
                      translationIcon: w,
                      unwrappedTileID: S,
                      pitchedLabelPlaneMatrix: k,
                      textPixelRatio: z,
                      holdingForFade: V,
                      collisionBoxArray: F,
                      partiallyEvaluatedTextSize: $,
                      collisionGroup: J,
                    } = e.parameters,
                    ae = d.get("text-optional"),
                    oe = d.get("icon-optional"),
                    se = s.aJ(d, "text-overlap", "text-allow-overlap"),
                    fe = se === "always",
                    be = s.aJ(d, "icon-overlap", "icon-allow-overlap"),
                    pe = be === "always",
                    we = d.get("text-rotation-alignment") === "map",
                    Pe = d.get("text-pitch-alignment") === "map",
                    ve = d.get("icon-text-fit") !== "none",
                    Re = d.get("symbol-z-order") === "viewport-y",
                    it = fe && (pe || !u.hasIconData() || oe),
                    Qe = pe && (fe || !u.hasTextData() || ae);
                  !u.collisionArrays && F && u.deserializeCollisionBoxes(F);
                  const tt = this.retainedQueryData[u.bucketInstanceId].tileID,
                    ot = this._getTerrainElevationFunc(tt),
                    Zt = this.transform.getFastPathSimpleProjectionMatrix(tt),
                    Ht = (Pt, yr, tn) => {
                      var Ln, cn;
                      if (i[Pt.crossTileID]) return;
                      if (V)
                        return void (this.placements[Pt.crossTileID] = new pi(
                          !1,
                          !1,
                          !1
                        ));
                      let Nn = !1,
                        ri = !1,
                        Un = !0,
                        gi = null,
                        Kn = {
                          box: null,
                          placeable: !1,
                          offscreen: null,
                          occluded: !1,
                        },
                        Ii = { placeable: !1 },
                        Jn = null,
                        fi = null,
                        Yi = null,
                        Ko = 0,
                        ao = 0,
                        Ua = 0;
                      yr.textFeatureIndex
                        ? (Ko = yr.textFeatureIndex)
                        : Pt.useRuntimeCollisionCircles &&
                          (Ko = Pt.featureIndex),
                        yr.verticalTextFeatureIndex &&
                          (ao = yr.verticalTextFeatureIndex);
                      const Jo = yr.textBox;
                      if (Jo) {
                        const Ki = (mi) => {
                            let ui = s.as.horizontal;
                            if (
                              u.allowVerticalPlacement &&
                              !mi &&
                              this.prevPlacement
                            ) {
                              const Mi =
                                this.prevPlacement.placedOrientations[
                                  Pt.crossTileID
                                ];
                              Mi &&
                                ((this.placedOrientations[Pt.crossTileID] = Mi),
                                (ui = Mi),
                                this.markUsedOrientation(u, ui, Pt));
                            }
                            return ui;
                          },
                          oo = (mi, ui) => {
                            if (
                              u.allowVerticalPlacement &&
                              Pt.numVerticalGlyphVertices > 0 &&
                              yr.verticalTextBox
                            ) {
                              for (const Mi of u.writingModes)
                                if (
                                  (Mi === s.as.vertical
                                    ? ((Kn = ui()), (Ii = Kn))
                                    : (Kn = mi()),
                                  Kn && Kn.placeable)
                                )
                                  break;
                            } else Kn = mi();
                          },
                          To = Pt.textAnchorOffsetStartIndex,
                          ol = Pt.textAnchorOffsetEndIndex;
                        if (ol === To) {
                          const mi = (ui, Mi) => {
                            const Hn = this.collisionIndex.placeCollisionBox(
                              ui,
                              se,
                              z,
                              tt,
                              S,
                              Pe,
                              we,
                              g,
                              J.predicate,
                              ot,
                              void 0,
                              Zt
                            );
                            return (
                              Hn &&
                                Hn.placeable &&
                                (this.markUsedOrientation(u, Mi, Pt),
                                (this.placedOrientations[Pt.crossTileID] = Mi)),
                              Hn
                            );
                          };
                          oo(
                            () => mi(Jo, s.as.horizontal),
                            () => {
                              const ui = yr.verticalTextBox;
                              return u.allowVerticalPlacement &&
                                Pt.numVerticalGlyphVertices > 0 &&
                                ui
                                ? mi(ui, s.as.vertical)
                                : { box: null, offscreen: null };
                            }
                          ),
                            Ki(Kn && Kn.placeable);
                        } else {
                          let mi =
                            s.aI[
                              (cn =
                                (Ln = this.prevPlacement) === null ||
                                Ln === void 0
                                  ? void 0
                                  : Ln.variableOffsets[Pt.crossTileID]) ===
                                null || cn === void 0
                                ? void 0
                                : cn.anchor
                            ];
                          const ui = (Hn, ka, So) => {
                            const Wd = Hn.x2 - Hn.x1,
                              Xd = Hn.y2 - Hn.y1,
                              Yd = Pt.textBoxScale,
                              es = ve && be === "never" ? ka : null;
                            let ts = null,
                              Au = se === "never" ? 1 : 2,
                              ic = "never";
                            mi && Au++;
                            for (let ku = 0; ku < Au; ku++) {
                              for (let so = To; so < ol; so++) {
                                const Co = u.textAnchorOffsets.get(so);
                                if (mi && Co.textAnchor !== mi) continue;
                                const ac = this.attemptAnchorPlacement(
                                  Co,
                                  Hn,
                                  Wd,
                                  Xd,
                                  Yd,
                                  we,
                                  Pe,
                                  z,
                                  tt,
                                  S,
                                  J,
                                  ic,
                                  Pt,
                                  u,
                                  So,
                                  g,
                                  w,
                                  es,
                                  ot
                                );
                                if (
                                  ac &&
                                  ((ts = ac.placedGlyphBoxes),
                                  ts && ts.placeable)
                                )
                                  return (Nn = !0), (gi = ac.shift), ts;
                              }
                              mi ? (mi = null) : (ic = se);
                            }
                            return (
                              l &&
                                !ts &&
                                (ts = {
                                  box: this.collisionIndex.placeCollisionBox(
                                    Jo,
                                    "always",
                                    z,
                                    tt,
                                    S,
                                    Pe,
                                    we,
                                    g,
                                    J.predicate,
                                    ot,
                                    void 0,
                                    Zt
                                  ).box,
                                  offscreen: !1,
                                  placeable: !1,
                                  occluded: !1,
                                }),
                              ts
                            );
                          };
                          oo(
                            () => ui(Jo, yr.iconBox, s.as.horizontal),
                            () => {
                              const Hn = yr.verticalTextBox;
                              return u.allowVerticalPlacement &&
                                (!Kn || !Kn.placeable) &&
                                Pt.numVerticalGlyphVertices > 0 &&
                                Hn
                                ? ui(Hn, yr.verticalIconBox, s.as.vertical)
                                : { box: null, occluded: !0, offscreen: null };
                            }
                          ),
                            Kn && ((Nn = Kn.placeable), (Un = Kn.offscreen));
                          const Mi = Ki(Kn && Kn.placeable);
                          if (!Nn && this.prevPlacement) {
                            const Hn =
                              this.prevPlacement.variableOffsets[
                                Pt.crossTileID
                              ];
                            Hn &&
                              ((this.variableOffsets[Pt.crossTileID] = Hn),
                              this.markUsedJustification(u, Hn.anchor, Pt, Mi));
                          }
                        }
                      }
                      if (
                        ((Jn = Kn),
                        (Nn = Jn && Jn.placeable),
                        (Un = Jn && Jn.offscreen),
                        Pt.useRuntimeCollisionCircles &&
                          Pt.centerJustifiedTextSymbolIndex >= 0)
                      ) {
                        const Ki = u.text.placedSymbolArray.get(
                            Pt.centerJustifiedTextSymbolIndex
                          ),
                          oo = s.at(u.textSizeData, $, Ki),
                          To = d.get("text-padding");
                        (fi = this.collisionIndex.placeCollisionCircles(
                          se,
                          Ki,
                          u.lineVertexArray,
                          u.glyphOffsetArray,
                          oo,
                          S,
                          k,
                          l,
                          Pe,
                          J.predicate,
                          Pt.collisionCircleDiameter,
                          To,
                          g,
                          ot
                        )),
                          fi.circles.length &&
                            fi.collisionDetected &&
                            !l &&
                            s.w(
                              "Collisions detected, but collision boxes are not shown"
                            ),
                          (Nn =
                            fe ||
                            (fi.circles.length > 0 && !fi.collisionDetected)),
                          (Un = Un && fi.offscreen);
                      }
                      if (
                        (yr.iconFeatureIndex && (Ua = yr.iconFeatureIndex),
                        yr.iconBox)
                      ) {
                        const Ki = (oo) =>
                          this.collisionIndex.placeCollisionBox(
                            oo,
                            be,
                            z,
                            tt,
                            S,
                            Pe,
                            we,
                            w,
                            J.predicate,
                            ot,
                            ve && gi ? gi : void 0,
                            Zt
                          );
                        Ii && Ii.placeable && yr.verticalIconBox
                          ? ((Yi = Ki(yr.verticalIconBox)), (ri = Yi.placeable))
                          : ((Yi = Ki(yr.iconBox)), (ri = Yi.placeable)),
                          (Un = Un && Yi.offscreen);
                      }
                      const Ps =
                          ae ||
                          (Pt.numHorizontalGlyphVertices === 0 &&
                            Pt.numVerticalGlyphVertices === 0),
                        Qo = oe || Pt.numIconVertices === 0;
                      Ps || Qo
                        ? Qo
                          ? Ps || (ri = ri && Nn)
                          : (Nn = ri && Nn)
                        : (ri = Nn = ri && Nn);
                      const ia = ri && Yi.placeable;
                      if (
                        (Nn &&
                          Jn.placeable &&
                          this.collisionIndex.insertCollisionBox(
                            Jn.box,
                            se,
                            d.get("text-ignore-placement"),
                            u.bucketInstanceId,
                            Ii && Ii.placeable && ao ? ao : Ko,
                            J.ID
                          ),
                        ia &&
                          this.collisionIndex.insertCollisionBox(
                            Yi.box,
                            be,
                            d.get("icon-ignore-placement"),
                            u.bucketInstanceId,
                            Ua,
                            J.ID
                          ),
                        fi &&
                          Nn &&
                          this.collisionIndex.insertCollisionCircles(
                            fi.circles,
                            se,
                            d.get("text-ignore-placement"),
                            u.bucketInstanceId,
                            Ko,
                            J.ID
                          ),
                        l &&
                          this.storeCollisionData(
                            u.bucketInstanceId,
                            tn,
                            yr,
                            Jn,
                            Yi,
                            fi
                          ),
                        Pt.crossTileID === 0)
                      )
                        throw new Error(
                          "symbolInstance.crossTileID can't be 0"
                        );
                      if (u.bucketInstanceId === 0)
                        throw new Error("bucket.bucketInstanceId can't be 0");
                      (this.placements[Pt.crossTileID] = new pi(
                        (Nn || it) && !(Jn != null && Jn.occluded),
                        (ri || Qe) && !(Yi != null && Yi.occluded),
                        Un || u.justReloaded
                      )),
                        (i[Pt.crossTileID] = !0);
                    };
                  if (Re) {
                    if (e.symbolInstanceStart !== 0)
                      throw new Error("bucket.bucketInstanceId should be 0");
                    const Pt = u.getSortedSymbolIndexes(
                      -this.transform.bearingInRadians
                    );
                    for (let yr = Pt.length - 1; yr >= 0; --yr) {
                      const tn = Pt[yr];
                      Ht(u.symbolInstances.get(tn), u.collisionArrays[tn], tn);
                    }
                  } else for (let Pt = e.symbolInstanceStart; Pt < e.symbolInstanceEnd; Pt++) Ht(u.symbolInstances.get(Pt), u.collisionArrays[Pt], Pt);
                  u.justReloaded = !1;
                }
                storeCollisionData(e, i, l, u, d, g) {
                  if (l.textBox || l.iconBox) {
                    let w, S;
                    this.collisionBoxArrays.has(e)
                      ? (w = this.collisionBoxArrays.get(e))
                      : ((w = new Map()), this.collisionBoxArrays.set(e, w)),
                      w.has(i)
                        ? (S = w.get(i))
                        : ((S = { text: null, icon: null }), w.set(i, S)),
                      l.textBox && (S.text = u.box),
                      l.iconBox && (S.icon = d.box);
                  }
                  if (g) {
                    let w = this.collisionCircleArrays[e];
                    w === void 0 && (w = this.collisionCircleArrays[e] = []);
                    for (let S = 0; S < g.circles.length; S += 4)
                      w.push(g.circles[S + 0] - hn),
                        w.push(g.circles[S + 1] - hn),
                        w.push(g.circles[S + 2]),
                        w.push(g.collisionDetected ? 1 : 0);
                  }
                }
                markUsedJustification(e, i, l, u) {
                  let d;
                  d =
                    u === s.as.vertical
                      ? l.verticalPlacedTextSymbolIndex
                      : {
                          left: l.leftJustifiedTextSymbolIndex,
                          center: l.centerJustifiedTextSymbolIndex,
                          right: l.rightJustifiedTextSymbolIndex,
                        }[s.aK(i)];
                  const g = [
                    l.leftJustifiedTextSymbolIndex,
                    l.centerJustifiedTextSymbolIndex,
                    l.rightJustifiedTextSymbolIndex,
                    l.verticalPlacedTextSymbolIndex,
                  ];
                  for (const w of g)
                    w >= 0 &&
                      (e.text.placedSymbolArray.get(w).crossTileID =
                        d >= 0 && w !== d ? 0 : l.crossTileID);
                }
                markUsedOrientation(e, i, l) {
                  const u =
                      i === s.as.horizontal || i === s.as.horizontalOnly
                        ? i
                        : 0,
                    d = i === s.as.vertical ? i : 0,
                    g = [
                      l.leftJustifiedTextSymbolIndex,
                      l.centerJustifiedTextSymbolIndex,
                      l.rightJustifiedTextSymbolIndex,
                    ];
                  for (const w of g)
                    e.text.placedSymbolArray.get(w).placedOrientation = u;
                  l.verticalPlacedTextSymbolIndex &&
                    (e.text.placedSymbolArray.get(
                      l.verticalPlacedTextSymbolIndex
                    ).placedOrientation = d);
                }
                commit(e) {
                  (this.commitTime = e),
                    (this.zoomAtLastRecencyCheck = this.transform.zoom);
                  const i = this.prevPlacement;
                  let l = !1;
                  this.prevZoomAdjustment = i
                    ? i.zoomAdjustment(this.transform.zoom)
                    : 0;
                  const u = i ? i.symbolFadeChange(e) : 1,
                    d = i ? i.opacities : {},
                    g = i ? i.variableOffsets : {},
                    w = i ? i.placedOrientations : {};
                  for (const S in this.placements) {
                    const k = this.placements[S],
                      z = d[S];
                    z
                      ? ((this.opacities[S] = new ii(z, u, k.text, k.icon)),
                        (l =
                          l ||
                          k.text !== z.text.placed ||
                          k.icon !== z.icon.placed))
                      : ((this.opacities[S] = new ii(
                          null,
                          u,
                          k.text,
                          k.icon,
                          k.skipFade
                        )),
                        (l = l || k.text || k.icon));
                  }
                  for (const S in d) {
                    const k = d[S];
                    if (!this.opacities[S]) {
                      const z = new ii(k, u, !1, !1);
                      z.isHidden() ||
                        ((this.opacities[S] = z),
                        (l = l || k.text.placed || k.icon.placed));
                    }
                  }
                  for (const S in g)
                    this.variableOffsets[S] ||
                      !this.opacities[S] ||
                      this.opacities[S].isHidden() ||
                      (this.variableOffsets[S] = g[S]);
                  for (const S in w)
                    this.placedOrientations[S] ||
                      !this.opacities[S] ||
                      this.opacities[S].isHidden() ||
                      (this.placedOrientations[S] = w[S]);
                  if (i && i.lastPlacementChangeTime === void 0)
                    throw new Error(
                      "Last placement time for previous placement is not defined"
                    );
                  l
                    ? (this.lastPlacementChangeTime = e)
                    : typeof this.lastPlacementChangeTime != "number" &&
                      (this.lastPlacementChangeTime = i
                        ? i.lastPlacementChangeTime
                        : e);
                }
                updateLayerOpacities(e, i) {
                  const l = {};
                  for (const u of i) {
                    const d = u.getBucket(e);
                    d &&
                      u.latestFeatureIndex &&
                      e.id === d.layerIds[0] &&
                      this.updateBucketOpacities(
                        d,
                        u.tileID,
                        l,
                        u.collisionBoxArray
                      );
                  }
                }
                updateBucketOpacities(e, i, l, u) {
                  e.hasTextData() &&
                    (e.text.opacityVertexArray.clear(),
                    (e.text.hasVisibleVertices = !1)),
                    e.hasIconData() &&
                      (e.icon.opacityVertexArray.clear(),
                      (e.icon.hasVisibleVertices = !1)),
                    e.hasIconCollisionBoxData() &&
                      e.iconCollisionBox.collisionVertexArray.clear(),
                    e.hasTextCollisionBoxData() &&
                      e.textCollisionBox.collisionVertexArray.clear();
                  const d = e.layers[0],
                    g = d.layout,
                    w = new ii(null, 0, !1, !1, !0),
                    S = g.get("text-allow-overlap"),
                    k = g.get("icon-allow-overlap"),
                    z =
                      d._unevaluatedLayout.hasValue("text-variable-anchor") ||
                      d._unevaluatedLayout.hasValue(
                        "text-variable-anchor-offset"
                      ),
                    V = g.get("text-rotation-alignment") === "map",
                    F = g.get("text-pitch-alignment") === "map",
                    $ = g.get("icon-text-fit") !== "none",
                    J = new ii(
                      null,
                      0,
                      S && (k || !e.hasIconData() || g.get("icon-optional")),
                      k && (S || !e.hasTextData() || g.get("text-optional")),
                      !0
                    );
                  !e.collisionArrays &&
                    u &&
                    (e.hasIconCollisionBoxData() ||
                      e.hasTextCollisionBoxData()) &&
                    e.deserializeCollisionBoxes(u);
                  const ae = (se, fe, be) => {
                      for (let pe = 0; pe < fe / 4; pe++)
                        se.opacityVertexArray.emplaceBack(be);
                      se.hasVisibleVertices =
                        se.hasVisibleVertices || be !== $n;
                    },
                    oe = this.collisionBoxArrays.get(e.bucketInstanceId);
                  for (let se = 0; se < e.symbolInstances.length; se++) {
                    const fe = e.symbolInstances.get(se),
                      {
                        numHorizontalGlyphVertices: be,
                        numVerticalGlyphVertices: pe,
                        crossTileID: we,
                      } = fe;
                    let Pe = this.opacities[we];
                    l[we]
                      ? (Pe = w)
                      : Pe || ((Pe = J), (this.opacities[we] = Pe)),
                      (l[we] = !0);
                    const ve = fe.numIconVertices > 0,
                      Re = this.placedOrientations[fe.crossTileID],
                      it = Re === s.as.vertical,
                      Qe = Re === s.as.horizontal || Re === s.as.horizontalOnly;
                    if (be > 0 || pe > 0) {
                      const ot = In(Pe.text);
                      ae(e.text, be, it ? $n : ot),
                        ae(e.text, pe, Qe ? $n : ot);
                      const Zt = Pe.text.isHidden();
                      [
                        fe.rightJustifiedTextSymbolIndex,
                        fe.centerJustifiedTextSymbolIndex,
                        fe.leftJustifiedTextSymbolIndex,
                      ].forEach((yr) => {
                        yr >= 0 &&
                          (e.text.placedSymbolArray.get(yr).hidden =
                            Zt || it ? 1 : 0);
                      }),
                        fe.verticalPlacedTextSymbolIndex >= 0 &&
                          (e.text.placedSymbolArray.get(
                            fe.verticalPlacedTextSymbolIndex
                          ).hidden = Zt || Qe ? 1 : 0);
                      const Ht = this.variableOffsets[fe.crossTileID];
                      Ht && this.markUsedJustification(e, Ht.anchor, fe, Re);
                      const Pt = this.placedOrientations[fe.crossTileID];
                      Pt &&
                        (this.markUsedJustification(e, "left", fe, Pt),
                        this.markUsedOrientation(e, Pt, fe));
                    }
                    if (ve) {
                      const ot = In(Pe.icon),
                        Zt = !($ && fe.verticalPlacedIconSymbolIndex && it);
                      fe.placedIconSymbolIndex >= 0 &&
                        (ae(e.icon, fe.numIconVertices, Zt ? ot : $n),
                        (e.icon.placedSymbolArray.get(
                          fe.placedIconSymbolIndex
                        ).hidden = Pe.icon.isHidden())),
                        fe.verticalPlacedIconSymbolIndex >= 0 &&
                          (ae(e.icon, fe.numVerticalIconVertices, Zt ? $n : ot),
                          (e.icon.placedSymbolArray.get(
                            fe.verticalPlacedIconSymbolIndex
                          ).hidden = Pe.icon.isHidden()));
                    }
                    const tt =
                      oe && oe.has(se)
                        ? oe.get(se)
                        : { text: null, icon: null };
                    if (
                      e.hasIconCollisionBoxData() ||
                      e.hasTextCollisionBoxData()
                    ) {
                      const ot = e.collisionArrays[se];
                      if (ot) {
                        let Zt = new s.P(0, 0);
                        if (ot.textBox || ot.verticalTextBox) {
                          let Ht = !0;
                          if (z) {
                            const Pt = this.variableOffsets[we];
                            Pt
                              ? ((Zt = Hi(
                                  Pt.anchor,
                                  Pt.width,
                                  Pt.height,
                                  Pt.textOffset,
                                  Pt.textBoxScale
                                )),
                                V &&
                                  Zt._rotate(
                                    F
                                      ? -this.transform.bearingInRadians
                                      : this.transform.bearingInRadians
                                  ))
                              : (Ht = !1);
                          }
                          if (ot.textBox || ot.verticalTextBox) {
                            let Pt;
                            ot.textBox && (Pt = it),
                              ot.verticalTextBox && (Pt = Qe),
                              Ta(
                                e.textCollisionBox.collisionVertexArray,
                                Pe.text.placed,
                                !Ht || Pt,
                                tt.text,
                                Zt.x,
                                Zt.y
                              );
                          }
                        }
                        if (ot.iconBox || ot.verticalIconBox) {
                          const Ht = !!(!Qe && ot.verticalIconBox);
                          let Pt;
                          ot.iconBox && (Pt = Ht),
                            ot.verticalIconBox && (Pt = !Ht),
                            Ta(
                              e.iconCollisionBox.collisionVertexArray,
                              Pe.icon.placed,
                              Pt,
                              tt.icon,
                              $ ? Zt.x : 0,
                              $ ? Zt.y : 0
                            );
                        }
                      }
                    }
                  }
                  if (
                    (e.sortFeatures(-this.transform.bearingInRadians),
                    this.retainedQueryData[e.bucketInstanceId] &&
                      (this.retainedQueryData[
                        e.bucketInstanceId
                      ].featureSortOrder = e.featureSortOrder),
                    e.hasTextData() &&
                      e.text.opacityVertexBuffer &&
                      e.text.opacityVertexBuffer.updateData(
                        e.text.opacityVertexArray
                      ),
                    e.hasIconData() &&
                      e.icon.opacityVertexBuffer &&
                      e.icon.opacityVertexBuffer.updateData(
                        e.icon.opacityVertexArray
                      ),
                    e.hasIconCollisionBoxData() &&
                      e.iconCollisionBox.collisionVertexBuffer &&
                      e.iconCollisionBox.collisionVertexBuffer.updateData(
                        e.iconCollisionBox.collisionVertexArray
                      ),
                    e.hasTextCollisionBoxData() &&
                      e.textCollisionBox.collisionVertexBuffer &&
                      e.textCollisionBox.collisionVertexBuffer.updateData(
                        e.textCollisionBox.collisionVertexArray
                      ),
                    e.text.opacityVertexArray.length !==
                      e.text.layoutVertexArray.length / 4)
                  )
                    throw new Error(
                      `bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`
                    );
                  if (
                    e.icon.opacityVertexArray.length !==
                    e.icon.layoutVertexArray.length / 4
                  )
                    throw new Error(
                      `bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`
                    );
                  e.bucketInstanceId in this.collisionCircleArrays &&
                    ((e.collisionCircleArray =
                      this.collisionCircleArrays[e.bucketInstanceId]),
                    delete this.collisionCircleArrays[e.bucketInstanceId]);
                }
                symbolFadeChange(e) {
                  return this.fadeDuration === 0
                    ? 1
                    : (e - this.commitTime) / this.fadeDuration +
                        this.prevZoomAdjustment;
                }
                zoomAdjustment(e) {
                  return Math.max(0, (this.transform.zoom - e) / 1.5);
                }
                hasTransitions(e) {
                  return (
                    this.stale ||
                    e - this.lastPlacementChangeTime < this.fadeDuration
                  );
                }
                stillRecent(e, i) {
                  const l =
                    this.zoomAtLastRecencyCheck === i
                      ? 1 - this.zoomAdjustment(i)
                      : 1;
                  return (
                    (this.zoomAtLastRecencyCheck = i),
                    this.commitTime + this.fadeDuration * l > e
                  );
                }
                setStale() {
                  this.stale = !0;
                }
              }
              function Ta(h, e, i, l, u, d) {
                (l && l.length !== 0) || (l = [0, 0, 0, 0]);
                const g = l[0] - hn,
                  w = l[1] - hn,
                  S = l[2] - hn,
                  k = l[3] - hn;
                h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, w),
                  h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, w),
                  h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, k),
                  h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, k);
              }
              const Na = Math.pow(2, 25),
                Do = Math.pow(2, 24),
                Sa = Math.pow(2, 17),
                Ca = Math.pow(2, 16),
                vt = Math.pow(2, 9),
                Kt = Math.pow(2, 8),
                qr = Math.pow(2, 1);
              function In(h) {
                if (h.opacity === 0 && !h.placed) return 0;
                if (h.opacity === 1 && h.placed) return 4294967295;
                const e = h.placed ? 1 : 0,
                  i = Math.floor(127 * h.opacity);
                return (
                  i * Na +
                  e * Do +
                  i * Sa +
                  e * Ca +
                  i * vt +
                  e * Kt +
                  i * qr +
                  e
                );
              }
              const $n = 0;
              class Ci {
                constructor(e) {
                  (this._sortAcrossTiles =
                    e.layout.get("symbol-z-order") !== "viewport-y" &&
                    !e.layout.get("symbol-sort-key").isConstant()),
                    (this._currentTileIndex = 0),
                    (this._currentPartIndex = 0),
                    (this._seenCrossTileIDs = {}),
                    (this._bucketParts = []);
                }
                continuePlacement(e, i, l, u, d) {
                  const g = this._bucketParts;
                  for (; this._currentTileIndex < e.length; )
                    if (
                      (i.getBucketParts(
                        g,
                        u,
                        e[this._currentTileIndex],
                        this._sortAcrossTiles
                      ),
                      this._currentTileIndex++,
                      d())
                    )
                      return !0;
                  for (
                    this._sortAcrossTiles &&
                    ((this._sortAcrossTiles = !1),
                    g.sort((w, S) => w.sortKey - S.sortKey));
                    this._currentPartIndex < g.length;

                  )
                    if (
                      (i.placeLayerBucketPart(
                        g[this._currentPartIndex],
                        this._seenCrossTileIDs,
                        l
                      ),
                      this._currentPartIndex++,
                      d())
                    )
                      return !0;
                  return !1;
                }
              }
              class Xn {
                constructor(e, i, l, u, d, g, w, S) {
                  (this.placement = new ma(e, i, g, w, S)),
                    (this._currentPlacementIndex = l.length - 1),
                    (this._forceFullPlacement = u),
                    (this._showCollisionBoxes = d),
                    (this._done = !1);
                }
                isDone() {
                  return this._done;
                }
                continuePlacement(e, i, l) {
                  const u = ne(),
                    d = () => !this._forceFullPlacement && ne() - u > 2;
                  for (; this._currentPlacementIndex >= 0; ) {
                    const g = i[e[this._currentPlacementIndex]],
                      w = this.placement.collisionIndex.transform.zoom;
                    if (
                      g.type === "symbol" &&
                      (!g.minzoom || g.minzoom <= w) &&
                      (!g.maxzoom || g.maxzoom > w)
                    ) {
                      if (
                        (this._inProgressLayer ||
                          (this._inProgressLayer = new Ci(g)),
                        this._inProgressLayer.continuePlacement(
                          l[g.source],
                          this.placement,
                          this._showCollisionBoxes,
                          g,
                          d
                        ))
                      )
                        return;
                      delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                  }
                  this._done = !0;
                }
                commit(e) {
                  return this.placement.commit(e), this.placement;
                }
              }
              const Mn = 512 / s.a3 / 2;
              class Vi {
                constructor(e, i, l) {
                  (this.tileID = e),
                    (this.bucketInstanceId = l),
                    (this._symbolsByKey = {});
                  const u = new Map();
                  for (let d = 0; d < i.length; d++) {
                    const g = i.get(d),
                      w = g.key,
                      S = u.get(w);
                    S ? S.push(g) : u.set(w, [g]);
                  }
                  for (const [d, g] of u) {
                    const w = {
                      positions: g.map((S) => ({
                        x: Math.floor(S.anchorX * Mn),
                        y: Math.floor(S.anchorY * Mn),
                      })),
                      crossTileIDs: g.map((S) => S.crossTileID),
                    };
                    if (w.positions.length > 128) {
                      const S = new s.aM(w.positions.length, 16, Uint16Array);
                      for (const { x: k, y: z } of w.positions) S.add(k, z);
                      S.finish(), delete w.positions, (w.index = S);
                    }
                    this._symbolsByKey[d] = w;
                  }
                }
                getScaledCoordinates(e, i) {
                  const { x: l, y: u, z: d } = this.tileID.canonical,
                    { x: g, y: w, z: S } = i.canonical,
                    k = Mn / Math.pow(2, S - d),
                    z = (w * s.a3 + e.anchorY) * k,
                    V = u * s.a3 * Mn;
                  return {
                    x: Math.floor((g * s.a3 + e.anchorX) * k - l * s.a3 * Mn),
                    y: Math.floor(z - V),
                  };
                }
                findMatches(e, i, l) {
                  const u =
                    this.tileID.canonical.z < i.canonical.z
                      ? 1
                      : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
                  for (let d = 0; d < e.length; d++) {
                    const g = e.get(d);
                    if (g.crossTileID) continue;
                    const w = this._symbolsByKey[g.key];
                    if (!w) continue;
                    const S = this.getScaledCoordinates(g, i);
                    if (w.index) {
                      const k = w.index
                        .range(S.x - u, S.y - u, S.x + u, S.y + u)
                        .sort();
                      for (const z of k) {
                        const V = w.crossTileIDs[z];
                        if (!l[V]) {
                          (l[V] = !0), (g.crossTileID = V);
                          break;
                        }
                      }
                    } else if (w.positions)
                      for (let k = 0; k < w.positions.length; k++) {
                        const z = w.positions[k],
                          V = w.crossTileIDs[k];
                        if (
                          Math.abs(z.x - S.x) <= u &&
                          Math.abs(z.y - S.y) <= u &&
                          !l[V]
                        ) {
                          (l[V] = !0), (g.crossTileID = V);
                          break;
                        }
                      }
                  }
                }
                getCrossTileIDsLists() {
                  return Object.values(this._symbolsByKey).map(
                    ({ crossTileIDs: e }) => e
                  );
                }
              }
              class Mr {
                constructor() {
                  this.maxCrossTileID = 0;
                }
                generate() {
                  return ++this.maxCrossTileID;
                }
              }
              class _r {
                constructor() {
                  (this.indexes = {}),
                    (this.usedCrossTileIDs = {}),
                    (this.lng = 0);
                }
                handleWrapJump(e) {
                  const i = Math.round((e - this.lng) / 360);
                  if (i !== 0)
                    for (const l in this.indexes) {
                      const u = this.indexes[l],
                        d = {};
                      for (const g in u) {
                        const w = u[g];
                        (w.tileID = w.tileID.unwrapTo(w.tileID.wrap + i)),
                          (d[w.tileID.key] = w);
                      }
                      this.indexes[l] = d;
                    }
                  this.lng = e;
                }
                addBucket(e, i, l) {
                  if (
                    this.indexes[e.overscaledZ] &&
                    this.indexes[e.overscaledZ][e.key]
                  ) {
                    if (
                      this.indexes[e.overscaledZ][e.key].bucketInstanceId ===
                      i.bucketInstanceId
                    )
                      return !1;
                    this.removeBucketCrossTileIDs(
                      e.overscaledZ,
                      this.indexes[e.overscaledZ][e.key]
                    );
                  }
                  for (let d = 0; d < i.symbolInstances.length; d++)
                    i.symbolInstances.get(d).crossTileID = 0;
                  this.usedCrossTileIDs[e.overscaledZ] ||
                    (this.usedCrossTileIDs[e.overscaledZ] = {});
                  const u = this.usedCrossTileIDs[e.overscaledZ];
                  for (const d in this.indexes) {
                    const g = this.indexes[d];
                    if (Number(d) > e.overscaledZ)
                      for (const w in g) {
                        const S = g[w];
                        S.tileID.isChildOf(e) &&
                          S.findMatches(i.symbolInstances, e, u);
                      }
                    else {
                      const w = g[e.scaledTo(Number(d)).key];
                      w && w.findMatches(i.symbolInstances, e, u);
                    }
                  }
                  for (let d = 0; d < i.symbolInstances.length; d++) {
                    const g = i.symbolInstances.get(d);
                    g.crossTileID ||
                      ((g.crossTileID = l.generate()), (u[g.crossTileID] = !0));
                  }
                  return (
                    this.indexes[e.overscaledZ] === void 0 &&
                      (this.indexes[e.overscaledZ] = {}),
                    (this.indexes[e.overscaledZ][e.key] = new Vi(
                      e,
                      i.symbolInstances,
                      i.bucketInstanceId
                    )),
                    !0
                  );
                }
                removeBucketCrossTileIDs(e, i) {
                  for (const l of i.getCrossTileIDsLists())
                    for (const u of l) delete this.usedCrossTileIDs[e][u];
                }
                removeStaleBuckets(e) {
                  let i = !1;
                  for (const l in this.indexes) {
                    const u = this.indexes[l];
                    for (const d in u)
                      e[u[d].bucketInstanceId] ||
                        (this.removeBucketCrossTileIDs(l, u[d]),
                        delete u[d],
                        (i = !0));
                  }
                  return i;
                }
              }
              class dn {
                constructor() {
                  (this.layerIndexes = {}),
                    (this.crossTileIDs = new Mr()),
                    (this.maxBucketInstanceId = 0),
                    (this.bucketsInCurrentPlacement = {});
                }
                addLayer(e, i, l) {
                  let u = this.layerIndexes[e.id];
                  u === void 0 && (u = this.layerIndexes[e.id] = new _r());
                  let d = !1;
                  const g = {};
                  u.handleWrapJump(l);
                  for (const w of i) {
                    const S = w.getBucket(e);
                    S &&
                      e.id === S.layerIds[0] &&
                      (S.bucketInstanceId ||
                        (S.bucketInstanceId = ++this.maxBucketInstanceId),
                      u.addBucket(w.tileID, S, this.crossTileIDs) && (d = !0),
                      (g[S.bucketInstanceId] = !0));
                  }
                  return u.removeStaleBuckets(g) && (d = !0), d;
                }
                pruneUnusedLayers(e) {
                  const i = {};
                  e.forEach((l) => {
                    i[l] = !0;
                  });
                  for (const l in this.layerIndexes)
                    i[l] || delete this.layerIndexes[l];
                }
              }
              var wn = "void main() {fragColor=vec4(1.0);}";
              const Cr = {
                prelude: Pr(
                  `#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`,
                  `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`
                ),
                projectionMercator: Pr(
                  "",
                  "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"
                ),
                projectionGlobe: Pr(
                  "",
                  `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY);
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`
                ),
                background: Pr(
                  `uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"
                ),
                backgroundPattern: Pr(
                  `uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"
                ),
                circle: Pr(
                  `in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`
                ),
                clippingMask: Pr(
                  wn,
                  "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"
                ),
                heatmap: Pr(
                  `uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`
                ),
                heatmapTexture: Pr(
                  `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`,
                  "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"
                ),
                collisionBox: Pr(
                  "in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}",
                  "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"
                ),
                collisionCircle: Pr(
                  "in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}",
                  "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"
                ),
                colorRelief: Pr(
                  `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"
                ),
                debug: Pr(
                  "uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}",
                  "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"
                ),
                depth: Pr(
                  wn,
                  `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`
                ),
                fill: Pr(
                  `#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`
                ),
                fillOutline: Pr(
                  `in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`
                ),
                fillOutlinePattern: Pr(
                  `uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`
                ),
                fillPattern: Pr(
                  `#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`
                ),
                fillExtrusion: Pr(
                  `in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`
                ),
                fillExtrusionPattern: Pr(
                  `uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`
                ),
                hillshadePrepare: Pr(
                  `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"
                ),
                hillshade: Pr(
                  `uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"
                ),
                line: Pr(
                  `uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`
                ),
                lineGradient: Pr(
                  `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`
                ),
                linePattern: Pr(
                  `#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`
                ),
                lineSDF: Pr(
                  `uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`
                ),
                lineGradientSDF: Pr(
                  `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`
                ),
                raster: Pr(
                  `uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`
                ),
                symbolIcon: Pr(
                  `uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`
                ),
                symbolSDF: Pr(
                  `#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`
                ),
                symbolTextAndIcon: Pr(
                  `#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
                  `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`
                ),
                terrain: Pr(
                  "uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}",
                  "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"
                ),
                terrainDepth: Pr(
                  "in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}",
                  "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"
                ),
                terrainCoords: Pr(
                  "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}",
                  "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"
                ),
                projectionErrorMeasurement: Pr(
                  "in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}",
                  "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"
                ),
                atmosphere: Pr(
                  `in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`,
                  "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"
                ),
                sky: Pr(
                  "uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}",
                  "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}"
                ),
              };
              function Pr(h, e) {
                const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                  l = e.match(/in ([\w]+) ([\w]+)/g),
                  u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
                  d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
                  g = d ? d.concat(u) : u,
                  w = {};
                return {
                  fragmentSource: (h = h.replace(
                    i,
                    (S, k, z, V, F) => (
                      (w[F] = !0),
                      k === "define"
                        ? `
#ifndef HAS_UNIFORM_u_${F}
in ${z} ${V} ${F};
#else
uniform ${z} ${V} u_${F};
#endif
`
                        : `
#ifdef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = u_${F};
#endif
`
                    )
                  )),
                  vertexSource: (e = e.replace(i, (S, k, z, V, F) => {
                    const $ = V === "float" ? "vec2" : "vec4",
                      J = F.match(/color/) ? "color" : $;
                    return w[F]
                      ? k === "define"
                        ? `
#ifndef HAS_UNIFORM_u_${F}
uniform lowp float u_${F}_t;
in ${z} ${$} a_${F};
out ${z} ${V} ${F};
#else
uniform ${z} ${V} u_${F};
#endif
`
                        : J === "vec4"
                        ? `
#ifndef HAS_UNIFORM_u_${F}
    ${F} = a_${F};
#else
    ${z} ${V} ${F} = u_${F};
#endif
`
                        : `
#ifndef HAS_UNIFORM_u_${F}
    ${F} = unpack_mix_${J}(a_${F}, u_${F}_t);
#else
    ${z} ${V} ${F} = u_${F};
#endif
`
                      : k === "define"
                      ? `
#ifndef HAS_UNIFORM_u_${F}
uniform lowp float u_${F}_t;
in ${z} ${$} a_${F};
#else
uniform ${z} ${V} u_${F};
#endif
`
                      : J === "vec4"
                      ? `
#ifndef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = a_${F};
#else
    ${z} ${V} ${F} = u_${F};
#endif
`
                      : `
#ifndef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = unpack_mix_${J}(a_${F}, u_${F}_t);
#else
    ${z} ${V} ${F} = u_${F};
#endif
`;
                  })),
                  staticAttributes: l,
                  staticUniforms: g,
                };
              }
              class Cn {
                constructor(e, i, l) {
                  (this.vertexBuffer = e),
                    (this.indexBuffer = i),
                    (this.segments = l);
                }
                destroy() {
                  this.vertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.segments.destroy(),
                    (this.vertexBuffer = null),
                    (this.indexBuffer = null),
                    (this.segments = null);
                }
              }
              var Vn = s.aN([{ name: "a_pos", type: "Int16", components: 2 }]);
              const kn = "#define PROJECTION_MERCATOR",
                Sn = "mercator";
              class Qr {
                constructor() {
                  this._cachedMesh = null;
                }
                get name() {
                  return "mercator";
                }
                get useSubdivision() {
                  return !1;
                }
                get shaderVariantName() {
                  return Sn;
                }
                get shaderDefine() {
                  return kn;
                }
                get shaderPreludeCode() {
                  return Cr.projectionMercator;
                }
                get vertexShaderPreludeCode() {
                  return Cr.projectionMercator.vertexSource;
                }
                get subdivisionGranularity() {
                  return s.aO.noSubdivision;
                }
                get useGlobeControls() {
                  return !1;
                }
                get transitionState() {
                  return 0;
                }
                get latitudeErrorCorrectionRadians() {
                  return 0;
                }
                destroy() {}
                updateGPUdependent(e) {}
                getMeshFromTileID(e, i, l, u, d) {
                  if (this._cachedMesh) return this._cachedMesh;
                  const g = new s.aP();
                  g.emplaceBack(0, 0),
                    g.emplaceBack(s.a3, 0),
                    g.emplaceBack(0, s.a3),
                    g.emplaceBack(s.a3, s.a3);
                  const w = e.createVertexBuffer(g, Vn.members),
                    S = s.aQ.simpleSegment(0, 0, 4, 2),
                    k = new s.aR();
                  k.emplaceBack(1, 0, 2), k.emplaceBack(1, 2, 3);
                  const z = e.createIndexBuffer(k);
                  return (this._cachedMesh = new Cn(w, z, S)), this._cachedMesh;
                }
                recalculate() {}
                hasTransition() {
                  return !1;
                }
                setErrorQueryLatitudeDegrees(e) {}
              }
              class Ar {
                constructor(e = 0, i = 0, l = 0, u = 0) {
                  if (
                    isNaN(e) ||
                    e < 0 ||
                    isNaN(i) ||
                    i < 0 ||
                    isNaN(l) ||
                    l < 0 ||
                    isNaN(u) ||
                    u < 0
                  )
                    throw new Error(
                      "Invalid value for edge-insets, top, bottom, left and right must all be numbers"
                    );
                  (this.top = e),
                    (this.bottom = i),
                    (this.left = l),
                    (this.right = u);
                }
                interpolate(e, i, l) {
                  return (
                    i.top != null &&
                      e.top != null &&
                      (this.top = s.F.number(e.top, i.top, l)),
                    i.bottom != null &&
                      e.bottom != null &&
                      (this.bottom = s.F.number(e.bottom, i.bottom, l)),
                    i.left != null &&
                      e.left != null &&
                      (this.left = s.F.number(e.left, i.left, l)),
                    i.right != null &&
                      e.right != null &&
                      (this.right = s.F.number(e.right, i.right, l)),
                    this
                  );
                }
                getCenter(e, i) {
                  const l = s.ai((this.left + e - this.right) / 2, 0, e),
                    u = s.ai((this.top + i - this.bottom) / 2, 0, i);
                  return new s.P(l, u);
                }
                equals(e) {
                  return (
                    this.top === e.top &&
                    this.bottom === e.bottom &&
                    this.left === e.left &&
                    this.right === e.right
                  );
                }
                clone() {
                  return new Ar(this.top, this.bottom, this.left, this.right);
                }
                toJSON() {
                  return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right,
                  };
                }
              }
              function sn(h, e) {
                if (!h.renderWorldCopies || h.lngRange) return;
                const i = e.lng - h.center.lng;
                e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
              }
              function qn(h) {
                return Math.max(0, Math.floor(h));
              }
              class pn {
                constructor(e, i) {
                  var l;
                  (this._callbacks = e),
                    (this._tileSize = 512),
                    (this._renderWorldCopies =
                      (i == null ? void 0 : i.renderWorldCopies) === void 0 ||
                      !!(i != null && i.renderWorldCopies)),
                    (this._minZoom = (i == null ? void 0 : i.minZoom) || 0),
                    (this._maxZoom = (i == null ? void 0 : i.maxZoom) || 22),
                    (this._minPitch =
                      (i == null ? void 0 : i.minPitch) == null
                        ? 0
                        : i == null
                        ? void 0
                        : i.minPitch),
                    (this._maxPitch =
                      (i == null ? void 0 : i.maxPitch) == null
                        ? 60
                        : i == null
                        ? void 0
                        : i.maxPitch),
                    (this._constrain =
                      (l = i == null ? void 0 : i.constrain) !== null &&
                      l !== void 0
                        ? l
                        : this._callbacks.constrain),
                    this.setMaxBounds(),
                    (this._width = 0),
                    (this._height = 0),
                    (this._center = new s.U(0, 0)),
                    (this._elevation = 0),
                    (this._zoom = 0),
                    (this._tileZoom = qn(this._zoom)),
                    (this._scale = s.al(this._zoom)),
                    (this._bearingInRadians = 0),
                    (this._fovInRadians = 0.6435011087932844),
                    (this._pitchInRadians = 0),
                    (this._rollInRadians = 0),
                    (this._unmodified = !0),
                    (this._edgeInsets = new Ar()),
                    (this._minElevationForCurrentTile = 0),
                    (this._autoCalculateNearFarZ = !0);
                }
                apply(e, i, l) {
                  (this._latRange = e.latRange),
                    (this._lngRange = e.lngRange),
                    (this._width = e.width),
                    (this._height = e.height),
                    (this._center = e.center),
                    (this._elevation = e.elevation),
                    (this._minElevationForCurrentTile =
                      e.minElevationForCurrentTile),
                    (this._zoom = e.zoom),
                    (this._tileZoom = qn(this._zoom)),
                    (this._scale = s.al(this._zoom)),
                    (this._bearingInRadians = e.bearingInRadians),
                    (this._fovInRadians = e.fovInRadians),
                    (this._pitchInRadians = e.pitchInRadians),
                    (this._rollInRadians = e.rollInRadians),
                    (this._unmodified = e.unmodified),
                    (this._edgeInsets = new Ar(
                      e.padding.top,
                      e.padding.bottom,
                      e.padding.left,
                      e.padding.right
                    )),
                    (this._minZoom = e.minZoom),
                    (this._maxZoom = e.maxZoom),
                    (this._minPitch = e.minPitch),
                    (this._maxPitch = e.maxPitch),
                    (this._renderWorldCopies = e.renderWorldCopies),
                    (this._cameraToCenterDistance = e.cameraToCenterDistance),
                    (this._nearZ = e.nearZ),
                    (this._farZ = e.farZ),
                    (this._autoCalculateNearFarZ =
                      !l && e.autoCalculateNearFarZ),
                    i && this.constrainInternal(),
                    this._calcMatrices();
                }
                get pixelsToClipSpaceMatrix() {
                  return this._pixelsToClipSpaceMatrix;
                }
                get clipSpaceToPixelsMatrix() {
                  return this._clipSpaceToPixelsMatrix;
                }
                get minElevationForCurrentTile() {
                  return this._minElevationForCurrentTile;
                }
                setMinElevationForCurrentTile(e) {
                  this._minElevationForCurrentTile = e;
                }
                get tileSize() {
                  return this._tileSize;
                }
                get tileZoom() {
                  return this._tileZoom;
                }
                get scale() {
                  return this._scale;
                }
                get width() {
                  return this._width;
                }
                get height() {
                  return this._height;
                }
                get bearingInRadians() {
                  return this._bearingInRadians;
                }
                get lngRange() {
                  return this._lngRange;
                }
                get latRange() {
                  return this._latRange;
                }
                get pixelsToGLUnits() {
                  return this._pixelsToGLUnits;
                }
                get minZoom() {
                  return this._minZoom;
                }
                setMinZoom(e) {
                  this._minZoom !== e &&
                    ((this._minZoom = e),
                    this.setZoom(this.constrain(this._center, this.zoom).zoom));
                }
                get maxZoom() {
                  return this._maxZoom;
                }
                setMaxZoom(e) {
                  this._maxZoom !== e &&
                    ((this._maxZoom = e),
                    this.setZoom(this.constrain(this._center, this.zoom).zoom));
                }
                get minPitch() {
                  return this._minPitch;
                }
                setMinPitch(e) {
                  this._minPitch !== e &&
                    ((this._minPitch = e),
                    this.setPitch(Math.max(this.pitch, e)));
                }
                get maxPitch() {
                  return this._maxPitch;
                }
                setMaxPitch(e) {
                  this._maxPitch !== e &&
                    ((this._maxPitch = e),
                    this.setPitch(Math.min(this.pitch, e)));
                }
                get renderWorldCopies() {
                  return this._renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                  e === void 0 ? (e = !0) : e === null && (e = !1),
                    (this._renderWorldCopies = e);
                }
                get constrain() {
                  return this._constrain;
                }
                setConstrain(e) {
                  e || (e = this._callbacks.constrain),
                    (this._constrain = e),
                    this.constrainInternal(),
                    this._calcMatrices();
                }
                get worldSize() {
                  return this._tileSize * this._scale;
                }
                get centerOffset() {
                  return this.centerPoint._sub(this.size._div(2));
                }
                get size() {
                  return new s.P(this._width, this._height);
                }
                get bearing() {
                  return (this._bearingInRadians / Math.PI) * 180;
                }
                setBearing(e) {
                  const i = (s.V(e, -180, 180) * Math.PI) / 180;
                  var l, u, d, g, w, S, k, z, V;
                  this._bearingInRadians !== i &&
                    ((this._unmodified = !1),
                    (this._bearingInRadians = i),
                    this._calcMatrices(),
                    (this._rotationMatrix = N()),
                    (l = this._rotationMatrix),
                    (d = -this._bearingInRadians),
                    (g = (u = this._rotationMatrix)[0]),
                    (w = u[1]),
                    (S = u[2]),
                    (k = u[3]),
                    (z = Math.sin(d)),
                    (V = Math.cos(d)),
                    (l[0] = g * V + S * z),
                    (l[1] = w * V + k * z),
                    (l[2] = g * -z + S * V),
                    (l[3] = w * -z + k * V));
                }
                get rotationMatrix() {
                  return this._rotationMatrix;
                }
                get pitchInRadians() {
                  return this._pitchInRadians;
                }
                get pitch() {
                  return (this._pitchInRadians / Math.PI) * 180;
                }
                setPitch(e) {
                  const i =
                    (s.ai(e, this.minPitch, this.maxPitch) / 180) * Math.PI;
                  this._pitchInRadians !== i &&
                    ((this._unmodified = !1),
                    (this._pitchInRadians = i),
                    this._calcMatrices());
                }
                get rollInRadians() {
                  return this._rollInRadians;
                }
                get roll() {
                  return (this._rollInRadians / Math.PI) * 180;
                }
                setRoll(e) {
                  const i = (e / 180) * Math.PI;
                  this._rollInRadians !== i &&
                    ((this._unmodified = !1),
                    (this._rollInRadians = i),
                    this._calcMatrices());
                }
                get fovInRadians() {
                  return this._fovInRadians;
                }
                get fov() {
                  return s.aS(this._fovInRadians);
                }
                setFov(e) {
                  (e = s.ai(e, 0.1, 150)),
                    this.fov !== e &&
                      ((this._unmodified = !1),
                      (this._fovInRadians = s.ak(e)),
                      this._calcMatrices());
                }
                get zoom() {
                  return this._zoom;
                }
                setZoom(e) {
                  const i = this.constrain(this._center, e).zoom;
                  this._zoom !== i &&
                    ((this._unmodified = !1),
                    (this._zoom = i),
                    (this._tileZoom = Math.max(0, Math.floor(i))),
                    (this._scale = s.al(i)),
                    this.constrainInternal(),
                    this._calcMatrices());
                }
                get center() {
                  return this._center;
                }
                setCenter(e) {
                  (e.lat === this._center.lat && e.lng === this._center.lng) ||
                    ((this._unmodified = !1),
                    (this._center = e),
                    this.constrainInternal(),
                    this._calcMatrices());
                }
                get elevation() {
                  return this._elevation;
                }
                setElevation(e) {
                  e !== this._elevation &&
                    ((this._elevation = e),
                    this.constrainInternal(),
                    this._calcMatrices());
                }
                get padding() {
                  return this._edgeInsets.toJSON();
                }
                setPadding(e) {
                  this._edgeInsets.equals(e) ||
                    ((this._unmodified = !1),
                    this._edgeInsets.interpolate(this._edgeInsets, e, 1),
                    this._calcMatrices());
                }
                get centerPoint() {
                  return this._edgeInsets.getCenter(this._width, this._height);
                }
                get pixelsPerMeter() {
                  return this._pixelPerMeter;
                }
                get unmodified() {
                  return this._unmodified;
                }
                get cameraToCenterDistance() {
                  return this._cameraToCenterDistance;
                }
                get nearZ() {
                  return this._nearZ;
                }
                get farZ() {
                  return this._farZ;
                }
                get autoCalculateNearFarZ() {
                  return this._autoCalculateNearFarZ;
                }
                overrideNearFarZ(e, i) {
                  (this._autoCalculateNearFarZ = !1),
                    (this._nearZ = e),
                    (this._farZ = i),
                    this._calcMatrices();
                }
                clearNearFarZOverride() {
                  (this._autoCalculateNearFarZ = !0), this._calcMatrices();
                }
                isPaddingEqual(e) {
                  return this._edgeInsets.equals(e);
                }
                interpolatePadding(e, i, l) {
                  (this._unmodified = !1),
                    this._edgeInsets.interpolate(e, i, l),
                    this.constrainInternal(),
                    this._calcMatrices();
                }
                resize(e, i, l = !0) {
                  (this._width = e),
                    (this._height = i),
                    l && this.constrainInternal(),
                    this._calcMatrices();
                }
                getMaxBounds() {
                  return this._latRange &&
                    this._latRange.length === 2 &&
                    this._lngRange &&
                    this._lngRange.length === 2
                    ? new At(
                        [this._lngRange[0], this._latRange[0]],
                        [this._lngRange[1], this._latRange[1]]
                      )
                    : null;
                }
                setMaxBounds(e) {
                  e
                    ? ((this._lngRange = [e.getWest(), e.getEast()]),
                      (this._latRange = [e.getSouth(), e.getNorth()]),
                      this.constrainInternal())
                    : ((this._lngRange = null),
                      (this._latRange = [-s.aj, s.aj]));
                }
                getCameraQueryGeometry(e, i) {
                  if (i.length === 1) return [i[0], e];
                  {
                    const {
                      minX: l,
                      minY: u,
                      maxX: d,
                      maxY: g,
                    } = s.a6.fromPoints(i).extend(e);
                    return [
                      new s.P(l, u),
                      new s.P(d, u),
                      new s.P(d, g),
                      new s.P(l, g),
                      new s.P(l, u),
                    ];
                  }
                }
                constrainInternal() {
                  if (
                    !this.center ||
                    !this._width ||
                    !this._height ||
                    this._constraining
                  )
                    return;
                  this._constraining = !0;
                  const e = this._unmodified,
                    { center: i, zoom: l } = this.constrain(
                      this.center,
                      this.zoom
                    );
                  this.setCenter(i),
                    this.setZoom(l),
                    (this._unmodified = e),
                    (this._constraining = !1);
                }
                _calcMatrices() {
                  if (this._width && this._height) {
                    this._pixelsToGLUnits = [
                      2 / this._width,
                      -2 / this._height,
                    ];
                    let e = s.am(new Float64Array(16));
                    s.O(e, e, [this._width / 2, -this._height / 2, 1]),
                      s.N(e, e, [1, -1, 0]),
                      (this._clipSpaceToPixelsMatrix = e),
                      (e = s.am(new Float64Array(16))),
                      s.O(e, e, [1, -1, 1]),
                      s.N(e, e, [-1, -1, 0]),
                      s.O(e, e, [2 / this._width, 2 / this._height, 1]),
                      (this._pixelsToClipSpaceMatrix = e),
                      (this._cameraToCenterDistance =
                        (0.5 / Math.tan(this.fovInRadians / 2)) * this._height);
                  }
                  this._callbacks.calcMatrices();
                }
                calculateCenterFromCameraLngLatAlt(e, i, l, u) {
                  const d = l !== void 0 ? l : this.bearing,
                    g = (u = u !== void 0 ? u : this.pitch),
                    w = s.a5.fromLngLat(e, i),
                    S = -Math.cos(s.ak(g)),
                    k = Math.sin(s.ak(g)),
                    z = k * Math.sin(s.ak(d)),
                    V = -k * Math.cos(s.ak(d));
                  let F = this.elevation;
                  const $ = i - F;
                  let J;
                  S * $ >= 0 || Math.abs(S) < 0.1
                    ? ((J = 1e4), (F = i + J * S))
                    : (J = -$ / S);
                  let ae,
                    oe,
                    se = s.aT(1, w.y),
                    fe = 0;
                  do {
                    if (((fe += 1), fe > 10)) break;
                    (oe = J / se),
                      (ae = new s.a5(w.x + z * oe, w.y + V * oe)),
                      (se = 1 / ae.meterInMercatorCoordinateUnits());
                  } while (Math.abs(J - oe * se) > 1e-12);
                  return {
                    center: ae.toLngLat(),
                    elevation: F,
                    zoom: s.ao(
                      this.height /
                        2 /
                        Math.tan(this.fovInRadians / 2) /
                        oe /
                        this.tileSize
                    ),
                  };
                }
                recalculateZoomAndCenter(e) {
                  if (this.elevation - e == 0) return;
                  const i = s.an(1, this.center.lat) * this.worldSize,
                    l = this.cameraToCenterDistance / i,
                    u = s.a5.fromLngLat(this.center, this.elevation),
                    d = _e(
                      this.center,
                      this.elevation,
                      this.pitch,
                      this.bearing,
                      l
                    );
                  this._elevation = e;
                  const g = this.calculateCenterFromCameraLngLatAlt(
                    d.toLngLat(),
                    s.aT(d.z, u.y),
                    this.bearing,
                    this.pitch
                  );
                  (this._elevation = g.elevation),
                    (this._center = g.center),
                    this.setZoom(g.zoom);
                }
                getCameraPoint() {
                  const e =
                    Math.tan(this.pitchInRadians) *
                    (this.cameraToCenterDistance || 1);
                  return this.centerPoint.add(
                    new s.P(
                      e * Math.sin(this.rollInRadians),
                      e * Math.cos(this.rollInRadians)
                    )
                  );
                }
                getCameraAltitude() {
                  return (
                    (Math.cos(this.pitchInRadians) *
                      this._cameraToCenterDistance) /
                      this._pixelPerMeter +
                    this.elevation
                  );
                }
                getCameraLngLat() {
                  const e = s.an(1, this.center.lat) * this.worldSize;
                  return _e(
                    this.center,
                    this.elevation,
                    this.pitch,
                    this.bearing,
                    this.cameraToCenterDistance / e
                  ).toLngLat();
                }
                getMercatorTileCoordinates(e) {
                  if (!e) return [0, 0, 1, 1];
                  const i =
                    e.canonical.z >= 0
                      ? 1 << e.canonical.z
                      : Math.pow(2, e.canonical.z);
                  return [
                    e.canonical.x / i,
                    e.canonical.y / i,
                    1 / i / s.a3,
                    1 / i / s.a3,
                  ];
                }
              }
              class En {
                constructor(e, i) {
                  (this.min = e),
                    (this.max = i),
                    (this.center = s.aU([], s.aV([], this.min, this.max), 0.5));
                }
                quadrant(e) {
                  const i = [e % 2 == 0, e < 2],
                    l = s.aW(this.min),
                    u = s.aW(this.max);
                  for (let d = 0; d < i.length; d++)
                    (l[d] = i[d] ? this.min[d] : this.center[d]),
                      (u[d] = i[d] ? this.center[d] : this.max[d]);
                  return (u[2] = this.max[2]), new En(l, u);
                }
                distanceX(e) {
                  return (
                    Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                  );
                }
                distanceY(e) {
                  return (
                    Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                  );
                }
                intersectsFrustum(e) {
                  let i = !0;
                  for (let l = 0; l < e.planes.length; l++) {
                    const u = this.intersectsPlane(e.planes[l]);
                    if (u === 0) return 0;
                    u === 1 && (i = !1);
                  }
                  return i
                    ? 2
                    : e.aabb.min[0] > this.max[0] ||
                      e.aabb.min[1] > this.max[1] ||
                      e.aabb.min[2] > this.max[2] ||
                      e.aabb.max[0] < this.min[0] ||
                      e.aabb.max[1] < this.min[1] ||
                      e.aabb.max[2] < this.min[2]
                    ? 0
                    : 1;
                }
                intersectsPlane(e) {
                  let i = e[3],
                    l = e[3];
                  for (let u = 0; u < 3; u++)
                    e[u] > 0
                      ? ((i += e[u] * this.min[u]), (l += e[u] * this.max[u]))
                      : ((l += e[u] * this.min[u]), (i += e[u] * this.max[u]));
                  return i >= 0 ? 2 : l < 0 ? 0 : 1;
                }
              }
              class Yn {
                distanceToTile2d(e, i, l, u) {
                  const d = u.distanceX([e, i]),
                    g = u.distanceY([e, i]);
                  return Math.hypot(d, g);
                }
                getWrap(e, i, l) {
                  return l;
                }
                getTileBoundingVolume(e, i, l, u) {
                  var d, g;
                  let w = 0,
                    S = 0;
                  if (u != null && u.terrain) {
                    const z = new s.a0(e.z, i, e.z, e.x, e.y),
                      V = u.terrain.getMinMaxElevation(z);
                    (w =
                      (d = V.minElevation) !== null && d !== void 0
                        ? d
                        : Math.min(0, l)),
                      (S =
                        (g = V.maxElevation) !== null && g !== void 0
                          ? g
                          : Math.max(0, l));
                  }
                  const k = 1 << e.z;
                  return new En(
                    [i + e.x / k, e.y / k, w],
                    [i + (e.x + 1) / k, (e.y + 1) / k, S]
                  );
                }
                allowVariableZoom(e, i) {
                  const l =
                      (e.fov *
                        (Math.abs(Math.cos(e.rollInRadians)) * e.height +
                          Math.abs(Math.sin(e.rollInRadians)) * e.width)) /
                      e.height,
                    u = s.ai(78.5 - l / 2, 0, 60);
                  return !!i.terrain || e.pitch > u;
                }
                allowWorldCopies() {
                  return !0;
                }
                prepareNextFrame() {}
              }
              class _a {
                constructor(e, i, l) {
                  (this.points = e), (this.planes = i), (this.aabb = l);
                }
                static fromInvProjectionMatrix(e, i = 1, l = 0, u, d) {
                  const g = d
                      ? [
                          [6, 5, 4],
                          [0, 1, 2],
                          [0, 3, 7],
                          [2, 1, 5],
                          [3, 2, 6],
                          [0, 4, 5],
                        ]
                      : [
                          [0, 1, 2],
                          [6, 5, 4],
                          [0, 3, 7],
                          [2, 1, 5],
                          [3, 2, 6],
                          [0, 4, 5],
                        ],
                    w = Math.pow(2, l),
                    S = [
                      [-1, 1, -1, 1],
                      [1, 1, -1, 1],
                      [1, -1, -1, 1],
                      [-1, -1, -1, 1],
                      [-1, 1, 1, 1],
                      [1, 1, 1, 1],
                      [1, -1, 1, 1],
                      [-1, -1, 1, 1],
                    ].map((F) =>
                      (function ($, J, ae, oe) {
                        const se = s.aA([], $, J),
                          fe = (1 / se[3] / ae) * oe;
                        return s.a$(se, se, [fe, fe, 1 / se[3], fe]);
                      })(F, e, i, w)
                    );
                  u &&
                    (function (F, $, J, ae) {
                      const oe = ae ? 4 : 0,
                        se = ae ? 0 : 4;
                      let fe = 0;
                      const be = [],
                        pe = [];
                      for (let ve = 0; ve < 4; ve++) {
                        const Re = s.aX([], F[ve + se], F[ve + oe]),
                          it = s.b0(Re);
                        s.aU(Re, Re, 1 / it), be.push(it), pe.push(Re);
                      }
                      for (let ve = 0; ve < 4; ve++) {
                        const Re = s.b1(F[ve + oe], pe[ve], J);
                        fe =
                          Re !== null && Re >= 0
                            ? Math.max(fe, Re)
                            : Math.max(fe, be[ve]);
                      }
                      const we = (function (ve, Re) {
                          const it = s.aX([], ve[Re[0]], ve[Re[1]]),
                            Qe = s.aX([], ve[Re[2]], ve[Re[1]]),
                            tt = [0, 0, 0, 0];
                          return (
                            s.aY(tt, s.aZ([], it, Qe)),
                            (tt[3] = -s.a_(tt, ve[Re[0]])),
                            tt
                          );
                        })(F, $),
                        Pe = (function (ve, Re) {
                          const it = s.b2(ve),
                            Qe = s.b3([], ve, 1 / it),
                            tt = s.aX([], Re, s.aU([], Qe, s.a_(Re, Qe))),
                            ot = s.b2(tt);
                          if (ot > 0) {
                            const Zt = Math.sqrt(1 - Qe[3] * Qe[3]),
                              Ht = s.aU([], Qe, -Qe[3]),
                              Pt = s.aV([], Ht, s.aU([], tt, Zt / ot));
                            return s.b4(Re, Pt);
                          }
                          return null;
                        })(J, we);
                      if (Pe !== null) {
                        const ve = Pe / s.a_(pe[0], we);
                        fe = Math.min(fe, ve);
                      }
                      for (let ve = 0; ve < 4; ve++) {
                        const Re = Math.min(fe, be[ve]);
                        F[ve + se] = [
                          F[ve + oe][0] + pe[ve][0] * Re,
                          F[ve + oe][1] + pe[ve][1] * Re,
                          F[ve + oe][2] + pe[ve][2] * Re,
                          1,
                        ];
                      }
                    })(S, g[0], u, d);
                  const k = g.map((F) => {
                      const $ = s.aX([], S[F[0]], S[F[1]]),
                        J = s.aX([], S[F[2]], S[F[1]]),
                        ae = s.aY([], s.aZ([], $, J)),
                        oe = -s.a_(ae, S[F[1]]);
                      return ae.concat(oe);
                    }),
                    z = [
                      Number.POSITIVE_INFINITY,
                      Number.POSITIVE_INFINITY,
                      Number.POSITIVE_INFINITY,
                    ],
                    V = [
                      Number.NEGATIVE_INFINITY,
                      Number.NEGATIVE_INFINITY,
                      Number.NEGATIVE_INFINITY,
                    ];
                  for (const F of S)
                    for (let $ = 0; $ < 3; $++)
                      (z[$] = Math.min(z[$], F[$])),
                        (V[$] = Math.max(V[$], F[$]));
                  return new _a(S, k, new En(z, V));
                }
              }
              class ea {
                get pixelsToClipSpaceMatrix() {
                  return this._helper.pixelsToClipSpaceMatrix;
                }
                get clipSpaceToPixelsMatrix() {
                  return this._helper.clipSpaceToPixelsMatrix;
                }
                get pixelsToGLUnits() {
                  return this._helper.pixelsToGLUnits;
                }
                get centerOffset() {
                  return this._helper.centerOffset;
                }
                get size() {
                  return this._helper.size;
                }
                get rotationMatrix() {
                  return this._helper.rotationMatrix;
                }
                get centerPoint() {
                  return this._helper.centerPoint;
                }
                get pixelsPerMeter() {
                  return this._helper.pixelsPerMeter;
                }
                setMinZoom(e) {
                  this._helper.setMinZoom(e);
                }
                setMaxZoom(e) {
                  this._helper.setMaxZoom(e);
                }
                setMinPitch(e) {
                  this._helper.setMinPitch(e);
                }
                setMaxPitch(e) {
                  this._helper.setMaxPitch(e);
                }
                setRenderWorldCopies(e) {
                  this._helper.setRenderWorldCopies(e);
                }
                setBearing(e) {
                  this._helper.setBearing(e);
                }
                setPitch(e) {
                  this._helper.setPitch(e);
                }
                setRoll(e) {
                  this._helper.setRoll(e);
                }
                setFov(e) {
                  this._helper.setFov(e);
                }
                setZoom(e) {
                  this._helper.setZoom(e);
                }
                setCenter(e) {
                  this._helper.setCenter(e);
                }
                setElevation(e) {
                  this._helper.setElevation(e);
                }
                setMinElevationForCurrentTile(e) {
                  this._helper.setMinElevationForCurrentTile(e);
                }
                setPadding(e) {
                  this._helper.setPadding(e);
                }
                interpolatePadding(e, i, l) {
                  return this._helper.interpolatePadding(e, i, l);
                }
                isPaddingEqual(e) {
                  return this._helper.isPaddingEqual(e);
                }
                resize(e, i, l = !0) {
                  this._helper.resize(e, i, l);
                }
                getMaxBounds() {
                  return this._helper.getMaxBounds();
                }
                setMaxBounds(e) {
                  this._helper.setMaxBounds(e);
                }
                setConstrain(e) {
                  this._helper.setConstrain(e);
                }
                overrideNearFarZ(e, i) {
                  this._helper.overrideNearFarZ(e, i);
                }
                clearNearFarZOverride() {
                  this._helper.clearNearFarZOverride();
                }
                getCameraQueryGeometry(e) {
                  return this._helper.getCameraQueryGeometry(
                    this.getCameraPoint(),
                    e
                  );
                }
                get tileSize() {
                  return this._helper.tileSize;
                }
                get tileZoom() {
                  return this._helper.tileZoom;
                }
                get scale() {
                  return this._helper.scale;
                }
                get worldSize() {
                  return this._helper.worldSize;
                }
                get width() {
                  return this._helper.width;
                }
                get height() {
                  return this._helper.height;
                }
                get lngRange() {
                  return this._helper.lngRange;
                }
                get latRange() {
                  return this._helper.latRange;
                }
                get minZoom() {
                  return this._helper.minZoom;
                }
                get maxZoom() {
                  return this._helper.maxZoom;
                }
                get zoom() {
                  return this._helper.zoom;
                }
                get center() {
                  return this._helper.center;
                }
                get minPitch() {
                  return this._helper.minPitch;
                }
                get maxPitch() {
                  return this._helper.maxPitch;
                }
                get pitch() {
                  return this._helper.pitch;
                }
                get pitchInRadians() {
                  return this._helper.pitchInRadians;
                }
                get roll() {
                  return this._helper.roll;
                }
                get rollInRadians() {
                  return this._helper.rollInRadians;
                }
                get bearing() {
                  return this._helper.bearing;
                }
                get bearingInRadians() {
                  return this._helper.bearingInRadians;
                }
                get fov() {
                  return this._helper.fov;
                }
                get fovInRadians() {
                  return this._helper.fovInRadians;
                }
                get elevation() {
                  return this._helper.elevation;
                }
                get minElevationForCurrentTile() {
                  return this._helper.minElevationForCurrentTile;
                }
                get padding() {
                  return this._helper.padding;
                }
                get unmodified() {
                  return this._helper.unmodified;
                }
                get renderWorldCopies() {
                  return this._helper.renderWorldCopies;
                }
                get cameraToCenterDistance() {
                  return this._helper.cameraToCenterDistance;
                }
                get constrain() {
                  return this._helper.constrain;
                }
                get nearZ() {
                  return this._helper.nearZ;
                }
                get farZ() {
                  return this._helper.farZ;
                }
                get autoCalculateNearFarZ() {
                  return this._helper.autoCalculateNearFarZ;
                }
                setTransitionState(e, i) {}
                constructor(e) {
                  (this._posMatrixCache = new Map()),
                    (this._alignedPosMatrixCache = new Map()),
                    (this._fogMatrixCacheF32 = new Map()),
                    (this.defaultConstrain = (i, l) => {
                      l = s.ai(+l, this.minZoom, this.maxZoom);
                      const u = { center: new s.U(i.lng, i.lat), zoom: l };
                      let d = this._helper._lngRange;
                      if (!this._helper._renderWorldCopies && d === null) {
                        const pe = 179.9999999999;
                        d = [-pe, pe];
                      }
                      const g = this.tileSize * s.al(u.zoom);
                      let w = 0,
                        S = g,
                        k = 0,
                        z = g,
                        V = 0,
                        F = 0;
                      const { x: $, y: J } = this.size;
                      if (this._helper._latRange) {
                        const pe = this._helper._latRange;
                        (w = s.W(pe[1]) * g),
                          (S = s.W(pe[0]) * g),
                          S - w < J && (V = J / (S - w));
                      }
                      d &&
                        ((k = s.V(s.X(d[0]) * g, 0, g)),
                        (z = s.V(s.X(d[1]) * g, 0, g)),
                        z < k && (z += g),
                        z - k < $ && (F = $ / (z - k)));
                      const { x: ae, y: oe } = Se(g, i);
                      let se, fe;
                      const be = Math.max(F || 0, V || 0);
                      if (be) {
                        const pe = new s.P(
                          F ? (z + k) / 2 : ae,
                          V ? (S + w) / 2 : oe
                        );
                        return (
                          (u.center = We(g, pe).wrap()), (u.zoom += s.ao(be)), u
                        );
                      }
                      if (this._helper._latRange) {
                        const pe = J / 2;
                        oe - pe < w && (fe = w + pe),
                          oe + pe > S && (fe = S - pe);
                      }
                      if (d) {
                        const pe = (k + z) / 2;
                        let we = ae;
                        this._helper._renderWorldCopies &&
                          (we = s.V(ae, pe - g / 2, pe + g / 2));
                        const Pe = $ / 2;
                        we - Pe < k && (se = k + Pe),
                          we + Pe > z && (se = z - Pe);
                      }
                      if (se !== void 0 || fe !== void 0) {
                        const pe = new s.P(se ?? ae, fe ?? oe);
                        u.center = We(g, pe).wrap();
                      }
                      return u;
                    }),
                    (this._helper = new pn(
                      {
                        calcMatrices: () => {
                          this._calcMatrices();
                        },
                        constrain: (i, l) => this.defaultConstrain(i, l),
                      },
                      e
                    )),
                    (this._coveringTilesDetailsProvider = new Yn());
                }
                clone() {
                  const e = new ea();
                  return e.apply(this), e;
                }
                apply(e, i, l) {
                  this._helper.apply(e, i, l);
                }
                get cameraPosition() {
                  return this._cameraPosition;
                }
                get projectionMatrix() {
                  return this._projectionMatrix;
                }
                get modelViewProjectionMatrix() {
                  return this._viewProjMatrix;
                }
                get inverseProjectionMatrix() {
                  return this._invProjMatrix;
                }
                get mercatorMatrix() {
                  return this._mercatorMatrix;
                }
                getVisibleUnwrappedCoordinates(e) {
                  const i = [new s.b5(0, e)];
                  if (this._helper._renderWorldCopies) {
                    const l = this.screenPointToMercatorCoordinate(
                        new s.P(0, 0)
                      ),
                      u = this.screenPointToMercatorCoordinate(
                        new s.P(this._helper._width, 0)
                      ),
                      d = this.screenPointToMercatorCoordinate(
                        new s.P(this._helper._width, this._helper._height)
                      ),
                      g = this.screenPointToMercatorCoordinate(
                        new s.P(0, this._helper._height)
                      ),
                      w = Math.floor(Math.min(l.x, u.x, d.x, g.x)),
                      S = Math.floor(Math.max(l.x, u.x, d.x, g.x)),
                      k = 1;
                    for (let z = w - k; z <= S + k; z++)
                      z !== 0 && i.push(new s.b5(z, e));
                  }
                  return i;
                }
                getCameraFrustum() {
                  return _a.fromInvProjectionMatrix(
                    this._invViewProjMatrix,
                    this.worldSize
                  );
                }
                getClippingPlane() {
                  return null;
                }
                getCoveringTilesDetailsProvider() {
                  return this._coveringTilesDetailsProvider;
                }
                recalculateZoomAndCenter(e) {
                  const i = this.screenPointToLocation(this.centerPoint, e),
                    l = e
                      ? e.getElevationForLngLatZoom(i, this._helper._tileZoom)
                      : 0;
                  this._helper.recalculateZoomAndCenter(l);
                }
                setLocationAtPoint(e, i) {
                  const l = s.an(this.elevation, this.center.lat),
                    u = this.screenPointToMercatorCoordinateAtZ(i, l),
                    d = this.screenPointToMercatorCoordinateAtZ(
                      this.centerPoint,
                      l
                    ),
                    g = s.a5.fromLngLat(e),
                    w = new s.a5(g.x - (u.x - d.x), g.y - (u.y - d.y));
                  this.setCenter(w == null ? void 0 : w.toLngLat()),
                    this._helper._renderWorldCopies &&
                      this.setCenter(this.center.wrap());
                }
                locationToScreenPoint(e, i) {
                  return i
                    ? this.coordinatePoint(
                        s.a5.fromLngLat(e),
                        i.getElevationForLngLatZoom(e, this._helper._tileZoom),
                        this._pixelMatrix3D
                      )
                    : this.coordinatePoint(s.a5.fromLngLat(e));
                }
                screenPointToLocation(e, i) {
                  var l;
                  return (l = this.screenPointToMercatorCoordinate(e, i)) ===
                    null || l === void 0
                    ? void 0
                    : l.toLngLat();
                }
                screenPointToMercatorCoordinate(e, i) {
                  if (i) {
                    const l = i.pointCoordinate(e);
                    if (l != null) return l;
                  }
                  return this.screenPointToMercatorCoordinateAtZ(e);
                }
                screenPointToMercatorCoordinateAtZ(e, i) {
                  const l = i || 0,
                    u = [e.x, e.y, 0, 1],
                    d = [e.x, e.y, 1, 1];
                  s.aA(u, u, this._pixelMatrixInverse),
                    s.aA(d, d, this._pixelMatrixInverse);
                  const g = u[3],
                    w = d[3],
                    S = u[1] / g,
                    k = d[1] / w,
                    z = u[2] / g,
                    V = d[2] / w,
                    F = z === V ? 0 : (l - z) / (V - z);
                  return new s.a5(
                    s.F.number(u[0] / g, d[0] / w, F) / this.worldSize,
                    s.F.number(S, k, F) / this.worldSize,
                    l
                  );
                }
                coordinatePoint(e, i = 0, l = this._pixelMatrix) {
                  const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
                  return s.aA(u, u, l), new s.P(u[0] / u[3], u[1] / u[3]);
                }
                getBounds() {
                  const e = Math.max(0, this._helper._height / 2 - Ze(this));
                  return new At()
                    .extend(this.screenPointToLocation(new s.P(0, e)))
                    .extend(
                      this.screenPointToLocation(
                        new s.P(this._helper._width, e)
                      )
                    )
                    .extend(
                      this.screenPointToLocation(
                        new s.P(this._helper._width, this._helper._height)
                      )
                    )
                    .extend(
                      this.screenPointToLocation(
                        new s.P(0, this._helper._height)
                      )
                    );
                }
                isPointOnMapSurface(e, i) {
                  return i
                    ? i.pointCoordinate(e) != null
                    : e.y > this.height / 2 - Ze(this);
                }
                calculatePosMatrix(e, i = !1, l) {
                  var u;
                  const d =
                      (u = e.key) !== null && u !== void 0
                        ? u
                        : s.b6(
                            e.wrap,
                            e.canonical.z,
                            e.canonical.z,
                            e.canonical.x,
                            e.canonical.y
                          ),
                    g = i ? this._alignedPosMatrixCache : this._posMatrixCache;
                  if (g.has(d)) {
                    const k = g.get(d);
                    return l ? k.f32 : k.f64;
                  }
                  const w = Ct(e, this.worldSize);
                  s.Q(w, i ? this._alignedProjMatrix : this._viewProjMatrix, w);
                  const S = { f64: w, f32: new Float32Array(w) };
                  return g.set(d, S), l ? S.f32 : S.f64;
                }
                calculateFogMatrix(e) {
                  const i = e.key,
                    l = this._fogMatrixCacheF32;
                  if (l.has(i)) return l.get(i);
                  const u = Ct(e, this.worldSize);
                  return (
                    s.Q(u, this._fogMatrix, u),
                    l.set(i, new Float32Array(u)),
                    l.get(i)
                  );
                }
                calculateCenterFromCameraLngLatAlt(e, i, l, u) {
                  return this._helper.calculateCenterFromCameraLngLatAlt(
                    e,
                    i,
                    l,
                    u
                  );
                }
                _calculateNearFarZIfNeeded(e, i, l) {
                  if (!this._helper.autoCalculateNearFarZ) return;
                  const u = Math.min(
                      this.elevation,
                      this.minElevationForCurrentTile,
                      this.getCameraAltitude() - 100
                    ),
                    d = e - (u * this._helper._pixelPerMeter) / Math.cos(i),
                    g = u < 0 ? d : e,
                    w = Math.PI / 2 + this.pitchInRadians,
                    S =
                      ((s.ak(this.fov) *
                        (Math.abs(Math.cos(s.ak(this.roll))) * this.height +
                          Math.abs(Math.sin(s.ak(this.roll))) * this.width)) /
                        this.height) *
                      (0.5 + l.y / this.height),
                    k =
                      (Math.sin(S) * g) /
                      Math.sin(s.ai(Math.PI - w - S, 0.01, Math.PI - 0.01)),
                    z = Ze(this),
                    V = Math.atan(z / this._helper.cameraToCenterDistance),
                    F = s.ak(0.75),
                    $ = V > F ? 2 * V * (0.5 + l.y / (2 * z)) : F,
                    J =
                      (Math.sin($) * g) /
                      Math.sin(s.ai(Math.PI - w - $, 0.01, Math.PI - 0.01)),
                    ae = Math.min(k, J);
                  (this._helper._farZ =
                    1.01 * (Math.cos(Math.PI / 2 - i) * ae + g)),
                    (this._helper._nearZ = this._helper._height / 50);
                }
                _calcMatrices() {
                  if (!this._helper._height) return;
                  const e = this.centerOffset,
                    i = Se(this.worldSize, this.center),
                    l = i.x,
                    u = i.y;
                  this._helper._pixelPerMeter =
                    s.an(1, this.center.lat) * this.worldSize;
                  const d = s.ak(Math.min(this.pitch, de)),
                    g = Math.max(
                      this._helper.cameraToCenterDistance / 2,
                      this._helper.cameraToCenterDistance +
                        (this._helper._elevation *
                          this._helper._pixelPerMeter) /
                          Math.cos(d)
                    );
                  let w;
                  this._calculateNearFarZIfNeeded(g, d, e),
                    (w = new Float64Array(16)),
                    s.b7(
                      w,
                      this.fovInRadians,
                      this._helper._width / this._helper._height,
                      this._helper._nearZ,
                      this._helper._farZ
                    ),
                    (this._invProjMatrix = new Float64Array(16)),
                    s.au(this._invProjMatrix, w),
                    (w[8] = (2 * -e.x) / this._helper._width),
                    (w[9] = (2 * e.y) / this._helper._height),
                    (this._projectionMatrix = s.b8(w)),
                    s.O(w, w, [1, -1, 1]),
                    s.N(w, w, [0, 0, -this._helper.cameraToCenterDistance]),
                    s.b9(w, w, -this.rollInRadians),
                    s.ba(w, w, this.pitchInRadians),
                    s.b9(w, w, -this.bearingInRadians),
                    s.N(w, w, [-l, -u, 0]),
                    (this._mercatorMatrix = s.O([], w, [
                      this.worldSize,
                      this.worldSize,
                      this.worldSize,
                    ])),
                    s.O(w, w, [1, 1, this._helper._pixelPerMeter]),
                    (this._pixelMatrix = s.Q(
                      new Float64Array(16),
                      this.clipSpaceToPixelsMatrix,
                      w
                    )),
                    s.N(w, w, [0, 0, -this.elevation]),
                    (this._viewProjMatrix = w),
                    (this._invViewProjMatrix = s.au([], w));
                  const S = [0, 0, -1, 1];
                  s.aA(S, S, this._invViewProjMatrix),
                    (this._cameraPosition = [
                      S[0] / S[3],
                      S[1] / S[3],
                      S[2] / S[3],
                    ]),
                    (this._fogMatrix = new Float64Array(16)),
                    s.b7(
                      this._fogMatrix,
                      this.fovInRadians,
                      this.width / this.height,
                      g,
                      this._helper._farZ
                    ),
                    (this._fogMatrix[8] = (2 * -e.x) / this.width),
                    (this._fogMatrix[9] = (2 * e.y) / this.height),
                    s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
                    s.N(this._fogMatrix, this._fogMatrix, [
                      0,
                      0,
                      -this.cameraToCenterDistance,
                    ]),
                    s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
                    s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
                    s.b9(
                      this._fogMatrix,
                      this._fogMatrix,
                      -this.bearingInRadians
                    ),
                    s.N(this._fogMatrix, this._fogMatrix, [-l, -u, 0]),
                    s.O(this._fogMatrix, this._fogMatrix, [
                      1,
                      1,
                      this._helper._pixelPerMeter,
                    ]),
                    s.N(this._fogMatrix, this._fogMatrix, [
                      0,
                      0,
                      -this.elevation,
                    ]),
                    (this._pixelMatrix3D = s.Q(
                      new Float64Array(16),
                      this.clipSpaceToPixelsMatrix,
                      w
                    ));
                  const k = (this._helper._width % 2) / 2,
                    z = (this._helper._height % 2) / 2,
                    V = Math.cos(this.bearingInRadians),
                    F = Math.sin(-this.bearingInRadians),
                    $ = l - Math.round(l) + V * k + F * z,
                    J = u - Math.round(u) + V * z + F * k,
                    ae = new Float64Array(w);
                  if (
                    (s.N(ae, ae, [$ > 0.5 ? $ - 1 : $, J > 0.5 ? J - 1 : J, 0]),
                    (this._alignedProjMatrix = ae),
                    (w = s.au(new Float64Array(16), this._pixelMatrix)),
                    !w)
                  )
                    throw new Error("failed to invert matrix");
                  (this._pixelMatrixInverse = w), this._clearMatrixCaches();
                }
                _clearMatrixCaches() {
                  this._posMatrixCache.clear(),
                    this._alignedPosMatrixCache.clear(),
                    this._fogMatrixCacheF32.clear();
                }
                maxPitchScaleFactor() {
                  if (!this._pixelMatrixInverse) return 1;
                  const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                    i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
                  return (
                    s.aA(i, i, this._pixelMatrix)[3] /
                    this._helper.cameraToCenterDistance
                  );
                }
                getCameraPoint() {
                  return this._helper.getCameraPoint();
                }
                getCameraAltitude() {
                  return this._helper.getCameraAltitude();
                }
                getCameraLngLat() {
                  const e = s.an(1, this.center.lat) * this.worldSize;
                  return _e(
                    this.center,
                    this.elevation,
                    this.pitch,
                    this.bearing,
                    this._helper.cameraToCenterDistance / e
                  ).toLngLat();
                }
                lngLatToCameraDepth(e, i) {
                  const l = s.a5.fromLngLat(e),
                    u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
                  return s.aA(u, u, this._viewProjMatrix), u[2] / u[3];
                }
                getProjectionData(e) {
                  const {
                      overscaledTileID: i,
                      aligned: l,
                      applyTerrainMatrix: u,
                    } = e,
                    d = this._helper.getMercatorTileCoordinates(i),
                    g = i ? this.calculatePosMatrix(i, l, !0) : null;
                  let w;
                  return (
                    (w =
                      i && i.terrainRttPosMatrix32f && u
                        ? i.terrainRttPosMatrix32f
                        : g || s.bb()),
                    {
                      mainMatrix: w,
                      tileMercatorCoords: d,
                      clippingPlane: [0, 0, 0, 0],
                      projectionTransition: 0,
                      fallbackMatrix: w,
                    }
                  );
                }
                isLocationOccluded(e) {
                  return !1;
                }
                getPixelScale() {
                  return 1;
                }
                getCircleRadiusCorrection() {
                  return 1;
                }
                getPitchedTextCorrection(e, i, l) {
                  return 1;
                }
                transformLightDirection(e) {
                  return s.aW(e);
                }
                getRayDirectionFromPixel(e) {
                  throw new Error("Not implemented.");
                }
                projectTileCoordinates(e, i, l, u) {
                  const d = this.calculatePosMatrix(l);
                  let g;
                  u
                    ? ((g = [e, i, u(e, i), 1]), s.aA(g, g, d))
                    : ((g = [e, i, 0, 1]), Rn(g, g, d));
                  const w = g[3];
                  return {
                    point: new s.P(g[0] / w, g[1] / w),
                    signedDistanceFromCamera: w,
                    isOccluded: !1,
                  };
                }
                populateCache(e) {
                  for (const i of e) this.calculatePosMatrix(i);
                }
                getMatrixForModel(e, i) {
                  const l = s.a5.fromLngLat(e, i),
                    u = l.meterInMercatorCoordinateUnits(),
                    d = s.bc();
                  return (
                    s.N(d, d, [l.x, l.y, l.z]),
                    s.b9(d, d, Math.PI),
                    s.ba(d, d, Math.PI / 2),
                    s.O(d, d, [-u, u, u]),
                    d
                  );
                }
                getProjectionDataForCustomLayer(e = !0) {
                  const i = new s.a0(0, 0, 0, 0, 0),
                    l = this.getProjectionData({
                      overscaledTileID: i,
                      applyGlobeMatrix: e,
                    }),
                    u = Ct(i, this.worldSize);
                  s.Q(u, this._viewProjMatrix, u),
                    (l.tileMercatorCoords = [0, 0, 1, 1]);
                  const d = [
                      s.a3,
                      s.a3,
                      this.worldSize / this._helper.pixelsPerMeter,
                    ],
                    g = s.bd();
                  return (
                    s.O(g, u, d), (l.fallbackMatrix = g), (l.mainMatrix = g), l
                  );
                }
                getFastPathSimpleProjectionMatrix(e) {
                  return this.calculatePosMatrix(e);
                }
              }
              function Dn() {
                s.w(
                  "Map cannot fit within canvas with the given bounds, padding, and/or offset."
                );
              }
              function ga(h) {
                if (h.useSlerp)
                  if (h.k < 1) {
                    const e = s.be(
                        h.startEulerAngles.roll,
                        h.startEulerAngles.pitch,
                        h.startEulerAngles.bearing
                      ),
                      i = s.be(
                        h.endEulerAngles.roll,
                        h.endEulerAngles.pitch,
                        h.endEulerAngles.bearing
                      ),
                      l = new Float64Array(4);
                    s.bf(l, e, i, h.k);
                    const u = s.bg(l);
                    h.tr.setRoll(u.roll),
                      h.tr.setPitch(u.pitch),
                      h.tr.setBearing(u.bearing);
                  } else
                    h.tr.setRoll(h.endEulerAngles.roll),
                      h.tr.setPitch(h.endEulerAngles.pitch),
                      h.tr.setBearing(h.endEulerAngles.bearing);
                else
                  h.tr.setRoll(
                    s.F.number(
                      h.startEulerAngles.roll,
                      h.endEulerAngles.roll,
                      h.k
                    )
                  ),
                    h.tr.setPitch(
                      s.F.number(
                        h.startEulerAngles.pitch,
                        h.endEulerAngles.pitch,
                        h.k
                      )
                    ),
                    h.tr.setBearing(
                      s.F.number(
                        h.startEulerAngles.bearing,
                        h.endEulerAngles.bearing,
                        h.k
                      )
                    );
              }
              function ta(h, e, i, l, u) {
                const d = u.padding,
                  g = Se(u.worldSize, i.getNorthWest()),
                  w = Se(u.worldSize, i.getNorthEast()),
                  S = Se(u.worldSize, i.getSouthEast()),
                  k = Se(u.worldSize, i.getSouthWest()),
                  z = s.ak(-l),
                  V = g.rotate(z),
                  F = w.rotate(z),
                  $ = S.rotate(z),
                  J = k.rotate(z),
                  ae = new s.P(
                    Math.max(V.x, F.x, J.x, $.x),
                    Math.max(V.y, F.y, J.y, $.y)
                  ),
                  oe = new s.P(
                    Math.min(V.x, F.x, J.x, $.x),
                    Math.min(V.y, F.y, J.y, $.y)
                  ),
                  se = ae.sub(oe),
                  fe = (u.width - (d.left + d.right + e.left + e.right)) / se.x,
                  be =
                    (u.height - (d.top + d.bottom + e.top + e.bottom)) / se.y;
                if (be < 0 || fe < 0) return void Dn();
                const pe = Math.min(
                    s.ao(u.scale * Math.min(fe, be)),
                    h.maxZoom
                  ),
                  we = s.P.convert(h.offset),
                  Pe = new s.P(
                    (e.left - e.right) / 2,
                    (e.top - e.bottom) / 2
                  ).rotate(s.ak(l)),
                  ve = we.add(Pe).mult(u.scale / s.al(pe));
                return {
                  center: We(u.worldSize, g.add(S).div(2).sub(ve)),
                  zoom: pe,
                  bearing: l,
                };
              }
              class va {
                get useGlobeControls() {
                  return !1;
                }
                handlePanInertia(e, i) {
                  const l = e.mag(),
                    u = Math.abs(Ze(i));
                  return {
                    easingOffset: e.mult(Math.min((0.75 * u) / l, 1)),
                    easingCenter: i.center,
                  };
                }
                handleMapControlsRollPitchBearingZoom(e, i) {
                  e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
                    e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
                    e.rollDelta && i.setRoll(i.roll + e.rollDelta),
                    e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
                }
                handleMapControlsPan(e, i, l) {
                  e.around.distSqr(i.centerPoint) < 0.01 ||
                    i.setLocationAtPoint(l, e.around);
                }
                cameraForBoxAndBearing(e, i, l, u, d) {
                  return ta(e, i, l, u, d);
                }
                handleJumpToCenterZoom(e, i) {
                  e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) &&
                    e.setZoom(+i.zoom),
                    i.center !== void 0 && e.setCenter(s.U.convert(i.center));
                }
                handleEaseTo(e, i) {
                  const l = e.zoom,
                    u = e.padding,
                    d = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
                    g = {
                      roll: i.roll === void 0 ? e.roll : i.roll,
                      pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                      bearing: i.bearing === void 0 ? e.bearing : i.bearing,
                    },
                    w = i.zoom !== void 0,
                    S = !e.isPaddingEqual(i.padding);
                  let k = !1;
                  const z = w ? +i.zoom : e.zoom;
                  let V = e.centerPoint.add(i.offsetAsPoint);
                  const F = e.screenPointToLocation(V),
                    { center: $, zoom: J } = e.constrain(
                      s.U.convert(i.center || F),
                      z ?? l
                    );
                  sn(e, $);
                  const ae = Se(e.worldSize, F),
                    oe = Se(e.worldSize, $).sub(ae),
                    se = s.al(J - l);
                  return (
                    (k = J !== l),
                    {
                      easeFunc: (fe) => {
                        if (
                          (k && e.setZoom(s.F.number(l, J, fe)),
                          s.bh(d, g) ||
                            ga({
                              startEulerAngles: d,
                              endEulerAngles: g,
                              tr: e,
                              k: fe,
                              useSlerp: d.roll != g.roll,
                            }),
                          S &&
                            (e.interpolatePadding(u, i.padding, fe),
                            (V = e.centerPoint.add(i.offsetAsPoint))),
                          i.around)
                        )
                          e.setLocationAtPoint(i.around, i.aroundPoint);
                        else {
                          const be = s.al(e.zoom - l),
                            pe = J > l ? Math.min(2, se) : Math.max(0.5, se),
                            we = Math.pow(pe, 1 - fe),
                            Pe = We(
                              e.worldSize,
                              ae.add(oe.mult(fe * we)).mult(be)
                            );
                          e.setLocationAtPoint(
                            e.renderWorldCopies ? Pe.wrap() : Pe,
                            V
                          );
                        }
                      },
                      isZooming: k,
                      elevationCenter: $,
                    }
                  );
                }
                handleFlyTo(e, i) {
                  const l = i.zoom !== void 0,
                    u = e.zoom,
                    d = e.constrain(
                      s.U.convert(i.center || i.locationAtOffset),
                      l ? +i.zoom : u
                    ),
                    g = d.center,
                    w = d.zoom;
                  sn(e, g);
                  const S = Se(e.worldSize, i.locationAtOffset),
                    k = Se(e.worldSize, g).sub(S),
                    z = k.mag(),
                    V = s.al(w - u);
                  let F;
                  if (i.minZoom !== void 0) {
                    const $ = Math.min(+i.minZoom, u, w),
                      J = e.constrain(g, $).zoom;
                    F = s.al(J - u);
                  }
                  return {
                    easeFunc: ($, J, ae, oe) => {
                      e.setZoom($ === 1 ? w : u + s.ao(J));
                      const se =
                        $ === 1
                          ? g
                          : We(e.worldSize, S.add(k.mult(ae)).mult(J));
                      e.setLocationAtPoint(
                        e.renderWorldCopies ? se.wrap() : se,
                        oe
                      );
                    },
                    scaleOfZoom: V,
                    targetCenter: g,
                    scaleOfMinZoom: F,
                    pixelPathLength: z,
                  };
                }
              }
              class _n {
                constructor(e, i, l) {
                  (this.blendFunction = e),
                    (this.blendColor = i),
                    (this.mask = l);
                }
              }
              (_n.Replace = [1, 0]),
                (_n.disabled = new _n(_n.Replace, s.bi.transparent, [
                  !1,
                  !1,
                  !1,
                  !1,
                ])),
                (_n.unblended = new _n(_n.Replace, s.bi.transparent, [
                  !0,
                  !0,
                  !0,
                  !0,
                ])),
                (_n.alphaBlended = new _n([1, 771], s.bi.transparent, [
                  !0,
                  !0,
                  !0,
                  !0,
                ]));
              const ja = 2305;
              class en {
                constructor(e, i, l) {
                  (this.enable = e), (this.mode = i), (this.frontFace = l);
                }
              }
              (en.disabled = new en(!1, 1029, ja)),
                (en.backCCW = new en(!0, 1029, ja)),
                (en.frontCCW = new en(!0, 1028, ja));
              class ln {
                constructor(e, i, l) {
                  (this.func = e), (this.mask = i), (this.range = l);
                }
              }
              (ln.ReadOnly = !1),
                (ln.ReadWrite = !0),
                (ln.disabled = new ln(519, ln.ReadOnly, [0, 1]));
              const vo = 7680;
              class xn {
                constructor(e, i, l, u, d, g) {
                  (this.test = e),
                    (this.ref = i),
                    (this.mask = l),
                    (this.fail = u),
                    (this.depthFail = d),
                    (this.pass = g);
                }
              }
              xn.disabled = new xn({ func: 519, mask: 0 }, 0, 0, vo, vo, vo);
              const Ya = new WeakMap();
              function Di(h) {
                var e;
                if (Ya.has(h)) return Ya.get(h);
                {
                  const i =
                    (e = h.getParameter(h.VERSION)) === null || e === void 0
                      ? void 0
                      : e.startsWith("WebGL 2.0");
                  return Ya.set(h, i), i;
                }
              }
              class Ro {
                get awaitingQuery() {
                  return !!this._readbackQueue;
                }
                constructor(e) {
                  (this._readbackWaitFrames = 4),
                    (this._measureWaitFrames = 6),
                    (this._texWidth = 1),
                    (this._texHeight = 1),
                    (this._measuredError = 0),
                    (this._updateCount = 0),
                    (this._lastReadbackFrame = -1e3),
                    (this._readbackQueue = null),
                    (this._cachedRenderContext = e);
                  const i = e.context,
                    l = i.gl;
                  (this._texFormat = l.RGBA), (this._texType = l.UNSIGNED_BYTE);
                  const u = new s.aP();
                  u.emplaceBack(-1, -1),
                    u.emplaceBack(2, -1),
                    u.emplaceBack(-1, 2);
                  const d = new s.aR();
                  d.emplaceBack(0, 1, 2),
                    (this._fullscreenTriangle = new Cn(
                      i.createVertexBuffer(u, Vn.members),
                      i.createIndexBuffer(d),
                      s.aQ.simpleSegment(0, 0, u.length, d.length)
                    )),
                    (this._resultBuffer = new Uint8Array(4)),
                    i.activeTexture.set(l.TEXTURE1);
                  const g = l.createTexture();
                  l.bindTexture(l.TEXTURE_2D, g),
                    l.texParameteri(
                      l.TEXTURE_2D,
                      l.TEXTURE_WRAP_S,
                      l.CLAMP_TO_EDGE
                    ),
                    l.texParameteri(
                      l.TEXTURE_2D,
                      l.TEXTURE_WRAP_T,
                      l.CLAMP_TO_EDGE
                    ),
                    l.texParameteri(
                      l.TEXTURE_2D,
                      l.TEXTURE_MIN_FILTER,
                      l.NEAREST
                    ),
                    l.texParameteri(
                      l.TEXTURE_2D,
                      l.TEXTURE_MAG_FILTER,
                      l.NEAREST
                    ),
                    l.texImage2D(
                      l.TEXTURE_2D,
                      0,
                      this._texFormat,
                      this._texWidth,
                      this._texHeight,
                      0,
                      this._texFormat,
                      this._texType,
                      null
                    ),
                    (this._fbo = i.createFramebuffer(
                      this._texWidth,
                      this._texHeight,
                      !1,
                      !1
                    )),
                    this._fbo.colorAttachment.set(g),
                    Di(l) &&
                      ((this._pbo = l.createBuffer()),
                      l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo),
                      l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ),
                      l.bindBuffer(l.PIXEL_PACK_BUFFER, null));
                }
                destroy() {
                  const e = this._cachedRenderContext.context.gl;
                  this._fullscreenTriangle.destroy(),
                    this._fbo.destroy(),
                    e.deleteBuffer(this._pbo),
                    (this._fullscreenTriangle = null),
                    (this._fbo = null),
                    (this._pbo = null),
                    (this._resultBuffer = null);
                }
                updateErrorLoop(e, i) {
                  const l = this._updateCount;
                  return (
                    this._readbackQueue
                      ? l >=
                          this._readbackQueue.frameNumberIssued +
                            this._readbackWaitFrames && this._tryReadback()
                      : l >=
                          this._lastReadbackFrame + this._measureWaitFrames &&
                        this._renderErrorTexture(e, i),
                    this._updateCount++,
                    this._measuredError
                  );
                }
                _bindFramebuffer() {
                  const e = this._cachedRenderContext.context,
                    i = e.gl;
                  e.activeTexture.set(i.TEXTURE1),
                    i.bindTexture(
                      i.TEXTURE_2D,
                      this._fbo.colorAttachment.get()
                    ),
                    e.bindFramebuffer.set(this._fbo.framebuffer);
                }
                _renderErrorTexture(e, i) {
                  const l = this._cachedRenderContext.context,
                    u = l.gl;
                  if (
                    (this._bindFramebuffer(),
                    l.viewport.set([0, 0, this._texWidth, this._texHeight]),
                    l.clear({ color: s.bi.transparent }),
                    this._cachedRenderContext
                      .useProgram("projectionErrorMeasurement")
                      .draw(
                        l,
                        u.TRIANGLES,
                        ln.disabled,
                        xn.disabled,
                        _n.unblended,
                        en.disabled,
                        ((d, g) => ({ u_input: d, u_output_expected: g }))(
                          e,
                          i
                        ),
                        null,
                        null,
                        "$clipping",
                        this._fullscreenTriangle.vertexBuffer,
                        this._fullscreenTriangle.indexBuffer,
                        this._fullscreenTriangle.segments
                      ),
                    this._pbo && Di(u))
                  ) {
                    u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo),
                      u.readBuffer(u.COLOR_ATTACHMENT0),
                      u.readPixels(
                        0,
                        0,
                        this._texWidth,
                        this._texHeight,
                        this._texFormat,
                        this._texType,
                        0
                      ),
                      u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
                    const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    u.flush(),
                      (this._readbackQueue = {
                        frameNumberIssued: this._updateCount,
                        sync: d,
                      });
                  } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
                }
                _tryReadback() {
                  const e = this._cachedRenderContext.context.gl;
                  if (this._pbo && this._readbackQueue && Di(e)) {
                    const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
                    if (i === e.WAIT_FAILED)
                      return (
                        s.w("WebGL2 clientWaitSync failed."),
                        (this._readbackQueue = null),
                        void (this._lastReadbackFrame = this._updateCount)
                      );
                    if (i === e.TIMEOUT_EXPIRED) return;
                    e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
                      e.getBufferSubData(
                        e.PIXEL_PACK_BUFFER,
                        0,
                        this._resultBuffer,
                        0,
                        4
                      ),
                      e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
                  } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                  (this._readbackQueue = null),
                    (this._measuredError = Ro._parseRGBA8float(
                      this._resultBuffer
                    )),
                    (this._lastReadbackFrame = this._updateCount);
                }
                static _parseRGBA8float(e) {
                  let i = 0;
                  return (
                    (i += e[0] / 256),
                    (i += e[1] / 65536),
                    (i += e[2] / 16777216),
                    e[3] < 127 && (i = -i),
                    i / 128
                  );
                }
              }
              const Pa = s.a3 / 128;
              function Ka(h, e) {
                const i =
                    h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
                  l = i + (h.generateBorders ? 2 : 0),
                  u =
                    i +
                    (h.extendToNorthPole || h.generateBorders ? 1 : 0) +
                    (h.extendToSouthPole || h.generateBorders ? 1 : 0),
                  d = l + 1,
                  g = u + 1,
                  w = h.generateBorders ? -1 : 0,
                  S = h.generateBorders || h.extendToNorthPole ? -1 : 0,
                  k = i + (h.generateBorders ? 1 : 0),
                  z = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
                  V = d * g,
                  F = l * u * 6,
                  $ = d * g > 65536;
                if ($ && e === "16bit")
                  throw new Error(
                    "Granularity is too large and meshes would not fit inside 16 bit vertex indices."
                  );
                const J = $ || e === "32bit",
                  ae = new Int16Array(2 * V);
                let oe = 0;
                for (let be = S; be <= z; be++)
                  for (let pe = w; pe <= k; pe++) {
                    let we = (pe / i) * s.a3;
                    pe === -1 && (we = -Pa), pe === i + 1 && (we = s.a3 + Pa);
                    let Pe = (be / i) * s.a3;
                    be === -1 && (Pe = h.extendToNorthPole ? s.bk : -Pa),
                      be === i + 1 &&
                        (Pe = h.extendToSouthPole ? s.bl : s.a3 + Pa),
                      (ae[oe++] = we),
                      (ae[oe++] = Pe);
                  }
                const se = J ? new Uint32Array(F) : new Uint16Array(F);
                let fe = 0;
                for (let be = 0; be < u; be++)
                  for (let pe = 0; pe < l; pe++) {
                    const we = pe + 1 + be * d,
                      Pe = pe + (be + 1) * d,
                      ve = pe + 1 + (be + 1) * d;
                    (se[fe++] = pe + be * d),
                      (se[fe++] = Pe),
                      (se[fe++] = we),
                      (se[fe++] = we),
                      (se[fe++] = Pe),
                      (se[fe++] = ve);
                  }
                return {
                  vertices: ae.buffer.slice(0),
                  indices: se.buffer.slice(0),
                  uses32bitIndices: J,
                };
              }
              const Fo = new s.aO({
                fill: new s.bm(128, 2),
                line: new s.bm(512, 0),
                tile: new s.bm(128, 32),
                stencil: new s.bm(128, 1),
                circle: 3,
              });
              class Tl {
                constructor() {
                  (this._tileMeshCache = {}),
                    (this._errorCorrectionUsable = 0),
                    (this._errorMeasurementLastValue = 0),
                    (this._errorCorrectionPreviousValue = 0),
                    (this._errorMeasurementLastChangeTime = -1e3);
                }
                get name() {
                  return "vertical-perspective";
                }
                get transitionState() {
                  return 1;
                }
                get useSubdivision() {
                  return !0;
                }
                get shaderVariantName() {
                  return "globe";
                }
                get shaderDefine() {
                  return "#define GLOBE";
                }
                get shaderPreludeCode() {
                  return Cr.projectionGlobe;
                }
                get vertexShaderPreludeCode() {
                  return Cr.projectionMercator.vertexSource;
                }
                get subdivisionGranularity() {
                  return Fo;
                }
                get useGlobeControls() {
                  return !0;
                }
                get latitudeErrorCorrectionRadians() {
                  return this._errorCorrectionUsable;
                }
                destroy() {
                  this._errorMeasurement && this._errorMeasurement.destroy();
                }
                updateGPUdependent(e) {
                  this._errorMeasurement ||
                    (this._errorMeasurement = new Ro(e));
                  const i = s.W(this._errorQueryLatitudeDegrees),
                    l =
                      2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) -
                      0.5 * Math.PI,
                    u = this._errorMeasurement.updateErrorLoop(i, l),
                    d = ne();
                  u !== this._errorMeasurementLastValue &&
                    ((this._errorCorrectionPreviousValue =
                      this._errorCorrectionUsable),
                    (this._errorMeasurementLastValue = u),
                    (this._errorMeasurementLastChangeTime = d));
                  const g = Math.min(
                    Math.max(
                      (d - this._errorMeasurementLastChangeTime) / 1e3 / 0.5,
                      0
                    ),
                    1
                  );
                  this._errorCorrectionUsable = s.bn(
                    this._errorCorrectionPreviousValue,
                    -this._errorMeasurementLastValue,
                    s.bo(g)
                  );
                }
                _getMeshKey(e) {
                  return `${e.granularity.toString(
                    36
                  )}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
                }
                getMeshFromTileID(e, i, l, u, d) {
                  const g = (
                    d === "stencil" ? Fo.stencil : Fo.tile
                  ).getGranularityForZoomLevel(i.z);
                  return this._getMesh(e, {
                    granularity: g,
                    generateBorders: l,
                    extendToNorthPole: i.y === 0 && u,
                    extendToSouthPole: i.y === (1 << i.z) - 1 && u,
                  });
                }
                _getMesh(e, i) {
                  const l = this._getMeshKey(i);
                  if (l in this._tileMeshCache) return this._tileMeshCache[l];
                  const u = (function (d, g) {
                    const w = Ka(g, "16bit"),
                      S = s.aP.deserialize({
                        arrayBuffer: w.vertices,
                        length: w.vertices.byteLength / 2 / 2,
                      }),
                      k = s.aR.deserialize({
                        arrayBuffer: w.indices,
                        length: w.indices.byteLength / 2 / 3,
                      });
                    return new Cn(
                      d.createVertexBuffer(S, Vn.members),
                      d.createIndexBuffer(k),
                      s.aQ.simpleSegment(0, 0, S.length, k.length)
                    );
                  })(e, i);
                  return (this._tileMeshCache[l] = u), u;
                }
                recalculate(e) {}
                hasTransition() {
                  const e = ne();
                  let i = !1;
                  return (
                    (i =
                      i ||
                      (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7),
                    (i =
                      i ||
                      (this._errorMeasurement &&
                        this._errorMeasurement.awaitingQuery)),
                    i
                  );
                }
                setErrorQueryLatitudeDegrees(e) {
                  this._errorQueryLatitudeDegrees = e;
                }
              }
              const Sl = new s.r({ type: new s.D(s.t.projection.type) });
              class Ns extends s.E {
                constructor(e) {
                  super(),
                    (this._transitionable = new s.x(Sl, void 0)),
                    this.setProjection(e),
                    (this._transitioning =
                      this._transitionable.untransitioned()),
                    this.recalculate(new s.G(0)),
                    (this._mercatorProjection = new Qr()),
                    (this._verticalPerspectiveProjection = new Tl());
                }
                get transitionState() {
                  const e = this.properties.get("type");
                  if (typeof e == "string" && e === "mercator") return 0;
                  if (typeof e == "string" && e === "vertical-perspective")
                    return 1;
                  if (e instanceof s.bp) {
                    if (
                      e.from === "vertical-perspective" &&
                      e.to === "mercator"
                    )
                      return 1 - e.transition;
                    if (
                      e.from === "mercator" &&
                      e.to === "vertical-perspective"
                    )
                      return e.transition;
                  }
                  return 1;
                }
                get useGlobeRendering() {
                  return this.transitionState > 0;
                }
                get latitudeErrorCorrectionRadians() {
                  return this
                    ._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
                }
                get currentProjection() {
                  return this.useGlobeRendering
                    ? this._verticalPerspectiveProjection
                    : this._mercatorProjection;
                }
                get name() {
                  return "globe";
                }
                get useSubdivision() {
                  return this.currentProjection.useSubdivision;
                }
                get shaderVariantName() {
                  return this.currentProjection.shaderVariantName;
                }
                get shaderDefine() {
                  return this.currentProjection.shaderDefine;
                }
                get shaderPreludeCode() {
                  return this.currentProjection.shaderPreludeCode;
                }
                get vertexShaderPreludeCode() {
                  return this.currentProjection.vertexShaderPreludeCode;
                }
                get subdivisionGranularity() {
                  return this.currentProjection.subdivisionGranularity;
                }
                get useGlobeControls() {
                  return this.transitionState > 0;
                }
                destroy() {
                  this._mercatorProjection.destroy(),
                    this._verticalPerspectiveProjection.destroy();
                }
                updateGPUdependent(e) {
                  this._mercatorProjection.updateGPUdependent(e),
                    this._verticalPerspectiveProjection.updateGPUdependent(e);
                }
                getMeshFromTileID(e, i, l, u, d) {
                  return this.currentProjection.getMeshFromTileID(
                    e,
                    i,
                    l,
                    u,
                    d
                  );
                }
                setProjection(e) {
                  this._transitionable.setValue(
                    "type",
                    (e == null ? void 0 : e.type) || "mercator"
                  );
                }
                updateTransitions(e) {
                  this._transitioning = this._transitionable.transitioned(
                    e,
                    this._transitioning
                  );
                }
                hasTransition() {
                  return (
                    this._transitioning.hasTransition() ||
                    this.currentProjection.hasTransition()
                  );
                }
                recalculate(e) {
                  this.properties = this._transitioning.possiblyEvaluate(e);
                }
                setErrorQueryLatitudeDegrees(e) {
                  this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(
                    e
                  ),
                    this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
                }
              }
              function fs(h) {
                const e = js(h.worldSize, h.center.lat);
                return 2 * Math.PI * e;
              }
              function yo(h, e, i, l, u) {
                const d = 1 / (1 << u),
                  g = (e / s.a3) * d + l * d,
                  w = s.br(
                    ((h / s.a3) * d + i * d) * Math.PI * 2 + Math.PI,
                    2 * Math.PI
                  ),
                  S =
                    2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) -
                    0.5 * Math.PI,
                  k = Math.cos(S),
                  z = new Float64Array(3);
                return (
                  (z[0] = Math.sin(w) * k),
                  (z[1] = Math.sin(S)),
                  (z[2] = Math.cos(w) * k),
                  z
                );
              }
              function Pi(h) {
                return (function (e, i) {
                  const l = Math.cos(i),
                    u = new Float64Array(3);
                  return (
                    (u[0] = Math.sin(e) * l),
                    (u[1] = Math.sin(i)),
                    (u[2] = Math.cos(e) * l),
                    u
                  );
                })((h.lng * Math.PI) / 180, (h.lat * Math.PI) / 180);
              }
              function js(h, e) {
                return h / (2 * Math.PI) / Math.cos((e * Math.PI) / 180);
              }
              function Qh(h) {
                const e = (Math.asin(h[1]) / Math.PI) * 180,
                  i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
                if (i > 1e-6) {
                  const l = h[0] / i,
                    u = Math.acos(h[2] / i),
                    d = ((l > 0 ? u : -u) / Math.PI) * 180;
                  return new s.U(s.V(d, -180, 180), e);
                }
                return new s.U(0, e);
              }
              function Cl(h) {
                return Math.cos((h * Math.PI) / 180);
              }
              function zn(h, e) {
                const i = Cl(h),
                  l = Cl(e);
                return s.ao(l / i);
              }
              function Pl(h, e) {
                const i = h.rotate(e.bearingInRadians),
                  l = e.zoom + zn(e.center.lat, 0),
                  u = s.bn(
                    1 / Cl(e.center.lat),
                    1 / Cl(Math.min(Math.abs(e.center.lat), 60)),
                    s.bq(l, 7, 3, 0, 1)
                  ),
                  d =
                    360 /
                    fs({
                      worldSize: e.worldSize,
                      center: { lat: e.center.lat },
                    });
                return new s.U(
                  e.center.lng - i.x * d * u,
                  s.ai(e.center.lat + i.y * d, -s.aj, s.aj)
                );
              }
              function ya(h) {
                const e = 0.5 * h,
                  i = Math.sin(e),
                  l = Math.cos(e);
                return Math.log(i + l) - Math.log(l - i);
              }
              function Vs(h, e, i, l) {
                const u = h.lat + i * l;
                if (Math.abs(i) > 1) {
                  const d =
                      ((Math.sign(h.lat + i) !== Math.sign(h.lat)
                        ? -Math.abs(h.lat)
                        : Math.abs(h.lat)) *
                        Math.PI) /
                      180,
                    g = (Math.abs(h.lat + i) * Math.PI) / 180,
                    w = ya(d + l * (g - d)),
                    S = ya(d),
                    k = ya(g);
                  return new s.U(h.lng + e * ((w - S) / (k - S)), u);
                }
                return new s.U(h.lng + e * l, u);
              }
              class ed {
                constructor(e) {
                  (this._cachePrevious = new Map()),
                    (this._cache = new Map()),
                    (this._hadAnyChanges = !1),
                    (this._boundingVolumeFactory = e);
                }
                swapBuffers() {
                  if (!this._hadAnyChanges) return;
                  const e = this._cachePrevious;
                  (this._cachePrevious = this._cache),
                    (this._cache = e),
                    this._cache.clear(),
                    (this._hadAnyChanges = !1);
                }
                getTileBoundingVolume(e, i, l, u) {
                  const d = `${e.z}_${e.x}_${e.y}_${
                      u != null && u.terrain ? "t" : ""
                    }`,
                    g = this._cache.get(d);
                  if (g) return g;
                  const w = this._cachePrevious.get(d);
                  if (w) return this._cache.set(d, w), w;
                  const S = this._boundingVolumeFactory(e, i, l, u);
                  return this._cache.set(d, S), (this._hadAnyChanges = !0), S;
                }
              }
              class Bo {
                constructor(e, i, l, u) {
                  (this.min = l),
                    (this.max = u),
                    (this.points = e),
                    (this.planes = i);
                }
                static fromAabb(e, i) {
                  const l = [];
                  for (let u = 0; u < 8; u++)
                    l.push([
                      1 & ~u ? e[0] : i[0],
                      ((u >> 1) & 1) == 1 ? i[1] : e[1],
                      ((u >> 2) & 1) == 1 ? i[2] : e[2],
                    ]);
                  return new Bo(
                    l,
                    [
                      [-1, 0, 0, i[0]],
                      [1, 0, 0, -e[0]],
                      [0, -1, 0, i[1]],
                      [0, 1, 0, -e[1]],
                      [0, 0, -1, i[2]],
                      [0, 0, 1, -e[2]],
                    ],
                    e,
                    i
                  );
                }
                static fromCenterSizeAngles(e, i, l) {
                  const u = s.bu([], l[0], l[1], l[2]),
                    d = s.bv([], [i[0], 0, 0], u),
                    g = s.bv([], [0, i[1], 0], u),
                    w = s.bv([], [0, 0, i[2]], u),
                    S = [...e],
                    k = [...e];
                  for (let V = 0; V < 8; V++)
                    for (let F = 0; F < 3; F++) {
                      const $ =
                        e[F] +
                        d[F] * (1 & ~V ? -1 : 1) +
                        g[F] * (((V >> 1) & 1) == 1 ? 1 : -1) +
                        w[F] * (((V >> 2) & 1) == 1 ? 1 : -1);
                      (S[F] = Math.min(S[F], $)), (k[F] = Math.max(k[F], $));
                    }
                  const z = [];
                  for (let V = 0; V < 8; V++) {
                    const F = [...e];
                    s.aV(F, F, s.aU([], d, 1 & ~V ? -1 : 1)),
                      s.aV(F, F, s.aU([], g, ((V >> 1) & 1) == 1 ? 1 : -1)),
                      s.aV(F, F, s.aU([], w, ((V >> 2) & 1) == 1 ? 1 : -1)),
                      z.push(F);
                  }
                  return new Bo(
                    z,
                    [
                      [...d, -s.a_(d, z[0])],
                      [...g, -s.a_(g, z[0])],
                      [...w, -s.a_(w, z[0])],
                      [-d[0], -d[1], -d[2], -s.a_(d, z[7])],
                      [-g[0], -g[1], -g[2], -s.a_(g, z[7])],
                      [-w[0], -w[1], -w[2], -s.a_(w, z[7])],
                    ],
                    S,
                    k
                  );
                }
                intersectsFrustum(e) {
                  let i = !0;
                  const l = this.points.length,
                    u = this.planes.length,
                    d = e.planes.length,
                    g = e.points.length;
                  for (let w = 0; w < d; w++) {
                    const S = e.planes[w];
                    let k = 0;
                    for (let z = 0; z < l; z++) {
                      const V = this.points[z];
                      S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 &&
                        k++;
                    }
                    if (k === 0) return 0;
                    k < l && (i = !1);
                  }
                  if (i) return 2;
                  for (let w = 0; w < u; w++) {
                    const S = this.planes[w];
                    let k = 0;
                    for (let z = 0; z < g; z++) {
                      const V = e.points[z];
                      S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 &&
                        k++;
                    }
                    if (k === 0) return 0;
                  }
                  return 1;
                }
                intersectsPlane(e) {
                  const i = this.points.length;
                  let l = 0;
                  for (let u = 0; u < i; u++) {
                    const d = this.points[u];
                    e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && l++;
                  }
                  return l === i ? 2 : l === 0 ? 0 : 1;
                }
              }
              function Ja(h, e, i) {
                const l = h - e;
                return l < 0 ? -l : Math.max(0, l - i);
              }
              function jc(h, e, i, l, u) {
                const d = h - i;
                let g;
                return (
                  (g =
                    d < 0
                      ? Math.min(-d, 1 + d - u)
                      : d > 1
                      ? Math.min(Math.max(d - u, 0), 1 - d)
                      : 0),
                  Math.max(g, Ja(e, l, u))
                );
              }
              class rf {
                constructor() {
                  this._boundingVolumeCache = new ed(
                    this._computeTileBoundingVolume
                  );
                }
                prepareNextFrame() {
                  this._boundingVolumeCache.swapBuffers();
                }
                distanceToTile2d(e, i, l, u) {
                  const d = 1 << l.z,
                    g = 1 / d,
                    w = l.x / d,
                    S = l.y / d;
                  let k = 2;
                  return (
                    (k = Math.min(k, jc(e, i, w, S, g))),
                    (k = Math.min(k, jc(e, i, w + 0.5, -S - g, g))),
                    (k = Math.min(k, jc(e, i, w + 0.5, 2 - S - g, g))),
                    k
                  );
                }
                getWrap(e, i, l) {
                  const u = 1 << i.z,
                    d = 1 / u,
                    g = i.x / u,
                    w = Ja(e.x, g, d),
                    S = Ja(e.x, g - 1, d),
                    k = Ja(e.x, g + 1, d),
                    z = Math.min(w, S, k);
                  return z === k ? 1 : z === S ? -1 : 0;
                }
                allowVariableZoom(e, i) {
                  return Nr(e, i) > 4;
                }
                allowWorldCopies() {
                  return !1;
                }
                getTileBoundingVolume(e, i, l, u) {
                  return this._boundingVolumeCache.getTileBoundingVolume(
                    e,
                    i,
                    l,
                    u
                  );
                }
                _computeTileBoundingVolume(e, i, l, u) {
                  var d, g;
                  let w = 0,
                    S = 0;
                  if (u != null && u.terrain) {
                    const k = new s.a0(e.z, i, e.z, e.x, e.y),
                      z = u.terrain.getMinMaxElevation(k);
                    (w =
                      (d = z.minElevation) !== null && d !== void 0
                        ? d
                        : Math.min(0, l)),
                      (S =
                        (g = z.maxElevation) !== null && g !== void 0
                          ? g
                          : Math.max(0, l));
                  }
                  if (((w /= s.bx), (S /= s.bx), (w += 1), (S += 1), e.z <= 0))
                    return Bo.fromAabb([-S, -S, -S], [S, S, S]);
                  if (e.z === 1)
                    return Bo.fromAabb(
                      [e.x === 0 ? -S : 0, e.y === 0 ? 0 : -S, -S],
                      [e.x === 0 ? 0 : S, e.y === 0 ? S : 0, S]
                    );
                  {
                    const k = [
                        yo(0, 0, e.x, e.y, e.z),
                        yo(s.a3, 0, e.x, e.y, e.z),
                        yo(s.a3, s.a3, e.x, e.y, e.z),
                        yo(0, s.a3, e.x, e.y, e.z),
                      ],
                      z = [];
                    for (const tt of k) z.push(s.aU([], tt, S));
                    if (S !== w) for (const tt of k) z.push(s.aU([], tt, w));
                    e.y === 0 && z.push([0, 1, 0]),
                      e.y === (1 << e.z) - 1 && z.push([0, -1, 0]);
                    const V = [1, 1, 1],
                      F = [-1, -1, -1];
                    for (const tt of z)
                      for (let ot = 0; ot < 3; ot++)
                        (V[ot] = Math.min(V[ot], tt[ot])),
                          (F[ot] = Math.max(F[ot], tt[ot]));
                    const $ = yo(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z),
                      J = s.aZ([], [0, 1, 0], $);
                    s.aY(J, J);
                    const ae = s.aZ([], $, J);
                    s.aY(ae, ae);
                    const oe = s.aZ([], k[2], k[1]);
                    s.aY(oe, oe);
                    const se = s.aZ([], k[0], k[3]);
                    s.aY(se, se),
                      z.push(s.aU([], $, S)),
                      e.y >= (1 << e.z) / 2 &&
                        z.push(s.aU([], yo(s.a3 / 2, 0, e.x, e.y, e.z), S)),
                      e.y < (1 << e.z) / 2 &&
                        z.push(s.aU([], yo(s.a3 / 2, s.a3, e.x, e.y, e.z), S));
                    const fe = td($, z),
                      be = td(ae, z),
                      pe = [-$[0], -$[1], -$[2], fe.max],
                      we = [$[0], $[1], $[2], -fe.min],
                      Pe = [-ae[0], -ae[1], -ae[2], be.max],
                      ve = [ae[0], ae[1], ae[2], -be.min],
                      Re = [...oe, 0],
                      it = [...se, 0],
                      Qe = [];
                    return (
                      e.y === 0
                        ? Qe.push(s.bw(it, Re, pe), s.bw(it, Re, we))
                        : Qe.push(
                            s.bw(Pe, Re, pe),
                            s.bw(Pe, Re, we),
                            s.bw(Pe, it, pe),
                            s.bw(Pe, it, we)
                          ),
                      e.y === (1 << e.z) - 1
                        ? Qe.push(s.bw(it, Re, pe), s.bw(it, Re, we))
                        : Qe.push(
                            s.bw(ve, Re, pe),
                            s.bw(ve, Re, we),
                            s.bw(ve, it, pe),
                            s.bw(ve, it, we)
                          ),
                      new Bo(Qe, [pe, we, Pe, ve, Re, it], V, F)
                    );
                  }
                }
              }
              function td(h, e) {
                let i = 1 / 0,
                  l = -1 / 0;
                for (const u of e) {
                  const d = s.a_(h, u);
                  (i = Math.min(i, d)), (l = Math.max(l, d));
                }
                return { min: i, max: l };
              }
              class Il {
                get pixelsToClipSpaceMatrix() {
                  return this._helper.pixelsToClipSpaceMatrix;
                }
                get clipSpaceToPixelsMatrix() {
                  return this._helper.clipSpaceToPixelsMatrix;
                }
                get pixelsToGLUnits() {
                  return this._helper.pixelsToGLUnits;
                }
                get centerOffset() {
                  return this._helper.centerOffset;
                }
                get size() {
                  return this._helper.size;
                }
                get rotationMatrix() {
                  return this._helper.rotationMatrix;
                }
                get centerPoint() {
                  return this._helper.centerPoint;
                }
                get pixelsPerMeter() {
                  return this._helper.pixelsPerMeter;
                }
                setMinZoom(e) {
                  this._helper.setMinZoom(e);
                }
                setMaxZoom(e) {
                  this._helper.setMaxZoom(e);
                }
                setMinPitch(e) {
                  this._helper.setMinPitch(e);
                }
                setMaxPitch(e) {
                  this._helper.setMaxPitch(e);
                }
                setRenderWorldCopies(e) {
                  this._helper.setRenderWorldCopies(e);
                }
                setBearing(e) {
                  this._helper.setBearing(e);
                }
                setPitch(e) {
                  this._helper.setPitch(e);
                }
                setRoll(e) {
                  this._helper.setRoll(e);
                }
                setFov(e) {
                  this._helper.setFov(e);
                }
                setZoom(e) {
                  this._helper.setZoom(e);
                }
                setCenter(e) {
                  this._helper.setCenter(e);
                }
                setElevation(e) {
                  this._helper.setElevation(e);
                }
                setMinElevationForCurrentTile(e) {
                  this._helper.setMinElevationForCurrentTile(e);
                }
                setPadding(e) {
                  this._helper.setPadding(e);
                }
                interpolatePadding(e, i, l) {
                  return this._helper.interpolatePadding(e, i, l);
                }
                isPaddingEqual(e) {
                  return this._helper.isPaddingEqual(e);
                }
                resize(e, i) {
                  this._helper.resize(e, i);
                }
                getMaxBounds() {
                  return this._helper.getMaxBounds();
                }
                setMaxBounds(e) {
                  this._helper.setMaxBounds(e);
                }
                setConstrain(e) {
                  this._helper.setConstrain(e);
                }
                overrideNearFarZ(e, i) {
                  this._helper.overrideNearFarZ(e, i);
                }
                clearNearFarZOverride() {
                  this._helper.clearNearFarZOverride();
                }
                getCameraQueryGeometry(e) {
                  return this._helper.getCameraQueryGeometry(
                    this.getCameraPoint(),
                    e
                  );
                }
                get tileSize() {
                  return this._helper.tileSize;
                }
                get tileZoom() {
                  return this._helper.tileZoom;
                }
                get scale() {
                  return this._helper.scale;
                }
                get worldSize() {
                  return this._helper.worldSize;
                }
                get width() {
                  return this._helper.width;
                }
                get height() {
                  return this._helper.height;
                }
                get lngRange() {
                  return this._helper.lngRange;
                }
                get latRange() {
                  return this._helper.latRange;
                }
                get minZoom() {
                  return this._helper.minZoom;
                }
                get maxZoom() {
                  return this._helper.maxZoom;
                }
                get zoom() {
                  return this._helper.zoom;
                }
                get center() {
                  return this._helper.center;
                }
                get minPitch() {
                  return this._helper.minPitch;
                }
                get maxPitch() {
                  return this._helper.maxPitch;
                }
                get pitch() {
                  return this._helper.pitch;
                }
                get pitchInRadians() {
                  return this._helper.pitchInRadians;
                }
                get roll() {
                  return this._helper.roll;
                }
                get rollInRadians() {
                  return this._helper.rollInRadians;
                }
                get bearing() {
                  return this._helper.bearing;
                }
                get bearingInRadians() {
                  return this._helper.bearingInRadians;
                }
                get fov() {
                  return this._helper.fov;
                }
                get fovInRadians() {
                  return this._helper.fovInRadians;
                }
                get elevation() {
                  return this._helper.elevation;
                }
                get minElevationForCurrentTile() {
                  return this._helper.minElevationForCurrentTile;
                }
                get padding() {
                  return this._helper.padding;
                }
                get unmodified() {
                  return this._helper.unmodified;
                }
                get renderWorldCopies() {
                  return this._helper.renderWorldCopies;
                }
                get constrain() {
                  return this._helper.constrain;
                }
                get nearZ() {
                  return this._helper.nearZ;
                }
                get farZ() {
                  return this._helper.farZ;
                }
                get autoCalculateNearFarZ() {
                  return this._helper.autoCalculateNearFarZ;
                }
                setTransitionState(e) {}
                constructor(e) {
                  (this._cachedClippingPlane = s.by()),
                    (this._projectionMatrix = s.bc()),
                    (this._globeViewProjMatrix32f = s.bb()),
                    (this._globeViewProjMatrixNoCorrection = s.bc()),
                    (this._globeViewProjMatrixNoCorrectionInverted = s.bc()),
                    (this._globeProjMatrixInverted = s.bc()),
                    (this._cameraPosition = s.bs()),
                    (this._globeLatitudeErrorCorrectionRadians = 0),
                    (this.defaultConstrain = (i, l) => {
                      const u = s.ai(i.lat, -s.aj, s.aj),
                        d = s.ai(+l, this.minZoom + zn(0, u), this.maxZoom);
                      return { center: new s.U(i.lng, u), zoom: d };
                    }),
                    (this._helper = new pn(
                      {
                        calcMatrices: () => {
                          this._calcMatrices();
                        },
                        constrain: (i, l) => this.defaultConstrain(i, l),
                      },
                      e
                    )),
                    (this._coveringTilesDetailsProvider = new rf());
                }
                clone() {
                  const e = new Il();
                  return e.apply(this), e;
                }
                apply(e, i) {
                  (this._globeLatitudeErrorCorrectionRadians = i || 0),
                    this._helper.apply(e);
                }
                get projectionMatrix() {
                  return this._projectionMatrix;
                }
                get modelViewProjectionMatrix() {
                  return this._globeViewProjMatrixNoCorrection;
                }
                get inverseProjectionMatrix() {
                  return this._globeProjMatrixInverted;
                }
                get cameraPosition() {
                  const e = s.bs();
                  return (
                    (e[0] = this._cameraPosition[0]),
                    (e[1] = this._cameraPosition[1]),
                    (e[2] = this._cameraPosition[2]),
                    e
                  );
                }
                get cameraToCenterDistance() {
                  return this._helper.cameraToCenterDistance;
                }
                getProjectionData(e) {
                  const { overscaledTileID: i, applyGlobeMatrix: l } = e,
                    u = this._helper.getMercatorTileCoordinates(i);
                  return {
                    mainMatrix: this._globeViewProjMatrix32f,
                    tileMercatorCoords: u,
                    clippingPlane: this._cachedClippingPlane,
                    projectionTransition: l ? 1 : 0,
                    fallbackMatrix: this._globeViewProjMatrix32f,
                  };
                }
                _computeClippingPlane(e) {
                  const i = this.pitchInRadians,
                    l = this.cameraToCenterDistance / e,
                    u = Math.sin(i) * l,
                    d = Math.cos(i) * l + 1,
                    g = (1 / Math.sqrt(u * u + d * d)) * 1;
                  let w = -u,
                    S = d;
                  const k = Math.sqrt(w * w + S * S);
                  (w /= k), (S /= k);
                  const z = [0, w, S];
                  s.bz(z, z, [0, 0, 0], -this.bearingInRadians),
                    s.bA(
                      z,
                      z,
                      [0, 0, 0],
                      (-1 * this.center.lat * Math.PI) / 180
                    ),
                    s.bB(z, z, [0, 0, 0], (this.center.lng * Math.PI) / 180);
                  const V = 1 / s.b0(z);
                  return s.aU(z, z, V), [...z, -g * V];
                }
                isLocationOccluded(e) {
                  return !this.isSurfacePointVisible(Pi(e));
                }
                transformLightDirection(e) {
                  const i = (this._helper._center.lng * Math.PI) / 180,
                    l = (this._helper._center.lat * Math.PI) / 180,
                    u = Math.cos(l),
                    d = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
                    g = [d[2], 0, -d[0]],
                    w = [0, 0, 0];
                  s.aZ(w, g, d), s.aY(g, g), s.aY(w, w);
                  const S = [0, 0, 0];
                  return (
                    s.aY(S, [
                      g[0] * e[0] + w[0] * e[1] + d[0] * e[2],
                      g[1] * e[0] + w[1] * e[1] + d[1] * e[2],
                      g[2] * e[0] + w[2] * e[1] + d[2] * e[2],
                    ]),
                    S
                  );
                }
                getPixelScale() {
                  return (
                    1 / Math.cos((this._helper._center.lat * Math.PI) / 180)
                  );
                }
                getCircleRadiusCorrection() {
                  return Math.cos((this._helper._center.lat * Math.PI) / 180);
                }
                getPitchedTextCorrection(e, i, l) {
                  const u = (function (w, S, k) {
                      const z = 1 / (1 << k.z);
                      return new s.a5(
                        (w / s.a3) * z + k.x * z,
                        (S / s.a3) * z + k.y * z
                      );
                    })(e, i, l.canonical),
                    d =
                      ((g = u.y),
                      [
                        s.br(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI),
                        2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) -
                          0.5 * Math.PI,
                      ]);
                  var g;
                  return this.getCircleRadiusCorrection() / Math.cos(d[1]);
                }
                projectTileCoordinates(e, i, l, u) {
                  const d = l.canonical,
                    g = yo(e, i, d.x, d.y, d.z),
                    w = 1 + (u ? u(e, i) : 0) / s.bx,
                    S = [g[0] * w, g[1] * w, g[2] * w, 1];
                  s.aA(S, S, this._globeViewProjMatrixNoCorrection);
                  const k = this._cachedClippingPlane,
                    z = k[0] * g[0] + k[1] * g[1] + k[2] * g[2] + k[3] < 0;
                  return {
                    point: new s.P(S[0] / S[3], S[1] / S[3]),
                    signedDistanceFromCamera: S[3],
                    isOccluded: z,
                  };
                }
                _calcMatrices() {
                  if (!this._helper._width || !this._helper._height) return;
                  const e = js(this.worldSize, this.center.lat),
                    i = s.bd(),
                    l = s.bd();
                  this._helper.autoCalculateNearFarZ &&
                    ((this._helper._nearZ = 0.5),
                    (this._helper._farZ = this.cameraToCenterDistance + 2 * e)),
                    s.b7(
                      i,
                      this.fovInRadians,
                      this.width / this.height,
                      this._helper._nearZ,
                      this._helper._farZ
                    );
                  const u = this.centerOffset;
                  (i[8] = (2 * -u.x) / this._helper._width),
                    (i[9] = (2 * u.y) / this._helper._height),
                    (this._projectionMatrix = s.b8(i)),
                    (this._globeProjMatrixInverted = s.bd()),
                    s.au(this._globeProjMatrixInverted, i),
                    s.N(i, i, [0, 0, -this.cameraToCenterDistance]),
                    s.b9(i, i, this.rollInRadians),
                    s.ba(i, i, -this.pitchInRadians),
                    s.b9(i, i, this.bearingInRadians),
                    s.N(i, i, [0, 0, -e]);
                  const d = s.bs();
                  (d[0] = e),
                    (d[1] = e),
                    (d[2] = e),
                    s.ba(l, i, (this.center.lat * Math.PI) / 180),
                    s.bC(l, l, (-this.center.lng * Math.PI) / 180),
                    s.O(l, l, d),
                    (this._globeViewProjMatrixNoCorrection = l),
                    s.ba(
                      i,
                      i,
                      (this.center.lat * Math.PI) / 180 -
                        this._globeLatitudeErrorCorrectionRadians
                    ),
                    s.bC(i, i, (-this.center.lng * Math.PI) / 180),
                    s.O(i, i, d),
                    (this._globeViewProjMatrix32f = new Float32Array(i)),
                    (this._globeViewProjMatrixNoCorrectionInverted = s.bd()),
                    s.au(this._globeViewProjMatrixNoCorrectionInverted, l);
                  const g = s.bs();
                  (this._cameraPosition = s.bs()),
                    (this._cameraPosition[2] = this.cameraToCenterDistance / e),
                    s.bz(
                      this._cameraPosition,
                      this._cameraPosition,
                      g,
                      -this.rollInRadians
                    ),
                    s.bA(
                      this._cameraPosition,
                      this._cameraPosition,
                      g,
                      this.pitchInRadians
                    ),
                    s.bz(
                      this._cameraPosition,
                      this._cameraPosition,
                      g,
                      -this.bearingInRadians
                    ),
                    s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
                    s.bA(
                      this._cameraPosition,
                      this._cameraPosition,
                      g,
                      (-this.center.lat * Math.PI) / 180
                    ),
                    s.bB(
                      this._cameraPosition,
                      this._cameraPosition,
                      g,
                      (this.center.lng * Math.PI) / 180
                    ),
                    (this._cachedClippingPlane = this._computeClippingPlane(e));
                  const w = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
                  s.O(w, w, [1, 1, -1]),
                    (this._cachedFrustum = _a.fromInvProjectionMatrix(
                      w,
                      1,
                      0,
                      this._cachedClippingPlane,
                      !0
                    ));
                }
                calculateFogMatrix(e) {
                  s.w(
                    "calculateFogMatrix is not supported on globe projection."
                  );
                  const i = s.bd();
                  return s.am(i), i;
                }
                getVisibleUnwrappedCoordinates(e) {
                  return [new s.b5(0, e)];
                }
                getCameraFrustum() {
                  return this._cachedFrustum;
                }
                getClippingPlane() {
                  return this._cachedClippingPlane;
                }
                getCoveringTilesDetailsProvider() {
                  return this._coveringTilesDetailsProvider;
                }
                recalculateZoomAndCenter(e) {
                  e &&
                    s.w(
                      "terrain is not fully supported on vertical perspective projection."
                    ),
                    this._helper.recalculateZoomAndCenter(0);
                }
                maxPitchScaleFactor() {
                  return 1;
                }
                getCameraPoint() {
                  return this._helper.getCameraPoint();
                }
                getCameraAltitude() {
                  return this._helper.getCameraAltitude();
                }
                getCameraLngLat() {
                  return this._helper.getCameraLngLat();
                }
                lngLatToCameraDepth(e, i) {
                  if (!this._globeViewProjMatrixNoCorrection) return 1;
                  const l = Pi(e);
                  s.aU(l, l, 1 + i / s.bx);
                  const u = s.by();
                  return (
                    s.aA(
                      u,
                      [l[0], l[1], l[2], 1],
                      this._globeViewProjMatrixNoCorrection
                    ),
                    u[2] / u[3]
                  );
                }
                populateCache(e) {}
                getBounds() {
                  const e = 0.5 * this.width,
                    i = 0.5 * this.height,
                    l = [
                      new s.P(0, 0),
                      new s.P(e, 0),
                      new s.P(this.width, 0),
                      new s.P(this.width, i),
                      new s.P(this.width, this.height),
                      new s.P(e, this.height),
                      new s.P(0, this.height),
                      new s.P(0, i),
                    ],
                    u = [];
                  for (const V of l) u.push(this.unprojectScreenPoint(V));
                  let d = 0,
                    g = 0,
                    w = 0,
                    S = 0;
                  const k = this.center;
                  for (const V of u) {
                    const F = s.bD(k.lng, V.lng),
                      $ = s.bD(k.lat, V.lat);
                    F < g && (g = F),
                      F > d && (d = F),
                      $ < S && (S = $),
                      $ > w && (w = $);
                  }
                  const z = [k.lng + g, k.lat + S, k.lng + d, k.lat + w];
                  return (
                    this.isSurfacePointOnScreen([0, 1, 0]) &&
                      ((z[3] = 90), (z[0] = -180), (z[2] = 180)),
                    this.isSurfacePointOnScreen([0, -1, 0]) &&
                      ((z[1] = -90), (z[0] = -180), (z[2] = 180)),
                    new At(z)
                  );
                }
                calculateCenterFromCameraLngLatAlt(e, i, l, u) {
                  return this._helper.calculateCenterFromCameraLngLatAlt(
                    e,
                    i,
                    l,
                    u
                  );
                }
                setLocationAtPoint(e, i) {
                  const l = Pi(this.unprojectScreenPoint(i)),
                    u = Pi(e),
                    d = s.bs();
                  s.bE(d);
                  const g = s.bs();
                  s.bB(g, l, d, (-this.center.lng * Math.PI) / 180),
                    s.bA(g, g, d, (this.center.lat * Math.PI) / 180);
                  const w = u[0] * u[0] + u[2] * u[2],
                    S = g[0] * g[0];
                  if (w < S) return;
                  const k = Math.sqrt(w - S),
                    z = -k,
                    V = s.bF(u[0], u[2], g[0], k),
                    F = s.bF(u[0], u[2], g[0], z),
                    $ = s.bs();
                  s.bB($, u, d, -V);
                  const J = s.bF($[1], $[2], g[1], g[2]),
                    ae = s.bs();
                  s.bB(ae, u, d, -F);
                  const oe = s.bF(ae[1], ae[2], g[1], g[2]),
                    se = 0.5 * Math.PI,
                    fe = J >= -se && J <= se,
                    be = oe >= -se && oe <= se;
                  let pe, we;
                  if (fe && be) {
                    const it = (this.center.lng * Math.PI) / 180,
                      Qe = (this.center.lat * Math.PI) / 180;
                    s.bG(V, it) + s.bG(J, Qe) < s.bG(F, it) + s.bG(oe, Qe)
                      ? ((pe = V), (we = J))
                      : ((pe = F), (we = oe));
                  } else if (fe) (pe = V), (we = J);
                  else {
                    if (!be) return;
                    (pe = F), (we = oe);
                  }
                  const Pe = (pe / Math.PI) * 180,
                    ve = (we / Math.PI) * 180,
                    Re = this.center.lat;
                  this.setCenter(new s.U(Pe, s.ai(ve, -90, 90))),
                    this.setZoom(this.zoom + zn(Re, this.center.lat));
                }
                locationToScreenPoint(e, i) {
                  const l = Pi(e);
                  if (i) {
                    const u = i.getElevationForLngLatZoom(
                      e,
                      this._helper._tileZoom
                    );
                    s.aU(l, l, 1 + u / s.bx);
                  }
                  return this._projectSurfacePointToScreen(l);
                }
                _projectSurfacePointToScreen(e) {
                  const i = s.by();
                  return (
                    s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
                    (i[0] /= i[3]),
                    (i[1] /= i[3]),
                    new s.P(
                      (0.5 * i[0] + 0.5) * this.width,
                      (0.5 * -i[1] + 0.5) * this.height
                    )
                  );
                }
                screenPointToMercatorCoordinate(e, i) {
                  if (i) {
                    const l = i.pointCoordinate(e);
                    if (l) return l;
                  }
                  return s.a5.fromLngLat(this.unprojectScreenPoint(e));
                }
                screenPointToLocation(e, i) {
                  var l;
                  return (l = this.screenPointToMercatorCoordinate(e, i)) ===
                    null || l === void 0
                    ? void 0
                    : l.toLngLat();
                }
                isPointOnMapSurface(e, i) {
                  const l = this._cameraPosition,
                    u = this.getRayDirectionFromPixel(e);
                  return !!this.rayPlanetIntersection(l, u);
                }
                getRayDirectionFromPixel(e) {
                  const i = s.by();
                  (i[0] = (e.x / this.width) * 2 - 1),
                    (i[1] = -1 * ((e.y / this.height) * 2 - 1)),
                    (i[2] = 1),
                    (i[3] = 1),
                    s.aA(i, i, this._globeViewProjMatrixNoCorrectionInverted),
                    (i[0] /= i[3]),
                    (i[1] /= i[3]),
                    (i[2] /= i[3]);
                  const l = s.bs();
                  (l[0] = i[0] - this._cameraPosition[0]),
                    (l[1] = i[1] - this._cameraPosition[1]),
                    (l[2] = i[2] - this._cameraPosition[2]);
                  const u = s.bs();
                  return s.aY(u, l), u;
                }
                isSurfacePointVisible(e) {
                  const i = this._cachedClippingPlane;
                  return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0;
                }
                isSurfacePointOnScreen(e) {
                  if (!this.isSurfacePointVisible(e)) return !1;
                  const i = s.by();
                  return (
                    s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
                    (i[0] /= i[3]),
                    (i[1] /= i[3]),
                    (i[2] /= i[3]),
                    i[0] > -1 &&
                      i[0] < 1 &&
                      i[1] > -1 &&
                      i[1] < 1 &&
                      i[2] > -1 &&
                      i[2] < 1
                  );
                }
                rayPlanetIntersection(e, i) {
                  const l = s.a_(e, i),
                    u = s.bs(),
                    d = s.bs();
                  s.aU(d, i, l), s.aX(u, e, d);
                  const g = 1 - s.a_(u, u);
                  if (g < 0) return null;
                  const w = s.a_(e, e) - 1,
                    S = -l + (l < 0 ? 1 : -1) * Math.sqrt(g),
                    k = w / S,
                    z = S;
                  return { tMin: Math.min(k, z), tMax: Math.max(k, z) };
                }
                unprojectScreenPoint(e) {
                  const i = this._cameraPosition,
                    l = this.getRayDirectionFromPixel(e),
                    u = this.rayPlanetIntersection(i, l);
                  if (u) {
                    const z = s.bs();
                    s.aV(z, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
                    const V = s.bs();
                    return s.aY(V, z), Qh(V);
                  }
                  const d = this._cachedClippingPlane,
                    g = d[0] * l[0] + d[1] * l[1] + d[2] * l[2],
                    w = -s.b4(d, i) / g,
                    S = s.bs();
                  if (w > 0) s.aV(S, i, [l[0] * w, l[1] * w, l[2] * w]);
                  else {
                    const z = s.bs();
                    s.aV(z, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
                    const V = s.b4(this._cachedClippingPlane, z);
                    s.aX(S, z, [
                      this._cachedClippingPlane[0] * V,
                      this._cachedClippingPlane[1] * V,
                      this._cachedClippingPlane[2] * V,
                    ]);
                  }
                  const k = (function (z) {
                    const V = s.bs();
                    return (
                      (V[0] = z[0] * -z[3]),
                      (V[1] = z[1] * -z[3]),
                      (V[2] = z[2] * -z[3]),
                      { center: V, radius: Math.sqrt(1 - z[3] * z[3]) }
                    );
                  })(d);
                  return Qh(
                    (function (z, V, F) {
                      const $ = s.bs();
                      s.aX($, F, z);
                      const J = s.bs();
                      return s.bt(J, z, $, V / s.b2($)), J;
                    })(k.center, k.radius, S)
                  );
                }
                getMatrixForModel(e, i) {
                  const l = s.U.convert(e),
                    u = 1 / s.bx,
                    d = s.bc();
                  return (
                    s.bC(d, d, (l.lng / 180) * Math.PI),
                    s.ba(d, d, (-l.lat / 180) * Math.PI),
                    s.N(d, d, [0, 0, 1 + i / s.bx]),
                    s.ba(d, d, 0.5 * Math.PI),
                    s.O(d, d, [u, u, u]),
                    d
                  );
                }
                getProjectionDataForCustomLayer(e = !0) {
                  const i = this.getProjectionData({
                    overscaledTileID: new s.a0(0, 0, 0, 0, 0),
                    applyGlobeMatrix: e,
                  });
                  return (i.tileMercatorCoords = [0, 0, 1, 1]), i;
                }
                getFastPathSimpleProjectionMatrix(e) {}
              }
              class Ml {
                get pixelsToClipSpaceMatrix() {
                  return this._helper.pixelsToClipSpaceMatrix;
                }
                get clipSpaceToPixelsMatrix() {
                  return this._helper.clipSpaceToPixelsMatrix;
                }
                get pixelsToGLUnits() {
                  return this._helper.pixelsToGLUnits;
                }
                get centerOffset() {
                  return this._helper.centerOffset;
                }
                get size() {
                  return this._helper.size;
                }
                get rotationMatrix() {
                  return this._helper.rotationMatrix;
                }
                get centerPoint() {
                  return this._helper.centerPoint;
                }
                get pixelsPerMeter() {
                  return this._helper.pixelsPerMeter;
                }
                setMinZoom(e) {
                  this._helper.setMinZoom(e);
                }
                setMaxZoom(e) {
                  this._helper.setMaxZoom(e);
                }
                setMinPitch(e) {
                  this._helper.setMinPitch(e);
                }
                setMaxPitch(e) {
                  this._helper.setMaxPitch(e);
                }
                setRenderWorldCopies(e) {
                  this._helper.setRenderWorldCopies(e);
                }
                setBearing(e) {
                  this._helper.setBearing(e);
                }
                setPitch(e) {
                  this._helper.setPitch(e);
                }
                setRoll(e) {
                  this._helper.setRoll(e);
                }
                setFov(e) {
                  this._helper.setFov(e);
                }
                setZoom(e) {
                  this._helper.setZoom(e);
                }
                setCenter(e) {
                  this._helper.setCenter(e);
                }
                setElevation(e) {
                  this._helper.setElevation(e);
                }
                setMinElevationForCurrentTile(e) {
                  this._helper.setMinElevationForCurrentTile(e);
                }
                setPadding(e) {
                  this._helper.setPadding(e);
                }
                interpolatePadding(e, i, l) {
                  return this._helper.interpolatePadding(e, i, l);
                }
                isPaddingEqual(e) {
                  return this._helper.isPaddingEqual(e);
                }
                resize(e, i, l = !0) {
                  this._helper.resize(e, i, l);
                }
                getMaxBounds() {
                  return this._helper.getMaxBounds();
                }
                setMaxBounds(e) {
                  this._helper.setMaxBounds(e);
                }
                setConstrain(e) {
                  this._helper.setConstrain(e);
                }
                overrideNearFarZ(e, i) {
                  this._helper.overrideNearFarZ(e, i);
                }
                clearNearFarZOverride() {
                  this._helper.clearNearFarZOverride();
                }
                getCameraQueryGeometry(e) {
                  return this._helper.getCameraQueryGeometry(
                    this.getCameraPoint(),
                    e
                  );
                }
                get tileSize() {
                  return this._helper.tileSize;
                }
                get tileZoom() {
                  return this._helper.tileZoom;
                }
                get scale() {
                  return this._helper.scale;
                }
                get worldSize() {
                  return this._helper.worldSize;
                }
                get width() {
                  return this._helper.width;
                }
                get height() {
                  return this._helper.height;
                }
                get lngRange() {
                  return this._helper.lngRange;
                }
                get latRange() {
                  return this._helper.latRange;
                }
                get minZoom() {
                  return this._helper.minZoom;
                }
                get maxZoom() {
                  return this._helper.maxZoom;
                }
                get zoom() {
                  return this._helper.zoom;
                }
                get center() {
                  return this._helper.center;
                }
                get minPitch() {
                  return this._helper.minPitch;
                }
                get maxPitch() {
                  return this._helper.maxPitch;
                }
                get pitch() {
                  return this._helper.pitch;
                }
                get pitchInRadians() {
                  return this._helper.pitchInRadians;
                }
                get roll() {
                  return this._helper.roll;
                }
                get rollInRadians() {
                  return this._helper.rollInRadians;
                }
                get bearing() {
                  return this._helper.bearing;
                }
                get bearingInRadians() {
                  return this._helper.bearingInRadians;
                }
                get fov() {
                  return this._helper.fov;
                }
                get fovInRadians() {
                  return this._helper.fovInRadians;
                }
                get elevation() {
                  return this._helper.elevation;
                }
                get minElevationForCurrentTile() {
                  return this._helper.minElevationForCurrentTile;
                }
                get padding() {
                  return this._helper.padding;
                }
                get unmodified() {
                  return this._helper.unmodified;
                }
                get renderWorldCopies() {
                  return this._helper.renderWorldCopies;
                }
                get cameraToCenterDistance() {
                  return this._helper.cameraToCenterDistance;
                }
                get constrain() {
                  return this._helper.constrain;
                }
                get nearZ() {
                  return this._helper.nearZ;
                }
                get farZ() {
                  return this._helper.farZ;
                }
                get autoCalculateNearFarZ() {
                  return this._helper.autoCalculateNearFarZ;
                }
                get isGlobeRendering() {
                  return this._globeness > 0;
                }
                setTransitionState(e, i) {
                  (this._globeness = e),
                    (this._globeLatitudeErrorCorrectionRadians = i),
                    this._calcMatrices(),
                    this._verticalPerspectiveTransform
                      .getCoveringTilesDetailsProvider()
                      .prepareNextFrame(),
                    this._mercatorTransform
                      .getCoveringTilesDetailsProvider()
                      .prepareNextFrame();
                }
                get currentTransform() {
                  return this.isGlobeRendering
                    ? this._verticalPerspectiveTransform
                    : this._mercatorTransform;
                }
                constructor(e) {
                  (this._globeLatitudeErrorCorrectionRadians = 0),
                    (this._globeness = 1),
                    (this.defaultConstrain = (i, l) =>
                      this.currentTransform.defaultConstrain(i, l)),
                    (this._helper = new pn(
                      {
                        calcMatrices: () => {
                          this._calcMatrices();
                        },
                        constrain: (i, l) => this.defaultConstrain(i, l),
                      },
                      e
                    )),
                    (this._globeness = 1),
                    (this._mercatorTransform = new ea()),
                    (this._verticalPerspectiveTransform = new Il());
                }
                clone() {
                  const e = new Ml();
                  return (
                    (e._globeness = this._globeness),
                    (e._globeLatitudeErrorCorrectionRadians =
                      this._globeLatitudeErrorCorrectionRadians),
                    e.apply(this),
                    e
                  );
                }
                apply(e) {
                  this._helper.apply(e),
                    this._mercatorTransform.apply(this),
                    this._verticalPerspectiveTransform.apply(
                      this,
                      this._globeLatitudeErrorCorrectionRadians
                    );
                }
                get projectionMatrix() {
                  return this.currentTransform.projectionMatrix;
                }
                get modelViewProjectionMatrix() {
                  return this.currentTransform.modelViewProjectionMatrix;
                }
                get inverseProjectionMatrix() {
                  return this.currentTransform.inverseProjectionMatrix;
                }
                get cameraPosition() {
                  return this.currentTransform.cameraPosition;
                }
                getProjectionData(e) {
                  const i = this._mercatorTransform.getProjectionData(e),
                    l = this._verticalPerspectiveTransform.getProjectionData(e);
                  return {
                    mainMatrix: this.isGlobeRendering
                      ? l.mainMatrix
                      : i.mainMatrix,
                    clippingPlane: l.clippingPlane,
                    tileMercatorCoords: l.tileMercatorCoords,
                    projectionTransition: e.applyGlobeMatrix
                      ? this._globeness
                      : 0,
                    fallbackMatrix: i.fallbackMatrix,
                  };
                }
                isLocationOccluded(e) {
                  return this.currentTransform.isLocationOccluded(e);
                }
                transformLightDirection(e) {
                  return this.currentTransform.transformLightDirection(e);
                }
                getPixelScale() {
                  return s.bn(
                    this._mercatorTransform.getPixelScale(),
                    this._verticalPerspectiveTransform.getPixelScale(),
                    this._globeness
                  );
                }
                getCircleRadiusCorrection() {
                  return s.bn(
                    this._mercatorTransform.getCircleRadiusCorrection(),
                    this._verticalPerspectiveTransform.getCircleRadiusCorrection(),
                    this._globeness
                  );
                }
                getPitchedTextCorrection(e, i, l) {
                  const u = this._mercatorTransform.getPitchedTextCorrection(
                      e,
                      i,
                      l
                    ),
                    d =
                      this._verticalPerspectiveTransform.getPitchedTextCorrection(
                        e,
                        i,
                        l
                      );
                  return s.bn(u, d, this._globeness);
                }
                projectTileCoordinates(e, i, l, u) {
                  return this.currentTransform.projectTileCoordinates(
                    e,
                    i,
                    l,
                    u
                  );
                }
                _calcMatrices() {
                  this._helper._width &&
                    this._helper._height &&
                    (this._verticalPerspectiveTransform.apply(
                      this,
                      this._globeLatitudeErrorCorrectionRadians
                    ),
                    (this._helper._nearZ =
                      this._verticalPerspectiveTransform.nearZ),
                    (this._helper._farZ =
                      this._verticalPerspectiveTransform.farZ),
                    this._mercatorTransform.apply(
                      this,
                      !0,
                      this.isGlobeRendering
                    ),
                    (this._helper._nearZ = this._mercatorTransform.nearZ),
                    (this._helper._farZ = this._mercatorTransform.farZ));
                }
                calculateFogMatrix(e) {
                  return this.currentTransform.calculateFogMatrix(e);
                }
                getVisibleUnwrappedCoordinates(e) {
                  return this.currentTransform.getVisibleUnwrappedCoordinates(
                    e
                  );
                }
                getCameraFrustum() {
                  return this.currentTransform.getCameraFrustum();
                }
                getClippingPlane() {
                  return this.currentTransform.getClippingPlane();
                }
                getCoveringTilesDetailsProvider() {
                  return this.currentTransform.getCoveringTilesDetailsProvider();
                }
                recalculateZoomAndCenter(e) {
                  this._mercatorTransform.recalculateZoomAndCenter(e),
                    this._verticalPerspectiveTransform.recalculateZoomAndCenter(
                      e
                    );
                }
                maxPitchScaleFactor() {
                  return this._mercatorTransform.maxPitchScaleFactor();
                }
                getCameraPoint() {
                  return this._helper.getCameraPoint();
                }
                getCameraAltitude() {
                  return this._helper.getCameraAltitude();
                }
                getCameraLngLat() {
                  return this._helper.getCameraLngLat();
                }
                lngLatToCameraDepth(e, i) {
                  return this.currentTransform.lngLatToCameraDepth(e, i);
                }
                populateCache(e) {
                  this._mercatorTransform.populateCache(e),
                    this._verticalPerspectiveTransform.populateCache(e);
                }
                getBounds() {
                  return this.currentTransform.getBounds();
                }
                calculateCenterFromCameraLngLatAlt(e, i, l, u) {
                  return this._helper.calculateCenterFromCameraLngLatAlt(
                    e,
                    i,
                    l,
                    u
                  );
                }
                setLocationAtPoint(e, i) {
                  if (!this.isGlobeRendering)
                    return (
                      this._mercatorTransform.setLocationAtPoint(e, i),
                      void this.apply(this._mercatorTransform)
                    );
                  this._verticalPerspectiveTransform.setLocationAtPoint(e, i),
                    this.apply(this._verticalPerspectiveTransform);
                }
                locationToScreenPoint(e, i) {
                  return this.currentTransform.locationToScreenPoint(e, i);
                }
                screenPointToMercatorCoordinate(e, i) {
                  return this.currentTransform.screenPointToMercatorCoordinate(
                    e,
                    i
                  );
                }
                screenPointToLocation(e, i) {
                  return this.currentTransform.screenPointToLocation(e, i);
                }
                isPointOnMapSurface(e, i) {
                  return this.currentTransform.isPointOnMapSurface(e, i);
                }
                getRayDirectionFromPixel(e) {
                  return this._verticalPerspectiveTransform.getRayDirectionFromPixel(
                    e
                  );
                }
                getMatrixForModel(e, i) {
                  return this.currentTransform.getMatrixForModel(e, i);
                }
                getProjectionDataForCustomLayer(e = !0) {
                  const i =
                    this._mercatorTransform.getProjectionDataForCustomLayer(e);
                  if (!this.isGlobeRendering) return i;
                  const l =
                    this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(
                      e
                    );
                  return (l.fallbackMatrix = i.mainMatrix), l;
                }
                getFastPathSimpleProjectionMatrix(e) {
                  return this.currentTransform.getFastPathSimpleProjectionMatrix(
                    e
                  );
                }
              }
              class Ia {
                get useGlobeControls() {
                  return !0;
                }
                handlePanInertia(e, i) {
                  const l = Pl(e, i);
                  return (
                    Math.abs(l.lng - i.center.lng) > 180 &&
                      (l.lng =
                        i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)),
                    { easingCenter: l, easingOffset: new s.P(0, 0) }
                  );
                }
                handleMapControlsRollPitchBearingZoom(e, i) {
                  const l = e.around,
                    u = i.screenPointToLocation(l);
                  e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
                    e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
                    e.rollDelta && i.setRoll(i.roll + e.rollDelta);
                  const d = i.zoom;
                  e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
                  const g = i.zoom - d;
                  if (g === 0) return;
                  const w = s.bD(i.center.lng, u.lng),
                    S = w / (Math.abs(w / 180) + 1),
                    k = s.bD(i.center.lat, u.lat),
                    z = i.getRayDirectionFromPixel(l),
                    V = i.cameraPosition,
                    F = -1 * s.a_(V, z),
                    $ = s.bs();
                  s.aV($, V, [z[0] * F, z[1] * F, z[2] * F]);
                  const J = s.b0($) - 1,
                    ae = Math.exp(0.5 * -Math.max(J - 0.3, 0)),
                    oe =
                      js(i.worldSize, i.center.lat) /
                      Math.min(i.width, i.height),
                    se = s.bq(oe, 0.9, 0.5, 1, 0.25),
                    fe = (1 - s.al(-g)) * Math.min(ae, se),
                    be = i.center.lat,
                    pe = i.zoom,
                    we = new s.U(
                      i.center.lng + S * fe,
                      s.ai(i.center.lat + k * fe, -s.aj, s.aj)
                    );
                  i.setLocationAtPoint(u, l);
                  const Pe = i.center,
                    ve = s.bq(Math.abs(w), 45, 85, 0, 1),
                    Re = s.bq(oe, 0.75, 0.35, 0, 1),
                    it = Math.pow(Math.max(ve, Re), 0.25),
                    Qe = s.bD(Pe.lng, we.lng),
                    tt = s.bD(Pe.lat, we.lat);
                  i.setCenter(
                    new s.U(Pe.lng + Qe * it, Pe.lat + tt * it).wrap()
                  ),
                    i.setZoom(pe + zn(be, i.center.lat));
                }
                handleMapControlsPan(e, i, l) {
                  if (!e.panDelta) return;
                  const u = i.center.lat,
                    d = i.zoom;
                  i.setCenter(Pl(e.panDelta, i).wrap()),
                    i.setZoom(d + zn(u, i.center.lat));
                }
                cameraForBoxAndBearing(e, i, l, u, d) {
                  const g = ta(e, i, l, u, d),
                    w = (i.left / d.width) * 2 - 1,
                    S = ((d.width - i.right) / d.width) * 2 - 1,
                    k = (i.top / d.height) * -2 + 1,
                    z = ((d.height - i.bottom) / d.height) * -2 + 1,
                    V = s.bD(l.getWest(), l.getEast()) < 0,
                    F = V ? l.getEast() : l.getWest(),
                    $ = V ? l.getWest() : l.getEast(),
                    J = Math.max(l.getNorth(), l.getSouth()),
                    ae = Math.min(l.getNorth(), l.getSouth()),
                    oe = F + 0.5 * s.bD(F, $),
                    se = J + 0.5 * s.bD(J, ae),
                    fe = d.clone();
                  fe.setCenter(g.center),
                    fe.setBearing(g.bearing),
                    fe.setPitch(0),
                    fe.setRoll(0),
                    fe.setZoom(g.zoom);
                  const be = fe.modelViewProjectionMatrix,
                    pe = [
                      Pi(l.getNorthWest()),
                      Pi(l.getNorthEast()),
                      Pi(l.getSouthWest()),
                      Pi(l.getSouthEast()),
                      Pi(new s.U($, se)),
                      Pi(new s.U(F, se)),
                      Pi(new s.U(oe, J)),
                      Pi(new s.U(oe, ae)),
                    ],
                    we = Pi(g.center);
                  let Pe = Number.POSITIVE_INFINITY;
                  for (const ve of pe)
                    w < 0 &&
                      (Pe = Ia.getLesserNonNegativeNonNull(
                        Pe,
                        Ia.solveVectorScale(ve, we, be, "x", w)
                      )),
                      S > 0 &&
                        (Pe = Ia.getLesserNonNegativeNonNull(
                          Pe,
                          Ia.solveVectorScale(ve, we, be, "x", S)
                        )),
                      k > 0 &&
                        (Pe = Ia.getLesserNonNegativeNonNull(
                          Pe,
                          Ia.solveVectorScale(ve, we, be, "y", k)
                        )),
                      z < 0 &&
                        (Pe = Ia.getLesserNonNegativeNonNull(
                          Pe,
                          Ia.solveVectorScale(ve, we, be, "y", z)
                        ));
                  if (Number.isFinite(Pe) && Pe !== 0)
                    return (g.zoom = fe.zoom + s.ao(Pe)), g;
                  Dn();
                }
                handleJumpToCenterZoom(e, i) {
                  const l = e.center.lat,
                    u = e.constrain(
                      i.center ? s.U.convert(i.center) : e.center,
                      e.zoom
                    ).center;
                  e.setCenter(u.wrap());
                  const d = i.zoom !== void 0 ? +i.zoom : e.zoom + zn(l, u.lat);
                  e.zoom !== d && e.setZoom(d);
                }
                handleEaseTo(e, i) {
                  const l = e.zoom,
                    u = e.center,
                    d = e.padding,
                    g = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
                    w = {
                      roll: i.roll === void 0 ? e.roll : i.roll,
                      pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                      bearing: i.bearing === void 0 ? e.bearing : i.bearing,
                    },
                    S = i.zoom !== void 0,
                    k = !e.isPaddingEqual(i.padding);
                  let z = !1;
                  const V = i.center ? s.U.convert(i.center) : u,
                    F = e.constrain(V, l).center;
                  sn(e, F);
                  const $ = e.clone();
                  $.setCenter(F),
                    $.setZoom(S ? +i.zoom : l + zn(u.lat, V.lat)),
                    $.setBearing(i.bearing);
                  const J = new s.P(
                    s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
                    s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)
                  );
                  $.setLocationAtPoint(F, J);
                  const ae =
                      (i.offset && i.offsetAsPoint.mag()) > 0 ? $.center : F,
                    oe = S ? +i.zoom : l + zn(u.lat, ae.lat),
                    se = l + zn(u.lat, 0),
                    fe = oe + zn(ae.lat, 0),
                    be = s.bD(u.lng, ae.lng),
                    pe = s.bD(u.lat, ae.lat),
                    we = s.al(fe - se);
                  return (
                    (z = oe !== l),
                    {
                      easeFunc: (Pe) => {
                        if (
                          (s.bh(g, w) ||
                            ga({
                              startEulerAngles: g,
                              endEulerAngles: w,
                              tr: e,
                              k: Pe,
                              useSlerp: g.roll != w.roll,
                            }),
                          k && e.interpolatePadding(d, i.padding, Pe),
                          i.around)
                        )
                          s.w(
                            "Easing around a point is not supported under globe projection."
                          ),
                            e.setLocationAtPoint(i.around, i.aroundPoint);
                        else {
                          const ve =
                              fe > se ? Math.min(2, we) : Math.max(0.5, we),
                            Re = Math.pow(ve, 1 - Pe),
                            it = Vs(u, be, pe, Pe * Re);
                          e.setCenter(it.wrap());
                        }
                        if (z) {
                          const ve =
                            s.F.number(se, fe, Pe) + zn(0, e.center.lat);
                          e.setZoom(ve);
                        }
                      },
                      isZooming: z,
                      elevationCenter: ae,
                    }
                  );
                }
                handleFlyTo(e, i) {
                  const l = i.zoom !== void 0,
                    u = e.center,
                    d = e.zoom,
                    g = e.padding,
                    w = !e.isPaddingEqual(i.padding),
                    S = e.constrain(
                      s.U.convert(i.center || i.locationAtOffset),
                      d
                    ).center,
                    k = l ? +i.zoom : e.zoom + zn(e.center.lat, S.lat),
                    z = e.clone();
                  z.setCenter(S), z.setZoom(k), z.setBearing(i.bearing);
                  const V = new s.P(
                    s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
                    s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)
                  );
                  z.setLocationAtPoint(S, V);
                  const F = z.center;
                  sn(e, F);
                  const $ = (function (pe, we, Pe) {
                      const ve = Pi(we),
                        Re = Pi(Pe),
                        it = s.a_(ve, Re),
                        Qe = Math.acos(it),
                        tt = fs(pe);
                      return (Qe / (2 * Math.PI)) * tt;
                    })(e, u, F),
                    J = d + zn(u.lat, 0),
                    ae = k + zn(F.lat, 0),
                    oe = s.al(ae - J);
                  let se;
                  if (typeof i.minZoom == "number") {
                    const pe = +i.minZoom + zn(F.lat, 0),
                      we = Math.min(pe, J, ae) + zn(0, F.lat),
                      Pe = e.constrain(F, we).zoom + zn(F.lat, 0);
                    se = s.al(Pe - J);
                  }
                  const fe = s.bD(u.lng, F.lng),
                    be = s.bD(u.lat, F.lat);
                  return {
                    easeFunc: (pe, we, Pe, ve) => {
                      const Re = Vs(u, fe, be, Pe);
                      w && e.interpolatePadding(g, i.padding, pe);
                      const it = pe === 1 ? F : Re;
                      e.setCenter(it.wrap());
                      const Qe = J + s.ao(we);
                      e.setZoom(pe === 1 ? k : Qe + zn(0, it.lat));
                    },
                    scaleOfZoom: oe,
                    targetCenter: F,
                    scaleOfMinZoom: se,
                    pixelPathLength: $,
                  };
                }
                static solveVectorScale(e, i, l, u, d) {
                  const g =
                      u === "x"
                        ? [l[0], l[4], l[8], l[12]]
                        : [l[1], l[5], l[9], l[13]],
                    w = [l[3], l[7], l[11], l[15]],
                    S = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
                    k = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
                    z = i[0] * g[0] + i[1] * g[1] + i[2] * g[2],
                    V = i[0] * w[0] + i[1] * w[1] + i[2] * w[2];
                  return z + d * k === S + d * V ||
                    w[3] * (S - z) + g[3] * (V - k) + S * V == z * k
                    ? null
                    : (z + g[3] - d * V - d * w[3]) / (z - S - d * V + d * k);
                }
                static getLesserNonNegativeNonNull(e, i) {
                  return i !== null && i >= 0 && i < e ? i : e;
                }
              }
              class qs {
                constructor(e) {
                  (this._globe = e),
                    (this._mercatorCameraHelper = new va()),
                    (this._verticalPerspectiveCameraHelper = new Ia());
                }
                get useGlobeControls() {
                  return this._globe.useGlobeRendering;
                }
                get currentHelper() {
                  return this.useGlobeControls
                    ? this._verticalPerspectiveCameraHelper
                    : this._mercatorCameraHelper;
                }
                handlePanInertia(e, i) {
                  return this.currentHelper.handlePanInertia(e, i);
                }
                handleMapControlsRollPitchBearingZoom(e, i) {
                  return this.currentHelper.handleMapControlsRollPitchBearingZoom(
                    e,
                    i
                  );
                }
                handleMapControlsPan(e, i, l) {
                  this.currentHelper.handleMapControlsPan(e, i, l);
                }
                cameraForBoxAndBearing(e, i, l, u, d) {
                  return this.currentHelper.cameraForBoxAndBearing(
                    e,
                    i,
                    l,
                    u,
                    d
                  );
                }
                handleJumpToCenterZoom(e, i) {
                  this.currentHelper.handleJumpToCenterZoom(e, i);
                }
                handleEaseTo(e, i) {
                  return this.currentHelper.handleEaseTo(e, i);
                }
                handleFlyTo(e, i) {
                  return this.currentHelper.handleFlyTo(e, i);
                }
              }
              const ms = (h, e) =>
                  s.z(
                    h,
                    e && e.filter((i) => i.identifier !== "source.canvas")
                  ),
                Al = s.bH();
              class Us extends s.E {
                constructor(e, i = {}) {
                  var l, u;
                  super(),
                    (this._rtlPluginLoaded = () => {
                      for (const g in this.tileManagers) {
                        const w = this.tileManagers[g].getSource().type;
                        (w !== "vector" && w !== "geojson") ||
                          this.tileManagers[g].reload();
                      }
                    }),
                    (this.map = e),
                    (this.dispatcher = new xt(at(), e._getMapId())),
                    this.dispatcher.registerMessageHandler("GG", (g, w) =>
                      this.getGlyphs(g, w)
                    ),
                    this.dispatcher.registerMessageHandler("GI", (g, w) =>
                      this.getImages(g, w)
                    ),
                    this.dispatcher.registerMessageHandler("GDA", (g, w) =>
                      this.getDashes(g, w)
                    ),
                    (this.imageManager = new nt()),
                    this.imageManager.setEventedParent(this);
                  const d =
                    ((l = e._container) === null || l === void 0
                      ? void 0
                      : l.lang) ||
                    (typeof document < "u" &&
                      ((u = document.documentElement) === null || u === void 0
                        ? void 0
                        : u.lang)) ||
                    void 0;
                  (this.glyphManager = new Xe(
                    e._requestManager,
                    i.localIdeographFontFamily,
                    d
                  )),
                    (this.lineAtlas = new yt(256, 512)),
                    (this.crossTileSymbolIndex = new dn()),
                    (this._spritesImagesIds = {}),
                    (this._layers = {}),
                    (this._order = []),
                    (this.tileManagers = {}),
                    (this.zoomHistory = new s.bI()),
                    (this._loaded = !1),
                    (this._availableImages = []),
                    (this._globalState = {}),
                    this._resetUpdates(),
                    this.dispatcher.broadcast("SR", s.bJ()),
                    D().on(Te, this._rtlPluginLoaded),
                    this.on("data", (g) => {
                      if (
                        g.dataType !== "source" ||
                        g.sourceDataType !== "metadata"
                      )
                        return;
                      const w = this.tileManagers[g.sourceId];
                      if (!w) return;
                      const S = w.getSource();
                      if (S && S.vectorLayerIds)
                        for (const k in this._layers) {
                          const z = this._layers[k];
                          z.source === S.id && this._validateLayer(z);
                        }
                    });
                }
                setGlobalStateProperty(e, i) {
                  var l, u, d;
                  this._checkLoaded();
                  const g =
                    i === null
                      ? (d =
                          (u =
                            (l = this.stylesheet.state) === null || l === void 0
                              ? void 0
                              : l[e]) === null || u === void 0
                            ? void 0
                            : u.default) !== null && d !== void 0
                        ? d
                        : null
                      : i;
                  if (s.bK(g, this._globalState[e])) return this;
                  (this._globalState[e] = g),
                    this._applyGlobalStateChanges([e]);
                }
                getGlobalState() {
                  return this._globalState;
                }
                setGlobalState(e) {
                  this._checkLoaded();
                  const i = [];
                  for (const l in e)
                    !s.bK(this._globalState[l], e[l].default) &&
                      (i.push(l), (this._globalState[l] = e[l].default));
                  this._applyGlobalStateChanges(i);
                }
                _applyGlobalStateChanges(e) {
                  if (e.length === 0) return;
                  const i = new Set(),
                    l = {};
                  for (const u of e) {
                    l[u] = this._globalState[u];
                    for (const d in this._layers) {
                      const g = this._layers[d],
                        w = g.getLayoutAffectingGlobalStateRefs(),
                        S = g.getPaintAffectingGlobalStateRefs();
                      if ((w.has(u) && i.add(g.source), S.has(u)))
                        for (const { name: k, value: z } of S.get(u))
                          this._updatePaintProperty(g, k, z);
                    }
                  }
                  this.dispatcher.broadcast("UGS", l);
                  for (const u in this.tileManagers)
                    i.has(u) && (this._reloadSource(u), (this._changed = !0));
                }
                loadURL(e, i = {}, l) {
                  this.fire(new s.l("dataloading", { dataType: "style" })),
                    (i.validate = typeof i.validate != "boolean" || i.validate);
                  const u = this.map._requestManager.transformRequest(
                    e,
                    "Style"
                  );
                  this._loadStyleRequest = new AbortController();
                  const d = this._loadStyleRequest;
                  s.j(u, this._loadStyleRequest)
                    .then((g) => {
                      (this._loadStyleRequest = null), this._load(g.data, i, l);
                    })
                    .catch((g) => {
                      (this._loadStyleRequest = null),
                        g && !d.signal.aborted && this.fire(new s.k(g));
                    });
                }
                loadJSON(e, i = {}, l) {
                  this.fire(new s.l("dataloading", { dataType: "style" })),
                    (this._frameRequest = new AbortController()),
                    re
                      .frameAsync(this._frameRequest)
                      .then(() => {
                        (this._frameRequest = null),
                          (i.validate = i.validate !== !1),
                          this._load(e, i, l);
                      })
                      .catch(() => {});
                }
                loadEmpty() {
                  this.fire(new s.l("dataloading", { dataType: "style" })),
                    this._load(Al, { validate: !1 });
                }
                _load(e, i, l) {
                  var u, d;
                  let g = i.transformStyle ? i.transformStyle(l, e) : e;
                  if (!i.validate || !ms(this, s.B(g))) {
                    (g = Object.assign({}, g)),
                      (this._loaded = !0),
                      (this.stylesheet = g);
                    for (const w in g.sources)
                      this.addSource(w, g.sources[w], { validate: !1 });
                    g.sprite
                      ? this._loadSprite(g.sprite)
                      : this.imageManager.setLoaded(!0),
                      this.glyphManager.setURL(g.glyphs),
                      this._createLayers(),
                      (this.light = new Fe(this.stylesheet.light)),
                      this._setProjectionInternal(
                        ((u = this.stylesheet.projection) === null ||
                        u === void 0
                          ? void 0
                          : u.type) || "mercator"
                      ),
                      (this.sky = new lt(this.stylesheet.sky)),
                      this.map.setTerrain(
                        (d = this.stylesheet.terrain) !== null && d !== void 0
                          ? d
                          : null
                      ),
                      this.fire(new s.l("data", { dataType: "style" })),
                      this.fire(new s.l("style.load"));
                  }
                }
                _createLayers() {
                  var e, i, l;
                  const u = s.bL(this.stylesheet.layers);
                  this.setGlobalState(
                    (e = this.stylesheet.state) !== null && e !== void 0
                      ? e
                      : null
                  ),
                    this.dispatcher.broadcast("SL", u),
                    (this._order = u.map((d) => d.id)),
                    (this._layers = {}),
                    (this._serializedLayers = null);
                  for (const d of u) {
                    const g = s.bM(d, this._globalState);
                    if (
                      (g.setEventedParent(this, { layer: { id: d.id } }),
                      (this._layers[d.id] = g),
                      s.bN(g) && this.tileManagers[g.source])
                    ) {
                      const w =
                        (l =
                          (i = d.paint) === null || i === void 0
                            ? void 0
                            : i["raster-fade-duration"]) !== null &&
                        l !== void 0
                          ? l
                          : g.paint.get("raster-fade-duration");
                      this.tileManagers[g.source].setRasterFadeDuration(w);
                    }
                  }
                }
                _loadSprite(e, i = !1, l = void 0) {
                  let u;
                  this.imageManager.setLoaded(!1),
                    (this._spriteRequest = new AbortController()),
                    (function (d, g, w, S) {
                      return s._(this, void 0, void 0, function* () {
                        const k = ke(d),
                          z = w > 1 ? "@2x" : "",
                          V = {},
                          F = {};
                        for (const { id: $, url: J } of k) {
                          const ae = g.transformRequest(
                            $e(J, z, ".json"),
                            "SpriteJSON"
                          );
                          V[$] = s.j(ae, S);
                          const oe = g.transformRequest(
                            $e(J, z, ".png"),
                            "SpriteImage"
                          );
                          F[$] = Ue.getImage(oe, S);
                        }
                        return (
                          yield Promise.all([
                            ...Object.values(V),
                            ...Object.values(F),
                          ]),
                          (function ($, J) {
                            return s._(this, void 0, void 0, function* () {
                              const ae = {};
                              for (const oe in $) {
                                ae[oe] = {};
                                const se = re.getImageCanvasContext(
                                    (yield J[oe]).data
                                  ),
                                  fe = (yield $[oe]).data;
                                for (const be in fe) {
                                  const {
                                    width: pe,
                                    height: we,
                                    x: Pe,
                                    y: ve,
                                    sdf: Re,
                                    pixelRatio: it,
                                    stretchX: Qe,
                                    stretchY: tt,
                                    content: ot,
                                    textFitWidth: Zt,
                                    textFitHeight: Ht,
                                  } = fe[be];
                                  ae[oe][be] = {
                                    data: null,
                                    pixelRatio: it,
                                    sdf: Re,
                                    stretchX: Qe,
                                    stretchY: tt,
                                    content: ot,
                                    textFitWidth: Zt,
                                    textFitHeight: Ht,
                                    spriteData: {
                                      width: pe,
                                      height: we,
                                      x: Pe,
                                      y: ve,
                                      context: se,
                                    },
                                  };
                                }
                              }
                              return ae;
                            });
                          })(V, F)
                        );
                      });
                    })(
                      e,
                      this.map._requestManager,
                      this.map.getPixelRatio(),
                      this._spriteRequest
                    )
                      .then((d) => {
                        if (((this._spriteRequest = null), d))
                          for (const g in d) {
                            this._spritesImagesIds[g] = [];
                            const w = this._spritesImagesIds[g]
                              ? this._spritesImagesIds[g].filter(
                                  (S) => !(S in d)
                                )
                              : [];
                            for (const S of w)
                              this.imageManager.removeImage(S),
                                (this._changedImages[S] = !0);
                            for (const S in d[g]) {
                              const k = g === "default" ? S : `${g}:${S}`;
                              this._spritesImagesIds[g].push(k),
                                k in this.imageManager.images
                                  ? this.imageManager.updateImage(
                                      k,
                                      d[g][S],
                                      !1
                                    )
                                  : this.imageManager.addImage(k, d[g][S]),
                                i && (this._changedImages[k] = !0);
                            }
                          }
                      })
                      .catch((d) => {
                        (this._spriteRequest = null),
                          (u = d),
                          this.fire(new s.k(u));
                      })
                      .finally(() => {
                        this.imageManager.setLoaded(!0),
                          (this._availableImages =
                            this.imageManager.listImages()),
                          i && (this._changed = !0),
                          this.dispatcher.broadcast(
                            "SI",
                            this._availableImages
                          ),
                          this.fire(new s.l("data", { dataType: "style" })),
                          l && l(u);
                      });
                }
                _unloadSprite() {
                  for (const e of Object.values(this._spritesImagesIds).flat())
                    this.imageManager.removeImage(e),
                      (this._changedImages[e] = !0);
                  (this._spritesImagesIds = {}),
                    (this._availableImages = this.imageManager.listImages()),
                    (this._changed = !0),
                    this.dispatcher.broadcast("SI", this._availableImages),
                    this.fire(new s.l("data", { dataType: "style" }));
                }
                _validateLayer(e) {
                  const i = this.tileManagers[e.source];
                  if (!i) return;
                  const l = e.sourceLayer;
                  if (!l) return;
                  const u = i.getSource();
                  (u.type === "geojson" ||
                    (u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1)) &&
                    this.fire(
                      new s.k(
                        new Error(
                          `Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`
                        )
                      )
                    );
                }
                loaded() {
                  if (!this._loaded || Object.keys(this._updatedSources).length)
                    return !1;
                  for (const e in this.tileManagers)
                    if (!this.tileManagers[e].loaded()) return !1;
                  return !!this.imageManager.isLoaded();
                }
                _serializeByIds(e, i = !1) {
                  const l = this._serializedAllLayers();
                  if (!e || e.length === 0)
                    return Object.values(i ? s.bO(l) : l);
                  const u = [];
                  for (const d of e)
                    if (l[d]) {
                      const g = i ? s.bO(l[d]) : l[d];
                      u.push(g);
                    }
                  return u;
                }
                _serializedAllLayers() {
                  let e = this._serializedLayers;
                  if (e) return e;
                  e = this._serializedLayers = {};
                  const i = Object.keys(this._layers);
                  for (const l of i) {
                    const u = this._layers[l];
                    u.type !== "custom" && (e[l] = u.serialize());
                  }
                  return e;
                }
                hasTransitions() {
                  var e, i, l;
                  if (
                    (!((e = this.light) === null || e === void 0) &&
                      e.hasTransition()) ||
                    (!((i = this.sky) === null || i === void 0) &&
                      i.hasTransition()) ||
                    (!((l = this.projection) === null || l === void 0) &&
                      l.hasTransition())
                  )
                    return !0;
                  for (const u in this.tileManagers)
                    if (this.tileManagers[u].hasTransition()) return !0;
                  for (const u in this._layers)
                    if (this._layers[u].hasTransition()) return !0;
                  return !1;
                }
                _checkLoaded() {
                  if (!this._loaded)
                    throw new Error("Style is not done loading.");
                }
                update(e) {
                  if (!this._loaded) return;
                  const i = this._changed;
                  if (i) {
                    const u = Object.keys(this._updatedLayers),
                      d = Object.keys(this._removedLayers);
                    (u.length || d.length) && this._updateWorkerLayers(u, d);
                    for (const g in this._updatedSources) {
                      const w = this._updatedSources[g];
                      if (w === "reload") this._reloadSource(g);
                      else {
                        if (w !== "clear")
                          throw new Error(`Invalid action ${w}`);
                        this._clearSource(g);
                      }
                    }
                    this._updateTilesForChangedImages(),
                      this._updateTilesForChangedGlyphs();
                    for (const g in this._updatedPaintProps)
                      this._layers[g].updateTransitions(e);
                    this.light.updateTransitions(e),
                      this.sky.updateTransitions(e),
                      this._resetUpdates();
                  }
                  const l = {};
                  for (const u in this.tileManagers) {
                    const d = this.tileManagers[u];
                    (l[u] = d.used), (d.used = !1);
                  }
                  for (const u of this._order) {
                    const d = this._layers[u];
                    d.recalculate(e, this._availableImages),
                      !d.isHidden(e.zoom) &&
                        d.source &&
                        (this.tileManagers[d.source].used = !0);
                  }
                  for (const u in l) {
                    const d = this.tileManagers[u];
                    !!l[u] != !!d.used &&
                      d.fire(
                        new s.l("data", {
                          sourceDataType: "visibility",
                          dataType: "source",
                          sourceId: u,
                        })
                      );
                  }
                  this.light.recalculate(e),
                    this.sky.recalculate(e),
                    this.projection.recalculate(e),
                    (this.z = e.zoom),
                    i && this.fire(new s.l("data", { dataType: "style" }));
                }
                _updateTilesForChangedImages() {
                  const e = Object.keys(this._changedImages);
                  if (e.length) {
                    for (const i in this.tileManagers)
                      this.tileManagers[i].reloadTilesForDependencies(
                        ["icons", "patterns"],
                        e
                      );
                    this._changedImages = {};
                  }
                }
                _updateTilesForChangedGlyphs() {
                  if (this._glyphsDidChange) {
                    for (const e in this.tileManagers)
                      this.tileManagers[e].reloadTilesForDependencies(
                        ["glyphs"],
                        [""]
                      );
                    this._glyphsDidChange = !1;
                  }
                }
                _updateWorkerLayers(e, i) {
                  this.dispatcher.broadcast("UL", {
                    layers: this._serializeByIds(e, !1),
                    removedIds: i,
                  });
                }
                _resetUpdates() {
                  (this._changed = !1),
                    (this._updatedLayers = {}),
                    (this._removedLayers = {}),
                    (this._updatedSources = {}),
                    (this._updatedPaintProps = {}),
                    (this._changedImages = {}),
                    (this._glyphsDidChange = !1);
                }
                setState(e, i = {}) {
                  var l;
                  this._checkLoaded();
                  const u = this.serialize();
                  if (
                    ((e = i.transformStyle ? i.transformStyle(u, e) : e),
                    ((l = i.validate) === null || l === void 0 || l) &&
                      ms(this, s.B(e)))
                  )
                    return !1;
                  (e = s.bO(e)).layers = s.bL(e.layers);
                  const d = s.bP(u, e),
                    g = this._getOperationsToPerform(d);
                  if (g.unimplemented.length > 0)
                    throw new Error(
                      `Unimplemented: ${g.unimplemented.join(", ")}.`
                    );
                  if (g.operations.length === 0) return !1;
                  for (const w of g.operations) w();
                  return (
                    (this.stylesheet = e), (this._serializedLayers = null), !0
                  );
                }
                _getOperationsToPerform(e) {
                  const i = [],
                    l = [];
                  for (const u of e)
                    switch (u.command) {
                      case "setCenter":
                      case "setZoom":
                      case "setBearing":
                      case "setPitch":
                      case "setRoll":
                        continue;
                      case "addLayer":
                        i.push(() => this.addLayer.apply(this, u.args));
                        break;
                      case "removeLayer":
                        i.push(() => this.removeLayer.apply(this, u.args));
                        break;
                      case "setPaintProperty":
                        i.push(() => this.setPaintProperty.apply(this, u.args));
                        break;
                      case "setLayoutProperty":
                        i.push(() =>
                          this.setLayoutProperty.apply(this, u.args)
                        );
                        break;
                      case "setFilter":
                        i.push(() => this.setFilter.apply(this, u.args));
                        break;
                      case "addSource":
                        i.push(() => this.addSource.apply(this, u.args));
                        break;
                      case "removeSource":
                        i.push(() => this.removeSource.apply(this, u.args));
                        break;
                      case "setLayerZoomRange":
                        i.push(() =>
                          this.setLayerZoomRange.apply(this, u.args)
                        );
                        break;
                      case "setLight":
                        i.push(() => this.setLight.apply(this, u.args));
                        break;
                      case "setGeoJSONSourceData":
                        i.push(() =>
                          this.setGeoJSONSourceData.apply(this, u.args)
                        );
                        break;
                      case "setGlyphs":
                        i.push(() => this.setGlyphs.apply(this, u.args));
                        break;
                      case "setSprite":
                        i.push(() => this.setSprite.apply(this, u.args));
                        break;
                      case "setTerrain":
                        i.push(() => this.map.setTerrain.apply(this, u.args));
                        break;
                      case "setSky":
                        i.push(() => this.setSky.apply(this, u.args));
                        break;
                      case "setProjection":
                        this.setProjection.apply(this, u.args);
                        break;
                      case "setGlobalState":
                        i.push(() => this.setGlobalState.apply(this, u.args));
                        break;
                      case "setTransition":
                        i.push(() => {});
                        break;
                      default:
                        l.push(u.command);
                    }
                  return { operations: i, unimplemented: l };
                }
                addImage(e, i) {
                  if (this.getImage(e))
                    return this.fire(
                      new s.k(
                        new Error(`An image named "${e}" already exists.`)
                      )
                    );
                  this.imageManager.addImage(e, i), this._afterImageUpdated(e);
                }
                updateImage(e, i) {
                  this.imageManager.updateImage(e, i);
                }
                getImage(e) {
                  return this.imageManager.getImage(e);
                }
                removeImage(e) {
                  if (!this.getImage(e))
                    return this.fire(
                      new s.k(
                        new Error(`An image named "${e}" does not exist.`)
                      )
                    );
                  this.imageManager.removeImage(e), this._afterImageUpdated(e);
                }
                _afterImageUpdated(e) {
                  (this._availableImages = this.imageManager.listImages()),
                    (this._changedImages[e] = !0),
                    (this._changed = !0),
                    this.dispatcher.broadcast("SI", this._availableImages),
                    this.fire(new s.l("data", { dataType: "style" }));
                }
                listImages() {
                  return this._checkLoaded(), this.imageManager.listImages();
                }
                addSource(e, i, l = {}) {
                  if ((this._checkLoaded(), this.tileManagers[e] !== void 0))
                    throw new Error(`Source "${e}" already exists.`);
                  if (!i.type)
                    throw new Error(
                      `The type property must be defined, but only the following properties were given: ${Object.keys(
                        i
                      ).join(", ")}.`
                    );
                  if (
                    ["vector", "raster", "geojson", "video", "image"].indexOf(
                      i.type
                    ) >= 0 &&
                    this._validate(s.B.source, `sources.${e}`, i, null, l)
                  )
                    return;
                  this.map &&
                    this.map._collectResourceTiming &&
                    (i.collectResourceTiming = !0);
                  const u = (this.tileManagers[e] = new un(
                    e,
                    i,
                    this.dispatcher
                  ));
                  (u.style = this),
                    u.setEventedParent(this, () => ({
                      isSourceLoaded: u.loaded(),
                      source: u.serialize(),
                      sourceId: e,
                    })),
                    u.onAdd(this.map),
                    (this._changed = !0);
                }
                removeSource(e) {
                  if ((this._checkLoaded(), this.tileManagers[e] === void 0))
                    throw new Error("There is no source with this ID");
                  for (const l in this._layers)
                    if (this._layers[l].source === e)
                      return this.fire(
                        new s.k(
                          new Error(
                            `Source "${e}" cannot be removed while layer "${l}" is using it.`
                          )
                        )
                      );
                  const i = this.tileManagers[e];
                  delete this.tileManagers[e],
                    delete this._updatedSources[e],
                    i.fire(
                      new s.l("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: e,
                      })
                    ),
                    i.setEventedParent(null),
                    i.onRemove(this.map),
                    (this._changed = !0);
                }
                setGeoJSONSourceData(e, i) {
                  if ((this._checkLoaded(), this.tileManagers[e] === void 0))
                    throw new Error(`There is no source with this ID=${e}`);
                  const l = this.tileManagers[e].getSource();
                  if (l.type !== "geojson")
                    throw new Error(
                      `geojsonSource.type is ${l.type}, which is !== 'geojson`
                    );
                  l.setData(i), (this._changed = !0);
                }
                getSource(e) {
                  return (
                    this.tileManagers[e] && this.tileManagers[e].getSource()
                  );
                }
                addLayer(e, i, l = {}) {
                  this._checkLoaded();
                  const u = e.id;
                  if (this.getLayer(u))
                    return void this.fire(
                      new s.k(
                        new Error(`Layer "${u}" already exists on this map.`)
                      )
                    );
                  let d;
                  if (e.type === "custom") {
                    if (ms(this, s.bQ(e))) return;
                    d = s.bM(e, this._globalState);
                  } else {
                    if (
                      ("source" in e &&
                        typeof e.source == "object" &&
                        (this.addSource(u, e.source),
                        (e = s.bO(e)),
                        (e = s.e(e, { source: u }))),
                      this._validate(
                        s.B.layer,
                        `layers.${u}`,
                        e,
                        { arrayIndex: -1 },
                        l
                      ))
                    )
                      return;
                    (d = s.bM(e, this._globalState)),
                      this._validateLayer(d),
                      d.setEventedParent(this, { layer: { id: u } });
                  }
                  const g = i ? this._order.indexOf(i) : this._order.length;
                  if (i && g === -1)
                    this.fire(
                      new s.k(
                        new Error(
                          `Cannot add layer "${u}" before non-existing layer "${i}".`
                        )
                      )
                    );
                  else {
                    if (
                      (this._order.splice(g, 0, u),
                      (this._layerOrderChanged = !0),
                      (this._layers[u] = d),
                      this._removedLayers[u] && d.source && d.type !== "custom")
                    ) {
                      const w = this._removedLayers[u];
                      delete this._removedLayers[u],
                        w.type !== d.type
                          ? (this._updatedSources[d.source] = "clear")
                          : ((this._updatedSources[d.source] = "reload"),
                            this.tileManagers[d.source].pause());
                    }
                    this._updateLayer(d), d.onAdd && d.onAdd(this.map);
                  }
                }
                moveLayer(e, i) {
                  if (
                    (this._checkLoaded(),
                    (this._changed = !0),
                    !this._layers[e])
                  )
                    return void this.fire(
                      new s.k(
                        new Error(
                          `The layer '${e}' does not exist in the map's style and cannot be moved.`
                        )
                      )
                    );
                  if (e === i) return;
                  const l = this._order.indexOf(e);
                  this._order.splice(l, 1);
                  const u = i ? this._order.indexOf(i) : this._order.length;
                  i && u === -1
                    ? this.fire(
                        new s.k(
                          new Error(
                            `Cannot move layer "${e}" before non-existing layer "${i}".`
                          )
                        )
                      )
                    : (this._order.splice(u, 0, e),
                      (this._layerOrderChanged = !0));
                }
                removeLayer(e) {
                  this._checkLoaded();
                  const i = this._layers[e];
                  if (!i)
                    return void this.fire(
                      new s.k(
                        new Error(`Cannot remove non-existing layer "${e}".`)
                      )
                    );
                  i.setEventedParent(null);
                  const l = this._order.indexOf(e);
                  this._order.splice(l, 1),
                    (this._layerOrderChanged = !0),
                    (this._changed = !0),
                    (this._removedLayers[e] = i),
                    delete this._layers[e],
                    this._serializedLayers && delete this._serializedLayers[e],
                    delete this._updatedLayers[e],
                    delete this._updatedPaintProps[e],
                    i.onRemove && i.onRemove(this.map);
                }
                getLayer(e) {
                  return this._layers[e];
                }
                getLayersOrder() {
                  return [...this._order];
                }
                hasLayer(e) {
                  return e in this._layers;
                }
                setLayerZoomRange(e, i, l) {
                  this._checkLoaded();
                  const u = this.getLayer(e);
                  u
                    ? (u.minzoom === i && u.maxzoom === l) ||
                      (i != null && (u.minzoom = i),
                      l != null && (u.maxzoom = l),
                      this._updateLayer(u))
                    : this.fire(
                        new s.k(
                          new Error(
                            `Cannot set the zoom range of non-existing layer "${e}".`
                          )
                        )
                      );
                }
                setFilter(e, i, l = {}) {
                  this._checkLoaded();
                  const u = this.getLayer(e);
                  if (u) {
                    if (!s.bK(u.filter, i))
                      return i == null
                        ? (u.setFilter(void 0), void this._updateLayer(u))
                        : void (
                            this._validate(
                              s.B.filter,
                              `layers.${u.id}.filter`,
                              i,
                              null,
                              l
                            ) || (u.setFilter(s.bO(i)), this._updateLayer(u))
                          );
                  } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
                }
                getFilter(e) {
                  return s.bO(this.getLayer(e).filter);
                }
                setLayoutProperty(e, i, l, u = {}) {
                  this._checkLoaded();
                  const d = this.getLayer(e);
                  d
                    ? s.bK(d.getLayoutProperty(i), l) ||
                      (d.setLayoutProperty(i, l, u), this._updateLayer(d))
                    : this.fire(
                        new s.k(
                          new Error(`Cannot style non-existing layer "${e}".`)
                        )
                      );
                }
                getLayoutProperty(e, i) {
                  const l = this.getLayer(e);
                  if (l) return l.getLayoutProperty(i);
                  this.fire(
                    new s.k(
                      new Error(
                        `Cannot get style of non-existing layer "${e}".`
                      )
                    )
                  );
                }
                setPaintProperty(e, i, l, u = {}) {
                  this._checkLoaded();
                  const d = this.getLayer(e);
                  d
                    ? s.bK(d.getPaintProperty(i), l) ||
                      this._updatePaintProperty(d, i, l, u)
                    : this.fire(
                        new s.k(
                          new Error(`Cannot style non-existing layer "${e}".`)
                        )
                      );
                }
                _updatePaintProperty(e, i, l, u = {}) {
                  e.setPaintProperty(i, l, u) && this._updateLayer(e),
                    s.bN(e) &&
                      i === "raster-fade-duration" &&
                      this.tileManagers[e.source].setRasterFadeDuration(l),
                    (this._changed = !0),
                    (this._updatedPaintProps[e.id] = !0),
                    (this._serializedLayers = null);
                }
                getPaintProperty(e, i) {
                  return this.getLayer(e).getPaintProperty(i);
                }
                setFeatureState(e, i) {
                  this._checkLoaded();
                  const l = e.source,
                    u = e.sourceLayer,
                    d = this.tileManagers[l];
                  if (d === void 0)
                    return void this.fire(
                      new s.k(
                        new Error(
                          `The source '${l}' does not exist in the map's style.`
                        )
                      )
                    );
                  const g = d.getSource().type;
                  g === "geojson" && u
                    ? this.fire(
                        new s.k(
                          new Error(
                            "GeoJSON sources cannot have a sourceLayer parameter."
                          )
                        )
                      )
                    : g !== "vector" || u
                    ? (e.id === void 0 &&
                        this.fire(
                          new s.k(
                            new Error(
                              "The feature id parameter must be provided."
                            )
                          )
                        ),
                      d.setFeatureState(u, e.id, i))
                    : this.fire(
                        new s.k(
                          new Error(
                            "The sourceLayer parameter must be provided for vector source types."
                          )
                        )
                      );
                }
                removeFeatureState(e, i) {
                  this._checkLoaded();
                  const l = e.source,
                    u = this.tileManagers[l];
                  if (u === void 0)
                    return void this.fire(
                      new s.k(
                        new Error(
                          `The source '${l}' does not exist in the map's style.`
                        )
                      )
                    );
                  const d = u.getSource().type,
                    g = d === "vector" ? e.sourceLayer : void 0;
                  d !== "vector" || g
                    ? i && typeof e.id != "string" && typeof e.id != "number"
                      ? this.fire(
                          new s.k(
                            new Error(
                              "A feature id is required to remove its specific state property."
                            )
                          )
                        )
                      : u.removeFeatureState(g, e.id, i)
                    : this.fire(
                        new s.k(
                          new Error(
                            "The sourceLayer parameter must be provided for vector source types."
                          )
                        )
                      );
                }
                getFeatureState(e) {
                  this._checkLoaded();
                  const i = e.source,
                    l = e.sourceLayer,
                    u = this.tileManagers[i];
                  if (u !== void 0)
                    return u.getSource().type !== "vector" || l
                      ? (e.id === void 0 &&
                          this.fire(
                            new s.k(
                              new Error(
                                "The feature id parameter must be provided."
                              )
                            )
                          ),
                        u.getFeatureState(l, e.id))
                      : void this.fire(
                          new s.k(
                            new Error(
                              "The sourceLayer parameter must be provided for vector source types."
                            )
                          )
                        );
                  this.fire(
                    new s.k(
                      new Error(
                        `The source '${i}' does not exist in the map's style.`
                      )
                    )
                  );
                }
                getTransition() {
                  return s.e(
                    { duration: 300, delay: 0 },
                    this.stylesheet && this.stylesheet.transition
                  );
                }
                serialize() {
                  if (!this._loaded) return;
                  const e = s.bR(this.tileManagers, (d) => d.serialize()),
                    i = this._serializeByIds(this._order, !0),
                    l = this.map.getTerrain() || void 0,
                    u = this.stylesheet;
                  return s.bS(
                    {
                      version: u.version,
                      name: u.name,
                      metadata: u.metadata,
                      light: u.light,
                      sky: u.sky,
                      center: u.center,
                      zoom: u.zoom,
                      bearing: u.bearing,
                      pitch: u.pitch,
                      sprite: u.sprite,
                      glyphs: u.glyphs,
                      transition: u.transition,
                      projection: u.projection,
                      sources: e,
                      layers: i,
                      terrain: l,
                    },
                    (d) => d !== void 0
                  );
                }
                _updateLayer(e) {
                  (this._updatedLayers[e.id] = !0),
                    e.source &&
                      !this._updatedSources[e.source] &&
                      this.tileManagers[e.source].getSource().type !==
                        "raster" &&
                      ((this._updatedSources[e.source] = "reload"),
                      this.tileManagers[e.source].pause()),
                    (this._serializedLayers = null),
                    (this._changed = !0);
                }
                _flattenAndSortRenderedFeatures(e) {
                  const i = (g) => this._layers[g].type === "fill-extrusion",
                    l = {},
                    u = [];
                  for (let g = this._order.length - 1; g >= 0; g--) {
                    const w = this._order[g];
                    if (i(w)) {
                      l[w] = g;
                      for (const S of e) {
                        const k = S[w];
                        if (k) for (const z of k) u.push(z);
                      }
                    }
                  }
                  u.sort((g, w) => w.intersectionZ - g.intersectionZ);
                  const d = [];
                  for (let g = this._order.length - 1; g >= 0; g--) {
                    const w = this._order[g];
                    if (i(w))
                      for (let S = u.length - 1; S >= 0; S--) {
                        const k = u[S].feature;
                        if (l[k.layer.id] < g) break;
                        d.push(k), u.pop();
                      }
                    else
                      for (const S of e) {
                        const k = S[w];
                        if (k) for (const z of k) d.push(z.feature);
                      }
                  }
                  return d;
                }
                queryRenderedFeatures(e, i, l) {
                  i &&
                    i.filter &&
                    this._validate(
                      s.B.filter,
                      "queryRenderedFeatures.filter",
                      i.filter,
                      null,
                      i
                    );
                  const u = {};
                  if (i && i.layers) {
                    if (!(Array.isArray(i.layers) || i.layers instanceof Set))
                      return (
                        this.fire(
                          new s.k(
                            new Error(
                              "parameters.layers must be an Array or a Set of strings"
                            )
                          )
                        ),
                        []
                      );
                    for (const k of i.layers) {
                      const z = this._layers[k];
                      if (!z)
                        return (
                          this.fire(
                            new s.k(
                              new Error(
                                `The layer '${k}' does not exist in the map's style and cannot be queried for features.`
                              )
                            )
                          ),
                          []
                        );
                      u[z.source] = !0;
                    }
                  }
                  const d = [];
                  i.availableImages = this._availableImages;
                  const g = this._serializedAllLayers(),
                    w =
                      i.layers instanceof Set
                        ? i.layers
                        : Array.isArray(i.layers)
                        ? new Set(i.layers)
                        : null,
                    S = Object.assign(Object.assign({}, i), {
                      layers: w,
                      globalState: this._globalState,
                    });
                  for (const k in this.tileManagers)
                    (i.layers && !u[k]) ||
                      d.push(
                        Mt(
                          this.tileManagers[k],
                          this._layers,
                          g,
                          e,
                          S,
                          l,
                          this.map.terrain
                            ? (z, V, F) =>
                                this.map.terrain.getElevation(z, V, F)
                            : void 0
                        )
                      );
                  return (
                    this.placement &&
                      d.push(
                        (function (k, z, V, F, $, J, ae) {
                          const oe = {},
                            se = J.queryRenderedSymbols(F),
                            fe = [];
                          for (const be of Object.keys(se).map(Number))
                            fe.push(ae[be]);
                          fe.sort(Wt);
                          for (const be of fe) {
                            const pe = be.featureIndex.lookupSymbolFeatures(
                              se[be.bucketInstanceId],
                              z,
                              be.bucketIndex,
                              be.sourceLayerIndex,
                              {
                                filterSpec: $.filter,
                                globalState: $.globalState,
                              },
                              $.layers,
                              $.availableImages,
                              k
                            );
                            for (const we in pe) {
                              const Pe = (oe[we] = oe[we] || []),
                                ve = pe[we];
                              ve.sort((Re, it) => {
                                const Qe = be.featureSortOrder;
                                if (Qe) {
                                  const tt = Qe.indexOf(Re.featureIndex);
                                  return Qe.indexOf(it.featureIndex) - tt;
                                }
                                return it.featureIndex - Re.featureIndex;
                              });
                              for (const Re of ve) Pe.push(Re);
                            }
                          }
                          return (function (be, pe, we) {
                            for (const Pe in be)
                              for (const ve of be[Pe])
                                Bt(ve, we[pe[Pe].source]);
                            return be;
                          })(oe, k, V);
                        })(
                          this._layers,
                          g,
                          this.tileManagers,
                          e,
                          S,
                          this.placement.collisionIndex,
                          this.placement.retainedQueryData
                        )
                      ),
                    this._flattenAndSortRenderedFeatures(d)
                  );
                }
                querySourceFeatures(e, i) {
                  i != null &&
                    i.filter &&
                    this._validate(
                      s.B.filter,
                      "querySourceFeatures.filter",
                      i.filter,
                      null,
                      i
                    );
                  const l = this.tileManagers[e];
                  return l
                    ? (function (u, d) {
                        const g = u
                            .getRenderableIds()
                            .map((k) => u.getTileByID(k)),
                          w = [],
                          S = {};
                        for (let k = 0; k < g.length; k++) {
                          const z = g[k],
                            V = z.tileID.canonical.key;
                          S[V] || ((S[V] = !0), z.querySourceFeatures(w, d));
                        }
                        return w;
                      })(
                        l,
                        i
                          ? Object.assign(Object.assign({}, i), {
                              globalState: this._globalState,
                            })
                          : { globalState: this._globalState }
                      )
                    : [];
                }
                getLight() {
                  return this.light.getLight();
                }
                setLight(e, i = {}) {
                  this._checkLoaded();
                  const l = this.light.getLight();
                  let u = !1;
                  for (const g in e)
                    if (!s.bK(e[g], l[g])) {
                      u = !0;
                      break;
                    }
                  if (!u) return;
                  const d = {
                    now: ne(),
                    transition: s.e(
                      { duration: 300, delay: 0 },
                      this.stylesheet.transition
                    ),
                  };
                  this.light.setLight(e, i), this.light.updateTransitions(d);
                }
                getProjection() {
                  var e;
                  return (e = this.stylesheet) === null || e === void 0
                    ? void 0
                    : e.projection;
                }
                setProjection(e) {
                  if ((this._checkLoaded(), this.projection)) {
                    if (this.projection.name === e.type) return;
                    this.projection.destroy(), delete this.projection;
                  }
                  (this.stylesheet.projection = e),
                    this._setProjectionInternal(e.type);
                }
                getSky() {
                  var e;
                  return (e = this.stylesheet) === null || e === void 0
                    ? void 0
                    : e.sky;
                }
                setSky(e, i = {}) {
                  this._checkLoaded();
                  const l = this.getSky();
                  let u = !1;
                  if (!e && !l) return;
                  if (e && !l) u = !0;
                  else if (!e && l) u = !0;
                  else
                    for (const g in e)
                      if (!s.bK(e[g], l[g])) {
                        u = !0;
                        break;
                      }
                  if (!u) return;
                  const d = {
                    now: ne(),
                    transition: s.e(
                      { duration: 300, delay: 0 },
                      this.stylesheet.transition
                    ),
                  };
                  (this.stylesheet.sky = e),
                    this.sky.setSky(e, i),
                    this.sky.updateTransitions(d);
                }
                _setProjectionInternal(e) {
                  const i = (function (l, u) {
                    const d = { constrain: u };
                    if (Array.isArray(l)) {
                      const g = new Ns({ type: l });
                      return {
                        projection: g,
                        transform: new Ml(d),
                        cameraHelper: new qs(g),
                      };
                    }
                    switch (l) {
                      case "mercator":
                        return {
                          projection: new Qr(),
                          transform: new ea(d),
                          cameraHelper: new va(),
                        };
                      case "globe": {
                        const g = new Ns({
                          type: [
                            "interpolate",
                            ["linear"],
                            ["zoom"],
                            11,
                            "vertical-perspective",
                            12,
                            "mercator",
                          ],
                        });
                        return {
                          projection: g,
                          transform: new Ml(d),
                          cameraHelper: new qs(g),
                        };
                      }
                      case "vertical-perspective":
                        return {
                          projection: new Tl(),
                          transform: new Il(d),
                          cameraHelper: new Ia(),
                        };
                      default:
                        return (
                          s.w(
                            `Unknown projection name: ${l}. Falling back to mercator projection.`
                          ),
                          {
                            projection: new Qr(),
                            transform: new ea(d),
                            cameraHelper: new va(),
                          }
                        );
                    }
                  })(e, this.map.transformConstrain);
                  (this.projection = i.projection),
                    this.map.migrateProjection(i.transform, i.cameraHelper);
                  for (const l in this.tileManagers)
                    this.tileManagers[l].reload();
                }
                _validate(e, i, l, u, d = {}) {
                  return (
                    (!d || d.validate !== !1) &&
                    ms(
                      this,
                      e.call(
                        s.B,
                        s.e(
                          {
                            key: i,
                            style: this.serialize(),
                            value: l,
                            styleSpec: s.t,
                          },
                          u
                        )
                      )
                    )
                  );
                }
                _remove(e = !0) {
                  this._frameRequest &&
                    (this._frameRequest.abort(), (this._frameRequest = null)),
                    this._loadStyleRequest &&
                      (this._loadStyleRequest.abort(),
                      (this._loadStyleRequest = null)),
                    this._spriteRequest &&
                      (this._spriteRequest.abort(),
                      (this._spriteRequest = null)),
                    D().off(Te, this._rtlPluginLoaded);
                  for (const i in this._layers)
                    this._layers[i].setEventedParent(null);
                  for (const i in this.tileManagers) {
                    const l = this.tileManagers[i];
                    l.setEventedParent(null), l.onRemove(this.map);
                  }
                  this.imageManager.setEventedParent(null),
                    this.setEventedParent(null),
                    e && this.dispatcher.broadcast("RM", void 0),
                    this.dispatcher.remove(e);
                }
                _clearSource(e) {
                  this.tileManagers[e].clearTiles();
                }
                _reloadSource(e) {
                  this.tileManagers[e].resume(), this.tileManagers[e].reload();
                }
                _updateSources(e) {
                  for (const i in this.tileManagers)
                    this.tileManagers[i].update(e, this.map.terrain);
                }
                _generateCollisionBoxes() {
                  for (const e in this.tileManagers) this._reloadSource(e);
                }
                _updatePlacement(e, i, l, u, d = !1) {
                  let g = !1,
                    w = !1;
                  const S = {};
                  for (const k of this._order) {
                    const z = this._layers[k];
                    if (z.type !== "symbol") continue;
                    if (!S[z.source]) {
                      const F = this.tileManagers[z.source];
                      S[z.source] = F.getRenderableIds(!0)
                        .map(($) => F.getTileByID($))
                        .sort(
                          ($, J) =>
                            J.tileID.overscaledZ - $.tileID.overscaledZ ||
                            ($.tileID.isLessThan(J.tileID) ? -1 : 1)
                        );
                    }
                    const V = this.crossTileSymbolIndex.addLayer(
                      z,
                      S[z.source],
                      e.center.lng
                    );
                    g = g || V;
                  }
                  if (
                    (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                    ((d = d || this._layerOrderChanged || l === 0) ||
                      !this.pauseablePlacement ||
                      (this.pauseablePlacement.isDone() &&
                        !this.placement.stillRecent(ne(), e.zoom))) &&
                      ((this.pauseablePlacement = new Xn(
                        e,
                        this.map.terrain,
                        this._order,
                        d,
                        i,
                        l,
                        u,
                        this.placement
                      )),
                      (this._layerOrderChanged = !1)),
                    this.pauseablePlacement.isDone()
                      ? this.placement.setStale()
                      : (this.pauseablePlacement.continuePlacement(
                          this._order,
                          this._layers,
                          S
                        ),
                        this.pauseablePlacement.isDone() &&
                          ((this.placement = this.pauseablePlacement.commit(
                            ne()
                          )),
                          (w = !0)),
                        g && this.pauseablePlacement.placement.setStale()),
                    w || g)
                  )
                    for (const k of this._order) {
                      const z = this._layers[k];
                      z.type === "symbol" &&
                        this.placement.updateLayerOpacities(z, S[z.source]);
                    }
                  return (
                    !this.pauseablePlacement.isDone() ||
                    this.placement.hasTransitions(ne())
                  );
                }
                _releaseSymbolFadeTiles() {
                  for (const e in this.tileManagers)
                    this.tileManagers[e].releaseSymbolFadeTiles();
                }
                getImages(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    const l = yield this.imageManager.getImages(i.icons);
                    this._updateTilesForChangedImages();
                    const u = this.tileManagers[i.source];
                    return (
                      u && u.setDependencies(i.tileID.key, i.type, i.icons), l
                    );
                  });
                }
                getGlyphs(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    const l = yield this.glyphManager.getGlyphs(i.stacks),
                      u = this.tileManagers[i.source];
                    return (
                      u && u.setDependencies(i.tileID.key, i.type, [""]), l
                    );
                  });
                }
                getGlyphsUrl() {
                  return this.stylesheet.glyphs || null;
                }
                setGlyphs(e, i = {}) {
                  this._checkLoaded(),
                    (e && this._validate(s.B.glyphs, "glyphs", e, null, i)) ||
                      ((this._glyphsDidChange = !0),
                      (this.stylesheet.glyphs = e),
                      (this.glyphManager.entries = {}),
                      this.glyphManager.setURL(e));
                }
                getDashes(e, i) {
                  return s._(this, void 0, void 0, function* () {
                    const l = {};
                    for (const [u, d] of Object.entries(i.dashes))
                      l[u] = this.lineAtlas.getDash(d.dasharray, d.round);
                    return l;
                  });
                }
                addSprite(e, i, l = {}, u) {
                  this._checkLoaded();
                  const d = [{ id: e, url: i }],
                    g = [...ke(this.stylesheet.sprite), ...d];
                  this._validate(s.B.sprite, "sprite", g, null, l) ||
                    ((this.stylesheet.sprite = g), this._loadSprite(d, !0, u));
                }
                removeSprite(e) {
                  this._checkLoaded();
                  const i = ke(this.stylesheet.sprite);
                  if (i.find((l) => l.id === e)) {
                    if (this._spritesImagesIds[e])
                      for (const l of this._spritesImagesIds[e])
                        this.imageManager.removeImage(l),
                          (this._changedImages[l] = !0);
                    i.splice(
                      i.findIndex((l) => l.id === e),
                      1
                    ),
                      (this.stylesheet.sprite = i.length > 0 ? i : void 0),
                      delete this._spritesImagesIds[e],
                      (this._availableImages = this.imageManager.listImages()),
                      (this._changed = !0),
                      this.dispatcher.broadcast("SI", this._availableImages),
                      this.fire(new s.l("data", { dataType: "style" }));
                  } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
                }
                getSprite() {
                  return ke(this.stylesheet.sprite);
                }
                setSprite(e, i = {}, l) {
                  this._checkLoaded(),
                    (e && this._validate(s.B.sprite, "sprite", e, null, i)) ||
                      ((this.stylesheet.sprite = e),
                      e
                        ? this._loadSprite(e, !0, l)
                        : (this._unloadSprite(), l && l(null)));
                }
              }
              var Vc = s.aN([
                { name: "a_pos", type: "Int16", components: 2 },
                { name: "a_texture_pos", type: "Int16", components: 2 },
              ]);
              class Va {
                constructor() {
                  (this.boundProgram = null),
                    (this.boundLayoutVertexBuffer = null),
                    (this.boundPaintVertexBuffers = []),
                    (this.boundIndexBuffer = null),
                    (this.boundVertexOffset = null),
                    (this.boundDynamicVertexBuffer = null),
                    (this.vao = null);
                }
                bind(e, i, l, u, d, g, w, S, k) {
                  this.context = e;
                  let z = this.boundPaintVertexBuffers.length !== u.length;
                  for (let V = 0; !z && V < u.length; V++)
                    this.boundPaintVertexBuffers[V] !== u[V] && (z = !0);
                  !this.vao ||
                  this.boundProgram !== i ||
                  this.boundLayoutVertexBuffer !== l ||
                  z ||
                  this.boundIndexBuffer !== d ||
                  this.boundVertexOffset !== g ||
                  this.boundDynamicVertexBuffer !== w ||
                  this.boundDynamicVertexBuffer2 !== S ||
                  this.boundDynamicVertexBuffer3 !== k
                    ? this.freshBind(i, l, u, d, g, w, S, k)
                    : (e.bindVertexArray.set(this.vao),
                      w && w.bind(),
                      d && d.dynamicDraw && d.bind(),
                      S && S.bind(),
                      k && k.bind());
                }
                freshBind(e, i, l, u, d, g, w, S) {
                  const k = e.numAttributes,
                    z = this.context,
                    V = z.gl;
                  this.vao && this.destroy(),
                    (this.vao = z.createVertexArray()),
                    z.bindVertexArray.set(this.vao),
                    (this.boundProgram = e),
                    (this.boundLayoutVertexBuffer = i),
                    (this.boundPaintVertexBuffers = l),
                    (this.boundIndexBuffer = u),
                    (this.boundVertexOffset = d),
                    (this.boundDynamicVertexBuffer = g),
                    (this.boundDynamicVertexBuffer2 = w),
                    (this.boundDynamicVertexBuffer3 = S),
                    i.enableAttributes(V, e);
                  for (const F of l) F.enableAttributes(V, e);
                  g && g.enableAttributes(V, e),
                    w && w.enableAttributes(V, e),
                    S && S.enableAttributes(V, e),
                    i.bind(),
                    i.setVertexAttribPointers(V, e, d);
                  for (const F of l)
                    F.bind(), F.setVertexAttribPointers(V, e, d);
                  g && (g.bind(), g.setVertexAttribPointers(V, e, d)),
                    u && u.bind(),
                    w && (w.bind(), w.setVertexAttribPointers(V, e, d)),
                    S && (S.bind(), S.setVertexAttribPointers(V, e, d)),
                    (z.currentNumAttributes = k);
                }
                destroy() {
                  this.vao &&
                    (this.context.deleteVertexArray(this.vao),
                    (this.vao = null));
                }
              }
              const nf = (h, e, i, l, u) => ({
                  u_texture: 0,
                  u_ele_delta: h,
                  u_fog_matrix: e,
                  u_fog_color: i ? i.properties.get("fog-color") : s.bi.white,
                  u_fog_ground_blend: i
                    ? i.properties.get("fog-ground-blend")
                    : 1,
                  u_fog_ground_blend_opacity: u
                    ? 0
                    : i
                    ? i.calculateFogBlendOpacity(l)
                    : 0,
                  u_horizon_color: i
                    ? i.properties.get("horizon-color")
                    : s.bi.white,
                  u_horizon_fog_blend: i
                    ? i.properties.get("horizon-fog-blend")
                    : 1,
                  u_is_globe_mode: u ? 1 : 0,
                }),
                qc = {
                  mainMatrix: "u_projection_matrix",
                  tileMercatorCoords: "u_projection_tile_mercator_coords",
                  clippingPlane: "u_projection_clipping_plane",
                  projectionTransition: "u_projection_transition",
                  fallbackMatrix: "u_projection_fallback_matrix",
                };
              function xo(h) {
                const e = [];
                for (let i = 0; i < h.length; i++) {
                  if (h[i] === null) continue;
                  const l = h[i].split(" ");
                  e.push(l.pop());
                }
                return e;
              }
              class Zs {
                constructor(e, i, l, u, d, g, w, S, k = []) {
                  const z = e.gl;
                  this.program = z.createProgram();
                  const V = xo(i.staticAttributes),
                    F = l ? l.getBinderAttributes() : [],
                    $ = V.concat(F),
                    J = Cr.prelude.staticUniforms
                      ? xo(Cr.prelude.staticUniforms)
                      : [],
                    ae = w.staticUniforms ? xo(w.staticUniforms) : [],
                    oe = i.staticUniforms ? xo(i.staticUniforms) : [],
                    se = l ? l.getBinderUniforms() : [],
                    fe = J.concat(ae).concat(oe).concat(se),
                    be = [];
                  for (const Qe of fe) be.indexOf(Qe) < 0 && be.push(Qe);
                  const pe = l ? l.defines() : [];
                  Di(z) && pe.unshift("#version 300 es"),
                    d && pe.push("#define OVERDRAW_INSPECTOR;"),
                    g && pe.push("#define TERRAIN3D;"),
                    S && pe.push(S),
                    k && pe.push(...k);
                  let we = pe.concat(
                      Cr.prelude.fragmentSource,
                      w.fragmentSource,
                      i.fragmentSource
                    ).join(`
`),
                    Pe = pe.concat(
                      Cr.prelude.vertexSource,
                      w.vertexSource,
                      i.vertexSource
                    ).join(`
`);
                  Di(z) ||
                    ((we = (function (Qe) {
                      return Qe.replace(/\bin\s/g, "varying ")
                        .replace("out highp vec4 fragColor;", "")
                        .replace(/fragColor/g, "gl_FragColor")
                        .replace(/texture\(/g, "texture2D(");
                    })(we)),
                    (Pe = (function (Qe) {
                      return Qe.replace(/\bin\s/g, "attribute ")
                        .replace(/\bout\s/g, "varying ")
                        .replace(/texture\(/g, "texture2D(");
                    })(Pe)));
                  const ve = z.createShader(z.FRAGMENT_SHADER);
                  if (z.isContextLost()) return void (this.failedToCreate = !0);
                  if (
                    (z.shaderSource(ve, we),
                    z.compileShader(ve),
                    !z.getShaderParameter(ve, z.COMPILE_STATUS))
                  )
                    throw new Error(
                      `Could not compile fragment shader: ${z.getShaderInfoLog(
                        ve
                      )}`
                    );
                  z.attachShader(this.program, ve);
                  const Re = z.createShader(z.VERTEX_SHADER);
                  if (z.isContextLost()) return void (this.failedToCreate = !0);
                  if (
                    (z.shaderSource(Re, Pe),
                    z.compileShader(Re),
                    !z.getShaderParameter(Re, z.COMPILE_STATUS))
                  )
                    throw new Error(
                      `Could not compile vertex shader: ${z.getShaderInfoLog(
                        Re
                      )}`
                    );
                  z.attachShader(this.program, Re), (this.attributes = {});
                  const it = {};
                  this.numAttributes = $.length;
                  for (let Qe = 0; Qe < this.numAttributes; Qe++)
                    $[Qe] &&
                      (z.bindAttribLocation(this.program, Qe, $[Qe]),
                      (this.attributes[$[Qe]] = Qe));
                  if (
                    (z.linkProgram(this.program),
                    !z.getProgramParameter(this.program, z.LINK_STATUS))
                  )
                    throw new Error(
                      `Program failed to link: ${z.getProgramInfoLog(
                        this.program
                      )}`
                    );
                  z.deleteShader(Re), z.deleteShader(ve);
                  for (let Qe = 0; Qe < be.length; Qe++) {
                    const tt = be[Qe];
                    if (tt && !it[tt]) {
                      const ot = z.getUniformLocation(this.program, tt);
                      ot && (it[tt] = ot);
                    }
                  }
                  (this.fixedUniforms = u(e, it)),
                    (this.terrainUniforms = ((Qe, tt) => ({
                      u_depth: new s.bT(Qe, tt.u_depth),
                      u_terrain: new s.bT(Qe, tt.u_terrain),
                      u_terrain_dim: new s.bj(Qe, tt.u_terrain_dim),
                      u_terrain_matrix: new s.bV(Qe, tt.u_terrain_matrix),
                      u_terrain_unpack: new s.bW(Qe, tt.u_terrain_unpack),
                      u_terrain_exaggeration: new s.bj(
                        Qe,
                        tt.u_terrain_exaggeration
                      ),
                    }))(e, it)),
                    (this.projectionUniforms = ((Qe, tt) => ({
                      u_projection_matrix: new s.bV(Qe, tt.u_projection_matrix),
                      u_projection_tile_mercator_coords: new s.bW(
                        Qe,
                        tt.u_projection_tile_mercator_coords
                      ),
                      u_projection_clipping_plane: new s.bW(
                        Qe,
                        tt.u_projection_clipping_plane
                      ),
                      u_projection_transition: new s.bj(
                        Qe,
                        tt.u_projection_transition
                      ),
                      u_projection_fallback_matrix: new s.bV(
                        Qe,
                        tt.u_projection_fallback_matrix
                      ),
                    }))(e, it)),
                    (this.binderUniforms = l ? l.getUniforms(e, it) : []);
                }
                draw(
                  e,
                  i,
                  l,
                  u,
                  d,
                  g,
                  w,
                  S,
                  k,
                  z,
                  V,
                  F,
                  $,
                  J,
                  ae,
                  oe,
                  se,
                  fe,
                  be
                ) {
                  const pe = e.gl;
                  if (this.failedToCreate) return;
                  if (
                    (e.program.set(this.program),
                    e.setDepthMode(l),
                    e.setStencilMode(u),
                    e.setColorMode(d),
                    e.setCullFace(g),
                    S)
                  ) {
                    e.activeTexture.set(pe.TEXTURE2),
                      pe.bindTexture(pe.TEXTURE_2D, S.depthTexture),
                      e.activeTexture.set(pe.TEXTURE3),
                      pe.bindTexture(pe.TEXTURE_2D, S.texture);
                    for (const Pe in this.terrainUniforms)
                      this.terrainUniforms[Pe].set(S[Pe]);
                  }
                  if (k)
                    for (const Pe in k)
                      this.projectionUniforms[qc[Pe]].set(k[Pe]);
                  if (w)
                    for (const Pe in this.fixedUniforms)
                      this.fixedUniforms[Pe].set(w[Pe]);
                  oe && oe.setUniforms(e, this.binderUniforms, J, { zoom: ae });
                  let we = 0;
                  switch (i) {
                    case pe.LINES:
                      we = 2;
                      break;
                    case pe.TRIANGLES:
                      we = 3;
                      break;
                    case pe.LINE_STRIP:
                      we = 1;
                  }
                  for (const Pe of $.get()) {
                    const ve = Pe.vaos || (Pe.vaos = {});
                    (ve[z] || (ve[z] = new Va())).bind(
                      e,
                      this,
                      V,
                      oe ? oe.getPaintVertexBuffers() : [],
                      F,
                      Pe.vertexOffset,
                      se,
                      fe,
                      be
                    ),
                      pe.drawElements(
                        i,
                        Pe.primitiveLength * we,
                        pe.UNSIGNED_SHORT,
                        Pe.primitiveOffset * we * 2
                      );
                  }
                }
              }
              function rd(h, e, i) {
                const l = 1 / s.aG(i, 1, e.transform.tileZoom),
                  u = Math.pow(2, i.tileID.overscaledZ),
                  d = (i.tileSize * Math.pow(2, e.transform.tileZoom)) / u,
                  g = d * (i.tileID.canonical.x + i.tileID.wrap * u),
                  w = d * i.tileID.canonical.y;
                return {
                  u_image: 0,
                  u_texsize: i.imageAtlasTexture.size,
                  u_scale: [l, h.fromScale, h.toScale],
                  u_fade: h.t,
                  u_pixel_coord_upper: [g >> 16, w >> 16],
                  u_pixel_coord_lower: [65535 & g, 65535 & w],
                };
              }
              const Gs = (h, e, i, l) => {
                  const u = h.style.light,
                    d = u.properties.get("position"),
                    g = [d.x, d.y, d.z],
                    w = s.bZ();
                  u.properties.get("anchor") === "viewport" &&
                    s.b_(w, h.transform.bearingInRadians),
                    s.b$(g, g, w);
                  const S = h.transform.transformLightDirection(g),
                    k = u.properties.get("color");
                  return {
                    u_lightpos: g,
                    u_lightpos_globe: S,
                    u_lightintensity: u.properties.get("intensity"),
                    u_lightcolor: [k.r, k.g, k.b],
                    u_vertical_gradient: +e,
                    u_opacity: i,
                    u_fill_translate: l,
                  };
                },
                af = (h, e, i, l, u, d, g) =>
                  s.e(Gs(h, e, i, l), rd(d, h, g), {
                    u_height_factor:
                      -Math.pow(2, u.overscaledZ) / g.tileSize / 8,
                  }),
                Oo = (h, e, i, l) => s.e(rd(e, h, i), { u_fill_translate: l }),
                of = (h, e) => ({ u_world: h, u_fill_translate: e }),
                nd = (h, e, i, l, u) => s.e(Oo(h, e, i, u), { u_world: l }),
                sf = (h, e, i, l, u) => {
                  const d = h.transform;
                  let g,
                    w,
                    S = 0;
                  if (i.paint.get("circle-pitch-alignment") === "map") {
                    const k = s.aG(e, 1, d.zoom);
                    (g = !0),
                      (w = [k, k]),
                      (S =
                        (k / (s.a3 * Math.pow(2, e.tileID.overscaledZ))) *
                        2 *
                        Math.PI *
                        u);
                  } else (g = !1), (w = d.pixelsToGLUnits);
                  return {
                    u_camera_to_center_distance: d.cameraToCenterDistance,
                    u_scale_with_map: +(
                      i.paint.get("circle-pitch-scale") === "map"
                    ),
                    u_pitch_with_map: +g,
                    u_device_pixel_ratio: h.pixelRatio,
                    u_extrude_scale: w,
                    u_globe_extrude_scale: S,
                    u_translate: l,
                  };
                },
                id = (h) => ({
                  u_pixel_extrude_scale: [1 / h.width, 1 / h.height],
                }),
                Uc = (h) => ({ u_viewport_size: [h.width, h.height] }),
                Zc = (h, e = 1) => ({
                  u_color: h,
                  u_overlay: 0,
                  u_overlay_scale: e,
                }),
                Gc = (h, e, i, l) => {
                  const u =
                    (s.aG(h, 1, e) /
                      (s.a3 * Math.pow(2, h.tileID.overscaledZ))) *
                    2 *
                    Math.PI *
                    l;
                  return {
                    u_extrude_scale: s.aG(h, 1, e),
                    u_intensity: i,
                    u_globe_extrude_scale: u,
                  };
                },
                $c = (h, e, i, l) => {
                  const u = s.M();
                  s.c0(u, 0, h.width, h.height, 0, 0, 1);
                  const d = h.context.gl;
                  return {
                    u_matrix: u,
                    u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
                    u_image: i,
                    u_color_ramp: l,
                    u_opacity: e.paint.get("heatmap-opacity"),
                  };
                },
                ad = (h, e, i) => {
                  const l = i.paint.get("hillshade-accent-color");
                  let u;
                  switch (i.paint.get("hillshade-method")) {
                    case "basic":
                      u = 4;
                      break;
                    case "combined":
                      u = 1;
                      break;
                    case "igor":
                      u = 2;
                      break;
                    case "multidirectional":
                      u = 3;
                      break;
                    default:
                      u = 0;
                  }
                  const d = i.getIlluminationProperties();
                  for (let g = 0; g < d.directionRadians.length; g++)
                    i.paint.get("hillshade-illumination-anchor") ===
                      "viewport" &&
                      (d.directionRadians[g] += h.transform.bearingInRadians);
                  return {
                    u_image: 0,
                    u_latrange: od(0, e.tileID),
                    u_exaggeration: i.paint.get("hillshade-exaggeration"),
                    u_altitudes: d.altitudeRadians,
                    u_azimuths: d.directionRadians,
                    u_accent: l,
                    u_method: u,
                    u_highlights: d.highlightColor,
                    u_shadows: d.shadowColor,
                  };
                },
                No = (h, e) => {
                  const i = e.stride,
                    l = s.M();
                  return (
                    s.c0(l, 0, s.a3, -s.a3, 0, 0, 1),
                    s.N(l, l, [0, -s.a3, 0]),
                    {
                      u_matrix: l,
                      u_image: 1,
                      u_dimension: [i, i],
                      u_zoom: h.overscaledZ,
                      u_unpack: e.getUnpackVector(),
                    }
                  );
                };
              function od(h, e) {
                const i = Math.pow(2, e.canonical.z),
                  l = e.canonical.y;
                return [
                  new s.a5(0, l / i).toLngLat().lat,
                  new s.a5(0, (l + 1) / i).toLngLat().lat,
                ];
              }
              const sd = (h, e, i = 0) => ({
                  u_image: 0,
                  u_unpack: e.getUnpackVector(),
                  u_dimension: [e.stride, e.stride],
                  u_elevation_stops: 1,
                  u_color_stops: 4,
                  u_color_ramp_size: i,
                  u_opacity: h.paint.get("color-relief-opacity"),
                }),
                bo = (h, e, i, l) => {
                  const u = h.transform;
                  return {
                    u_translation: Hc(h, e, i),
                    u_ratio: l / s.aG(e, 1, u.zoom),
                    u_device_pixel_ratio: h.pixelRatio,
                    u_units_to_pixels: [
                      1 / u.pixelsToGLUnits[0],
                      1 / u.pixelsToGLUnits[1],
                    ],
                  };
                },
                lf = (h, e, i, l, u) =>
                  s.e(bo(h, e, i, l), { u_image: 0, u_image_height: u }),
                kl = (h, e, i, l, u) => {
                  const d = h.transform,
                    g = El(e, d);
                  return {
                    u_translation: Hc(h, e, i),
                    u_texsize: e.imageAtlasTexture.size,
                    u_ratio: l / s.aG(e, 1, d.zoom),
                    u_device_pixel_ratio: h.pixelRatio,
                    u_image: 0,
                    u_scale: [g, u.fromScale, u.toScale],
                    u_fade: u.t,
                    u_units_to_pixels: [
                      1 / d.pixelsToGLUnits[0],
                      1 / d.pixelsToGLUnits[1],
                    ],
                  };
                },
                cf = (h, e, i, l, u) => {
                  const d = El(e, h.transform);
                  return s.e(bo(h, e, i, l), {
                    u_tileratio: d,
                    u_crossfade_from: u.fromScale,
                    u_crossfade_to: u.toScale,
                    u_image: 0,
                    u_mix: u.t,
                    u_lineatlas_width: h.lineAtlas.width,
                    u_lineatlas_height: h.lineAtlas.height,
                  });
                },
                uf = (h, e, i, l, u, d) => {
                  const g = El(e, h.transform);
                  return s.e(bo(h, e, i, l), {
                    u_image: 0,
                    u_image_height: d,
                    u_tileratio: g,
                    u_crossfade_from: u.fromScale,
                    u_crossfade_to: u.toScale,
                    u_image_dash: 1,
                    u_mix: u.t,
                    u_lineatlas_width: h.lineAtlas.width,
                    u_lineatlas_height: h.lineAtlas.height,
                  });
                };
              function El(h, e) {
                return 1 / s.aG(h, 1, e.tileZoom);
              }
              function Hc(h, e, i) {
                return s.aH(
                  h.transform,
                  e,
                  i.paint.get("line-translate"),
                  i.paint.get("line-translate-anchor")
                );
              }
              const ld = (h, e, i, l, u) => {
                return {
                  u_tl_parent: h,
                  u_scale_parent: e,
                  u_buffer_scale: 1,
                  u_fade_t: i.mix,
                  u_opacity: i.opacity * l.paint.get("raster-opacity"),
                  u_image0: 0,
                  u_image1: 1,
                  u_brightness_low: l.paint.get("raster-brightness-min"),
                  u_brightness_high: l.paint.get("raster-brightness-max"),
                  u_saturation_factor:
                    ((g = l.paint.get("raster-saturation")),
                    g > 0 ? 1 - 1 / (1.001 - g) : -g),
                  u_contrast_factor:
                    ((d = l.paint.get("raster-contrast")),
                    d > 0 ? 1 / (1 - d) : 1 + d),
                  u_spin_weights: Wc(l.paint.get("raster-hue-rotate")),
                  u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
                  u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y],
                };
                var d, g;
              };
              function Wc(h) {
                h *= Math.PI / 180;
                const e = Math.sin(h),
                  i = Math.cos(h);
                return [
                  (2 * i + 1) / 3,
                  (-Math.sqrt(3) * e - i + 1) / 3,
                  (Math.sqrt(3) * e - i + 1) / 3,
                ];
              }
              const Xc = (h, e, i, l, u, d, g, w, S, k, z, V, F) => {
                  const $ = g.transform;
                  return {
                    u_is_size_zoom_constant: +(
                      h === "constant" || h === "source"
                    ),
                    u_is_size_feature_constant: +(
                      h === "constant" || h === "camera"
                    ),
                    u_size_t: e ? e.uSizeT : 0,
                    u_size: e ? e.uSize : 0,
                    u_camera_to_center_distance: $.cameraToCenterDistance,
                    u_pitch: ($.pitch / 360) * 2 * Math.PI,
                    u_rotate_symbol: +i,
                    u_aspect_ratio: $.width / $.height,
                    u_fade_change: g.options.fadeDuration
                      ? g.symbolFadeChange
                      : 1,
                    u_label_plane_matrix: w,
                    u_coord_matrix: S,
                    u_is_text: +z,
                    u_pitch_with_map: +l,
                    u_is_along_line: u,
                    u_is_variable_anchor: d,
                    u_texsize: V,
                    u_texture: 0,
                    u_translation: k,
                    u_pitched_scale: F,
                  };
                },
                $s = (h, e, i, l, u, d, g, w, S, k, z, V, F, $) => {
                  const J = g.transform;
                  return s.e(Xc(h, e, i, l, u, d, g, w, S, k, z, V, $), {
                    u_gamma_scale: l
                      ? Math.cos((J.pitch * Math.PI) / 180) *
                        J.cameraToCenterDistance
                      : 1,
                    u_device_pixel_ratio: g.pixelRatio,
                    u_is_halo: 1,
                  });
                },
                Qa = (h, e, i, l, u, d, g, w, S, k, z, V, F) =>
                  s.e($s(h, e, i, l, u, d, g, w, S, k, !0, z, 0, F), {
                    u_texsize_icon: V,
                    u_texture_icon: 1,
                  }),
                Yc = (h, e) => ({ u_opacity: h, u_color: e }),
                Kc = (h, e, i, l, u) =>
                  s.e(
                    (function (d, g, w, S) {
                      const k = w.imageManager.getPattern(d.from.toString()),
                        z = w.imageManager.getPattern(d.to.toString()),
                        { width: V, height: F } = w.imageManager.getPixelSize(),
                        $ = Math.pow(2, S.tileID.overscaledZ),
                        J =
                          (S.tileSize * Math.pow(2, w.transform.tileZoom)) / $,
                        ae = J * (S.tileID.canonical.x + S.tileID.wrap * $),
                        oe = J * S.tileID.canonical.y;
                      return {
                        u_image: 0,
                        u_pattern_tl_a: k.tl,
                        u_pattern_br_a: k.br,
                        u_pattern_tl_b: z.tl,
                        u_pattern_br_b: z.br,
                        u_texsize: [V, F],
                        u_mix: g.t,
                        u_pattern_size_a: k.displaySize,
                        u_pattern_size_b: z.displaySize,
                        u_scale_a: g.fromScale,
                        u_scale_b: g.toScale,
                        u_tile_units_to_pixels:
                          1 / s.aG(S, 1, w.transform.tileZoom),
                        u_pixel_coord_upper: [ae >> 16, oe >> 16],
                        u_pixel_coord_lower: [65535 & ae, 65535 & oe],
                      };
                    })(i, u, e, l),
                    { u_opacity: h }
                  ),
                zl = (h, e) => {},
                cd = {
                  fillExtrusion: (h, e) => ({
                    u_lightpos: new s.bX(h, e.u_lightpos),
                    u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
                    u_lightintensity: new s.bj(h, e.u_lightintensity),
                    u_lightcolor: new s.bX(h, e.u_lightcolor),
                    u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
                    u_opacity: new s.bj(h, e.u_opacity),
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                  }),
                  fillExtrusionPattern: (h, e) => ({
                    u_lightpos: new s.bX(h, e.u_lightpos),
                    u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
                    u_lightintensity: new s.bj(h, e.u_lightintensity),
                    u_lightcolor: new s.bX(h, e.u_lightcolor),
                    u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
                    u_height_factor: new s.bj(h, e.u_height_factor),
                    u_opacity: new s.bj(h, e.u_opacity),
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                    u_image: new s.bT(h, e.u_image),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
                    u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
                    u_scale: new s.bX(h, e.u_scale),
                    u_fade: new s.bj(h, e.u_fade),
                  }),
                  fill: (h, e) => ({
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                  }),
                  fillPattern: (h, e) => ({
                    u_image: new s.bT(h, e.u_image),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
                    u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
                    u_scale: new s.bX(h, e.u_scale),
                    u_fade: new s.bj(h, e.u_fade),
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                  }),
                  fillOutline: (h, e) => ({
                    u_world: new s.bY(h, e.u_world),
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                  }),
                  fillOutlinePattern: (h, e) => ({
                    u_world: new s.bY(h, e.u_world),
                    u_image: new s.bT(h, e.u_image),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
                    u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
                    u_scale: new s.bX(h, e.u_scale),
                    u_fade: new s.bj(h, e.u_fade),
                    u_fill_translate: new s.bY(h, e.u_fill_translate),
                  }),
                  circle: (h, e) => ({
                    u_camera_to_center_distance: new s.bj(
                      h,
                      e.u_camera_to_center_distance
                    ),
                    u_scale_with_map: new s.bT(h, e.u_scale_with_map),
                    u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
                    u_extrude_scale: new s.bY(h, e.u_extrude_scale),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale),
                    u_translate: new s.bY(h, e.u_translate),
                  }),
                  collisionBox: (h, e) => ({
                    u_pixel_extrude_scale: new s.bY(h, e.u_pixel_extrude_scale),
                  }),
                  collisionCircle: (h, e) => ({
                    u_viewport_size: new s.bY(h, e.u_viewport_size),
                  }),
                  debug: (h, e) => ({
                    u_color: new s.bU(h, e.u_color),
                    u_overlay: new s.bT(h, e.u_overlay),
                    u_overlay_scale: new s.bj(h, e.u_overlay_scale),
                  }),
                  depth: zl,
                  clippingMask: zl,
                  heatmap: (h, e) => ({
                    u_extrude_scale: new s.bj(h, e.u_extrude_scale),
                    u_intensity: new s.bj(h, e.u_intensity),
                    u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale),
                  }),
                  heatmapTexture: (h, e) => ({
                    u_matrix: new s.bV(h, e.u_matrix),
                    u_world: new s.bY(h, e.u_world),
                    u_image: new s.bT(h, e.u_image),
                    u_color_ramp: new s.bT(h, e.u_color_ramp),
                    u_opacity: new s.bj(h, e.u_opacity),
                  }),
                  hillshade: (h, e) => ({
                    u_image: new s.bT(h, e.u_image),
                    u_latrange: new s.bY(h, e.u_latrange),
                    u_exaggeration: new s.bj(h, e.u_exaggeration),
                    u_altitudes: new s.c2(h, e.u_altitudes),
                    u_azimuths: new s.c2(h, e.u_azimuths),
                    u_accent: new s.bU(h, e.u_accent),
                    u_method: new s.bT(h, e.u_method),
                    u_shadows: new s.c1(h, e.u_shadows),
                    u_highlights: new s.c1(h, e.u_highlights),
                  }),
                  hillshadePrepare: (h, e) => ({
                    u_matrix: new s.bV(h, e.u_matrix),
                    u_image: new s.bT(h, e.u_image),
                    u_dimension: new s.bY(h, e.u_dimension),
                    u_zoom: new s.bj(h, e.u_zoom),
                    u_unpack: new s.bW(h, e.u_unpack),
                  }),
                  colorRelief: (h, e) => ({
                    u_image: new s.bT(h, e.u_image),
                    u_unpack: new s.bW(h, e.u_unpack),
                    u_dimension: new s.bY(h, e.u_dimension),
                    u_elevation_stops: new s.bT(h, e.u_elevation_stops),
                    u_color_stops: new s.bT(h, e.u_color_stops),
                    u_color_ramp_size: new s.bT(h, e.u_color_ramp_size),
                    u_opacity: new s.bj(h, e.u_opacity),
                  }),
                  line: (h, e) => ({
                    u_translation: new s.bY(h, e.u_translation),
                    u_ratio: new s.bj(h, e.u_ratio),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
                  }),
                  lineGradient: (h, e) => ({
                    u_translation: new s.bY(h, e.u_translation),
                    u_ratio: new s.bj(h, e.u_ratio),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
                    u_image: new s.bT(h, e.u_image),
                    u_image_height: new s.bj(h, e.u_image_height),
                  }),
                  linePattern: (h, e) => ({
                    u_translation: new s.bY(h, e.u_translation),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_ratio: new s.bj(h, e.u_ratio),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_image: new s.bT(h, e.u_image),
                    u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
                    u_scale: new s.bX(h, e.u_scale),
                    u_fade: new s.bj(h, e.u_fade),
                  }),
                  lineSDF: (h, e) => ({
                    u_translation: new s.bY(h, e.u_translation),
                    u_ratio: new s.bj(h, e.u_ratio),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
                    u_image: new s.bT(h, e.u_image),
                    u_mix: new s.bj(h, e.u_mix),
                    u_tileratio: new s.bj(h, e.u_tileratio),
                    u_crossfade_from: new s.bj(h, e.u_crossfade_from),
                    u_crossfade_to: new s.bj(h, e.u_crossfade_to),
                    u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
                    u_lineatlas_height: new s.bj(h, e.u_lineatlas_height),
                  }),
                  lineGradientSDF: (h, e) => ({
                    u_translation: new s.bY(h, e.u_translation),
                    u_ratio: new s.bj(h, e.u_ratio),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
                    u_image: new s.bT(h, e.u_image),
                    u_image_height: new s.bj(h, e.u_image_height),
                    u_tileratio: new s.bj(h, e.u_tileratio),
                    u_crossfade_from: new s.bj(h, e.u_crossfade_from),
                    u_crossfade_to: new s.bj(h, e.u_crossfade_to),
                    u_image_dash: new s.bT(h, e.u_image_dash),
                    u_mix: new s.bj(h, e.u_mix),
                    u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
                    u_lineatlas_height: new s.bj(h, e.u_lineatlas_height),
                  }),
                  raster: (h, e) => ({
                    u_tl_parent: new s.bY(h, e.u_tl_parent),
                    u_scale_parent: new s.bj(h, e.u_scale_parent),
                    u_buffer_scale: new s.bj(h, e.u_buffer_scale),
                    u_fade_t: new s.bj(h, e.u_fade_t),
                    u_opacity: new s.bj(h, e.u_opacity),
                    u_image0: new s.bT(h, e.u_image0),
                    u_image1: new s.bT(h, e.u_image1),
                    u_brightness_low: new s.bj(h, e.u_brightness_low),
                    u_brightness_high: new s.bj(h, e.u_brightness_high),
                    u_saturation_factor: new s.bj(h, e.u_saturation_factor),
                    u_contrast_factor: new s.bj(h, e.u_contrast_factor),
                    u_spin_weights: new s.bX(h, e.u_spin_weights),
                    u_coords_top: new s.bW(h, e.u_coords_top),
                    u_coords_bottom: new s.bW(h, e.u_coords_bottom),
                  }),
                  symbolIcon: (h, e) => ({
                    u_is_size_zoom_constant: new s.bT(
                      h,
                      e.u_is_size_zoom_constant
                    ),
                    u_is_size_feature_constant: new s.bT(
                      h,
                      e.u_is_size_feature_constant
                    ),
                    u_size_t: new s.bj(h, e.u_size_t),
                    u_size: new s.bj(h, e.u_size),
                    u_camera_to_center_distance: new s.bj(
                      h,
                      e.u_camera_to_center_distance
                    ),
                    u_pitch: new s.bj(h, e.u_pitch),
                    u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
                    u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
                    u_fade_change: new s.bj(h, e.u_fade_change),
                    u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
                    u_coord_matrix: new s.bV(h, e.u_coord_matrix),
                    u_is_text: new s.bT(h, e.u_is_text),
                    u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
                    u_is_along_line: new s.bT(h, e.u_is_along_line),
                    u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_texture: new s.bT(h, e.u_texture),
                    u_translation: new s.bY(h, e.u_translation),
                    u_pitched_scale: new s.bj(h, e.u_pitched_scale),
                  }),
                  symbolSDF: (h, e) => ({
                    u_is_size_zoom_constant: new s.bT(
                      h,
                      e.u_is_size_zoom_constant
                    ),
                    u_is_size_feature_constant: new s.bT(
                      h,
                      e.u_is_size_feature_constant
                    ),
                    u_size_t: new s.bj(h, e.u_size_t),
                    u_size: new s.bj(h, e.u_size),
                    u_camera_to_center_distance: new s.bj(
                      h,
                      e.u_camera_to_center_distance
                    ),
                    u_pitch: new s.bj(h, e.u_pitch),
                    u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
                    u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
                    u_fade_change: new s.bj(h, e.u_fade_change),
                    u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
                    u_coord_matrix: new s.bV(h, e.u_coord_matrix),
                    u_is_text: new s.bT(h, e.u_is_text),
                    u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
                    u_is_along_line: new s.bT(h, e.u_is_along_line),
                    u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_texture: new s.bT(h, e.u_texture),
                    u_gamma_scale: new s.bj(h, e.u_gamma_scale),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_is_halo: new s.bT(h, e.u_is_halo),
                    u_translation: new s.bY(h, e.u_translation),
                    u_pitched_scale: new s.bj(h, e.u_pitched_scale),
                  }),
                  symbolTextAndIcon: (h, e) => ({
                    u_is_size_zoom_constant: new s.bT(
                      h,
                      e.u_is_size_zoom_constant
                    ),
                    u_is_size_feature_constant: new s.bT(
                      h,
                      e.u_is_size_feature_constant
                    ),
                    u_size_t: new s.bj(h, e.u_size_t),
                    u_size: new s.bj(h, e.u_size),
                    u_camera_to_center_distance: new s.bj(
                      h,
                      e.u_camera_to_center_distance
                    ),
                    u_pitch: new s.bj(h, e.u_pitch),
                    u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
                    u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
                    u_fade_change: new s.bj(h, e.u_fade_change),
                    u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
                    u_coord_matrix: new s.bV(h, e.u_coord_matrix),
                    u_is_text: new s.bT(h, e.u_is_text),
                    u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
                    u_is_along_line: new s.bT(h, e.u_is_along_line),
                    u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_texsize_icon: new s.bY(h, e.u_texsize_icon),
                    u_texture: new s.bT(h, e.u_texture),
                    u_texture_icon: new s.bT(h, e.u_texture_icon),
                    u_gamma_scale: new s.bj(h, e.u_gamma_scale),
                    u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
                    u_is_halo: new s.bT(h, e.u_is_halo),
                    u_translation: new s.bY(h, e.u_translation),
                    u_pitched_scale: new s.bj(h, e.u_pitched_scale),
                  }),
                  background: (h, e) => ({
                    u_opacity: new s.bj(h, e.u_opacity),
                    u_color: new s.bU(h, e.u_color),
                  }),
                  backgroundPattern: (h, e) => ({
                    u_opacity: new s.bj(h, e.u_opacity),
                    u_image: new s.bT(h, e.u_image),
                    u_pattern_tl_a: new s.bY(h, e.u_pattern_tl_a),
                    u_pattern_br_a: new s.bY(h, e.u_pattern_br_a),
                    u_pattern_tl_b: new s.bY(h, e.u_pattern_tl_b),
                    u_pattern_br_b: new s.bY(h, e.u_pattern_br_b),
                    u_texsize: new s.bY(h, e.u_texsize),
                    u_mix: new s.bj(h, e.u_mix),
                    u_pattern_size_a: new s.bY(h, e.u_pattern_size_a),
                    u_pattern_size_b: new s.bY(h, e.u_pattern_size_b),
                    u_scale_a: new s.bj(h, e.u_scale_a),
                    u_scale_b: new s.bj(h, e.u_scale_b),
                    u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
                    u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
                    u_tile_units_to_pixels: new s.bj(
                      h,
                      e.u_tile_units_to_pixels
                    ),
                  }),
                  terrain: (h, e) => ({
                    u_texture: new s.bT(h, e.u_texture),
                    u_ele_delta: new s.bj(h, e.u_ele_delta),
                    u_fog_matrix: new s.bV(h, e.u_fog_matrix),
                    u_fog_color: new s.bU(h, e.u_fog_color),
                    u_fog_ground_blend: new s.bj(h, e.u_fog_ground_blend),
                    u_fog_ground_blend_opacity: new s.bj(
                      h,
                      e.u_fog_ground_blend_opacity
                    ),
                    u_horizon_color: new s.bU(h, e.u_horizon_color),
                    u_horizon_fog_blend: new s.bj(h, e.u_horizon_fog_blend),
                    u_is_globe_mode: new s.bj(h, e.u_is_globe_mode),
                  }),
                  terrainDepth: (h, e) => ({
                    u_ele_delta: new s.bj(h, e.u_ele_delta),
                  }),
                  terrainCoords: (h, e) => ({
                    u_texture: new s.bT(h, e.u_texture),
                    u_terrain_coords_id: new s.bj(h, e.u_terrain_coords_id),
                    u_ele_delta: new s.bj(h, e.u_ele_delta),
                  }),
                  projectionErrorMeasurement: (h, e) => ({
                    u_input: new s.bj(h, e.u_input),
                    u_output_expected: new s.bj(h, e.u_output_expected),
                  }),
                  atmosphere: (h, e) => ({
                    u_sun_pos: new s.bX(h, e.u_sun_pos),
                    u_atmosphere_blend: new s.bj(h, e.u_atmosphere_blend),
                    u_globe_position: new s.bX(h, e.u_globe_position),
                    u_globe_radius: new s.bj(h, e.u_globe_radius),
                    u_inv_proj_matrix: new s.bV(h, e.u_inv_proj_matrix),
                  }),
                  sky: (h, e) => ({
                    u_sky_color: new s.bU(h, e.u_sky_color),
                    u_horizon_color: new s.bU(h, e.u_horizon_color),
                    u_horizon: new s.bY(h, e.u_horizon),
                    u_horizon_normal: new s.bY(h, e.u_horizon_normal),
                    u_sky_horizon_blend: new s.bj(h, e.u_sky_horizon_blend),
                    u_sky_blend: new s.bj(h, e.u_sky_blend),
                  }),
                };
              class Jc {
                constructor(e, i, l) {
                  this.context = e;
                  const u = e.gl;
                  (this.buffer = u.createBuffer()),
                    (this.dynamicDraw = !!l),
                    this.context.unbindVAO(),
                    e.bindElementBuffer.set(this.buffer),
                    u.bufferData(
                      u.ELEMENT_ARRAY_BUFFER,
                      i.arrayBuffer,
                      this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW
                    ),
                    this.dynamicDraw || delete i.arrayBuffer;
                }
                bind() {
                  this.context.bindElementBuffer.set(this.buffer);
                }
                updateData(e) {
                  const i = this.context.gl;
                  if (!this.dynamicDraw)
                    throw new Error(
                      "Attempted to update data while not in dynamic mode."
                    );
                  this.context.unbindVAO(),
                    this.bind(),
                    i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
                }
                destroy() {
                  this.buffer &&
                    (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer);
                }
              }
              const jo = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT",
              };
              class Qc {
                constructor(e, i, l, u) {
                  (this.length = i.length),
                    (this.attributes = l),
                    (this.itemSize = i.bytesPerElement),
                    (this.dynamicDraw = u),
                    (this.context = e);
                  const d = e.gl;
                  (this.buffer = d.createBuffer()),
                    e.bindVertexBuffer.set(this.buffer),
                    d.bufferData(
                      d.ARRAY_BUFFER,
                      i.arrayBuffer,
                      this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW
                    ),
                    this.dynamicDraw || delete i.arrayBuffer;
                }
                bind() {
                  this.context.bindVertexBuffer.set(this.buffer);
                }
                updateData(e) {
                  if (e.length !== this.length)
                    throw new Error(
                      `Length of new data is ${e.length}, which doesn't match current length of ${this.length}`
                    );
                  const i = this.context.gl;
                  this.bind(),
                    i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer);
                }
                enableAttributes(e, i) {
                  for (let l = 0; l < this.attributes.length; l++) {
                    const u = i.attributes[this.attributes[l].name];
                    u !== void 0 && e.enableVertexAttribArray(u);
                  }
                }
                setVertexAttribPointers(e, i, l) {
                  for (let u = 0; u < this.attributes.length; u++) {
                    const d = this.attributes[u],
                      g = i.attributes[d.name];
                    g !== void 0 &&
                      e.vertexAttribPointer(
                        g,
                        d.components,
                        e[jo[d.type]],
                        !1,
                        this.itemSize,
                        d.offset + this.itemSize * (l || 0)
                      );
                  }
                }
                destroy() {
                  this.buffer &&
                    (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer);
                }
              }
              class An {
                constructor(e) {
                  (this.gl = e.gl),
                    (this.default = this.getDefault()),
                    (this.current = this.default),
                    (this.dirty = !1);
                }
                get() {
                  return this.current;
                }
                set(e) {}
                getDefault() {
                  return this.default;
                }
                setDefault() {
                  this.set(this.default);
                }
              }
              class hf extends An {
                getDefault() {
                  return s.bi.transparent;
                }
                set(e) {
                  const i = this.current;
                  (e.r !== i.r ||
                    e.g !== i.g ||
                    e.b !== i.b ||
                    e.a !== i.a ||
                    this.dirty) &&
                    (this.gl.clearColor(e.r, e.g, e.b, e.a),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class df extends An {
                getDefault() {
                  return 1;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.clearDepth(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class pf extends An {
                getDefault() {
                  return 0;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.clearStencil(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class ud extends An {
                getDefault() {
                  return [!0, !0, !0, !0];
                }
                set(e) {
                  const i = this.current;
                  (e[0] !== i[0] ||
                    e[1] !== i[1] ||
                    e[2] !== i[2] ||
                    e[3] !== i[3] ||
                    this.dirty) &&
                    (this.gl.colorMask(e[0], e[1], e[2], e[3]),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class ff extends An {
                getDefault() {
                  return !0;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.depthMask(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class hd extends An {
                getDefault() {
                  return 255;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.stencilMask(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Ll extends An {
                getDefault() {
                  return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
                }
                set(e) {
                  const i = this.current;
                  (e.func !== i.func ||
                    e.ref !== i.ref ||
                    e.mask !== i.mask ||
                    this.dirty) &&
                    (this.gl.stencilFunc(e.func, e.ref, e.mask),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Dl extends An {
                getDefault() {
                  const e = this.gl;
                  return [e.KEEP, e.KEEP, e.KEEP];
                }
                set(e) {
                  const i = this.current;
                  (e[0] !== i[0] ||
                    e[1] !== i[1] ||
                    e[2] !== i[2] ||
                    this.dirty) &&
                    (this.gl.stencilOp(e[0], e[1], e[2]),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Rl extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class eu extends An {
                getDefault() {
                  return [0, 1];
                }
                set(e) {
                  const i = this.current;
                  (e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
                    (this.gl.depthRange(e[0], e[1]),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Vo extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class Hs extends An {
                getDefault() {
                  return this.gl.LESS;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.depthFunc(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class _s extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  e ? i.enable(i.BLEND) : i.disable(i.BLEND),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class xa extends An {
                getDefault() {
                  const e = this.gl;
                  return [e.ONE, e.ZERO];
                }
                set(e) {
                  const i = this.current;
                  (e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
                    (this.gl.blendFunc(e[0], e[1]),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class dd extends An {
                getDefault() {
                  return s.bi.transparent;
                }
                set(e) {
                  const i = this.current;
                  (e.r !== i.r ||
                    e.g !== i.g ||
                    e.b !== i.b ||
                    e.a !== i.a ||
                    this.dirty) &&
                    (this.gl.blendColor(e.r, e.g, e.b, e.a),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class pd extends An {
                getDefault() {
                  return this.gl.FUNC_ADD;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.blendEquation(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class tu extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class qo extends An {
                getDefault() {
                  return this.gl.BACK;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.cullFace(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Fl extends An {
                getDefault() {
                  return this.gl.CCW;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.frontFace(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Bl extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.useProgram(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Ws extends An {
                getDefault() {
                  return this.gl.TEXTURE0;
                }
                set(e) {
                  (e !== this.current || this.dirty) &&
                    (this.gl.activeTexture(e),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class Ol extends An {
                getDefault() {
                  const e = this.gl;
                  return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
                }
                set(e) {
                  const i = this.current;
                  (e[0] !== i[0] ||
                    e[1] !== i[1] ||
                    e[2] !== i[2] ||
                    e[3] !== i[3] ||
                    this.dirty) &&
                    (this.gl.viewport(e[0], e[1], e[2], e[3]),
                    (this.current = e),
                    (this.dirty = !1));
                }
              }
              class fd extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.bindFramebuffer(i.FRAMEBUFFER, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class gs extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.bindRenderbuffer(i.RENDERBUFFER, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class vs extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.bindTexture(i.TEXTURE_2D, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class md extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.bindBuffer(i.ARRAY_BUFFER, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class ru extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  const i = this.gl;
                  i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class vn extends An {
                getDefault() {
                  return null;
                }
                set(e) {
                  var i;
                  if (e === this.current && !this.dirty) return;
                  const l = this.gl;
                  Di(l)
                    ? l.bindVertexArray(e)
                    : (i = l.getExtension("OES_vertex_array_object")) ===
                        null ||
                      i === void 0 ||
                      i.bindVertexArrayOES(e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class Nl extends An {
                getDefault() {
                  return 4;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.pixelStorei(i.UNPACK_ALIGNMENT, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class mf extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class _d extends An {
                getDefault() {
                  return !1;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  const i = this.gl;
                  i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class Uo extends An {
                constructor(e, i) {
                  super(e), (this.context = e), (this.parent = i);
                }
                getDefault() {
                  return null;
                }
              }
              class _f extends Uo {
                setDirty() {
                  this.dirty = !0;
                }
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const i = this.gl;
                  i.framebufferTexture2D(
                    i.FRAMEBUFFER,
                    i.COLOR_ATTACHMENT0,
                    i.TEXTURE_2D,
                    e,
                    0
                  ),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class gf extends Uo {
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const i = this.gl;
                  i.framebufferRenderbuffer(
                    i.FRAMEBUFFER,
                    i.DEPTH_ATTACHMENT,
                    i.RENDERBUFFER,
                    e
                  ),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              class gd extends Uo {
                set(e) {
                  if (e === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const i = this.gl;
                  i.framebufferRenderbuffer(
                    i.FRAMEBUFFER,
                    i.DEPTH_STENCIL_ATTACHMENT,
                    i.RENDERBUFFER,
                    e
                  ),
                    (this.current = e),
                    (this.dirty = !1);
                }
              }
              const vd = "Framebuffer is not complete";
              class nu {
                constructor(e, i, l, u, d) {
                  (this.context = e), (this.width = i), (this.height = l);
                  const g = e.gl,
                    w = (this.framebuffer = g.createFramebuffer());
                  if (((this.colorAttachment = new _f(e, w)), u))
                    this.depthAttachment = d ? new gd(e, w) : new gf(e, w);
                  else if (d)
                    throw new Error("Stencil cannot be set without depth");
                  if (
                    g.checkFramebufferStatus(g.FRAMEBUFFER) !==
                    g.FRAMEBUFFER_COMPLETE
                  )
                    throw new Error(vd);
                }
                destroy() {
                  const e = this.context.gl,
                    i = this.colorAttachment.get();
                  if ((i && e.deleteTexture(i), this.depthAttachment)) {
                    const l = this.depthAttachment.get();
                    l && e.deleteRenderbuffer(l);
                  }
                  e.deleteFramebuffer(this.framebuffer);
                }
              }
              class jl {
                constructor(e) {
                  var i, l;
                  if (
                    ((this.gl = e),
                    (this.clearColor = new hf(this)),
                    (this.clearDepth = new df(this)),
                    (this.clearStencil = new pf(this)),
                    (this.colorMask = new ud(this)),
                    (this.depthMask = new ff(this)),
                    (this.stencilMask = new hd(this)),
                    (this.stencilFunc = new Ll(this)),
                    (this.stencilOp = new Dl(this)),
                    (this.stencilTest = new Rl(this)),
                    (this.depthRange = new eu(this)),
                    (this.depthTest = new Vo(this)),
                    (this.depthFunc = new Hs(this)),
                    (this.blend = new _s(this)),
                    (this.blendFunc = new xa(this)),
                    (this.blendColor = new dd(this)),
                    (this.blendEquation = new pd(this)),
                    (this.cullFace = new tu(this)),
                    (this.cullFaceSide = new qo(this)),
                    (this.frontFace = new Fl(this)),
                    (this.program = new Bl(this)),
                    (this.activeTexture = new Ws(this)),
                    (this.viewport = new Ol(this)),
                    (this.bindFramebuffer = new fd(this)),
                    (this.bindRenderbuffer = new gs(this)),
                    (this.bindTexture = new vs(this)),
                    (this.bindVertexBuffer = new md(this)),
                    (this.bindElementBuffer = new ru(this)),
                    (this.bindVertexArray = new vn(this)),
                    (this.pixelStoreUnpack = new Nl(this)),
                    (this.pixelStoreUnpackPremultiplyAlpha = new mf(this)),
                    (this.pixelStoreUnpackFlipY = new _d(this)),
                    (this.extTextureFilterAnisotropic =
                      e.getExtension("EXT_texture_filter_anisotropic") ||
                      e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                      e.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                    this.extTextureFilterAnisotropic &&
                      (this.extTextureFilterAnisotropicMax = e.getParameter(
                        this.extTextureFilterAnisotropic
                          .MAX_TEXTURE_MAX_ANISOTROPY_EXT
                      )),
                    (this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)),
                    Di(e))
                  ) {
                    this.HALF_FLOAT = e.HALF_FLOAT;
                    const u = e.getExtension("EXT_color_buffer_half_float");
                    (this.RGBA16F =
                      (i = e.RGBA16F) !== null && i !== void 0
                        ? i
                        : u == null
                        ? void 0
                        : u.RGBA16F_EXT),
                      (this.RGB16F =
                        (l = e.RGB16F) !== null && l !== void 0
                          ? l
                          : u == null
                          ? void 0
                          : u.RGB16F_EXT),
                      e.getExtension("EXT_color_buffer_float");
                  } else {
                    e.getExtension("EXT_color_buffer_half_float"),
                      e.getExtension("OES_texture_half_float_linear");
                    const u = e.getExtension("OES_texture_half_float");
                    this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES;
                  }
                }
                setDefault() {
                  this.unbindVAO(),
                    this.clearColor.setDefault(),
                    this.clearDepth.setDefault(),
                    this.clearStencil.setDefault(),
                    this.colorMask.setDefault(),
                    this.depthMask.setDefault(),
                    this.stencilMask.setDefault(),
                    this.stencilFunc.setDefault(),
                    this.stencilOp.setDefault(),
                    this.stencilTest.setDefault(),
                    this.depthRange.setDefault(),
                    this.depthTest.setDefault(),
                    this.depthFunc.setDefault(),
                    this.blend.setDefault(),
                    this.blendFunc.setDefault(),
                    this.blendColor.setDefault(),
                    this.blendEquation.setDefault(),
                    this.cullFace.setDefault(),
                    this.cullFaceSide.setDefault(),
                    this.frontFace.setDefault(),
                    this.program.setDefault(),
                    this.activeTexture.setDefault(),
                    this.bindFramebuffer.setDefault(),
                    this.pixelStoreUnpack.setDefault(),
                    this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.pixelStoreUnpackFlipY.setDefault();
                }
                setDirty() {
                  (this.clearColor.dirty = !0),
                    (this.clearDepth.dirty = !0),
                    (this.clearStencil.dirty = !0),
                    (this.colorMask.dirty = !0),
                    (this.depthMask.dirty = !0),
                    (this.stencilMask.dirty = !0),
                    (this.stencilFunc.dirty = !0),
                    (this.stencilOp.dirty = !0),
                    (this.stencilTest.dirty = !0),
                    (this.depthRange.dirty = !0),
                    (this.depthTest.dirty = !0),
                    (this.depthFunc.dirty = !0),
                    (this.blend.dirty = !0),
                    (this.blendFunc.dirty = !0),
                    (this.blendColor.dirty = !0),
                    (this.blendEquation.dirty = !0),
                    (this.cullFace.dirty = !0),
                    (this.cullFaceSide.dirty = !0),
                    (this.frontFace.dirty = !0),
                    (this.program.dirty = !0),
                    (this.activeTexture.dirty = !0),
                    (this.viewport.dirty = !0),
                    (this.bindFramebuffer.dirty = !0),
                    (this.bindRenderbuffer.dirty = !0),
                    (this.bindTexture.dirty = !0),
                    (this.bindVertexBuffer.dirty = !0),
                    (this.bindElementBuffer.dirty = !0),
                    (this.bindVertexArray.dirty = !0),
                    (this.pixelStoreUnpack.dirty = !0),
                    (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                    (this.pixelStoreUnpackFlipY.dirty = !0);
                }
                createIndexBuffer(e, i) {
                  return new Jc(this, e, i);
                }
                createVertexBuffer(e, i, l) {
                  return new Qc(this, e, i, l);
                }
                createRenderbuffer(e, i, l) {
                  const u = this.gl,
                    d = u.createRenderbuffer();
                  return (
                    this.bindRenderbuffer.set(d),
                    u.renderbufferStorage(u.RENDERBUFFER, e, i, l),
                    this.bindRenderbuffer.set(null),
                    d
                  );
                }
                createFramebuffer(e, i, l, u) {
                  return new nu(this, e, i, l, u);
                }
                clear({ color: e, depth: i, stencil: l }) {
                  const u = this.gl;
                  let d = 0;
                  e &&
                    ((d |= u.COLOR_BUFFER_BIT),
                    this.clearColor.set(e),
                    this.colorMask.set([!0, !0, !0, !0])),
                    i !== void 0 &&
                      ((d |= u.DEPTH_BUFFER_BIT),
                      this.depthRange.set([0, 1]),
                      this.clearDepth.set(i),
                      this.depthMask.set(!0)),
                    l !== void 0 &&
                      ((d |= u.STENCIL_BUFFER_BIT),
                      this.clearStencil.set(l),
                      this.stencilMask.set(255)),
                    u.clear(d);
                }
                setCullFace(e) {
                  e.enable === !1
                    ? this.cullFace.set(!1)
                    : (this.cullFace.set(!0),
                      this.cullFaceSide.set(e.mode),
                      this.frontFace.set(e.frontFace));
                }
                setDepthMode(e) {
                  e.func !== this.gl.ALWAYS || e.mask
                    ? (this.depthTest.set(!0),
                      this.depthFunc.set(e.func),
                      this.depthMask.set(e.mask),
                      this.depthRange.set(e.range))
                    : this.depthTest.set(!1);
                }
                setStencilMode(e) {
                  e.test.func !== this.gl.ALWAYS || e.mask
                    ? (this.stencilTest.set(!0),
                      this.stencilMask.set(e.mask),
                      this.stencilOp.set([e.fail, e.depthFail, e.pass]),
                      this.stencilFunc.set({
                        func: e.test.func,
                        ref: e.ref,
                        mask: e.test.mask,
                      }))
                    : this.stencilTest.set(!1);
                }
                setColorMode(e) {
                  s.bK(e.blendFunction, _n.Replace)
                    ? this.blend.set(!1)
                    : (this.blend.set(!0),
                      this.blendFunc.set(e.blendFunction),
                      this.blendColor.set(e.blendColor)),
                    this.colorMask.set(e.mask);
                }
                createVertexArray() {
                  var e;
                  return Di(this.gl)
                    ? this.gl.createVertexArray()
                    : (e = this.gl.getExtension("OES_vertex_array_object")) ===
                        null || e === void 0
                    ? void 0
                    : e.createVertexArrayOES();
                }
                deleteVertexArray(e) {
                  var i;
                  return Di(this.gl)
                    ? this.gl.deleteVertexArray(e)
                    : (i = this.gl.getExtension("OES_vertex_array_object")) ===
                        null || i === void 0
                    ? void 0
                    : i.deleteVertexArrayOES(e);
                }
                unbindVAO() {
                  this.bindVertexArray.set(null);
                }
              }
              let Zo;
              function Xs(h, e, i, l, u) {
                const d = h.context,
                  g = h.transform,
                  w = d.gl,
                  S = h.useProgram("collisionBox"),
                  k = [];
                let z = 0,
                  V = 0;
                for (let se = 0; se < l.length; se++) {
                  const fe = l[se],
                    be = e.getTile(fe).getBucket(i);
                  if (!be) continue;
                  const pe = u ? be.textCollisionBox : be.iconCollisionBox,
                    we = be.collisionCircleArray;
                  we.length > 0 &&
                    (k.push({ circleArray: we, circleOffset: V, coord: fe }),
                    (z += we.length / 4),
                    (V = z)),
                    pe &&
                      S.draw(
                        d,
                        w.LINES,
                        ln.disabled,
                        xn.disabled,
                        h.colorModeForRenderPass(),
                        en.disabled,
                        id(h.transform),
                        h.style.map.terrain &&
                          h.style.map.terrain.getTerrainData(fe),
                        g.getProjectionData({
                          overscaledTileID: fe,
                          applyGlobeMatrix: !0,
                          applyTerrainMatrix: !0,
                        }),
                        i.id,
                        pe.layoutVertexBuffer,
                        pe.indexBuffer,
                        pe.segments,
                        null,
                        h.transform.zoom,
                        null,
                        null,
                        pe.collisionVertexBuffer
                      );
                }
                if (!u || !k.length) return;
                const F = h.useProgram("collisionCircle"),
                  $ = new s.c3();
                $.resize(4 * z), $._trim();
                let J = 0;
                for (const se of k)
                  for (let fe = 0; fe < se.circleArray.length / 4; fe++) {
                    const be = 4 * fe,
                      pe = se.circleArray[be + 0],
                      we = se.circleArray[be + 1],
                      Pe = se.circleArray[be + 2],
                      ve = se.circleArray[be + 3];
                    $.emplace(J++, pe, we, Pe, ve, 0),
                      $.emplace(J++, pe, we, Pe, ve, 1),
                      $.emplace(J++, pe, we, Pe, ve, 2),
                      $.emplace(J++, pe, we, Pe, ve, 3);
                  }
                (!Zo || Zo.length < 2 * z) &&
                  (Zo = (function (se) {
                    const fe = 2 * se,
                      be = new s.c5();
                    be.resize(fe), be._trim();
                    for (let pe = 0; pe < fe; pe++) {
                      const we = 6 * pe;
                      (be.uint16[we + 0] = 4 * pe + 0),
                        (be.uint16[we + 1] = 4 * pe + 1),
                        (be.uint16[we + 2] = 4 * pe + 2),
                        (be.uint16[we + 3] = 4 * pe + 2),
                        (be.uint16[we + 4] = 4 * pe + 3),
                        (be.uint16[we + 5] = 4 * pe + 0);
                    }
                    return be;
                  })(z));
                const ae = d.createIndexBuffer(Zo, !0),
                  oe = d.createVertexBuffer($, s.c4.members, !0);
                for (const se of k) {
                  const fe = Uc(h.transform);
                  F.draw(
                    d,
                    w.TRIANGLES,
                    ln.disabled,
                    xn.disabled,
                    h.colorModeForRenderPass(),
                    en.disabled,
                    fe,
                    h.style.map.terrain &&
                      h.style.map.terrain.getTerrainData(se.coord),
                    null,
                    i.id,
                    oe,
                    ae,
                    s.aQ.simpleSegment(
                      0,
                      2 * se.circleOffset,
                      se.circleArray.length,
                      se.circleArray.length / 2
                    ),
                    null,
                    h.transform.zoom,
                    null,
                    null,
                    null
                  );
                }
                oe.destroy(), ae.destroy();
              }
              const iu = s.am(new Float32Array(16));
              function yd(h, e, i, l, u, d) {
                const { horizontalAlign: g, verticalAlign: w } = s.aL(h);
                return new s.P(
                  ((-(g - 0.5) * e) / u + l[0]) * d,
                  ((-(w - 0.5) * i) / u + l[1]) * d
                );
              }
              function Vl(h, e, i, l, u, d) {
                const g = e.tileAnchorPoint.add(
                  new s.P(e.translation[0], e.translation[1])
                );
                if (e.pitchWithMap) {
                  let w = l.mult(d);
                  i || (w = w.rotate(-u));
                  const S = g.add(w);
                  return rt(S.x, S.y, e.pitchedLabelPlaneMatrix, e.getElevation)
                    .point;
                }
                if (i) {
                  const w = jr(
                      e.tileAnchorPoint.x + 1,
                      e.tileAnchorPoint.y,
                      e
                    ).point.sub(h),
                    S = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
                  return h.add(l.rotate(S));
                }
                return h.add(l);
              }
              function ql(h, e, i, l, u, d, g, w, S, k, z, V) {
                const F = h.text.placedSymbolArray,
                  $ = h.text.dynamicLayoutVertexArray,
                  J = h.icon.dynamicLayoutVertexArray,
                  ae = {};
                $.clear();
                for (let oe = 0; oe < F.length; oe++) {
                  const se = F.get(oe),
                    fe =
                      se.hidden ||
                      !se.crossTileID ||
                      (h.allowVerticalPlacement && !se.placedOrientation)
                        ? null
                        : l[se.crossTileID];
                  if (fe) {
                    const be = new s.P(se.anchorX, se.anchorY),
                      pe = {
                        getElevation: V,
                        width: u.width,
                        height: u.height,
                        pitchedLabelPlaneMatrix: d,
                        pitchWithMap: i,
                        transform: u,
                        tileAnchorPoint: be,
                        translation: k,
                        unwrappedTileID: z,
                      },
                      we = i ? fr(be.x, be.y, pe) : jr(be.x, be.y, pe),
                      Pe = $t(
                        u.cameraToCenterDistance,
                        we.signedDistanceFromCamera
                      );
                    let ve = (s.at(h.textSizeData, w, se) * Pe) / s.aF;
                    i && (ve *= h.tilePixelRatio / g);
                    const {
                        width: Re,
                        height: it,
                        anchor: Qe,
                        textOffset: tt,
                        textBoxScale: ot,
                      } = fe,
                      Zt = yd(Qe, Re, it, tt, ot, ve),
                      Ht = u.getPitchedTextCorrection(
                        be.x + k[0],
                        be.y + k[1],
                        z
                      ),
                      Pt = Vl(we.point, pe, e, Zt, -u.bearingInRadians, Ht),
                      yr =
                        h.allowVerticalPlacement &&
                        se.placedOrientation === s.as.vertical
                          ? Math.PI / 2
                          : 0;
                    for (let tn = 0; tn < se.numGlyphs; tn++) s.az($, Pt, yr);
                    S &&
                      se.associatedIconIndex >= 0 &&
                      (ae[se.associatedIconIndex] = {
                        shiftedAnchor: Pt,
                        angle: yr,
                      });
                  } else Gn(se.numGlyphs, $);
                }
                if (S) {
                  J.clear();
                  const oe = h.icon.placedSymbolArray;
                  for (let se = 0; se < oe.length; se++) {
                    const fe = oe.get(se);
                    if (fe.hidden) Gn(fe.numGlyphs, J);
                    else {
                      const be = ae[se];
                      if (be)
                        for (let pe = 0; pe < fe.numGlyphs; pe++)
                          s.az(J, be.shiftedAnchor, be.angle);
                      else Gn(fe.numGlyphs, J);
                    }
                  }
                  h.icon.dynamicLayoutVertexBuffer.updateData(J);
                }
                h.text.dynamicLayoutVertexBuffer.updateData($);
              }
              function Ul(h, e, i) {
                return i.iconsInText && e
                  ? "symbolTextAndIcon"
                  : h
                  ? "symbolSDF"
                  : "symbolIcon";
              }
              function Go(h, e, i, l, u, d, g, w, S, k, z, V, F) {
                const $ = h.context,
                  J = $.gl,
                  ae = h.transform,
                  oe = w === "map",
                  se = S === "map",
                  fe =
                    w !== "viewport" &&
                    i.layout.get("symbol-placement") !== "point",
                  be = oe && !se && !fe,
                  pe = !i.layout.get("symbol-sort-key").isConstant();
                let we = !1;
                const Pe = h.getDepthModeForSublayer(0, ln.ReadOnly),
                  ve =
                    i._unevaluatedLayout.hasValue("text-variable-anchor") ||
                    i._unevaluatedLayout.hasValue(
                      "text-variable-anchor-offset"
                    ),
                  Re = [],
                  it = ae.getCircleRadiusCorrection();
                for (const Qe of l) {
                  const tt = e.getTile(Qe),
                    ot = tt.getBucket(i);
                  if (!ot) continue;
                  const Zt = u ? ot.text : ot.icon;
                  if (
                    !Zt ||
                    !Zt.segments.get().length ||
                    !Zt.hasVisibleVertices
                  )
                    continue;
                  const Ht = Zt.programConfigurations.get(i.id),
                    Pt = u || ot.sdfIcons,
                    yr = u ? ot.textSizeData : ot.iconSizeData,
                    tn = se || ae.pitch !== 0,
                    Ln = h.useProgram(Ul(Pt, u, ot), Ht),
                    cn = s.ar(yr, ae.zoom),
                    Nn =
                      h.style.map.terrain &&
                      h.style.map.terrain.getTerrainData(Qe);
                  let ri,
                    Un,
                    gi,
                    Kn,
                    Ii = [0, 0],
                    Jn = null;
                  if (u)
                    (Un = tt.glyphAtlasTexture),
                      (gi = J.LINEAR),
                      (ri = tt.glyphAtlasTexture.size),
                      ot.iconsInText &&
                        ((Ii = tt.imageAtlasTexture.size),
                        (Jn = tt.imageAtlasTexture),
                        (Kn =
                          tn ||
                          h.options.rotating ||
                          h.options.zooming ||
                          yr.kind === "composite" ||
                          yr.kind === "camera"
                            ? J.LINEAR
                            : J.NEAREST));
                  else {
                    const mi =
                      i.layout.get("icon-size").constantOr(0) !== 1 ||
                      ot.iconsNeedLinear;
                    (Un = tt.imageAtlasTexture),
                      (gi =
                        Pt ||
                        h.options.rotating ||
                        h.options.zooming ||
                        mi ||
                        tn
                          ? J.LINEAR
                          : J.NEAREST),
                      (ri = tt.imageAtlasTexture.size);
                  }
                  const fi = s.aG(tt, 1, h.transform.zoom),
                    Yi = Pn(oe, h.transform, fi),
                    Ko = s.M();
                  s.au(Ko, Yi);
                  const ao = zt(se, oe, h.transform, fi),
                    Ua = s.aH(ae, tt, d, g),
                    Jo = ae.getProjectionData({
                      overscaledTileID: Qe,
                      applyGlobeMatrix: !F,
                      applyTerrainMatrix: !0,
                    }),
                    Ps = ve && ot.hasTextData(),
                    Qo =
                      i.layout.get("icon-text-fit") !== "none" &&
                      Ps &&
                      ot.hasIconData();
                  if (fe) {
                    const mi = h.style.map.terrain
                        ? (Mi, Hn) =>
                            h.style.map.terrain.getElevation(Qe, Mi, Hn)
                        : null,
                      ui = i.layout.get("text-rotation-alignment") === "map";
                    gt(
                      ot,
                      h,
                      u,
                      Yi,
                      Ko,
                      se,
                      k,
                      ui,
                      Qe.toUnwrapped(),
                      ae.width,
                      ae.height,
                      Ua,
                      mi
                    );
                  }
                  const ia = (u && ve) || Qo,
                    Ki =
                      fe || ia
                        ? iu
                        : se
                        ? Yi
                        : h.transform.clipSpaceToPixelsMatrix,
                    oo =
                      Pt &&
                      i.paint
                        .get(u ? "text-halo-width" : "icon-halo-width")
                        .constantOr(1) !== 0;
                  let To;
                  To = Pt
                    ? ot.iconsInText
                      ? Qa(
                          yr.kind,
                          cn,
                          be,
                          se,
                          fe,
                          ia,
                          h,
                          Ki,
                          ao,
                          Ua,
                          ri,
                          Ii,
                          it
                        )
                      : $s(
                          yr.kind,
                          cn,
                          be,
                          se,
                          fe,
                          ia,
                          h,
                          Ki,
                          ao,
                          Ua,
                          u,
                          ri,
                          0,
                          it
                        )
                    : Xc(yr.kind, cn, be, se, fe, ia, h, Ki, ao, Ua, u, ri, it);
                  const ol = {
                    program: Ln,
                    buffers: Zt,
                    uniformValues: To,
                    projectionData: Jo,
                    atlasTexture: Un,
                    atlasTextureIcon: Jn,
                    atlasInterpolation: gi,
                    atlasInterpolationIcon: Kn,
                    isSDF: Pt,
                    hasHalo: oo,
                  };
                  if (pe && ot.canOverlap) {
                    we = !0;
                    const mi = Zt.segments.get();
                    for (const ui of mi)
                      Re.push({
                        segments: new s.aQ([ui]),
                        sortKey: ui.sortKey,
                        state: ol,
                        terrainData: Nn,
                      });
                  } else
                    Re.push({
                      segments: Zt.segments,
                      sortKey: 0,
                      state: ol,
                      terrainData: Nn,
                    });
                }
                we && Re.sort((Qe, tt) => Qe.sortKey - tt.sortKey);
                for (const Qe of Re) {
                  const tt = Qe.state;
                  if (
                    ($.activeTexture.set(J.TEXTURE0),
                    tt.atlasTexture.bind(
                      tt.atlasInterpolation,
                      J.CLAMP_TO_EDGE
                    ),
                    tt.atlasTextureIcon &&
                      ($.activeTexture.set(J.TEXTURE1),
                      tt.atlasTextureIcon &&
                        tt.atlasTextureIcon.bind(
                          tt.atlasInterpolationIcon,
                          J.CLAMP_TO_EDGE
                        )),
                    tt.isSDF)
                  ) {
                    const ot = tt.uniformValues;
                    tt.hasHalo &&
                      ((ot.u_is_halo = 1),
                      Zl(
                        tt.buffers,
                        Qe.segments,
                        i,
                        h,
                        tt.program,
                        Pe,
                        z,
                        V,
                        ot,
                        tt.projectionData,
                        Qe.terrainData
                      )),
                      (ot.u_is_halo = 0);
                  }
                  Zl(
                    tt.buffers,
                    Qe.segments,
                    i,
                    h,
                    tt.program,
                    Pe,
                    z,
                    V,
                    tt.uniformValues,
                    tt.projectionData,
                    Qe.terrainData
                  );
                }
              }
              function Zl(h, e, i, l, u, d, g, w, S, k, z) {
                const V = l.context;
                u.draw(
                  V,
                  V.gl.TRIANGLES,
                  d,
                  g,
                  w,
                  en.backCCW,
                  S,
                  z,
                  k,
                  i.id,
                  h.layoutVertexBuffer,
                  h.indexBuffer,
                  e,
                  i.paint,
                  l.transform.zoom,
                  h.programConfigurations.get(i.id),
                  h.dynamicLayoutVertexBuffer,
                  h.opacityVertexBuffer
                );
              }
              function vf(h, e, i, l, u) {
                const d = h.context,
                  g = d.gl,
                  w = xn.disabled,
                  S = new _n([g.ONE, g.ONE], s.bi.transparent, [
                    !0,
                    !0,
                    !0,
                    !0,
                  ]),
                  k = e.getBucket(i);
                if (!k) return;
                const z = l.key;
                let V = i.heatmapFbos.get(z);
                V ||
                  ((V = xd(d, e.tileSize, e.tileSize)),
                  i.heatmapFbos.set(z, V)),
                  d.bindFramebuffer.set(V.framebuffer),
                  d.viewport.set([0, 0, e.tileSize, e.tileSize]),
                  d.clear({ color: s.bi.transparent });
                const F = k.programConfigurations.get(i.id),
                  $ = h.useProgram("heatmap", F, !u),
                  J = h.transform.getProjectionData({
                    overscaledTileID: e.tileID,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0,
                  }),
                  ae = h.style.map.terrain.getTerrainData(l);
                $.draw(
                  d,
                  g.TRIANGLES,
                  ln.disabled,
                  w,
                  S,
                  en.disabled,
                  Gc(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1),
                  ae,
                  J,
                  i.id,
                  k.layoutVertexBuffer,
                  k.indexBuffer,
                  k.segments,
                  i.paint,
                  h.transform.zoom,
                  F
                );
              }
              function Ys(h, e, i, l, u) {
                const d = h.context,
                  g = d.gl,
                  w = h.transform;
                d.setColorMode(h.colorModeForRenderPass());
                const S = au(d, e),
                  k = i.key,
                  z = e.heatmapFbos.get(k);
                if (!z) return;
                d.activeTexture.set(g.TEXTURE0),
                  g.bindTexture(g.TEXTURE_2D, z.colorAttachment.get()),
                  d.activeTexture.set(g.TEXTURE1),
                  S.bind(g.LINEAR, g.CLAMP_TO_EDGE);
                const V = w.getProjectionData({
                  overscaledTileID: i,
                  applyTerrainMatrix: u,
                  applyGlobeMatrix: !l,
                });
                h
                  .useProgram("heatmapTexture")
                  .draw(
                    d,
                    g.TRIANGLES,
                    ln.disabled,
                    xn.disabled,
                    h.colorModeForRenderPass(),
                    en.disabled,
                    $c(h, e, 0, 1),
                    null,
                    V,
                    e.id,
                    h.rasterBoundsBuffer,
                    h.quadTriangleIndexBuffer,
                    h.rasterBoundsSegments,
                    e.paint,
                    w.zoom
                  ),
                  z.destroy(),
                  e.heatmapFbos.delete(k);
              }
              function xd(h, e, i) {
                var l, u;
                const d = h.gl,
                  g = d.createTexture();
                d.bindTexture(d.TEXTURE_2D, g),
                  d.texParameteri(
                    d.TEXTURE_2D,
                    d.TEXTURE_WRAP_S,
                    d.CLAMP_TO_EDGE
                  ),
                  d.texParameteri(
                    d.TEXTURE_2D,
                    d.TEXTURE_WRAP_T,
                    d.CLAMP_TO_EDGE
                  ),
                  d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR),
                  d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
                const w =
                    (l = h.HALF_FLOAT) !== null && l !== void 0
                      ? l
                      : d.UNSIGNED_BYTE,
                  S = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
                d.texImage2D(d.TEXTURE_2D, 0, S, e, i, 0, d.RGBA, w, null);
                const k = h.createFramebuffer(e, i, !1, !1);
                return k.colorAttachment.set(g), k;
              }
              function au(h, e) {
                return (
                  e.colorRampTexture ||
                    (e.colorRampTexture = new s.T(h, e.colorRamp, h.gl.RGBA)),
                  e.colorRampTexture
                );
              }
              function Ks(h, e, i, l, u, d, g, w) {
                let S = 256;
                if (u.stepInterpolant) {
                  const k = e.getSource().maxzoom,
                    z =
                      g.canonical.z === k
                        ? Math.ceil(1 << (h.transform.maxZoom - g.canonical.z))
                        : 1;
                  S = s.ai(
                    s.c7((d.maxLineLength / s.a3) * 1024 * z),
                    256,
                    i.maxTextureSize
                  );
                }
                return (
                  (w.gradient = s.c8({
                    expression: u.gradientExpression(),
                    evaluationKey: "lineProgress",
                    resolution: S,
                    image: w.gradient || void 0,
                    clips: d.lineClipsArray,
                  })),
                  w.texture
                    ? w.texture.update(w.gradient)
                    : (w.texture = new s.T(i, w.gradient, l.RGBA)),
                  (w.version = u.gradientVersion),
                  w.texture
                );
              }
              function ou(h, e, i, l, u) {
                h.activeTexture.set(e.TEXTURE0),
                  i.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE),
                  l.updatePaintBuffers(u);
              }
              function bd(h, e, i, l, u, d) {
                (u || h.lineAtlas.dirty) &&
                  (e.activeTexture.set(i.TEXTURE0), h.lineAtlas.bind(e)),
                  l.updatePaintBuffers(d);
              }
              function wd(h, e, i, l, u, d, g) {
                const w = d.gradients[u.id];
                let S = w.texture;
                u.gradientVersion !== w.version &&
                  (S = Ks(h, e, i, l, u, d, g, w)),
                  i.activeTexture.set(l.TEXTURE0),
                  S.bind(
                    u.stepInterpolant ? l.NEAREST : l.LINEAR,
                    l.CLAMP_TO_EDGE
                  );
              }
              function Gl(h, e, i, l, u, d, g, w, S) {
                const k = d.gradients[u.id];
                let z = k.texture;
                u.gradientVersion !== k.version &&
                  (z = Ks(h, e, i, l, u, d, g, k)),
                  i.activeTexture.set(l.TEXTURE0),
                  z.bind(
                    u.stepInterpolant ? l.NEAREST : l.LINEAR,
                    l.CLAMP_TO_EDGE
                  ),
                  i.activeTexture.set(l.TEXTURE1),
                  h.lineAtlas.bind(i),
                  w.updatePaintBuffers(S);
              }
              function $l(h, e, i, l, u) {
                if (!i || !l || !l.imageAtlas) return;
                const d = l.imageAtlas.patternPositions;
                let g = d[i.to.toString()],
                  w = d[i.from.toString()];
                if ((!g && w && (g = w), !w && g && (w = g), !g || !w)) {
                  const S = u.getPaintProperty(e);
                  (g = d[S]), (w = d[S]);
                }
                g && w && h.setConstantPatternPositions(g, w);
              }
              function Td(h, e, i, l, u, d, g, w) {
                const S = h.context.gl,
                  k = "fill-pattern",
                  z = i.paint.get(k),
                  V = z && z.constantOr(1),
                  F = i.getCrossfadeParameters();
                let $, J, ae, oe, se;
                const fe = h.transform,
                  be = i.paint.get("fill-translate"),
                  pe = i.paint.get("fill-translate-anchor");
                g
                  ? ((J =
                      V && !i.getPaintProperty("fill-outline-color")
                        ? "fillOutlinePattern"
                        : "fillOutline"),
                    ($ = S.LINES))
                  : ((J = V ? "fillPattern" : "fill"), ($ = S.TRIANGLES));
                const we = z.constantOr(null);
                for (const Pe of l) {
                  const ve = e.getTile(Pe);
                  if (V && !ve.patternsLoaded()) continue;
                  const Re = ve.getBucket(i);
                  if (!Re) continue;
                  const it = Re.programConfigurations.get(i.id),
                    Qe = h.useProgram(J, it),
                    tt =
                      h.style.map.terrain &&
                      h.style.map.terrain.getTerrainData(Pe);
                  V &&
                    (h.context.activeTexture.set(S.TEXTURE0),
                    ve.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                    it.updatePaintBuffers(F)),
                    $l(it, k, we, ve, i);
                  const ot = fe.getProjectionData({
                      overscaledTileID: Pe,
                      applyGlobeMatrix: !w,
                      applyTerrainMatrix: !0,
                    }),
                    Zt = s.aH(fe, ve, be, pe);
                  if (g) {
                    (oe = Re.indexBuffer2), (se = Re.segments2);
                    const Pt = [S.drawingBufferWidth, S.drawingBufferHeight];
                    ae =
                      J === "fillOutlinePattern" && V
                        ? nd(h, F, ve, Pt, Zt)
                        : of(Pt, Zt);
                  } else
                    (oe = Re.indexBuffer),
                      (se = Re.segments),
                      (ae = V ? Oo(h, F, ve, Zt) : { u_fill_translate: Zt });
                  const Ht = h.stencilModeForClipping(Pe);
                  Qe.draw(
                    h.context,
                    $,
                    u,
                    Ht,
                    d,
                    en.backCCW,
                    ae,
                    tt,
                    ot,
                    i.id,
                    Re.layoutVertexBuffer,
                    oe,
                    se,
                    i.paint,
                    h.transform.zoom,
                    it
                  );
                }
              }
              function Hl(h, e, i, l, u, d, g, w) {
                const S = h.context,
                  k = S.gl,
                  z = "fill-extrusion-pattern",
                  V = i.paint.get(z),
                  F = V.constantOr(1),
                  $ = i.getCrossfadeParameters(),
                  J = i.paint.get("fill-extrusion-opacity"),
                  ae = V.constantOr(null),
                  oe = h.transform;
                for (const se of l) {
                  const fe = e.getTile(se),
                    be = fe.getBucket(i);
                  if (!be) continue;
                  const pe =
                      h.style.map.terrain &&
                      h.style.map.terrain.getTerrainData(se),
                    we = be.programConfigurations.get(i.id),
                    Pe = h.useProgram(
                      F ? "fillExtrusionPattern" : "fillExtrusion",
                      we
                    );
                  F &&
                    (h.context.activeTexture.set(k.TEXTURE0),
                    fe.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE),
                    we.updatePaintBuffers($));
                  const ve = oe.getProjectionData({
                    overscaledTileID: se,
                    applyGlobeMatrix: !w,
                    applyTerrainMatrix: !0,
                  });
                  $l(we, z, ae, fe, i);
                  const Re = s.aH(
                      oe,
                      fe,
                      i.paint.get("fill-extrusion-translate"),
                      i.paint.get("fill-extrusion-translate-anchor")
                    ),
                    it = i.paint.get("fill-extrusion-vertical-gradient"),
                    Qe = F ? af(h, it, J, Re, se, $, fe) : Gs(h, it, J, Re);
                  Pe.draw(
                    S,
                    S.gl.TRIANGLES,
                    u,
                    d,
                    g,
                    en.backCCW,
                    Qe,
                    pe,
                    ve,
                    i.id,
                    be.layoutVertexBuffer,
                    be.indexBuffer,
                    be.segments,
                    i.paint,
                    h.transform.zoom,
                    we,
                    h.style.map.terrain && be.centroidVertexBuffer
                  );
                }
              }
              function ei(h, e, i, l, u, d, g, w, S) {
                var k;
                const z = h.style.projection,
                  V = h.context,
                  F = h.transform,
                  $ = V.gl,
                  J = [
                    `#define NUM_ILLUMINATION_SOURCES ${
                      i.paint.get("hillshade-highlight-color").values.length
                    }`,
                  ],
                  ae = h.useProgram("hillshade", null, !1, J),
                  oe = !h.options.moving;
                for (const se of l) {
                  const fe = e.getTile(se),
                    be = fe.fbo;
                  if (!be) continue;
                  const pe = z.getMeshFromTileID(
                      V,
                      se.canonical,
                      w,
                      !0,
                      "raster"
                    ),
                    we =
                      (k = h.style.map.terrain) === null || k === void 0
                        ? void 0
                        : k.getTerrainData(se);
                  V.activeTexture.set($.TEXTURE0),
                    $.bindTexture($.TEXTURE_2D, be.colorAttachment.get());
                  const Pe = F.getProjectionData({
                    overscaledTileID: se,
                    aligned: oe,
                    applyGlobeMatrix: !S,
                    applyTerrainMatrix: !0,
                  });
                  ae.draw(
                    V,
                    $.TRIANGLES,
                    d,
                    u[se.overscaledZ],
                    g,
                    en.backCCW,
                    ad(h, fe, i),
                    we,
                    Pe,
                    i.id,
                    pe.vertexBuffer,
                    pe.indexBuffer,
                    pe.segments
                  );
                }
              }
              function eo(h, e, i, l, u, d, g, w, S) {
                var k;
                const z = h.style.projection,
                  V = h.context,
                  F = h.transform,
                  $ = V.gl,
                  J = h.useProgram("colorRelief"),
                  ae = !h.options.moving;
                let oe = !0,
                  se = 0;
                for (const fe of l) {
                  const be = e.getTile(fe),
                    pe = be.dem;
                  if (oe) {
                    const Qe = $.getParameter($.MAX_TEXTURE_SIZE),
                      { elevationTexture: tt, colorTexture: ot } =
                        i.getColorRampTextures(V, Qe, pe.getUnpackVector());
                    V.activeTexture.set($.TEXTURE1),
                      tt.bind($.NEAREST, $.CLAMP_TO_EDGE),
                      V.activeTexture.set($.TEXTURE4),
                      ot.bind($.LINEAR, $.CLAMP_TO_EDGE),
                      (oe = !1),
                      (se = tt.size[0]);
                  }
                  if (!pe || !pe.data) continue;
                  const we = pe.stride,
                    Pe = pe.getPixels();
                  if (
                    (V.activeTexture.set($.TEXTURE0),
                    V.pixelStoreUnpackPremultiplyAlpha.set(!1),
                    (be.demTexture = be.demTexture || h.getTileTexture(we)),
                    be.demTexture)
                  ) {
                    const Qe = be.demTexture;
                    Qe.update(Pe, { premultiply: !1 }),
                      Qe.bind($.LINEAR, $.CLAMP_TO_EDGE);
                  } else
                    (be.demTexture = new s.T(V, Pe, $.RGBA, {
                      premultiply: !1,
                    })),
                      be.demTexture.bind($.LINEAR, $.CLAMP_TO_EDGE);
                  const ve = z.getMeshFromTileID(
                      V,
                      fe.canonical,
                      w,
                      !0,
                      "raster"
                    ),
                    Re =
                      (k = h.style.map.terrain) === null || k === void 0
                        ? void 0
                        : k.getTerrainData(fe),
                    it = F.getProjectionData({
                      overscaledTileID: fe,
                      aligned: ae,
                      applyGlobeMatrix: !S,
                      applyTerrainMatrix: !0,
                    });
                  J.draw(
                    V,
                    $.TRIANGLES,
                    d,
                    u[fe.overscaledZ],
                    g,
                    en.backCCW,
                    sd(i, be.dem, se),
                    Re,
                    it,
                    i.id,
                    ve.vertexBuffer,
                    ve.indexBuffer,
                    ve.segments
                  );
                }
              }
              const ra = [
                new s.P(0, 0),
                new s.P(s.a3, 0),
                new s.P(s.a3, s.a3),
                new s.P(0, s.a3),
              ];
              function ys(h, e, i, l, u, d, g, w, S = !1, k = !1) {
                const z = l[l.length - 1].overscaledZ,
                  V = h.context,
                  F = V.gl,
                  $ = h.useProgram("raster"),
                  J = h.transform,
                  ae = h.style.projection,
                  oe = h.colorModeForRenderPass(),
                  se = !h.options.moving,
                  fe = i.paint.get("raster-opacity"),
                  be = i.paint.get("raster-resampling"),
                  pe = i.paint.get("raster-fade-duration"),
                  we = !!h.style.map.terrain;
                for (const Pe of l) {
                  const ve = h.getDepthModeForSublayer(
                      Pe.overscaledZ - z,
                      fe === 1 ? ln.ReadWrite : ln.ReadOnly,
                      F.LESS
                    ),
                    Re = e.getTile(Pe),
                    it = be === "nearest" ? F.NEAREST : F.LINEAR;
                  V.activeTexture.set(F.TEXTURE0),
                    Re.texture.bind(
                      it,
                      F.CLAMP_TO_EDGE,
                      F.LINEAR_MIPMAP_NEAREST
                    ),
                    V.activeTexture.set(F.TEXTURE1);
                  const {
                    parentTile: Qe,
                    parentScaleBy: tt,
                    parentTopLeft: ot,
                    fadeValues: Zt,
                  } = Wl(Re, e, pe, we);
                  (Re.fadeOpacity = Zt.tileOpacity),
                    Qe
                      ? ((Qe.fadeOpacity = Zt.parentTileOpacity),
                        Qe.texture.bind(
                          it,
                          F.CLAMP_TO_EDGE,
                          F.LINEAR_MIPMAP_NEAREST
                        ))
                      : Re.texture.bind(
                          it,
                          F.CLAMP_TO_EDGE,
                          F.LINEAR_MIPMAP_NEAREST
                        ),
                    Re.texture.useMipmap &&
                      V.extTextureFilterAnisotropic &&
                      h.transform.pitch > 20 &&
                      F.texParameterf(
                        F.TEXTURE_2D,
                        V.extTextureFilterAnisotropic
                          .TEXTURE_MAX_ANISOTROPY_EXT,
                        V.extTextureFilterAnisotropicMax
                      );
                  const Ht =
                      h.style.map.terrain &&
                      h.style.map.terrain.getTerrainData(Pe),
                    Pt = J.getProjectionData({
                      overscaledTileID: Pe,
                      aligned: se,
                      applyGlobeMatrix: !k,
                      applyTerrainMatrix: !0,
                    }),
                    yr = ld(ot, tt, Zt.fadeMix, i, w),
                    tn = ae.getMeshFromTileID(V, Pe.canonical, d, g, "raster");
                  $.draw(
                    V,
                    F.TRIANGLES,
                    ve,
                    u ? u[Pe.overscaledZ] : xn.disabled,
                    oe,
                    S ? en.frontCCW : en.backCCW,
                    yr,
                    Ht,
                    Pt,
                    i.id,
                    tn.vertexBuffer,
                    tn.indexBuffer,
                    tn.segments
                  );
                }
              }
              function Wl(h, e, i, l) {
                const u = {
                  parentTile: null,
                  parentScaleBy: 1,
                  parentTopLeft: [0, 0],
                  fadeValues: {
                    tileOpacity: 1,
                    parentTileOpacity: 1,
                    fadeMix: { opacity: 1, mix: 0 },
                  },
                };
                if (i === 0 || l) return u;
                if (h.fadingParentID) {
                  const d = e.getLoadedTile(h.fadingParentID);
                  if (!d) return u;
                  const g = Math.pow(
                      2,
                      d.tileID.overscaledZ - h.tileID.overscaledZ
                    ),
                    w = [
                      (h.tileID.canonical.x * g) % 1,
                      (h.tileID.canonical.y * g) % 1,
                    ],
                    S = (function (k, z, V) {
                      const F = ne(),
                        $ = (F - z.timeAdded) / V,
                        J = k.fadingDirection === H.Incoming,
                        ae = s.ai((F - k.timeAdded) / V, 0, 1),
                        oe = s.ai(1 - $, 0, 1),
                        se = J ? ae : oe;
                      return {
                        tileOpacity: se,
                        parentTileOpacity: J ? oe : ae,
                        fadeMix: { opacity: 1, mix: 1 - se },
                      };
                    })(h, d, i);
                  return {
                    parentTile: d,
                    parentScaleBy: g,
                    parentTopLeft: w,
                    fadeValues: S,
                  };
                }
                if (h.selfFading) {
                  const d = (function (g, w) {
                    const S = (ne() - g.timeAdded) / w,
                      k = s.ai(S, 0, 1);
                    return { tileOpacity: k, fadeMix: { opacity: k, mix: 0 } };
                  })(h, i);
                  return {
                    parentTile: null,
                    parentScaleBy: 1,
                    parentTopLeft: [0, 0],
                    fadeValues: d,
                  };
                }
                return u;
              }
              const Sd = new s.bi(1, 0, 0, 1),
                xs = new s.bi(0, 1, 0, 1),
                su = new s.bi(0, 0, 1, 1),
                Js = new s.bi(1, 0, 1, 1),
                lu = new s.bi(0, 1, 1, 1);
              function cu(h, e, i, l) {
                Qs(h, 0, e + i / 2, h.transform.width, i, l);
              }
              function uu(h, e, i, l) {
                Qs(h, e - i / 2, 0, i, h.transform.height, l);
              }
              function Qs(h, e, i, l, u, d) {
                const g = h.context,
                  w = g.gl;
                w.enable(w.SCISSOR_TEST),
                  w.scissor(
                    e * h.pixelRatio,
                    i * h.pixelRatio,
                    l * h.pixelRatio,
                    u * h.pixelRatio
                  ),
                  g.clear({ color: d }),
                  w.disable(w.SCISSOR_TEST);
              }
              function Cd(h, e, i) {
                const l = h.context,
                  u = l.gl,
                  d = h.useProgram("debug"),
                  g = ln.disabled,
                  w = xn.disabled,
                  S = h.colorModeForRenderPass(),
                  k = "$debug",
                  z =
                    h.style.map.terrain &&
                    h.style.map.terrain.getTerrainData(i);
                l.activeTexture.set(u.TEXTURE0);
                const V = e.getTileByID(i.key).latestRawTileData,
                  F = Math.floor(((V && V.byteLength) || 0) / 1024),
                  $ = e.getTile(i).tileSize,
                  J =
                    (512 / Math.min($, 512)) *
                    (i.overscaledZ / h.transform.zoom) *
                    0.5;
                let ae = i.canonical.toString();
                i.overscaledZ !== i.canonical.z &&
                  (ae += ` => ${i.overscaledZ}`),
                  (function (se, fe) {
                    se.initDebugOverlayCanvas();
                    const be = se.debugOverlayCanvas,
                      pe = se.context.gl,
                      we = se.debugOverlayCanvas.getContext("2d");
                    we.clearRect(0, 0, be.width, be.height),
                      (we.shadowColor = "white"),
                      (we.shadowBlur = 2),
                      (we.lineWidth = 1.5),
                      (we.strokeStyle = "white"),
                      (we.textBaseline = "top"),
                      (we.font = "bold 36px Open Sans, sans-serif"),
                      we.fillText(fe, 5, 5),
                      we.strokeText(fe, 5, 5),
                      se.debugOverlayTexture.update(be),
                      se.debugOverlayTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE);
                  })(h, `${ae} ${F}kB`);
                const oe = h.transform.getProjectionData({
                  overscaledTileID: i,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0,
                });
                d.draw(
                  l,
                  u.TRIANGLES,
                  g,
                  w,
                  _n.alphaBlended,
                  en.disabled,
                  Zc(s.bi.transparent, J),
                  null,
                  oe,
                  k,
                  h.debugBuffer,
                  h.quadTriangleIndexBuffer,
                  h.debugSegments
                ),
                  d.draw(
                    l,
                    u.LINE_STRIP,
                    g,
                    w,
                    S,
                    en.disabled,
                    Zc(s.bi.red),
                    z,
                    oe,
                    k,
                    h.debugBuffer,
                    h.tileBorderIndexBuffer,
                    h.debugSegments
                  );
              }
              function hu(h, e, i, l) {
                const { isRenderingGlobe: u } = l,
                  d = h.context,
                  g = d.gl,
                  w = h.transform,
                  S = h.colorModeForRenderPass(),
                  k = h.getDepthModeFor3D(),
                  z = h.useProgram("terrain");
                d.bindFramebuffer.set(null),
                  d.viewport.set([0, 0, h.width, h.height]);
                for (const V of i) {
                  const F = e.getTerrainMesh(V.tileID),
                    $ = h.renderToTexture.getTexture(V),
                    J = e.getTerrainData(V.tileID);
                  d.activeTexture.set(g.TEXTURE0),
                    g.bindTexture(g.TEXTURE_2D, $.texture);
                  const ae = e.getMeshFrameDelta(w.zoom),
                    oe = w.calculateFogMatrix(V.tileID.toUnwrapped()),
                    se = nf(ae, oe, h.style.sky, w.pitch, u),
                    fe = w.getProjectionData({
                      overscaledTileID: V.tileID,
                      applyTerrainMatrix: !1,
                      applyGlobeMatrix: !0,
                    });
                  z.draw(
                    d,
                    g.TRIANGLES,
                    k,
                    xn.disabled,
                    S,
                    en.backCCW,
                    se,
                    J,
                    fe,
                    "terrain",
                    F.vertexBuffer,
                    F.indexBuffer,
                    F.segments
                  );
                }
              }
              function wo(h, e) {
                if (!e.mesh) {
                  const i = new s.aP();
                  i.emplaceBack(-1, -1),
                    i.emplaceBack(1, -1),
                    i.emplaceBack(1, 1),
                    i.emplaceBack(-1, 1);
                  const l = new s.aR();
                  l.emplaceBack(0, 1, 2),
                    l.emplaceBack(0, 2, 3),
                    (e.mesh = new Cn(
                      h.createVertexBuffer(i, Vn.members),
                      h.createIndexBuffer(l),
                      s.aQ.simpleSegment(0, 0, i.length, l.length)
                    ));
                }
                return e.mesh;
              }
              class Pd {
                constructor(e, i) {
                  (this.context = new jl(e)),
                    (this.transform = i),
                    (this._tileTextures = {}),
                    (this.terrainFacilitator = {
                      dirty: !0,
                      matrix: s.am(new Float64Array(16)),
                      renderTime: 0,
                    }),
                    this.setup(),
                    (this.numSublayers =
                      un.maxUnderzooming + un.maxOverzooming + 1),
                    (this.depthEpsilon = 1 / Math.pow(2, 16)),
                    (this.crossTileSymbolIndex = new dn());
                }
                resize(e, i, l) {
                  if (
                    ((this.width = Math.floor(e * l)),
                    (this.height = Math.floor(i * l)),
                    (this.pixelRatio = l),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.style)
                  )
                    for (const u of this.style._order)
                      this.style._layers[u].resize();
                }
                setup() {
                  const e = this.context,
                    i = new s.aP();
                  i.emplaceBack(0, 0),
                    i.emplaceBack(s.a3, 0),
                    i.emplaceBack(0, s.a3),
                    i.emplaceBack(s.a3, s.a3),
                    (this.tileExtentBuffer = e.createVertexBuffer(
                      i,
                      Vn.members
                    )),
                    (this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2));
                  const l = new s.aP();
                  l.emplaceBack(0, 0),
                    l.emplaceBack(s.a3, 0),
                    l.emplaceBack(0, s.a3),
                    l.emplaceBack(s.a3, s.a3),
                    (this.debugBuffer = e.createVertexBuffer(l, Vn.members)),
                    (this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5));
                  const u = new s.ca();
                  u.emplaceBack(0, 0, 0, 0),
                    u.emplaceBack(s.a3, 0, s.a3, 0),
                    u.emplaceBack(0, s.a3, 0, s.a3),
                    u.emplaceBack(s.a3, s.a3, s.a3, s.a3),
                    (this.rasterBoundsBuffer = e.createVertexBuffer(
                      u,
                      Vc.members
                    )),
                    (this.rasterBoundsSegments = s.aQ.simpleSegment(
                      0,
                      0,
                      4,
                      2
                    ));
                  const d = new s.aP();
                  d.emplaceBack(0, 0),
                    d.emplaceBack(s.a3, 0),
                    d.emplaceBack(0, s.a3),
                    d.emplaceBack(s.a3, s.a3),
                    (this.rasterBoundsBufferPosOnly = e.createVertexBuffer(
                      d,
                      Vn.members
                    )),
                    (this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(
                      0,
                      0,
                      4,
                      5
                    ));
                  const g = new s.aP();
                  g.emplaceBack(0, 0),
                    g.emplaceBack(1, 0),
                    g.emplaceBack(0, 1),
                    g.emplaceBack(1, 1),
                    (this.viewportBuffer = e.createVertexBuffer(g, Vn.members)),
                    (this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2));
                  const w = new s.cb();
                  w.emplaceBack(0),
                    w.emplaceBack(1),
                    w.emplaceBack(3),
                    w.emplaceBack(2),
                    w.emplaceBack(0),
                    (this.tileBorderIndexBuffer = e.createIndexBuffer(w));
                  const S = new s.aR();
                  S.emplaceBack(1, 0, 2),
                    S.emplaceBack(1, 2, 3),
                    (this.quadTriangleIndexBuffer = e.createIndexBuffer(S));
                  const k = this.context.gl;
                  (this.stencilClearMode = new xn(
                    { func: k.ALWAYS, mask: 0 },
                    0,
                    255,
                    k.ZERO,
                    k.ZERO,
                    k.ZERO
                  )),
                    (this.tileExtentMesh = new Cn(
                      this.tileExtentBuffer,
                      this.quadTriangleIndexBuffer,
                      this.tileExtentSegments
                    ));
                }
                clearStencil() {
                  const e = this.context,
                    i = e.gl;
                  (this.nextStencilID = 1),
                    (this.currentStencilSource = void 0);
                  const l = s.M();
                  s.c0(l, 0, this.width, this.height, 0, 0, 1),
                    s.O(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
                  const u = {
                    mainMatrix: l,
                    tileMercatorCoords: [0, 0, 1, 1],
                    clippingPlane: [0, 0, 0, 0],
                    projectionTransition: 0,
                    fallbackMatrix: l,
                  };
                  this.useProgram("clippingMask", null, !0).draw(
                    e,
                    i.TRIANGLES,
                    ln.disabled,
                    this.stencilClearMode,
                    _n.disabled,
                    en.disabled,
                    null,
                    null,
                    u,
                    "$clipping",
                    this.viewportBuffer,
                    this.quadTriangleIndexBuffer,
                    this.viewportSegments
                  );
                }
                _renderTileClippingMasks(e, i, l) {
                  if (
                    this.currentStencilSource === e.source ||
                    !e.isTileClipped() ||
                    !i ||
                    !i.length
                  )
                    return;
                  (this.currentStencilSource = e.source),
                    this.nextStencilID + i.length > 256 && this.clearStencil();
                  const u = this.context;
                  u.setColorMode(_n.disabled), u.setDepthMode(ln.disabled);
                  const d = {};
                  for (const g of i) d[g.key] = this.nextStencilID++;
                  this._renderTileMasks(d, i, l, !0),
                    this._renderTileMasks(d, i, l, !1),
                    (this._tileClippingMaskIDs = d);
                }
                _renderTileMasks(e, i, l, u) {
                  const d = this.context,
                    g = d.gl,
                    w = this.style.projection,
                    S = this.transform,
                    k = this.useProgram("clippingMask");
                  for (const z of i) {
                    const V = e[z.key],
                      F =
                        this.style.map.terrain &&
                        this.style.map.terrain.getTerrainData(z),
                      $ = w.getMeshFromTileID(
                        this.context,
                        z.canonical,
                        u,
                        !0,
                        "stencil"
                      ),
                      J = S.getProjectionData({
                        overscaledTileID: z,
                        applyGlobeMatrix: !l,
                        applyTerrainMatrix: !0,
                      });
                    k.draw(
                      d,
                      g.TRIANGLES,
                      ln.disabled,
                      new xn(
                        { func: g.ALWAYS, mask: 0 },
                        V,
                        255,
                        g.KEEP,
                        g.KEEP,
                        g.REPLACE
                      ),
                      _n.disabled,
                      l ? en.disabled : en.backCCW,
                      null,
                      F,
                      J,
                      "$clipping",
                      $.vertexBuffer,
                      $.indexBuffer,
                      $.segments
                    );
                  }
                }
                _renderTilesDepthBuffer() {
                  const e = this.context,
                    i = e.gl,
                    l = this.style.projection,
                    u = this.transform,
                    d = this.useProgram("depth"),
                    g = this.getDepthModeFor3D(),
                    w = Ur(u, { tileSize: u.tileSize });
                  for (const S of w) {
                    const k =
                        this.style.map.terrain &&
                        this.style.map.terrain.getTerrainData(S),
                      z = l.getMeshFromTileID(
                        this.context,
                        S.canonical,
                        !0,
                        !0,
                        "raster"
                      ),
                      V = u.getProjectionData({
                        overscaledTileID: S,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0,
                      });
                    d.draw(
                      e,
                      i.TRIANGLES,
                      g,
                      xn.disabled,
                      _n.disabled,
                      en.backCCW,
                      null,
                      k,
                      V,
                      "$clipping",
                      z.vertexBuffer,
                      z.indexBuffer,
                      z.segments
                    );
                  }
                }
                stencilModeFor3D() {
                  (this.currentStencilSource = void 0),
                    this.nextStencilID + 1 > 256 && this.clearStencil();
                  const e = this.nextStencilID++,
                    i = this.context.gl;
                  return new xn(
                    { func: i.NOTEQUAL, mask: 255 },
                    e,
                    255,
                    i.KEEP,
                    i.KEEP,
                    i.REPLACE
                  );
                }
                stencilModeForClipping(e) {
                  const i = this.context.gl;
                  return new xn(
                    { func: i.EQUAL, mask: 255 },
                    this._tileClippingMaskIDs[e.key],
                    0,
                    i.KEEP,
                    i.KEEP,
                    i.REPLACE
                  );
                }
                getStencilConfigForOverlapAndUpdateStencilID(e) {
                  const i = this.context.gl,
                    l = e.sort((g, w) => w.overscaledZ - g.overscaledZ),
                    u = l[l.length - 1].overscaledZ,
                    d = l[0].overscaledZ - u + 1;
                  if (d > 1) {
                    (this.currentStencilSource = void 0),
                      this.nextStencilID + d > 256 && this.clearStencil();
                    const g = {};
                    for (let w = 0; w < d; w++)
                      g[w + u] = new xn(
                        { func: i.GEQUAL, mask: 255 },
                        w + this.nextStencilID,
                        255,
                        i.KEEP,
                        i.KEEP,
                        i.REPLACE
                      );
                    return (this.nextStencilID += d), [g, l];
                  }
                  return [{ [u]: xn.disabled }, l];
                }
                stencilConfigForOverlapTwoPass(e) {
                  const i = this.context.gl,
                    l = e.sort((g, w) => w.overscaledZ - g.overscaledZ),
                    u = l[l.length - 1].overscaledZ,
                    d = l[0].overscaledZ - u + 1;
                  if ((this.clearStencil(), d > 1)) {
                    const g = {},
                      w = {};
                    for (let S = 0; S < d; S++)
                      (g[S + u] = new xn(
                        { func: i.GREATER, mask: 255 },
                        d + 1 + S,
                        255,
                        i.KEEP,
                        i.KEEP,
                        i.REPLACE
                      )),
                        (w[S + u] = new xn(
                          { func: i.GREATER, mask: 255 },
                          1 + S,
                          255,
                          i.KEEP,
                          i.KEEP,
                          i.REPLACE
                        ));
                    return (this.nextStencilID = 2 * d + 1), [g, w, l];
                  }
                  return (
                    (this.nextStencilID = 3),
                    [
                      {
                        [u]: new xn(
                          { func: i.GREATER, mask: 255 },
                          2,
                          255,
                          i.KEEP,
                          i.KEEP,
                          i.REPLACE
                        ),
                      },
                      {
                        [u]: new xn(
                          { func: i.GREATER, mask: 255 },
                          1,
                          255,
                          i.KEEP,
                          i.KEEP,
                          i.REPLACE
                        ),
                      },
                      l,
                    ]
                  );
                }
                colorModeForRenderPass() {
                  const e = this.context.gl;
                  return this._showOverdrawInspector
                    ? new _n(
                        [e.CONSTANT_COLOR, e.ONE],
                        new s.bi(0.125, 0.125, 0.125, 0),
                        [!0, !0, !0, !0]
                      )
                    : this.renderPass === "opaque"
                    ? _n.unblended
                    : _n.alphaBlended;
                }
                getDepthModeForSublayer(e, i, l) {
                  if (!this.opaquePassEnabledForLayer()) return ln.disabled;
                  const u =
                    1 -
                    ((1 + this.currentLayer) * this.numSublayers + e) *
                      this.depthEpsilon;
                  return new ln(l || this.context.gl.LEQUAL, i, [u, u]);
                }
                getDepthModeFor3D() {
                  return new ln(
                    this.context.gl.LEQUAL,
                    ln.ReadWrite,
                    this.depthRangeFor3D
                  );
                }
                opaquePassEnabledForLayer() {
                  return this.currentLayer < this.opaquePassCutoff;
                }
                render(e, i) {
                  var l, u;
                  (this.style = e),
                    (this.options = i),
                    (this.lineAtlas = e.lineAtlas),
                    (this.imageManager = e.imageManager),
                    (this.glyphManager = e.glyphManager),
                    (this.symbolFadeChange = e.placement.symbolFadeChange(
                      ne()
                    )),
                    this.imageManager.beginFrame();
                  const d = this.style._order,
                    g = this.style.tileManagers,
                    w = {},
                    S = {},
                    k = {},
                    z = {
                      isRenderingToTexture: !1,
                      isRenderingGlobe:
                        ((l = e.projection) === null || l === void 0
                          ? void 0
                          : l.transitionState) > 0,
                    };
                  for (const F in g) {
                    const $ = g[F];
                    $.used && $.prepare(this.context),
                      (w[F] = $.getVisibleCoordinates(!1)),
                      (S[F] = w[F].slice().reverse()),
                      (k[F] = $.getVisibleCoordinates(!0).reverse());
                  }
                  this.opaquePassCutoff = 1 / 0;
                  for (let F = 0; F < d.length; F++)
                    if (this.style._layers[d[F]].is3D()) {
                      this.opaquePassCutoff = F;
                      break;
                    }
                  this.maybeDrawDepthAndCoords(!1),
                    this.renderToTexture &&
                      (this.renderToTexture.prepareForRender(
                        this.style,
                        this.transform.zoom
                      ),
                      (this.opaquePassCutoff = 0)),
                    (this.renderPass = "offscreen");
                  for (const F of d) {
                    const $ = this.style._layers[F];
                    if (
                      !$.hasOffscreenPass() ||
                      $.isHidden(this.transform.zoom)
                    )
                      continue;
                    const J = S[$.source];
                    ($.type === "custom" || J.length) &&
                      this.renderLayer(this, g[$.source], $, J, z);
                  }
                  if (
                    ((u = this.style.projection) === null ||
                      u === void 0 ||
                      u.updateGPUdependent({
                        context: this.context,
                        useProgram: (F) => this.useProgram(F),
                      }),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.context.bindFramebuffer.set(null),
                    this.context.clear({
                      color: i.showOverdrawInspector
                        ? s.bi.black
                        : s.bi.transparent,
                      depth: 1,
                    }),
                    this.clearStencil(),
                    this.style.sky &&
                      (function (F, $) {
                        const J = F.context,
                          ae = J.gl,
                          oe = ((Pe, ve, Re) => {
                            const it = Math.cos(ve.rollInRadians),
                              Qe = Math.sin(ve.rollInRadians),
                              tt = Ze(ve),
                              ot = ve.getProjectionData({
                                overscaledTileID: null,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0,
                              }).projectionTransition;
                            return {
                              u_sky_color: Pe.properties.get("sky-color"),
                              u_horizon_color:
                                Pe.properties.get("horizon-color"),
                              u_horizon: [
                                (ve.width / 2 - tt * Qe) * Re,
                                (ve.height / 2 + tt * it) * Re,
                              ],
                              u_horizon_normal: [-Qe, it],
                              u_sky_horizon_blend:
                                ((Pe.properties.get("sky-horizon-blend") *
                                  ve.height) /
                                  2) *
                                Re,
                              u_sky_blend: ot,
                            };
                          })($, F.style.map.transform, F.pixelRatio),
                          se = new ln(ae.LEQUAL, ln.ReadWrite, [0, 1]),
                          fe = xn.disabled,
                          be = F.colorModeForRenderPass(),
                          pe = F.useProgram("sky"),
                          we = wo(J, $);
                        pe.draw(
                          J,
                          ae.TRIANGLES,
                          se,
                          fe,
                          be,
                          en.disabled,
                          oe,
                          null,
                          void 0,
                          "sky",
                          we.vertexBuffer,
                          we.indexBuffer,
                          we.segments
                        );
                      })(this, this.style.sky),
                    (this._showOverdrawInspector = i.showOverdrawInspector),
                    (this.depthRangeFor3D = [
                      0,
                      1 -
                        (e._order.length + 2) *
                          this.numSublayers *
                          this.depthEpsilon,
                    ]),
                    !this.renderToTexture)
                  )
                    for (
                      this.renderPass = "opaque",
                        this.currentLayer = d.length - 1;
                      this.currentLayer >= 0;
                      this.currentLayer--
                    ) {
                      const F = this.style._layers[d[this.currentLayer]],
                        $ = g[F.source],
                        J = w[F.source];
                      this._renderTileClippingMasks(F, J, !1),
                        this.renderLayer(this, $, F, J, z);
                    }
                  this.renderPass = "translucent";
                  let V = !1;
                  for (
                    this.currentLayer = 0;
                    this.currentLayer < d.length;
                    this.currentLayer++
                  ) {
                    const F = this.style._layers[d[this.currentLayer]],
                      $ = g[F.source];
                    if (
                      this.renderToTexture &&
                      this.renderToTexture.renderLayer(F, z)
                    )
                      continue;
                    this.opaquePassEnabledForLayer() ||
                      V ||
                      ((V = !0),
                      z.isRenderingGlobe &&
                        !this.style.map.terrain &&
                        this._renderTilesDepthBuffer());
                    const J = (F.type === "symbol" ? k : S)[F.source];
                    this._renderTileClippingMasks(
                      F,
                      w[F.source],
                      !!this.renderToTexture
                    ),
                      this.renderLayer(this, $, F, J, z);
                  }
                  if (
                    (z.isRenderingGlobe &&
                      (function (F, $, J) {
                        const ae = F.context,
                          oe = ae.gl,
                          se = F.useProgram("atmosphere"),
                          fe = new ln(oe.LEQUAL, ln.ReadOnly, [0, 1]),
                          be = F.transform,
                          pe = (function (ot, Zt) {
                            const Ht = ot.properties.get("position"),
                              Pt = [-Ht.x, -Ht.y, -Ht.z],
                              yr = s.am(new Float64Array(16));
                            return (
                              ot.properties.get("anchor") === "map" &&
                                (s.b9(yr, yr, Zt.rollInRadians),
                                s.ba(yr, yr, -Zt.pitchInRadians),
                                s.b9(yr, yr, Zt.bearingInRadians),
                                s.ba(yr, yr, (Zt.center.lat * Math.PI) / 180),
                                s.bC(yr, yr, (-Zt.center.lng * Math.PI) / 180)),
                              s.c9(Pt, Pt, yr),
                              Pt
                            );
                          })(J, F.transform),
                          we = be.getProjectionData({
                            overscaledTileID: null,
                            applyGlobeMatrix: !0,
                            applyTerrainMatrix: !0,
                          }),
                          Pe =
                            $.properties.get("atmosphere-blend") *
                            we.projectionTransition;
                        if (Pe === 0) return;
                        const ve = js(be.worldSize, be.center.lat),
                          Re = be.inverseProjectionMatrix,
                          it = new Float64Array(4);
                        (it[3] = 1),
                          s.aA(it, it, be.modelViewProjectionMatrix),
                          (it[0] /= it[3]),
                          (it[1] /= it[3]),
                          (it[2] /= it[3]),
                          (it[3] = 1),
                          s.aA(it, it, Re),
                          (it[0] /= it[3]),
                          (it[1] /= it[3]),
                          (it[2] /= it[3]),
                          (it[3] = 1);
                        const Qe = ((ot, Zt, Ht, Pt, yr) => ({
                            u_sun_pos: ot,
                            u_atmosphere_blend: Zt,
                            u_globe_position: Ht,
                            u_globe_radius: Pt,
                            u_inv_proj_matrix: yr,
                          }))(pe, Pe, [it[0], it[1], it[2]], ve, Re),
                          tt = wo(ae, $);
                        se.draw(
                          ae,
                          oe.TRIANGLES,
                          fe,
                          xn.disabled,
                          _n.alphaBlended,
                          en.disabled,
                          Qe,
                          null,
                          null,
                          "atmosphere",
                          tt.vertexBuffer,
                          tt.indexBuffer,
                          tt.segments
                        );
                      })(this, this.style.sky, this.style.light),
                    this.options.showTileBoundaries)
                  ) {
                    const F = (function ($, J) {
                      let ae = null;
                      const oe = Object.values($._layers).flatMap((pe) =>
                          pe.source && !pe.isHidden(J)
                            ? [$.tileManagers[pe.source]]
                            : []
                        ),
                        se = oe.filter(
                          (pe) => pe.getSource().type === "vector"
                        ),
                        fe = oe.filter(
                          (pe) => pe.getSource().type !== "vector"
                        ),
                        be = (pe) => {
                          (!ae ||
                            ae.getSource().maxzoom < pe.getSource().maxzoom) &&
                            (ae = pe);
                        };
                      return (
                        se.forEach((pe) => be(pe)),
                        ae || fe.forEach((pe) => be(pe)),
                        ae
                      );
                    })(this.style, this.transform.zoom);
                    F &&
                      (function ($, J, ae) {
                        for (let oe = 0; oe < ae.length; oe++) Cd($, J, ae[oe]);
                      })(this, F, F.getVisibleCoordinates());
                  }
                  this.options.showPadding &&
                    (function (F) {
                      const $ = F.transform.padding;
                      cu(F, F.transform.height - ($.top || 0), 3, Sd),
                        cu(F, $.bottom || 0, 3, xs),
                        uu(F, $.left || 0, 3, su),
                        uu(F, F.transform.width - ($.right || 0), 3, Js);
                      const J = F.transform.centerPoint;
                      (function (ae, oe, se, fe) {
                        Qs(ae, oe - 1, se - 10, 2, 20, fe),
                          Qs(ae, oe - 10, se - 1, 20, 2, fe);
                      })(F, J.x, F.transform.height - J.y, lu);
                    })(this),
                    this.context.setDefault();
                }
                maybeDrawDepthAndCoords(e) {
                  if (!this.style || !this.style.map || !this.style.map.terrain)
                    return;
                  const i = this.terrainFacilitator.matrix,
                    l = this.transform.modelViewProjectionMatrix;
                  let u = this.terrainFacilitator.dirty;
                  u || (u = e ? !s.cc(i, l) : !s.cd(i, l)),
                    u ||
                      (u = this.style.map.terrain.tileManager.anyTilesAfterTime(
                        this.terrainFacilitator.renderTime
                      )),
                    u &&
                      (s.ce(i, l),
                      (this.terrainFacilitator.renderTime = Date.now()),
                      (this.terrainFacilitator.dirty = !1),
                      (function (d, g) {
                        const w = d.context,
                          S = w.gl,
                          k = d.transform,
                          z = _n.unblended,
                          V = new ln(S.LEQUAL, ln.ReadWrite, [0, 1]),
                          F = g.tileManager.getRenderableTiles(),
                          $ = d.useProgram("terrainDepth");
                        w.bindFramebuffer.set(
                          g.getFramebuffer("depth").framebuffer
                        ),
                          w.viewport.set([
                            0,
                            0,
                            d.width / devicePixelRatio,
                            d.height / devicePixelRatio,
                          ]),
                          w.clear({ color: s.bi.transparent, depth: 1 });
                        for (const J of F) {
                          const ae = g.getTerrainMesh(J.tileID),
                            oe = g.getTerrainData(J.tileID),
                            se = k.getProjectionData({
                              overscaledTileID: J.tileID,
                              applyTerrainMatrix: !1,
                              applyGlobeMatrix: !0,
                            }),
                            fe = { u_ele_delta: g.getMeshFrameDelta(k.zoom) };
                          $.draw(
                            w,
                            S.TRIANGLES,
                            V,
                            xn.disabled,
                            z,
                            en.backCCW,
                            fe,
                            oe,
                            se,
                            "terrain",
                            ae.vertexBuffer,
                            ae.indexBuffer,
                            ae.segments
                          );
                        }
                        w.bindFramebuffer.set(null),
                          w.viewport.set([0, 0, d.width, d.height]);
                      })(this, this.style.map.terrain),
                      (function (d, g) {
                        const w = d.context,
                          S = w.gl,
                          k = d.transform,
                          z = _n.unblended,
                          V = new ln(S.LEQUAL, ln.ReadWrite, [0, 1]),
                          F = g.getCoordsTexture(),
                          $ = g.tileManager.getRenderableTiles(),
                          J = d.useProgram("terrainCoords");
                        w.bindFramebuffer.set(
                          g.getFramebuffer("coords").framebuffer
                        ),
                          w.viewport.set([
                            0,
                            0,
                            d.width / devicePixelRatio,
                            d.height / devicePixelRatio,
                          ]),
                          w.clear({ color: s.bi.transparent, depth: 1 }),
                          (g.coordsIndex = []);
                        for (const ae of $) {
                          const oe = g.getTerrainMesh(ae.tileID),
                            se = g.getTerrainData(ae.tileID);
                          w.activeTexture.set(S.TEXTURE0),
                            S.bindTexture(S.TEXTURE_2D, F.texture);
                          const fe = {
                              u_terrain_coords_id:
                                (255 - g.coordsIndex.length) / 255,
                              u_texture: 0,
                              u_ele_delta: g.getMeshFrameDelta(k.zoom),
                            },
                            be = k.getProjectionData({
                              overscaledTileID: ae.tileID,
                              applyTerrainMatrix: !1,
                              applyGlobeMatrix: !0,
                            });
                          J.draw(
                            w,
                            S.TRIANGLES,
                            V,
                            xn.disabled,
                            z,
                            en.backCCW,
                            fe,
                            se,
                            be,
                            "terrain",
                            oe.vertexBuffer,
                            oe.indexBuffer,
                            oe.segments
                          ),
                            g.coordsIndex.push(ae.tileID.key);
                        }
                        w.bindFramebuffer.set(null),
                          w.viewport.set([0, 0, d.width, d.height]);
                      })(this, this.style.map.terrain));
                }
                renderLayer(e, i, l, u, d) {
                  l.isHidden(this.transform.zoom) ||
                    ((l.type === "background" ||
                      l.type === "custom" ||
                      (u || []).length) &&
                      ((this.id = l.id),
                      s.cf(l)
                        ? (function (g, w, S, k, z, V) {
                            if (g.renderPass !== "translucent") return;
                            const { isRenderingToTexture: F } = V,
                              $ = xn.disabled,
                              J = g.colorModeForRenderPass();
                            (S._unevaluatedLayout.hasValue(
                              "text-variable-anchor"
                            ) ||
                              S._unevaluatedLayout.hasValue(
                                "text-variable-anchor-offset"
                              )) &&
                              (function (ae, oe, se, fe, be, pe, we, Pe, ve) {
                                const Re = oe.transform,
                                  it = oe.style.map.terrain,
                                  Qe = be === "map",
                                  tt = pe === "map";
                                for (const ot of ae) {
                                  const Zt = fe.getTile(ot),
                                    Ht = Zt.getBucket(se);
                                  if (
                                    !Ht ||
                                    !Ht.text ||
                                    !Ht.text.segments.get().length
                                  )
                                    continue;
                                  const Pt = s.ar(Ht.textSizeData, Re.zoom),
                                    yr = s.aG(Zt, 1, oe.transform.zoom),
                                    tn = Pn(Qe, oe.transform, yr),
                                    Ln =
                                      se.layout.get("icon-text-fit") !==
                                        "none" && Ht.hasIconData();
                                  if (Pt) {
                                    const cn = Math.pow(
                                        2,
                                        Re.zoom - Zt.tileID.overscaledZ
                                      ),
                                      Nn = it
                                        ? (ri, Un) =>
                                            it.getElevation(ot, ri, Un)
                                        : null;
                                    ql(
                                      Ht,
                                      Qe,
                                      tt,
                                      ve,
                                      Re,
                                      tn,
                                      cn,
                                      Pt,
                                      Ln,
                                      s.aH(Re, Zt, we, Pe),
                                      ot.toUnwrapped(),
                                      Nn
                                    );
                                  }
                                }
                              })(
                                k,
                                g,
                                S,
                                w,
                                S.layout.get("text-rotation-alignment"),
                                S.layout.get("text-pitch-alignment"),
                                S.paint.get("text-translate"),
                                S.paint.get("text-translate-anchor"),
                                z
                              ),
                              S.paint.get("icon-opacity").constantOr(1) !== 0 &&
                                Go(
                                  g,
                                  w,
                                  S,
                                  k,
                                  !1,
                                  S.paint.get("icon-translate"),
                                  S.paint.get("icon-translate-anchor"),
                                  S.layout.get("icon-rotation-alignment"),
                                  S.layout.get("icon-pitch-alignment"),
                                  S.layout.get("icon-keep-upright"),
                                  $,
                                  J,
                                  F
                                ),
                              S.paint.get("text-opacity").constantOr(1) !== 0 &&
                                Go(
                                  g,
                                  w,
                                  S,
                                  k,
                                  !0,
                                  S.paint.get("text-translate"),
                                  S.paint.get("text-translate-anchor"),
                                  S.layout.get("text-rotation-alignment"),
                                  S.layout.get("text-pitch-alignment"),
                                  S.layout.get("text-keep-upright"),
                                  $,
                                  J,
                                  F
                                ),
                              w.map.showCollisionBoxes &&
                                (Xs(g, w, S, k, !0), Xs(g, w, S, k, !1));
                          })(
                            e,
                            i,
                            l,
                            u,
                            this.style.placement.variableOffsets,
                            d
                          )
                        : s.cg(l)
                        ? (function (g, w, S, k, z) {
                            if (g.renderPass !== "translucent") return;
                            const { isRenderingToTexture: V } = z,
                              F = S.paint.get("circle-opacity"),
                              $ = S.paint.get("circle-stroke-width"),
                              J = S.paint.get("circle-stroke-opacity"),
                              ae = !S.layout
                                .get("circle-sort-key")
                                .isConstant();
                            if (
                              F.constantOr(1) === 0 &&
                              ($.constantOr(1) === 0 || J.constantOr(1) === 0)
                            )
                              return;
                            const oe = g.context,
                              se = oe.gl,
                              fe = g.transform,
                              be = g.getDepthModeForSublayer(0, ln.ReadOnly),
                              pe = xn.disabled,
                              we = g.colorModeForRenderPass(),
                              Pe = [],
                              ve = fe.getCircleRadiusCorrection();
                            for (let Re = 0; Re < k.length; Re++) {
                              const it = k[Re],
                                Qe = w.getTile(it),
                                tt = Qe.getBucket(S);
                              if (!tt) continue;
                              const ot = S.paint.get("circle-translate"),
                                Zt = S.paint.get("circle-translate-anchor"),
                                Ht = s.aH(fe, Qe, ot, Zt),
                                Pt = tt.programConfigurations.get(S.id),
                                yr = g.useProgram("circle", Pt),
                                tn = tt.layoutVertexBuffer,
                                Ln = tt.indexBuffer,
                                cn =
                                  g.style.map.terrain &&
                                  g.style.map.terrain.getTerrainData(it),
                                Nn = {
                                  programConfiguration: Pt,
                                  program: yr,
                                  layoutVertexBuffer: tn,
                                  indexBuffer: Ln,
                                  uniformValues: sf(g, Qe, S, Ht, ve),
                                  terrainData: cn,
                                  projectionData: fe.getProjectionData({
                                    overscaledTileID: it,
                                    applyGlobeMatrix: !V,
                                    applyTerrainMatrix: !0,
                                  }),
                                };
                              if (ae) {
                                const ri = tt.segments.get();
                                for (const Un of ri)
                                  Pe.push({
                                    segments: new s.aQ([Un]),
                                    sortKey: Un.sortKey,
                                    state: Nn,
                                  });
                              } else
                                Pe.push({
                                  segments: tt.segments,
                                  sortKey: 0,
                                  state: Nn,
                                });
                            }
                            ae && Pe.sort((Re, it) => Re.sortKey - it.sortKey);
                            for (const Re of Pe) {
                              const {
                                programConfiguration: it,
                                program: Qe,
                                layoutVertexBuffer: tt,
                                indexBuffer: ot,
                                uniformValues: Zt,
                                terrainData: Ht,
                                projectionData: Pt,
                              } = Re.state;
                              Qe.draw(
                                oe,
                                se.TRIANGLES,
                                be,
                                pe,
                                we,
                                en.backCCW,
                                Zt,
                                Ht,
                                Pt,
                                S.id,
                                tt,
                                ot,
                                Re.segments,
                                S.paint,
                                g.transform.zoom,
                                it
                              );
                            }
                          })(e, i, l, u, d)
                        : s.ch(l)
                        ? (function (g, w, S, k, z) {
                            if (S.paint.get("heatmap-opacity") === 0) return;
                            const V = g.context,
                              { isRenderingToTexture: F, isRenderingGlobe: $ } =
                                z;
                            if (g.style.map.terrain) {
                              for (const J of k) {
                                const ae = w.getTile(J);
                                w.hasRenderableParent(J) ||
                                  (g.renderPass === "offscreen"
                                    ? vf(g, ae, S, J, $)
                                    : g.renderPass === "translucent" &&
                                      Ys(g, S, J, F, $));
                              }
                              V.viewport.set([0, 0, g.width, g.height]);
                            } else
                              g.renderPass === "offscreen"
                                ? (function (J, ae, oe, se) {
                                    const fe = J.context,
                                      be = fe.gl,
                                      pe = J.transform,
                                      we = xn.disabled,
                                      Pe = new _n(
                                        [be.ONE, be.ONE],
                                        s.bi.transparent,
                                        [!0, !0, !0, !0]
                                      );
                                    (function (ve, Re, it) {
                                      const Qe = ve.gl;
                                      ve.activeTexture.set(Qe.TEXTURE1),
                                        ve.viewport.set([
                                          0,
                                          0,
                                          Re.width / 4,
                                          Re.height / 4,
                                        ]);
                                      let tt = it.heatmapFbos.get(s.c6);
                                      tt
                                        ? (Qe.bindTexture(
                                            Qe.TEXTURE_2D,
                                            tt.colorAttachment.get()
                                          ),
                                          ve.bindFramebuffer.set(
                                            tt.framebuffer
                                          ))
                                        : ((tt = xd(
                                            ve,
                                            Re.width / 4,
                                            Re.height / 4
                                          )),
                                          it.heatmapFbos.set(s.c6, tt));
                                    })(fe, J, oe),
                                      fe.clear({ color: s.bi.transparent });
                                    for (let ve = 0; ve < se.length; ve++) {
                                      const Re = se[ve];
                                      if (ae.hasRenderableParent(Re)) continue;
                                      const it = ae.getTile(Re),
                                        Qe = it.getBucket(oe);
                                      if (!Qe) continue;
                                      const tt = Qe.programConfigurations.get(
                                          oe.id
                                        ),
                                        ot = J.useProgram("heatmap", tt),
                                        Zt = pe.getProjectionData({
                                          overscaledTileID: Re,
                                          applyGlobeMatrix: !0,
                                          applyTerrainMatrix: !1,
                                        }),
                                        Ht = pe.getCircleRadiusCorrection();
                                      ot.draw(
                                        fe,
                                        be.TRIANGLES,
                                        ln.disabled,
                                        we,
                                        Pe,
                                        en.backCCW,
                                        Gc(
                                          it,
                                          pe.zoom,
                                          oe.paint.get("heatmap-intensity"),
                                          Ht
                                        ),
                                        null,
                                        Zt,
                                        oe.id,
                                        Qe.layoutVertexBuffer,
                                        Qe.indexBuffer,
                                        Qe.segments,
                                        oe.paint,
                                        pe.zoom,
                                        tt
                                      );
                                    }
                                    fe.viewport.set([0, 0, J.width, J.height]);
                                  })(g, w, S, k)
                                : g.renderPass === "translucent" &&
                                  (function (J, ae) {
                                    const oe = J.context,
                                      se = oe.gl;
                                    oe.setColorMode(J.colorModeForRenderPass());
                                    const fe = ae.heatmapFbos.get(s.c6);
                                    fe &&
                                      (oe.activeTexture.set(se.TEXTURE0),
                                      se.bindTexture(
                                        se.TEXTURE_2D,
                                        fe.colorAttachment.get()
                                      ),
                                      oe.activeTexture.set(se.TEXTURE1),
                                      au(oe, ae).bind(
                                        se.LINEAR,
                                        se.CLAMP_TO_EDGE
                                      ),
                                      J.useProgram("heatmapTexture").draw(
                                        oe,
                                        se.TRIANGLES,
                                        ln.disabled,
                                        xn.disabled,
                                        J.colorModeForRenderPass(),
                                        en.disabled,
                                        $c(J, ae, 0, 1),
                                        null,
                                        null,
                                        ae.id,
                                        J.viewportBuffer,
                                        J.quadTriangleIndexBuffer,
                                        J.viewportSegments,
                                        ae.paint,
                                        J.transform.zoom
                                      ));
                                  })(g, S);
                          })(e, i, l, u, d)
                        : s.ci(l)
                        ? (function (g, w, S, k, z) {
                            if (g.renderPass !== "translucent") return;
                            const { isRenderingToTexture: V } = z,
                              F = S.paint.get("line-opacity"),
                              $ = S.paint.get("line-width");
                            if (F.constantOr(1) === 0 || $.constantOr(1) === 0)
                              return;
                            const J = g.getDepthModeForSublayer(0, ln.ReadOnly),
                              ae = g.colorModeForRenderPass(),
                              oe = S.paint.get("line-dasharray"),
                              se = oe.constantOr(1),
                              fe = S.paint.get("line-pattern"),
                              be = fe.constantOr(1),
                              pe = S.paint.get("line-gradient"),
                              we = S.getCrossfadeParameters();
                            let Pe;
                            Pe = be
                              ? "linePattern"
                              : se && pe
                              ? "lineGradientSDF"
                              : se
                              ? "lineSDF"
                              : pe
                              ? "lineGradient"
                              : "line";
                            const ve = g.context,
                              Re = ve.gl,
                              it = g.transform;
                            let Qe = !0;
                            for (const tt of k) {
                              const ot = w.getTile(tt);
                              if (be && !ot.patternsLoaded()) continue;
                              const Zt = ot.getBucket(S);
                              if (!Zt) continue;
                              const Ht = Zt.programConfigurations.get(S.id),
                                Pt = g.context.program.get(),
                                yr = g.useProgram(Pe, Ht),
                                tn = Qe || yr.program !== Pt,
                                Ln =
                                  g.style.map.terrain &&
                                  g.style.map.terrain.getTerrainData(tt),
                                cn = fe.constantOr(null),
                                Nn = oe && oe.constantOr(null);
                              if (cn && ot.imageAtlas) {
                                const Ii = ot.imageAtlas,
                                  Jn = Ii.patternPositions[cn.to.toString()],
                                  fi = Ii.patternPositions[cn.from.toString()];
                                Jn &&
                                  fi &&
                                  Ht.setConstantPatternPositions(Jn, fi);
                              } else if (Nn) {
                                const Ii = S.layout.get("line-cap") === "round",
                                  Jn = g.lineAtlas.getDash(Nn.to, Ii),
                                  fi = g.lineAtlas.getDash(Nn.from, Ii);
                                Ht.setConstantDashPositions(Jn, fi);
                              }
                              const ri = it.getProjectionData({
                                  overscaledTileID: tt,
                                  applyGlobeMatrix: !V,
                                  applyTerrainMatrix: !0,
                                }),
                                Un = it.getPixelScale();
                              let gi;
                              be
                                ? ((gi = kl(g, ot, S, Un, we)),
                                  ou(ve, Re, ot, Ht, we))
                                : se && pe
                                ? ((gi = uf(
                                    g,
                                    ot,
                                    S,
                                    Un,
                                    we,
                                    Zt.lineClipsArray.length
                                  )),
                                  Gl(g, w, ve, Re, S, Zt, tt, Ht, we))
                                : se
                                ? ((gi = cf(g, ot, S, Un, we)),
                                  bd(g, ve, Re, Ht, tn, we))
                                : pe
                                ? ((gi = lf(
                                    g,
                                    ot,
                                    S,
                                    Un,
                                    Zt.lineClipsArray.length
                                  )),
                                  wd(g, w, ve, Re, S, Zt, tt))
                                : (gi = bo(g, ot, S, Un));
                              const Kn = g.stencilModeForClipping(tt);
                              yr.draw(
                                ve,
                                Re.TRIANGLES,
                                J,
                                Kn,
                                ae,
                                en.disabled,
                                gi,
                                Ln,
                                ri,
                                S.id,
                                Zt.layoutVertexBuffer,
                                Zt.indexBuffer,
                                Zt.segments,
                                S.paint,
                                g.transform.zoom,
                                Ht,
                                Zt.layoutVertexBuffer2
                              ),
                                (Qe = !1);
                            }
                          })(e, i, l, u, d)
                        : s.cj(l)
                        ? (function (g, w, S, k, z) {
                            const V = S.paint.get("fill-color"),
                              F = S.paint.get("fill-opacity");
                            if (F.constantOr(1) === 0) return;
                            const { isRenderingToTexture: $ } = z,
                              J = g.colorModeForRenderPass(),
                              ae = S.paint.get("fill-pattern"),
                              oe =
                                g.opaquePassEnabledForLayer() &&
                                !ae.constantOr(1) &&
                                V.constantOr(s.bi.transparent).a === 1 &&
                                F.constantOr(0) === 1
                                  ? "opaque"
                                  : "translucent";
                            if (g.renderPass === oe) {
                              const se = g.getDepthModeForSublayer(
                                1,
                                g.renderPass === "opaque"
                                  ? ln.ReadWrite
                                  : ln.ReadOnly
                              );
                              Td(g, w, S, k, se, J, !1, $);
                            }
                            if (
                              g.renderPass === "translucent" &&
                              S.paint.get("fill-antialias")
                            ) {
                              const se = g.getDepthModeForSublayer(
                                S.getPaintProperty("fill-outline-color")
                                  ? 2
                                  : 0,
                                ln.ReadOnly
                              );
                              Td(g, w, S, k, se, J, !0, $);
                            }
                          })(e, i, l, u, d)
                        : s.ck(l)
                        ? (function (g, w, S, k, z) {
                            const V = S.paint.get("fill-extrusion-opacity");
                            if (V === 0) return;
                            const { isRenderingToTexture: F } = z;
                            if (g.renderPass === "translucent") {
                              const $ = new ln(
                                g.context.gl.LEQUAL,
                                ln.ReadWrite,
                                g.depthRangeFor3D
                              );
                              if (
                                V !== 1 ||
                                S.paint
                                  .get("fill-extrusion-pattern")
                                  .constantOr(1)
                              )
                                Hl(g, w, S, k, $, xn.disabled, _n.disabled, F),
                                  Hl(
                                    g,
                                    w,
                                    S,
                                    k,
                                    $,
                                    g.stencilModeFor3D(),
                                    g.colorModeForRenderPass(),
                                    F
                                  );
                              else {
                                const J = g.colorModeForRenderPass();
                                Hl(g, w, S, k, $, xn.disabled, J, F);
                              }
                            }
                          })(e, i, l, u, d)
                        : s.cl(l)
                        ? (function (g, w, S, k, z) {
                            if (
                              g.renderPass !== "offscreen" &&
                              g.renderPass !== "translucent"
                            )
                              return;
                            const { isRenderingToTexture: V } = z,
                              F = g.context,
                              $ = g.style.projection.useSubdivision,
                              J = g.getDepthModeForSublayer(0, ln.ReadOnly),
                              ae = g.colorModeForRenderPass();
                            if (g.renderPass === "offscreen")
                              (function (oe, se, fe, be, pe, we, Pe) {
                                const ve = oe.context,
                                  Re = ve.gl;
                                for (const it of fe) {
                                  const Qe = se.getTile(it),
                                    tt = Qe.dem;
                                  if (
                                    !tt ||
                                    !tt.data ||
                                    !Qe.needsHillshadePrepare
                                  )
                                    continue;
                                  const ot = tt.dim,
                                    Zt = tt.stride,
                                    Ht = tt.getPixels();
                                  if (
                                    (ve.activeTexture.set(Re.TEXTURE1),
                                    ve.pixelStoreUnpackPremultiplyAlpha.set(!1),
                                    (Qe.demTexture =
                                      Qe.demTexture || oe.getTileTexture(Zt)),
                                    Qe.demTexture)
                                  ) {
                                    const yr = Qe.demTexture;
                                    yr.update(Ht, { premultiply: !1 }),
                                      yr.bind(Re.NEAREST, Re.CLAMP_TO_EDGE);
                                  } else
                                    (Qe.demTexture = new s.T(ve, Ht, Re.RGBA, {
                                      premultiply: !1,
                                    })),
                                      Qe.demTexture.bind(
                                        Re.NEAREST,
                                        Re.CLAMP_TO_EDGE
                                      );
                                  ve.activeTexture.set(Re.TEXTURE0);
                                  let Pt = Qe.fbo;
                                  if (!Pt) {
                                    const yr = new s.T(
                                      ve,
                                      { width: ot, height: ot, data: null },
                                      Re.RGBA
                                    );
                                    yr.bind(Re.LINEAR, Re.CLAMP_TO_EDGE),
                                      (Pt = Qe.fbo =
                                        ve.createFramebuffer(ot, ot, !0, !1)),
                                      Pt.colorAttachment.set(yr.texture);
                                  }
                                  ve.bindFramebuffer.set(Pt.framebuffer),
                                    ve.viewport.set([0, 0, ot, ot]),
                                    oe
                                      .useProgram("hillshadePrepare")
                                      .draw(
                                        ve,
                                        Re.TRIANGLES,
                                        pe,
                                        we,
                                        Pe,
                                        en.disabled,
                                        No(Qe.tileID, tt),
                                        null,
                                        null,
                                        be.id,
                                        oe.rasterBoundsBuffer,
                                        oe.quadTriangleIndexBuffer,
                                        oe.rasterBoundsSegments
                                      ),
                                    (Qe.needsHillshadePrepare = !1);
                                }
                              })(g, w, k, S, J, xn.disabled, ae),
                                F.viewport.set([0, 0, g.width, g.height]);
                            else if (g.renderPass === "translucent")
                              if ($) {
                                const [oe, se, fe] =
                                  g.stencilConfigForOverlapTwoPass(k);
                                ei(g, w, S, fe, oe, J, ae, !1, V),
                                  ei(g, w, S, fe, se, J, ae, !0, V);
                              } else {
                                const [oe, se] =
                                  g.getStencilConfigForOverlapAndUpdateStencilID(
                                    k
                                  );
                                ei(g, w, S, se, oe, J, ae, !1, V);
                              }
                          })(e, i, l, u, d)
                        : s.cm(l)
                        ? (function (g, w, S, k, z) {
                            if (g.renderPass !== "translucent" || !k.length)
                              return;
                            const { isRenderingToTexture: V } = z,
                              F = g.style.projection.useSubdivision,
                              $ = g.getDepthModeForSublayer(0, ln.ReadOnly),
                              J = g.colorModeForRenderPass();
                            if (F) {
                              const [ae, oe, se] =
                                g.stencilConfigForOverlapTwoPass(k);
                              eo(g, w, S, se, ae, $, J, !1, V),
                                eo(g, w, S, se, oe, $, J, !0, V);
                            } else {
                              const [ae, oe] =
                                g.getStencilConfigForOverlapAndUpdateStencilID(
                                  k
                                );
                              eo(g, w, S, oe, ae, $, J, !1, V);
                            }
                          })(e, i, l, u, d)
                        : s.bN(l)
                        ? (function (g, w, S, k, z) {
                            if (
                              g.renderPass !== "translucent" ||
                              S.paint.get("raster-opacity") === 0 ||
                              !k.length
                            )
                              return;
                            const { isRenderingToTexture: V } = z,
                              F = w.getSource(),
                              $ = g.style.projection.useSubdivision;
                            if (F instanceof ar)
                              ys(
                                g,
                                w,
                                S,
                                k,
                                null,
                                !1,
                                !1,
                                F.tileCoords,
                                F.flippedWindingOrder,
                                V
                              );
                            else if ($) {
                              const [J, ae, oe] =
                                g.stencilConfigForOverlapTwoPass(k);
                              ys(g, w, S, oe, J, !1, !0, ra, !1, V),
                                ys(g, w, S, oe, ae, !0, !0, ra, !1, V);
                            } else {
                              const [J, ae] =
                                g.getStencilConfigForOverlapAndUpdateStencilID(
                                  k
                                );
                              ys(g, w, S, ae, J, !1, !0, ra, !1, V);
                            }
                          })(e, i, l, u, d)
                        : s.cn(l)
                        ? (function (g, w, S, k, z) {
                            const V = S.paint.get("background-color"),
                              F = S.paint.get("background-opacity");
                            if (F === 0) return;
                            const { isRenderingToTexture: $ } = z,
                              J = g.context,
                              ae = J.gl,
                              oe = g.style.projection,
                              se = g.transform,
                              fe = se.tileSize,
                              be = S.paint.get("background-pattern");
                            if (g.isPatternMissing(be)) return;
                            const pe =
                              !be &&
                              V.a === 1 &&
                              F === 1 &&
                              g.opaquePassEnabledForLayer()
                                ? "opaque"
                                : "translucent";
                            if (g.renderPass !== pe) return;
                            const we = xn.disabled,
                              Pe = g.getDepthModeForSublayer(
                                0,
                                pe === "opaque" ? ln.ReadWrite : ln.ReadOnly
                              ),
                              ve = g.colorModeForRenderPass(),
                              Re = g.useProgram(
                                be ? "backgroundPattern" : "background"
                              ),
                              it =
                                k ||
                                Ur(se, {
                                  tileSize: fe,
                                  terrain: g.style.map.terrain,
                                });
                            be &&
                              (J.activeTexture.set(ae.TEXTURE0),
                              g.imageManager.bind(g.context));
                            const Qe = S.getCrossfadeParameters();
                            for (const tt of it) {
                              const ot = se.getProjectionData({
                                  overscaledTileID: tt,
                                  applyGlobeMatrix: !$,
                                  applyTerrainMatrix: !0,
                                }),
                                Zt = be
                                  ? Kc(
                                      F,
                                      g,
                                      be,
                                      { tileID: tt, tileSize: fe },
                                      Qe
                                    )
                                  : Yc(F, V),
                                Ht =
                                  g.style.map.terrain &&
                                  g.style.map.terrain.getTerrainData(tt),
                                Pt = oe.getMeshFromTileID(
                                  J,
                                  tt.canonical,
                                  !1,
                                  !0,
                                  "raster"
                                );
                              Re.draw(
                                J,
                                ae.TRIANGLES,
                                Pe,
                                we,
                                ve,
                                en.backCCW,
                                Zt,
                                Ht,
                                ot,
                                S.id,
                                Pt.vertexBuffer,
                                Pt.indexBuffer,
                                Pt.segments
                              );
                            }
                          })(e, 0, l, u, d)
                        : s.co(l) &&
                          (function (g, w, S, k) {
                            const { isRenderingGlobe: z } = k,
                              V = g.context,
                              F = S.implementation,
                              $ = g.style.projection,
                              J = g.transform,
                              ae = J.getProjectionDataForCustomLayer(z),
                              oe = {
                                farZ: J.farZ,
                                nearZ: J.nearZ,
                                fov: (J.fov * Math.PI) / 180,
                                modelViewProjectionMatrix:
                                  J.modelViewProjectionMatrix,
                                projectionMatrix: J.projectionMatrix,
                                shaderData: {
                                  variantName: $.shaderVariantName,
                                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${$.shaderPreludeCode.vertexSource}`,
                                  define: $.shaderDefine,
                                },
                                defaultProjectionData: ae,
                              },
                              se = F.renderingMode ? F.renderingMode : "2d";
                            if (g.renderPass === "offscreen") {
                              const fe = F.prerender;
                              fe &&
                                (g.setCustomLayerDefaults(),
                                V.setColorMode(g.colorModeForRenderPass()),
                                fe.call(F, V.gl, oe),
                                V.setDirty(),
                                g.setBaseState());
                            } else if (g.renderPass === "translucent") {
                              g.setCustomLayerDefaults(),
                                V.setColorMode(g.colorModeForRenderPass()),
                                V.setStencilMode(xn.disabled);
                              const fe =
                                se === "3d"
                                  ? g.getDepthModeFor3D()
                                  : g.getDepthModeForSublayer(0, ln.ReadOnly);
                              V.setDepthMode(fe),
                                F.render(V.gl, oe),
                                V.setDirty(),
                                g.setBaseState(),
                                V.bindFramebuffer.set(null);
                            }
                          })(e, 0, l, d)));
                }
                saveTileTexture(e) {
                  const i = this._tileTextures[e.size[0]];
                  i ? i.push(e) : (this._tileTextures[e.size[0]] = [e]);
                }
                getTileTexture(e) {
                  const i = this._tileTextures[e];
                  return i && i.length > 0 ? i.pop() : null;
                }
                isPatternMissing(e) {
                  if (!e) return !1;
                  if (!e.from || !e.to) return !0;
                  const i = this.imageManager.getPattern(e.from.toString()),
                    l = this.imageManager.getPattern(e.to.toString());
                  return !i || !l;
                }
                useProgram(e, i, l = !1, u = []) {
                  this.cache = this.cache || {};
                  const d = !!this.style.map.terrain,
                    g = this.style.projection,
                    w = l ? Cr.projectionMercator : g.shaderPreludeCode,
                    S = l ? kn : g.shaderDefine,
                    k =
                      e +
                      (i ? i.cacheKey : "") +
                      `/${l ? Sn : g.shaderVariantName}` +
                      (this._showOverdrawInspector ? "/overdraw" : "") +
                      (d ? "/terrain" : "") +
                      (u ? `/${u.join("/")}` : "");
                  return (
                    this.cache[k] ||
                      (this.cache[k] = new Zs(
                        this.context,
                        Cr[e],
                        i,
                        cd[e],
                        this._showOverdrawInspector,
                        d,
                        w,
                        S,
                        u
                      )),
                    this.cache[k]
                  );
                }
                setCustomLayerDefaults() {
                  this.context.unbindVAO(),
                    this.context.cullFace.setDefault(),
                    this.context.activeTexture.setDefault(),
                    this.context.pixelStoreUnpack.setDefault(),
                    this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.context.pixelStoreUnpackFlipY.setDefault();
                }
                setBaseState() {
                  const e = this.context.gl;
                  this.context.cullFace.set(!1),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.context.blendEquation.set(e.FUNC_ADD);
                }
                initDebugOverlayCanvas() {
                  this.debugOverlayCanvas == null &&
                    ((this.debugOverlayCanvas =
                      document.createElement("canvas")),
                    (this.debugOverlayCanvas.width = 512),
                    (this.debugOverlayCanvas.height = 512),
                    (this.debugOverlayTexture = new s.T(
                      this.context,
                      this.debugOverlayCanvas,
                      this.context.gl.RGBA
                    )));
                }
                destroy() {
                  this.debugOverlayTexture &&
                    this.debugOverlayTexture.destroy();
                }
                overLimit() {
                  const { drawingBufferWidth: e, drawingBufferHeight: i } =
                    this.context.gl;
                  return this.width !== e || this.height !== i;
                }
              }
              function du(h, e) {
                let i,
                  l = !1,
                  u = null,
                  d = null;
                const g = () => {
                  (u = null),
                    l && (h.apply(d, i), (u = setTimeout(g, e)), (l = !1));
                };
                return (...w) => ((l = !0), (d = this), (i = w), u || g(), u);
              }
              class pu {
                constructor(e) {
                  (this._getCurrentHash = () => {
                    const i = window.location.hash.replace("#", "");
                    if (this._hashName) {
                      let l;
                      return (
                        i
                          .split("&")
                          .map((u) => u.split("="))
                          .forEach((u) => {
                            u[0] === this._hashName && (l = u);
                          }),
                        ((l && l[1]) || "").split("/")
                      );
                    }
                    return i.split("/");
                  }),
                    (this._onHashChange = () => {
                      const i = this._getCurrentHash();
                      if (!this._isValidHash(i)) return !1;
                      const l =
                        this._map.dragRotate.isEnabled() &&
                        this._map.touchZoomRotate.isEnabled()
                          ? +(i[3] || 0)
                          : this._map.getBearing();
                      return (
                        this._map.jumpTo({
                          center: [+i[2], +i[1]],
                          zoom: +i[0],
                          bearing: l,
                          pitch: +(i[4] || 0),
                        }),
                        !0
                      );
                    }),
                    (this._updateHashUnthrottled = () => {
                      const i = window.location.href.replace(
                        /(#.*)?$/,
                        this.getHashString()
                      );
                      window.history.replaceState(
                        window.history.state,
                        null,
                        i
                      );
                    }),
                    (this._removeHash = () => {
                      const i = this._getCurrentHash();
                      if (i.length === 0) return;
                      const l = i.join("/");
                      let u = l;
                      u.split("&").length > 0 && (u = u.split("&")[0]),
                        this._hashName && (u = `${this._hashName}=${l}`);
                      let d = window.location.hash.replace(u, "");
                      d.startsWith("#&")
                        ? (d = d.slice(0, 1) + d.slice(2))
                        : d === "#" && (d = "");
                      let g = window.location.href.replace(/(#.+)?$/, d);
                      (g = g.replace("&&", "&")),
                        window.history.replaceState(
                          window.history.state,
                          null,
                          g
                        );
                    }),
                    (this._updateHash = du(this._updateHashUnthrottled, 300)),
                    (this._hashName = e && encodeURIComponent(e));
                }
                addTo(e) {
                  return (
                    (this._map = e),
                    addEventListener("hashchange", this._onHashChange, !1),
                    this._map.on("moveend", this._updateHash),
                    this
                  );
                }
                remove() {
                  return (
                    removeEventListener("hashchange", this._onHashChange, !1),
                    this._map.off("moveend", this._updateHash),
                    clearTimeout(this._updateHash()),
                    this._removeHash(),
                    delete this._map,
                    this
                  );
                }
                getHashString(e) {
                  const i = this._map.getCenter(),
                    l = Math.round(100 * this._map.getZoom()) / 100,
                    u = Math.ceil(
                      (l * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
                    ),
                    d = Math.pow(10, u),
                    g = Math.round(i.lng * d) / d,
                    w = Math.round(i.lat * d) / d,
                    S = this._map.getBearing(),
                    k = this._map.getPitch();
                  let z = "";
                  if (
                    ((z += e ? `/${g}/${w}/${l}` : `${l}/${w}/${g}`),
                    (S || k) && (z += "/" + Math.round(10 * S) / 10),
                    k && (z += `/${Math.round(k)}`),
                    this._hashName)
                  ) {
                    const V = this._hashName;
                    let F = !1;
                    const $ = window.location.hash
                      .slice(1)
                      .split("&")
                      .map((J) => {
                        const ae = J.split("=")[0];
                        return ae === V ? ((F = !0), `${ae}=${z}`) : J;
                      })
                      .filter((J) => J);
                    return F || $.push(`${V}=${z}`), `#${$.join("&")}`;
                  }
                  return `#${z}`;
                }
                _isValidHash(e) {
                  if (e.length < 3 || e.some(isNaN)) return !1;
                  try {
                    new s.U(+e[2], +e[1]);
                  } catch {
                    return !1;
                  }
                  const i = +e[0],
                    l = +(e[3] || 0),
                    u = +(e[4] || 0);
                  return (
                    i >= this._map.getMinZoom() &&
                    i <= this._map.getMaxZoom() &&
                    l >= -180 &&
                    l <= 180 &&
                    u >= this._map.getMinPitch() &&
                    u <= this._map.getMaxPitch()
                  );
                }
              }
              const bs = { linearity: 0.3, easing: s.cp(0, 0, 0.3, 1) },
                Id = s.e({ deceleration: 2500, maxSpeed: 1400 }, bs),
                Md = s.e({ deceleration: 20, maxSpeed: 1400 }, bs),
                Ad = s.e({ deceleration: 1e3, maxSpeed: 360 }, bs),
                kd = s.e({ deceleration: 1e3, maxSpeed: 90 }, bs),
                Xl = s.e({ deceleration: 1e3, maxSpeed: 360 }, bs);
              class Ed {
                constructor(e) {
                  (this._map = e), this.clear();
                }
                clear() {
                  this._inertiaBuffer = [];
                }
                record(e) {
                  this._drainInertiaBuffer(),
                    this._inertiaBuffer.push({ time: ne(), settings: e });
                }
                _drainInertiaBuffer() {
                  const e = this._inertiaBuffer,
                    i = ne();
                  for (; e.length > 0 && i - e[0].time > 160; ) e.shift();
                }
                _onMoveEnd(e) {
                  if (
                    (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                  )
                    return;
                  const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    roll: 0,
                    pan: new s.P(0, 0),
                    pinchAround: void 0,
                    around: void 0,
                  };
                  for (const { settings: d } of this._inertiaBuffer)
                    (i.zoom += d.zoomDelta || 0),
                      (i.bearing += d.bearingDelta || 0),
                      (i.pitch += d.pitchDelta || 0),
                      (i.roll += d.rollDelta || 0),
                      d.panDelta && i.pan._add(d.panDelta),
                      d.around && (i.around = d.around),
                      d.pinchAround && (i.pinchAround = d.pinchAround);
                  const l =
                      this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                      this._inertiaBuffer[0].time,
                    u = {};
                  if (i.pan.mag()) {
                    const d = Wi(i.pan.mag(), l, s.e({}, Id, e || {})),
                      g = i.pan.mult(d.amount / i.pan.mag()),
                      w = this._map.cameraHelper.handlePanInertia(
                        g,
                        this._map.transform
                      );
                    (u.center = w.easingCenter),
                      (u.offset = w.easingOffset),
                      qi(u, d);
                  }
                  if (i.zoom) {
                    const d = Wi(i.zoom, l, Md);
                    (u.zoom = this._map.transform.zoom + d.amount), qi(u, d);
                  }
                  if (i.bearing) {
                    const d = Wi(i.bearing, l, Ad);
                    (u.bearing =
                      this._map.transform.bearing + s.ai(d.amount, -179, 179)),
                      qi(u, d);
                  }
                  if (i.pitch) {
                    const d = Wi(i.pitch, l, kd);
                    (u.pitch = this._map.transform.pitch + d.amount), qi(u, d);
                  }
                  if (i.roll) {
                    const d = Wi(i.roll, l, Xl);
                    (u.roll =
                      this._map.transform.roll + s.ai(d.amount, -179, 179)),
                      qi(u, d);
                  }
                  if (u.zoom || u.bearing) {
                    const d =
                      i.pinchAround === void 0 ? i.around : i.pinchAround;
                    u.around = d
                      ? this._map.unproject(d)
                      : this._map.getCenter();
                  }
                  return this.clear(), s.e(u, { noMoveStart: !0 });
                }
              }
              function qi(h, e) {
                (!h.duration || h.duration < e.duration) &&
                  ((h.duration = e.duration), (h.easing = e.easing));
              }
              function Wi(h, e, i) {
                const { maxSpeed: l, linearity: u, deceleration: d } = i,
                  g = s.ai((h * u) / (e / 1e3), -l, l),
                  w = Math.abs(g) / (d * u);
                return {
                  easing: i.easing,
                  duration: 1e3 * w,
                  amount: g * (w / 2),
                };
              }
              class na extends s.l {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(e, i, l, u = {}) {
                  l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
                  const d = Y.mousePos(i.getCanvas(), l),
                    g = i.unproject(d);
                  super(e, s.e({ point: d, lngLat: g, originalEvent: l }, u)),
                    (this._defaultPrevented = !1),
                    (this.target = i);
                }
              }
              class Xi extends s.l {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(e, i, l) {
                  const u = e === "touchend" ? l.changedTouches : l.touches,
                    d = Y.touchPos(i.getCanvasContainer(), u),
                    g = d.map((S) => i.unproject(S)),
                    w = d.reduce(
                      (S, k, z, V) => S.add(k.div(V.length)),
                      new s.P(0, 0)
                    );
                  super(e, {
                    points: d,
                    point: w,
                    lngLats: g,
                    lngLat: i.unproject(w),
                    originalEvent: l,
                  }),
                    (this._defaultPrevented = !1);
                }
              }
              class zd extends s.l {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(e, i, l) {
                  super(e, { originalEvent: l }), (this._defaultPrevented = !1);
                }
              }
              class ws {
                constructor(e, i) {
                  (this._map = e), (this._clickTolerance = i.clickTolerance);
                }
                reset() {
                  delete this._mousedownPos;
                }
                wheel(e) {
                  return this._firePreventable(new zd(e.type, this._map, e));
                }
                mousedown(e, i) {
                  return (
                    (this._mousedownPos = i),
                    this._firePreventable(new na(e.type, this._map, e))
                  );
                }
                mouseup(e) {
                  this._map.fire(new na(e.type, this._map, e));
                }
                click(e, i) {
                  (this._mousedownPos &&
                    this._mousedownPos.dist(i) >= this._clickTolerance) ||
                    this._map.fire(new na(e.type, this._map, e));
                }
                dblclick(e) {
                  return this._firePreventable(new na(e.type, this._map, e));
                }
                mouseover(e) {
                  this._map.fire(new na(e.type, this._map, e));
                }
                mouseout(e) {
                  this._map.fire(new na(e.type, this._map, e));
                }
                touchstart(e) {
                  return this._firePreventable(new Xi(e.type, this._map, e));
                }
                touchmove(e) {
                  this._map.fire(new Xi(e.type, this._map, e));
                }
                touchend(e) {
                  this._map.fire(new Xi(e.type, this._map, e));
                }
                touchcancel(e) {
                  this._map.fire(new Xi(e.type, this._map, e));
                }
                _firePreventable(e) {
                  if ((this._map.fire(e), e.defaultPrevented)) return {};
                }
                isEnabled() {
                  return !0;
                }
                isActive() {
                  return !1;
                }
                enable() {}
                disable() {}
              }
              class yf {
                constructor(e) {
                  this._map = e;
                }
                reset() {
                  (this._delayContextMenu = !1),
                    (this._ignoreContextMenu = !0),
                    delete this._contextMenuEvent;
                }
                mousemove(e) {
                  this._map.fire(new na(e.type, this._map, e));
                }
                mousedown() {
                  (this._delayContextMenu = !0), (this._ignoreContextMenu = !1);
                }
                mouseup() {
                  (this._delayContextMenu = !1),
                    this._contextMenuEvent &&
                      (this._map.fire(
                        new na("contextmenu", this._map, this._contextMenuEvent)
                      ),
                      delete this._contextMenuEvent);
                }
                contextmenu(e) {
                  this._delayContextMenu
                    ? (this._contextMenuEvent = e)
                    : this._ignoreContextMenu ||
                      this._map.fire(new na(e.type, this._map, e)),
                    this._map.listens("contextmenu") && e.preventDefault();
                }
                isEnabled() {
                  return !0;
                }
                isActive() {
                  return !1;
                }
                enable() {}
                disable() {}
              }
              class el {
                constructor(e) {
                  this._map = e;
                }
                get transform() {
                  return this._map._requestedCameraState || this._map.transform;
                }
                get center() {
                  return {
                    lng: this.transform.center.lng,
                    lat: this.transform.center.lat,
                  };
                }
                get zoom() {
                  return this.transform.zoom;
                }
                get pitch() {
                  return this.transform.pitch;
                }
                get bearing() {
                  return this.transform.bearing;
                }
                unproject(e) {
                  return this.transform.screenPointToLocation(
                    s.P.convert(e),
                    this._map.terrain
                  );
                }
              }
              class Ld {
                constructor(e, i) {
                  (this._map = e),
                    (this._tr = new el(e)),
                    (this._el = e.getCanvasContainer()),
                    (this._container = e.getContainer()),
                    (this._clickTolerance = i.clickTolerance || 1);
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return !!this._active;
                }
                enable() {
                  this.isEnabled() || (this._enabled = !0);
                }
                disable() {
                  this.isEnabled() && (this._enabled = !1);
                }
                mousedown(e, i) {
                  this.isEnabled() &&
                    e.shiftKey &&
                    e.button === 0 &&
                    (Y.disableDrag(),
                    (this._startPos = this._lastPos = i),
                    (this._active = !0));
                }
                mousemoveWindow(e, i) {
                  if (!this._active) return;
                  const l = i;
                  if (
                    this._lastPos.equals(l) ||
                    (!this._box &&
                      l.dist(this._startPos) < this._clickTolerance)
                  )
                    return;
                  const u = this._startPos;
                  (this._lastPos = l),
                    this._box ||
                      ((this._box = Y.create(
                        "div",
                        "maplibregl-boxzoom",
                        this._container
                      )),
                      this._container.classList.add("maplibregl-crosshair"),
                      this._fireEvent("boxzoomstart", e));
                  const d = Math.min(u.x, l.x),
                    g = Math.max(u.x, l.x),
                    w = Math.min(u.y, l.y),
                    S = Math.max(u.y, l.y);
                  Y.setTransform(this._box, `translate(${d}px,${w}px)`),
                    (this._box.style.width = g - d + "px"),
                    (this._box.style.height = S - w + "px");
                }
                mouseupWindow(e, i) {
                  if (!this._active || e.button !== 0) return;
                  const l = this._startPos,
                    u = i;
                  if (
                    (this.reset(),
                    Y.suppressClick(),
                    l.x !== u.x || l.y !== u.y)
                  )
                    return (
                      this._map.fire(
                        new s.l("boxzoomend", { originalEvent: e })
                      ),
                      {
                        cameraAnimation: (d) =>
                          d.fitScreenCoordinates(l, u, this._tr.bearing, {
                            linear: !0,
                          }),
                      }
                    );
                  this._fireEvent("boxzoomcancel", e);
                }
                keydown(e) {
                  this._active &&
                    e.keyCode === 27 &&
                    (this.reset(), this._fireEvent("boxzoomcancel", e));
                }
                reset() {
                  (this._active = !1),
                    this._container.classList.remove("maplibregl-crosshair"),
                    this._box && (Y.remove(this._box), (this._box = null)),
                    Y.enableDrag(),
                    delete this._startPos,
                    delete this._lastPos;
                }
                _fireEvent(e, i) {
                  return this._map.fire(new s.l(e, { originalEvent: i }));
                }
              }
              function fu(h, e) {
                if (h.length !== e.length)
                  throw new Error(
                    `The number of touches and points are not equal - touches ${h.length}, points ${e.length}`
                  );
                const i = {};
                for (let l = 0; l < h.length; l++) i[h[l].identifier] = e[l];
                return i;
              }
              class Dd {
                constructor(e) {
                  this.reset(), (this.numTouches = e.numTouches);
                }
                reset() {
                  delete this.centroid,
                    delete this.startTime,
                    delete this.touches,
                    (this.aborted = !1);
                }
                touchstart(e, i, l) {
                  (this.centroid || l.length > this.numTouches) &&
                    (this.aborted = !0),
                    this.aborted ||
                      (this.startTime === void 0 &&
                        (this.startTime = e.timeStamp),
                      l.length === this.numTouches &&
                        ((this.centroid = (function (u) {
                          const d = new s.P(0, 0);
                          for (const g of u) d._add(g);
                          return d.div(u.length);
                        })(i)),
                        (this.touches = fu(l, i))));
                }
                touchmove(e, i, l) {
                  if (this.aborted || !this.centroid) return;
                  const u = fu(l, i);
                  for (const d in this.touches) {
                    const g = u[d];
                    (!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0);
                  }
                }
                touchend(e, i, l) {
                  if (
                    ((!this.centroid || e.timeStamp - this.startTime > 500) &&
                      (this.aborted = !0),
                    l.length === 0)
                  ) {
                    const u = !this.aborted && this.centroid;
                    if ((this.reset(), u)) return u;
                  }
                }
              }
              class $o {
                constructor(e) {
                  (this.singleTap = new Dd(e)),
                    (this.numTaps = e.numTaps),
                    this.reset();
                }
                reset() {
                  (this.lastTime = 1 / 0),
                    delete this.lastTap,
                    (this.count = 0),
                    this.singleTap.reset();
                }
                touchstart(e, i, l) {
                  this.singleTap.touchstart(e, i, l);
                }
                touchmove(e, i, l) {
                  this.singleTap.touchmove(e, i, l);
                }
                touchend(e, i, l) {
                  const u = this.singleTap.touchend(e, i, l);
                  if (u) {
                    const d = e.timeStamp - this.lastTime < 500,
                      g = !this.lastTap || this.lastTap.dist(u) < 30;
                    if (
                      ((d && g) || this.reset(),
                      this.count++,
                      (this.lastTime = e.timeStamp),
                      (this.lastTap = u),
                      this.count === this.numTaps)
                    )
                      return this.reset(), u;
                  }
                }
              }
              class to {
                constructor(e) {
                  (this._tr = new el(e)),
                    (this._zoomIn = new $o({ numTouches: 1, numTaps: 2 })),
                    (this._zoomOut = new $o({ numTouches: 2, numTaps: 1 })),
                    this.reset();
                }
                reset() {
                  (this._active = !1),
                    this._zoomIn.reset(),
                    this._zoomOut.reset();
                }
                touchstart(e, i, l) {
                  this._zoomIn.touchstart(e, i, l),
                    this._zoomOut.touchstart(e, i, l);
                }
                touchmove(e, i, l) {
                  this._zoomIn.touchmove(e, i, l),
                    this._zoomOut.touchmove(e, i, l);
                }
                touchend(e, i, l) {
                  const u = this._zoomIn.touchend(e, i, l),
                    d = this._zoomOut.touchend(e, i, l),
                    g = this._tr;
                  return u
                    ? ((this._active = !0),
                      e.preventDefault(),
                      setTimeout(() => this.reset(), 0),
                      {
                        cameraAnimation: (w) =>
                          w.easeTo(
                            {
                              duration: 300,
                              zoom: g.zoom + 1,
                              around: g.unproject(u),
                            },
                            { originalEvent: e }
                          ),
                      })
                    : d
                    ? ((this._active = !0),
                      e.preventDefault(),
                      setTimeout(() => this.reset(), 0),
                      {
                        cameraAnimation: (w) =>
                          w.easeTo(
                            {
                              duration: 300,
                              zoom: g.zoom - 1,
                              around: g.unproject(d),
                            },
                            { originalEvent: e }
                          ),
                      })
                    : void 0;
                }
                touchcancel() {
                  this.reset();
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class hr {
                constructor(e) {
                  (this._enabled = !!e.enable),
                    (this._moveStateManager = e.moveStateManager),
                    (this._clickTolerance = e.clickTolerance || 1),
                    (this._moveFunction = e.move),
                    (this._activateOnStart = !!e.activateOnStart),
                    e.assignEvents(this),
                    this.reset();
                }
                reset(e) {
                  (this._active = !1),
                    (this._moved = !1),
                    delete this._lastPoint,
                    this._moveStateManager.endMove(e);
                }
                _move(...e) {
                  const i = this._moveFunction(...e);
                  if (
                    i.bearingDelta ||
                    i.pitchDelta ||
                    i.rollDelta ||
                    i.around ||
                    i.panDelta
                  )
                    return (this._active = !0), i;
                }
                dragStart(e, i) {
                  this.isEnabled() &&
                    !this._lastPoint &&
                    this._moveStateManager.isValidStartEvent(e) &&
                    (this._moveStateManager.startMove(e),
                    (this._lastPoint = Array.isArray(i) ? i[0] : i),
                    this._activateOnStart &&
                      this._lastPoint &&
                      (this._active = !0));
                }
                dragMove(e, i) {
                  if (!this.isEnabled()) return;
                  const l = this._lastPoint;
                  if (!l) return;
                  if (
                    (e.preventDefault(),
                    !this._moveStateManager.isValidMoveEvent(e))
                  )
                    return void this.reset(e);
                  const u = Array.isArray(i) ? i[0] : i;
                  return !this._moved && u.dist(l) < this._clickTolerance
                    ? void 0
                    : ((this._moved = !0),
                      (this._lastPoint = u),
                      this._move(l, u));
                }
                dragEnd(e) {
                  this.isEnabled() &&
                    this._lastPoint &&
                    this._moveStateManager.isValidEndEvent(e) &&
                    (this._moved && Y.suppressClick(), this.reset(e));
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
                getClickTolerance() {
                  return this._clickTolerance;
                }
              }
              const Rd = 0,
                mu = 2,
                Fd = { [Rd]: 1, [mu]: 2 };
              class ro {
                constructor(e) {
                  this._correctEvent = e.checkCorrectEvent;
                }
                startMove(e) {
                  const i = Y.mouseButton(e);
                  this._eventButton = i;
                }
                endMove(e) {
                  delete this._eventButton;
                }
                isValidStartEvent(e) {
                  return this._correctEvent(e);
                }
                isValidMoveEvent(e) {
                  return !(function (i, l) {
                    const u = Fd[l];
                    return i.buttons === void 0 || (i.buttons & u) !== u;
                  })(e, this._eventButton);
                }
                isValidEndEvent(e) {
                  return Y.mouseButton(e) === this._eventButton;
                }
              }
              class tl {
                constructor() {
                  this._firstTouch = void 0;
                }
                _isOneFingerTouch(e) {
                  return e.targetTouches.length === 1;
                }
                _isSameTouchEvent(e) {
                  return e.targetTouches[0].identifier === this._firstTouch;
                }
                startMove(e) {
                  this._firstTouch = e.targetTouches[0].identifier;
                }
                endMove(e) {
                  delete this._firstTouch;
                }
                isValidStartEvent(e) {
                  return this._isOneFingerTouch(e);
                }
                isValidMoveEvent(e) {
                  return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
                }
                isValidEndEvent(e) {
                  return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
                }
              }
              class _u {
                constructor(
                  e = new ro({ checkCorrectEvent: () => !0 }),
                  i = new tl()
                ) {
                  (this.mouseMoveStateManager = e),
                    (this.oneFingerTouchMoveStateManager = i);
                }
                _executeRelevantHandler(e, i, l) {
                  return e instanceof MouseEvent
                    ? i(e)
                    : typeof TouchEvent < "u" && e instanceof TouchEvent
                    ? l(e)
                    : void 0;
                }
                startMove(e) {
                  this._executeRelevantHandler(
                    e,
                    (i) => this.mouseMoveStateManager.startMove(i),
                    (i) => this.oneFingerTouchMoveStateManager.startMove(i)
                  );
                }
                endMove(e) {
                  this._executeRelevantHandler(
                    e,
                    (i) => this.mouseMoveStateManager.endMove(i),
                    (i) => this.oneFingerTouchMoveStateManager.endMove(i)
                  );
                }
                isValidStartEvent(e) {
                  return this._executeRelevantHandler(
                    e,
                    (i) => this.mouseMoveStateManager.isValidStartEvent(i),
                    (i) =>
                      this.oneFingerTouchMoveStateManager.isValidStartEvent(i)
                  );
                }
                isValidMoveEvent(e) {
                  return this._executeRelevantHandler(
                    e,
                    (i) => this.mouseMoveStateManager.isValidMoveEvent(i),
                    (i) =>
                      this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)
                  );
                }
                isValidEndEvent(e) {
                  return this._executeRelevantHandler(
                    e,
                    (i) => this.mouseMoveStateManager.isValidEndEvent(i),
                    (i) =>
                      this.oneFingerTouchMoveStateManager.isValidEndEvent(i)
                  );
                }
              }
              const mn = (h) => {
                (h.mousedown = h.dragStart),
                  (h.mousemoveWindow = h.dragMove),
                  (h.mouseup = h.dragEnd),
                  (h.contextmenu = (e) => {
                    e.preventDefault();
                  });
              };
              class gu {
                constructor(e, i) {
                  (this._clickTolerance = e.clickTolerance || 1),
                    (this._map = i),
                    this.reset();
                }
                reset() {
                  (this._active = !1),
                    (this._touches = {}),
                    (this._sum = new s.P(0, 0));
                }
                _shouldBePrevented(e) {
                  return (
                    e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
                  );
                }
                touchstart(e, i, l) {
                  return this._calculateTransform(e, i, l);
                }
                touchmove(e, i, l) {
                  if (this._active) {
                    if (!this._shouldBePrevented(l.length))
                      return (
                        e.preventDefault(), this._calculateTransform(e, i, l)
                      );
                    this._map.cooperativeGestures.notifyGestureBlocked(
                      "touch_pan",
                      e
                    );
                  }
                }
                touchend(e, i, l) {
                  this._calculateTransform(e, i, l),
                    this._active &&
                      this._shouldBePrevented(l.length) &&
                      this.reset();
                }
                touchcancel() {
                  this.reset();
                }
                _calculateTransform(e, i, l) {
                  l.length > 0 && (this._active = !0);
                  const u = fu(l, i),
                    d = new s.P(0, 0),
                    g = new s.P(0, 0);
                  let w = 0;
                  for (const k in u) {
                    const z = u[k],
                      V = this._touches[k];
                    V && (d._add(z), g._add(z.sub(V)), w++, (u[k] = z));
                  }
                  if (
                    ((this._touches = u),
                    this._shouldBePrevented(w) || !g.mag())
                  )
                    return;
                  const S = g.div(w);
                  return (
                    this._sum._add(S),
                    this._sum.mag() < this._clickTolerance
                      ? void 0
                      : { around: d.div(w), panDelta: S }
                  );
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class vu {
                constructor() {
                  this.reset();
                }
                reset() {
                  (this._active = !1), delete this._firstTwoTouches;
                }
                touchstart(e, i, l) {
                  this._firstTwoTouches ||
                    l.length < 2 ||
                    ((this._firstTwoTouches = [
                      l[0].identifier,
                      l[1].identifier,
                    ]),
                    this._start([i[0], i[1]]));
                }
                touchmove(e, i, l) {
                  if (!this._firstTwoTouches) return;
                  e.preventDefault();
                  const [u, d] = this._firstTwoTouches,
                    g = Ts(l, i, u),
                    w = Ts(l, i, d);
                  if (!g || !w) return;
                  const S = this._aroundCenter ? null : g.add(w).div(2);
                  return this._move([g, w], S, e);
                }
                touchend(e, i, l) {
                  if (!this._firstTwoTouches) return;
                  const [u, d] = this._firstTwoTouches,
                    g = Ts(l, i, u),
                    w = Ts(l, i, d);
                  (g && w) || (this._active && Y.suppressClick(), this.reset());
                }
                touchcancel() {
                  this.reset();
                }
                enable(e) {
                  (this._enabled = !0),
                    (this._aroundCenter = !!e && e.around === "center");
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return !!this._active;
                }
              }
              function Ts(h, e, i) {
                for (let l = 0; l < h.length; l++)
                  if (h[l].identifier === i) return e[l];
              }
              function Bd(h, e) {
                return Math.log(h / e) / Math.LN2;
              }
              class Od extends vu {
                reset() {
                  super.reset(),
                    delete this._distance,
                    delete this._startDistance;
                }
                _start(e) {
                  this._startDistance = this._distance = e[0].dist(e[1]);
                }
                _move(e, i) {
                  const l = this._distance;
                  if (
                    ((this._distance = e[0].dist(e[1])),
                    this._active ||
                      !(
                        Math.abs(Bd(this._distance, this._startDistance)) < 0.1
                      ))
                  )
                    return (
                      (this._active = !0),
                      { zoomDelta: Bd(this._distance, l), pinchAround: i }
                    );
                }
              }
              function yu(h, e) {
                return (180 * h.angleWith(e)) / Math.PI;
              }
              class Yl extends vu {
                reset() {
                  super.reset(),
                    delete this._minDiameter,
                    delete this._startVector,
                    delete this._vector;
                }
                _start(e) {
                  (this._startVector = this._vector = e[0].sub(e[1])),
                    (this._minDiameter = e[0].dist(e[1]));
                }
                _move(e, i, l) {
                  const u = this._vector;
                  if (
                    ((this._vector = e[0].sub(e[1])),
                    this._active || !this._isBelowThreshold(this._vector))
                  )
                    return (
                      (this._active = !0),
                      { bearingDelta: yu(this._vector, u), pinchAround: i }
                    );
                }
                _isBelowThreshold(e) {
                  this._minDiameter = Math.min(this._minDiameter, e.mag());
                  const i = (25 / (Math.PI * this._minDiameter)) * 360,
                    l = yu(e, this._startVector);
                  return Math.abs(l) < i;
                }
              }
              function Kl(h) {
                return Math.abs(h.y) > Math.abs(h.x);
              }
              class Nd extends vu {
                constructor(e) {
                  super(), (this._currentTouchCount = 0), (this._map = e);
                }
                reset() {
                  super.reset(),
                    (this._valid = void 0),
                    delete this._firstMove,
                    delete this._lastPoints;
                }
                touchstart(e, i, l) {
                  super.touchstart(e, i, l),
                    (this._currentTouchCount = l.length);
                }
                _start(e) {
                  (this._lastPoints = e),
                    Kl(e[0].sub(e[1])) && (this._valid = !1);
                }
                _move(e, i, l) {
                  if (
                    this._map.cooperativeGestures.isEnabled() &&
                    this._currentTouchCount < 3
                  )
                    return;
                  const u = e[0].sub(this._lastPoints[0]),
                    d = e[1].sub(this._lastPoints[1]);
                  return (
                    (this._valid = this.gestureBeginsVertically(
                      u,
                      d,
                      l.timeStamp
                    )),
                    this._valid
                      ? ((this._lastPoints = e),
                        (this._active = !0),
                        { pitchDelta: ((u.y + d.y) / 2) * -0.5 })
                      : void 0
                  );
                }
                gestureBeginsVertically(e, i, l) {
                  if (this._valid !== void 0) return this._valid;
                  const u = e.mag() >= 2,
                    d = i.mag() >= 2;
                  if (!u && !d) return;
                  if (!u || !d)
                    return (
                      this._firstMove === void 0 && (this._firstMove = l),
                      l - this._firstMove < 100 && void 0
                    );
                  const g = e.y > 0 == i.y > 0;
                  return Kl(e) && Kl(i) && g;
                }
              }
              const jd = { panStep: 100, bearingStep: 15, pitchStep: 10 };
              class Vd {
                constructor(e) {
                  this._tr = new el(e);
                  const i = jd;
                  (this._panStep = i.panStep),
                    (this._bearingStep = i.bearingStep),
                    (this._pitchStep = i.pitchStep),
                    (this._rotationDisabled = !1);
                }
                reset() {
                  this._active = !1;
                }
                keydown(e) {
                  if (e.altKey || e.ctrlKey || e.metaKey) return;
                  let i = 0,
                    l = 0,
                    u = 0,
                    d = 0,
                    g = 0;
                  switch (e.keyCode) {
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                      i = 1;
                      break;
                    case 189:
                    case 109:
                    case 173:
                      i = -1;
                      break;
                    case 37:
                      e.shiftKey ? (l = -1) : (e.preventDefault(), (d = -1));
                      break;
                    case 39:
                      e.shiftKey ? (l = 1) : (e.preventDefault(), (d = 1));
                      break;
                    case 38:
                      e.shiftKey ? (u = 1) : (e.preventDefault(), (g = -1));
                      break;
                    case 40:
                      e.shiftKey ? (u = -1) : (e.preventDefault(), (g = 1));
                      break;
                    default:
                      return;
                  }
                  return (
                    this._rotationDisabled && ((l = 0), (u = 0)),
                    {
                      cameraAnimation: (w) => {
                        const S = this._tr;
                        w.easeTo(
                          {
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: xf,
                            zoom: i
                              ? Math.round(S.zoom) + i * (e.shiftKey ? 2 : 1)
                              : S.zoom,
                            bearing: S.bearing + l * this._bearingStep,
                            pitch: S.pitch + u * this._pitchStep,
                            offset: [-d * this._panStep, -g * this._panStep],
                            center: S.center,
                          },
                          { originalEvent: e }
                        );
                      },
                    }
                  );
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
                disableRotation() {
                  this._rotationDisabled = !0;
                }
                enableRotation() {
                  this._rotationDisabled = !1;
                }
              }
              function xf(h) {
                return h * (2 - h);
              }
              const no = 4.000244140625,
                On = 1 / 450;
              class qd {
                constructor(e, i) {
                  (this._onTimeout = (l) => {
                    (this._type = "wheel"),
                      (this._delta -= this._lastValue),
                      this._active || this._start(l);
                  }),
                    (this._map = e),
                    (this._tr = new el(e)),
                    (this._triggerRenderFrame = i),
                    (this._delta = 0),
                    (this._defaultZoomRate = 0.01),
                    (this._wheelZoomRate = On);
                }
                setZoomRate(e) {
                  this._defaultZoomRate = e;
                }
                setWheelZoomRate(e) {
                  this._wheelZoomRate = e;
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return !!this._active || this._finishTimeout !== void 0;
                }
                isZooming() {
                  return !!this._zooming;
                }
                enable(e) {
                  this.isEnabled() ||
                    ((this._enabled = !0),
                    (this._aroundCenter = !!e && e.around === "center"));
                }
                disable() {
                  this.isEnabled() && (this._enabled = !1);
                }
                _shouldBePrevented(e) {
                  return (
                    !!this._map.cooperativeGestures.isEnabled() &&
                    !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
                  );
                }
                wheel(e) {
                  if (!this.isEnabled()) return;
                  if (this._shouldBePrevented(e))
                    return void this._map.cooperativeGestures.notifyGestureBlocked(
                      "wheel_zoom",
                      e
                    );
                  let i =
                    e.deltaMode === WheelEvent.DOM_DELTA_LINE
                      ? 40 * e.deltaY
                      : e.deltaY;
                  const l = ne(),
                    u = l - (this._lastWheelEventTime || 0);
                  (this._lastWheelEventTime = l),
                    i !== 0 && i % no == 0
                      ? (this._type = "wheel")
                      : i !== 0 && Math.abs(i) < 4
                      ? (this._type = "trackpad")
                      : u > 400
                      ? ((this._type = null),
                        (this._lastValue = i),
                        (this._timeout = setTimeout(this._onTimeout, 40, e)))
                      : this._type ||
                        ((this._type =
                          Math.abs(u * i) < 200 ? "trackpad" : "wheel"),
                        this._timeout &&
                          (clearTimeout(this._timeout),
                          (this._timeout = null),
                          (i += this._lastValue))),
                    e.shiftKey && i && (i /= 4),
                    this._type &&
                      ((this._lastWheelEvent = e),
                      (this._delta -= i),
                      this._active || this._start(e)),
                    e.preventDefault();
                }
                _start(e) {
                  if (!this._delta) return;
                  this._frameId && (this._frameId = null),
                    (this._active = !0),
                    this.isZooming() || (this._zooming = !0),
                    this._finishTimeout &&
                      (clearTimeout(this._finishTimeout),
                      delete this._finishTimeout);
                  const i = Y.mousePos(this._map.getCanvas(), e),
                    l = this._tr;
                  (this._aroundPoint = this._aroundCenter
                    ? l.transform.locationToScreenPoint(s.U.convert(l.center))
                    : i),
                    this._frameId ||
                      ((this._frameId = !0), this._triggerRenderFrame());
                }
                renderFrame() {
                  if (
                    !this._frameId ||
                    ((this._frameId = null), !this.isActive())
                  )
                    return;
                  const e = this._tr.transform;
                  if (typeof this._lastExpectedZoom == "number") {
                    const w = e.zoom - this._lastExpectedZoom;
                    typeof this._startZoom == "number" &&
                      (this._startZoom += w),
                      typeof this._targetZoom == "number" &&
                        (this._targetZoom += w);
                  }
                  if (this._delta !== 0) {
                    const w =
                      this._type === "wheel" && Math.abs(this._delta) > no
                        ? this._wheelZoomRate
                        : this._defaultZoomRate;
                    let S = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
                    this._delta < 0 && S !== 0 && (S = 1 / S);
                    const k =
                      typeof this._targetZoom != "number"
                        ? e.scale
                        : s.al(this._targetZoom);
                    (this._targetZoom = e.constrain(
                      e.getCameraLngLat(),
                      s.ao(k * S)
                    ).zoom),
                      this._type === "wheel" &&
                        ((this._startZoom = e.zoom),
                        (this._easing = this._smoothOutEasing(200))),
                      (this._delta = 0);
                  }
                  const i =
                      typeof this._targetZoom != "number"
                        ? e.zoom
                        : this._targetZoom,
                    l = this._startZoom,
                    u = this._easing;
                  let d,
                    g = !1;
                  if (this._type === "wheel" && l && u) {
                    const w = ne() - this._lastWheelEventTime,
                      S = Math.min((w + 5) / 200, 1),
                      k = u(S);
                    (d = s.F.number(l, i, k)),
                      S < 1 ? this._frameId || (this._frameId = !0) : (g = !0);
                  } else (d = i), (g = !0);
                  return (
                    (this._active = !0),
                    g &&
                      ((this._active = !1),
                      (this._finishTimeout = setTimeout(() => {
                        (this._zooming = !1),
                          this._triggerRenderFrame(),
                          delete this._targetZoom,
                          delete this._lastExpectedZoom,
                          delete this._finishTimeout;
                      }, 200))),
                    (this._lastExpectedZoom = d),
                    {
                      noInertia: !0,
                      needsRenderFrame: !g,
                      zoomDelta: d - e.zoom,
                      around: this._aroundPoint,
                      originalEvent: this._lastWheelEvent,
                    }
                  );
                }
                _smoothOutEasing(e) {
                  let i = s.cr;
                  if (this._prevEase) {
                    const l = this._prevEase,
                      u = (ne() - l.start) / l.duration,
                      d = l.easing(u + 0.01) - l.easing(u),
                      g = (0.27 / Math.sqrt(d * d + 1e-4)) * 0.01,
                      w = Math.sqrt(0.0729 - g * g);
                    i = s.cp(g, w, 0.25, 1);
                  }
                  return (
                    (this._prevEase = { start: ne(), duration: e, easing: i }),
                    i
                  );
                }
                reset() {
                  (this._active = !1),
                    (this._zooming = !1),
                    delete this._targetZoom,
                    delete this._lastExpectedZoom,
                    this._finishTimeout &&
                      (clearTimeout(this._finishTimeout),
                      delete this._finishTimeout);
                }
              }
              class rl {
                constructor(e, i) {
                  (this._clickZoom = e), (this._tapZoom = i);
                }
                enable() {
                  this._clickZoom.enable(), this._tapZoom.enable();
                }
                disable() {
                  this._clickZoom.disable(), this._tapZoom.disable();
                }
                isEnabled() {
                  return (
                    this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                  );
                }
                isActive() {
                  return this._clickZoom.isActive() || this._tapZoom.isActive();
                }
              }
              class xu {
                constructor(e) {
                  (this._tr = new el(e)), this.reset();
                }
                reset() {
                  this._active = !1;
                }
                dblclick(e, i) {
                  return (
                    e.preventDefault(),
                    {
                      cameraAnimation: (l) => {
                        l.easeTo(
                          {
                            duration: 300,
                            zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                            around: this._tr.unproject(i),
                          },
                          { originalEvent: e }
                        );
                      },
                    }
                  );
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class Ud {
                constructor() {
                  (this._tap = new $o({ numTouches: 1, numTaps: 1 })),
                    this.reset();
                }
                reset() {
                  (this._active = !1),
                    delete this._swipePoint,
                    delete this._swipeTouch,
                    delete this._tapTime,
                    delete this._tapPoint,
                    this._tap.reset();
                }
                touchstart(e, i, l) {
                  if (!this._swipePoint)
                    if (this._tapTime) {
                      const u = i[0],
                        d = e.timeStamp - this._tapTime < 500,
                        g = this._tapPoint.dist(u) < 30;
                      d && g
                        ? l.length > 0 &&
                          ((this._swipePoint = u),
                          (this._swipeTouch = l[0].identifier))
                        : this.reset();
                    } else this._tap.touchstart(e, i, l);
                }
                touchmove(e, i, l) {
                  if (this._tapTime) {
                    if (this._swipePoint) {
                      if (l[0].identifier !== this._swipeTouch) return;
                      const u = i[0],
                        d = u.y - this._swipePoint.y;
                      return (
                        (this._swipePoint = u),
                        e.preventDefault(),
                        (this._active = !0),
                        { zoomDelta: d / 128 }
                      );
                    }
                  } else this._tap.touchmove(e, i, l);
                }
                touchend(e, i, l) {
                  if (this._tapTime)
                    this._swipePoint && l.length === 0 && this.reset();
                  else {
                    const u = this._tap.touchend(e, i, l);
                    u && ((this._tapTime = e.timeStamp), (this._tapPoint = u));
                  }
                }
                touchcancel() {
                  this.reset();
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  (this._enabled = !1), this.reset();
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class bu {
                constructor(e, i, l) {
                  (this._el = e), (this._mousePan = i), (this._touchPan = l);
                }
                enable(e) {
                  (this._inertiaOptions = e || {}),
                    this._mousePan.enable(),
                    this._touchPan.enable(),
                    this._el.classList.add("maplibregl-touch-drag-pan");
                }
                disable() {
                  this._mousePan.disable(),
                    this._touchPan.disable(),
                    this._el.classList.remove("maplibregl-touch-drag-pan");
                }
                isEnabled() {
                  return (
                    this._mousePan.isEnabled() && this._touchPan.isEnabled()
                  );
                }
                isActive() {
                  return this._mousePan.isActive() || this._touchPan.isActive();
                }
              }
              class wu {
                constructor(e, i, l, u) {
                  (this._pitchWithRotate = e.pitchWithRotate),
                    (this._rollEnabled = e.rollEnabled),
                    (this._mouseRotate = i),
                    (this._mousePitch = l),
                    (this._mouseRoll = u);
                }
                enable() {
                  this._mouseRotate.enable(),
                    this._pitchWithRotate && this._mousePitch.enable(),
                    this._rollEnabled && this._mouseRoll.enable();
                }
                disable() {
                  this._mouseRotate.disable(),
                    this._mousePitch.disable(),
                    this._mouseRoll.disable();
                }
                isEnabled() {
                  return (
                    this._mouseRotate.isEnabled() &&
                    (!this._pitchWithRotate || this._mousePitch.isEnabled()) &&
                    (!this._rollEnabled || this._mouseRoll.isEnabled())
                  );
                }
                isActive() {
                  return (
                    this._mouseRotate.isActive() ||
                    this._mousePitch.isActive() ||
                    this._mouseRoll.isActive()
                  );
                }
              }
              class Zd {
                constructor(e, i, l, u) {
                  (this._el = e),
                    (this._touchZoom = i),
                    (this._touchRotate = l),
                    (this._tapDragZoom = u),
                    (this._rotationDisabled = !1),
                    (this._enabled = !0);
                }
                enable(e) {
                  this._touchZoom.enable(e),
                    this._rotationDisabled || this._touchRotate.enable(e),
                    this._tapDragZoom.enable(),
                    this._el.classList.add("maplibregl-touch-zoom-rotate");
                }
                disable() {
                  this._touchZoom.disable(),
                    this._touchRotate.disable(),
                    this._tapDragZoom.disable(),
                    this._el.classList.remove("maplibregl-touch-zoom-rotate");
                }
                isEnabled() {
                  return (
                    this._touchZoom.isEnabled() &&
                    (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                    this._tapDragZoom.isEnabled()
                  );
                }
                isActive() {
                  return (
                    this._touchZoom.isActive() ||
                    this._touchRotate.isActive() ||
                    this._tapDragZoom.isActive()
                  );
                }
                disableRotation() {
                  (this._rotationDisabled = !0), this._touchRotate.disable();
                }
                enableRotation() {
                  (this._rotationDisabled = !1),
                    this._touchZoom.isEnabled() && this._touchRotate.enable();
                }
              }
              class Ma {
                constructor(e, i) {
                  (this._bypassKey =
                    navigator.userAgent.indexOf("Mac") !== -1
                      ? "metaKey"
                      : "ctrlKey"),
                    (this._map = e),
                    (this._options = i),
                    (this._enabled = !1);
                }
                isActive() {
                  return !1;
                }
                reset() {}
                _setupUI() {
                  if (this._container) return;
                  const e = this._map.getCanvasContainer();
                  e.classList.add("maplibregl-cooperative-gestures"),
                    (this._container = Y.create(
                      "div",
                      "maplibregl-cooperative-gesture-screen",
                      e
                    ));
                  let i = this._map._getUIString(
                    "CooperativeGesturesHandler.WindowsHelpText"
                  );
                  this._bypassKey === "metaKey" &&
                    (i = this._map._getUIString(
                      "CooperativeGesturesHandler.MacHelpText"
                    ));
                  const l = this._map._getUIString(
                      "CooperativeGesturesHandler.MobileHelpText"
                    ),
                    u = document.createElement("div");
                  (u.className = "maplibregl-desktop-message"),
                    (u.textContent = i),
                    this._container.appendChild(u);
                  const d = document.createElement("div");
                  (d.className = "maplibregl-mobile-message"),
                    (d.textContent = l),
                    this._container.appendChild(d),
                    this._container.setAttribute("aria-hidden", "true");
                }
                _destroyUI() {
                  this._container &&
                    (Y.remove(this._container),
                    this._map
                      .getCanvasContainer()
                      .classList.remove("maplibregl-cooperative-gestures")),
                    delete this._container;
                }
                enable() {
                  this._setupUI(), (this._enabled = !0);
                }
                disable() {
                  (this._enabled = !1), this._destroyUI();
                }
                isEnabled() {
                  return this._enabled;
                }
                isBypassed(e) {
                  return e[this._bypassKey];
                }
                notifyGestureBlocked(e, i) {
                  this._enabled &&
                    (this._map.fire(
                      new s.l("cooperativegestureprevented", {
                        gestureType: e,
                        originalEvent: i,
                      })
                    ),
                    this._container.classList.add("maplibregl-show"),
                    setTimeout(() => {
                      this._container.classList.remove("maplibregl-show");
                    }, 100));
                }
              }
              const Ho = (h) =>
                h.zoom || h.drag || h.roll || h.pitch || h.rotate;
              class zr extends s.l {}
              function Gr(h) {
                return (
                  (h.panDelta && h.panDelta.mag()) ||
                  h.zoomDelta ||
                  h.bearingDelta ||
                  h.pitchDelta ||
                  h.rollDelta
                );
              }
              class nl {
                constructor(e, i) {
                  (this.handleWindowEvent = (u) => {
                    this.handleEvent(u, `${u.type}Window`);
                  }),
                    (this.handleEvent = (u, d) => {
                      if (u.type === "blur") return void this.stop(!0);
                      this._updatingCamera = !0;
                      const g = u.type === "renderFrame" ? void 0 : u,
                        w = { needsRenderFrame: !1 },
                        S = {},
                        k = {};
                      for (const {
                        handlerName: F,
                        handler: $,
                        allowed: J,
                      } of this._handlers) {
                        if (!$.isEnabled()) continue;
                        let ae;
                        if (this._blockedByActive(k, J, F)) $.reset();
                        else if ($[d || u.type]) {
                          if (s.cs(u, d || u.type)) {
                            const oe = Y.mousePos(this._map.getCanvas(), u);
                            ae = $[d || u.type](u, oe);
                          } else if (s.ct(u, d || u.type)) {
                            const oe = this._getMapTouches(u.touches),
                              se = Y.touchPos(this._map.getCanvas(), oe);
                            ae = $[d || u.type](u, se, oe);
                          } else s.cu(d || u.type) || (ae = $[d || u.type](u));
                          this.mergeHandlerResult(w, S, ae, F, g),
                            ae &&
                              ae.needsRenderFrame &&
                              this._triggerRenderFrame();
                        }
                        (ae || $.isActive()) && (k[F] = $);
                      }
                      const z = {};
                      for (const F in this._previousActiveHandlers)
                        k[F] || (z[F] = g);
                      (this._previousActiveHandlers = k),
                        (Object.keys(z).length || Gr(w)) &&
                          (this._changes.push([w, S, z]),
                          this._triggerRenderFrame()),
                        (Object.keys(k).length || Gr(w)) && this._map._stop(!0),
                        (this._updatingCamera = !1);
                      const { cameraAnimation: V } = w;
                      V &&
                        (this._inertia.clear(),
                        this._fireEvents({}, {}, !0),
                        (this._changes = []),
                        V(this._map));
                    }),
                    (this._map = e),
                    (this._el = this._map.getCanvasContainer()),
                    (this._handlers = []),
                    (this._handlersById = {}),
                    (this._changes = []),
                    (this._inertia = new Ed(e)),
                    (this._bearingSnap = i.bearingSnap),
                    (this._previousActiveHandlers = {}),
                    (this._eventsInProgress = {}),
                    this._addDefaultHandlers(i);
                  const l = this._el;
                  this._listeners = [
                    [l, "touchstart", { passive: !0 }],
                    [l, "touchmove", { passive: !1 }],
                    [l, "touchend", void 0],
                    [l, "touchcancel", void 0],
                    [l, "mousedown", void 0],
                    [l, "mousemove", void 0],
                    [l, "mouseup", void 0],
                    [document, "mousemove", { capture: !0 }],
                    [document, "mouseup", void 0],
                    [l, "mouseover", void 0],
                    [l, "mouseout", void 0],
                    [l, "dblclick", void 0],
                    [l, "click", void 0],
                    [l, "keydown", { capture: !1 }],
                    [l, "keyup", void 0],
                    [l, "wheel", { passive: !1 }],
                    [l, "contextmenu", void 0],
                    [window, "blur", void 0],
                  ];
                  for (const [u, d, g] of this._listeners)
                    Y.addEventListener(
                      u,
                      d,
                      u === document
                        ? this.handleWindowEvent
                        : this.handleEvent,
                      g
                    );
                }
                destroy() {
                  for (const [e, i, l] of this._listeners)
                    Y.removeEventListener(
                      e,
                      i,
                      e === document
                        ? this.handleWindowEvent
                        : this.handleEvent,
                      l
                    );
                }
                _addDefaultHandlers(e) {
                  const i = this._map,
                    l = i.getCanvasContainer();
                  this._add("mapEvent", new ws(i, e));
                  const u = (i.boxZoom = new Ld(i, e));
                  this._add("boxZoom", u),
                    e.interactive && e.boxZoom && u.enable();
                  const d = (i.cooperativeGestures = new Ma(
                    i,
                    e.cooperativeGestures
                  ));
                  this._add("cooperativeGestures", d),
                    e.cooperativeGestures && d.enable();
                  const g = new to(i),
                    w = new xu(i);
                  (i.doubleClickZoom = new rl(w, g)),
                    this._add("tapZoom", g),
                    this._add("clickZoom", w),
                    e.interactive &&
                      e.doubleClickZoom &&
                      i.doubleClickZoom.enable();
                  const S = new Ud();
                  this._add("tapDragZoom", S);
                  const k = (i.touchPitch = new Nd(i));
                  this._add("touchPitch", k),
                    e.interactive &&
                      e.touchPitch &&
                      i.touchPitch.enable(e.touchPitch);
                  const z = () => i.project(i.getCenter()),
                    V = (function (
                      {
                        enable: pe,
                        clickTolerance: we,
                        aroundCenter: Pe = !0,
                        minPixelCenterThreshold: ve = 100,
                        rotateDegreesPerPixelMoved: Re = 0.8,
                      },
                      it
                    ) {
                      const Qe = new ro({
                        checkCorrectEvent: (tt) =>
                          (Y.mouseButton(tt) === 0 && tt.ctrlKey) ||
                          (Y.mouseButton(tt) === 2 && !tt.ctrlKey),
                      });
                      return new hr({
                        clickTolerance: we,
                        move: (tt, ot) => {
                          const Zt = it();
                          if (Pe && Math.abs(Zt.y - tt.y) > ve)
                            return {
                              bearingDelta: s.cq(new s.P(tt.x, ot.y), ot, Zt),
                            };
                          let Ht = (ot.x - tt.x) * Re;
                          return (
                            Pe && ot.y < Zt.y && (Ht = -Ht),
                            { bearingDelta: Ht }
                          );
                        },
                        moveStateManager: Qe,
                        enable: pe,
                        assignEvents: mn,
                      });
                    })(e, z),
                    F = (function ({
                      enable: pe,
                      clickTolerance: we,
                      pitchDegreesPerPixelMoved: Pe = -0.5,
                    }) {
                      const ve = new ro({
                        checkCorrectEvent: (Re) =>
                          (Y.mouseButton(Re) === 0 && Re.ctrlKey) ||
                          Y.mouseButton(Re) === 2,
                      });
                      return new hr({
                        clickTolerance: we,
                        move: (Re, it) => ({ pitchDelta: (it.y - Re.y) * Pe }),
                        moveStateManager: ve,
                        enable: pe,
                        assignEvents: mn,
                      });
                    })(e),
                    $ = (function (
                      {
                        enable: pe,
                        clickTolerance: we,
                        rollDegreesPerPixelMoved: Pe = 0.3,
                      },
                      ve
                    ) {
                      const Re = new ro({
                        checkCorrectEvent: (it) =>
                          Y.mouseButton(it) === 2 && it.ctrlKey,
                      });
                      return new hr({
                        clickTolerance: we,
                        move: (it, Qe) => {
                          const tt = ve();
                          let ot = (Qe.x - it.x) * Pe;
                          return Qe.y < tt.y && (ot = -ot), { rollDelta: ot };
                        },
                        moveStateManager: Re,
                        enable: pe,
                        assignEvents: mn,
                      });
                    })(e, z);
                  (i.dragRotate = new wu(e, V, F, $)),
                    this._add("mouseRotate", V, ["mousePitch"]),
                    this._add("mousePitch", F, ["mouseRotate", "mouseRoll"]),
                    this._add("mouseRoll", $, ["mousePitch"]),
                    e.interactive && e.dragRotate && i.dragRotate.enable();
                  const J = (function ({ enable: pe, clickTolerance: we }) {
                      const Pe = new ro({
                        checkCorrectEvent: (ve) =>
                          Y.mouseButton(ve) === 0 && !ve.ctrlKey,
                      });
                      return new hr({
                        clickTolerance: we,
                        move: (ve, Re) => ({
                          around: Re,
                          panDelta: Re.sub(ve),
                        }),
                        activateOnStart: !0,
                        moveStateManager: Pe,
                        enable: pe,
                        assignEvents: mn,
                      });
                    })(e),
                    ae = new gu(e, i);
                  (i.dragPan = new bu(l, J, ae)),
                    this._add("mousePan", J),
                    this._add("touchPan", ae, ["touchZoom", "touchRotate"]),
                    e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
                  const oe = new Yl(),
                    se = new Od();
                  (i.touchZoomRotate = new Zd(l, se, oe, S)),
                    this._add("touchRotate", oe, ["touchPan", "touchZoom"]),
                    this._add("touchZoom", se, ["touchPan", "touchRotate"]),
                    e.interactive &&
                      e.touchZoomRotate &&
                      i.touchZoomRotate.enable(e.touchZoomRotate),
                    this._add("blockableMapEvent", new yf(i));
                  const fe = (i.scrollZoom = new qd(i, () =>
                    this._triggerRenderFrame()
                  ));
                  this._add("scrollZoom", fe, ["mousePan"]),
                    e.interactive &&
                      e.scrollZoom &&
                      i.scrollZoom.enable(e.scrollZoom);
                  const be = (i.keyboard = new Vd(i));
                  this._add("keyboard", be),
                    e.interactive && e.keyboard && i.keyboard.enable();
                }
                _add(e, i, l) {
                  this._handlers.push({
                    handlerName: e,
                    handler: i,
                    allowed: l,
                  }),
                    (this._handlersById[e] = i);
                }
                stop(e) {
                  if (!this._updatingCamera) {
                    for (const { handler: i } of this._handlers) i.reset();
                    this._inertia.clear(),
                      this._fireEvents({}, {}, e),
                      (this._changes = []);
                  }
                }
                isActive() {
                  for (const { handler: e } of this._handlers)
                    if (e.isActive()) return !0;
                  return !1;
                }
                isZooming() {
                  return (
                    !!this._eventsInProgress.zoom ||
                    this._map.scrollZoom.isZooming()
                  );
                }
                isRotating() {
                  return !!this._eventsInProgress.rotate;
                }
                isMoving() {
                  return !!Ho(this._eventsInProgress) || this.isZooming();
                }
                _blockedByActive(e, i, l) {
                  for (const u in e)
                    if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
                  return !1;
                }
                _getMapTouches(e) {
                  const i = [];
                  for (const l of e) this._el.contains(l.target) && i.push(l);
                  return i;
                }
                mergeHandlerResult(e, i, l, u, d) {
                  if (!l) return;
                  s.e(e, l);
                  const g = {
                    handlerName: u,
                    originalEvent: l.originalEvent || d,
                  };
                  l.zoomDelta !== void 0 && (i.zoom = g),
                    l.panDelta !== void 0 && (i.drag = g),
                    l.rollDelta !== void 0 && (i.roll = g),
                    l.pitchDelta !== void 0 && (i.pitch = g),
                    l.bearingDelta !== void 0 && (i.rotate = g);
                }
                _applyChanges() {
                  const e = {},
                    i = {},
                    l = {};
                  for (const [u, d, g] of this._changes)
                    u.panDelta &&
                      (e.panDelta = (e.panDelta || new s.P(0, 0))._add(
                        u.panDelta
                      )),
                      u.zoomDelta &&
                        (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta),
                      u.bearingDelta &&
                        (e.bearingDelta =
                          (e.bearingDelta || 0) + u.bearingDelta),
                      u.pitchDelta &&
                        (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta),
                      u.rollDelta &&
                        (e.rollDelta = (e.rollDelta || 0) + u.rollDelta),
                      u.around !== void 0 && (e.around = u.around),
                      u.pinchAround !== void 0 &&
                        (e.pinchAround = u.pinchAround),
                      u.noInertia && (e.noInertia = u.noInertia),
                      s.e(i, d),
                      s.e(l, g);
                  this._updateMapTransform(e, i, l), (this._changes = []);
                }
                _updateMapTransform(e, i, l) {
                  const u = this._map,
                    d = u._getTransformForUpdate(),
                    g = u.terrain;
                  if (!(Gr(e) || (g && this._terrainMovement)))
                    return this._fireEvents(i, l, !0);
                  u._stop(!0);
                  let {
                    panDelta: w,
                    zoomDelta: S,
                    bearingDelta: k,
                    pitchDelta: z,
                    rollDelta: V,
                    around: F,
                    pinchAround: $,
                  } = e;
                  $ !== void 0 && (F = $),
                    (F = F || u.transform.centerPoint),
                    g && !d.isPointOnMapSurface(F) && (F = d.centerPoint);
                  const J = {
                    panDelta: w,
                    zoomDelta: S,
                    rollDelta: V,
                    pitchDelta: z,
                    bearingDelta: k,
                    around: F,
                  };
                  this._map.cameraHelper.useGlobeControls &&
                    !d.isPointOnMapSurface(F) &&
                    (F = d.centerPoint);
                  const ae =
                    F.distSqr(d.centerPoint) < 0.01
                      ? d.center
                      : d.screenPointToLocation(w ? F.sub(w) : F);
                  this._handleMapControls({
                    terrain: g,
                    tr: d,
                    deltasForHelper: J,
                    preZoomAroundLoc: ae,
                    combinedEventsInProgress: i,
                    panDelta: w,
                  }),
                    u._applyUpdatedTransform(d),
                    this._map._update(),
                    e.noInertia || this._inertia.record(e),
                    this._fireEvents(i, l, !0);
                }
                _handleMapControls({
                  terrain: e,
                  tr: i,
                  deltasForHelper: l,
                  preZoomAroundLoc: u,
                  combinedEventsInProgress: d,
                  panDelta: g,
                }) {
                  const w = this._map.cameraHelper;
                  if ((w.handleMapControlsRollPitchBearingZoom(l, i), e))
                    return w.useGlobeControls
                      ? (this._terrainMovement ||
                          (!d.drag && !d.zoom) ||
                          ((this._terrainMovement = !0),
                          (this._map._elevationFreeze = !0)),
                        void w.handleMapControlsPan(l, i, u))
                      : this._terrainMovement || (!d.drag && !d.zoom)
                      ? void (d.drag && this._terrainMovement && g
                          ? i.setCenter(
                              i.screenPointToLocation(i.centerPoint.sub(g))
                            )
                          : w.handleMapControlsPan(l, i, u))
                      : ((this._terrainMovement = !0),
                        (this._map._elevationFreeze = !0),
                        void w.handleMapControlsPan(l, i, u));
                  w.handleMapControlsPan(l, i, u);
                }
                _fireEvents(e, i, l) {
                  const u = Ho(this._eventsInProgress),
                    d = Ho(e),
                    g = {};
                  for (const V in e) {
                    const { originalEvent: F } = e[V];
                    this._eventsInProgress[V] || (g[`${V}start`] = F),
                      (this._eventsInProgress[V] = e[V]);
                  }
                  !u && d && this._fireEvent("movestart", d.originalEvent);
                  for (const V in g) this._fireEvent(V, g[V]);
                  d && this._fireEvent("move", d.originalEvent);
                  for (const V in e) {
                    const { originalEvent: F } = e[V];
                    this._fireEvent(V, F);
                  }
                  const w = {};
                  let S;
                  for (const V in this._eventsInProgress) {
                    const { handlerName: F, originalEvent: $ } =
                      this._eventsInProgress[V];
                    this._handlersById[F].isActive() ||
                      (delete this._eventsInProgress[V],
                      (S = i[F] || $),
                      (w[`${V}end`] = S));
                  }
                  for (const V in w) this._fireEvent(V, w[V]);
                  const k = Ho(this._eventsInProgress),
                    z = (u || d) && !k;
                  if (z && this._terrainMovement) {
                    (this._map._elevationFreeze = !1),
                      (this._terrainMovement = !1);
                    const V = this._map._getTransformForUpdate();
                    this._map.getCenterClampedToGround() &&
                      V.recalculateZoomAndCenter(this._map.terrain),
                      this._map._applyUpdatedTransform(V);
                  }
                  if (l && z) {
                    this._updatingCamera = !0;
                    const V = this._inertia._onMoveEnd(
                        this._map.dragPan._inertiaOptions
                      ),
                      F = ($) =>
                        $ !== 0 &&
                        -this._bearingSnap < $ &&
                        $ < this._bearingSnap;
                    !V || (!V.essential && re.prefersReducedMotion)
                      ? (this._map.fire(
                          new s.l("moveend", { originalEvent: S })
                        ),
                        F(this._map.getBearing()) && this._map.resetNorth())
                      : (F(V.bearing || this._map.getBearing()) &&
                          (V.bearing = 0),
                        (V.freezeElevation = !0),
                        this._map.easeTo(V, { originalEvent: S })),
                      (this._updatingCamera = !1);
                  }
                }
                _fireEvent(e, i) {
                  this._map.fire(new s.l(e, i ? { originalEvent: i } : {}));
                }
                _requestFrame() {
                  return (
                    this._map.triggerRepaint(),
                    this._map._renderTaskQueue.add((e) => {
                      delete this._frameId,
                        this.handleEvent(
                          new zr("renderFrame", { timeStamp: e })
                        ),
                        this._applyChanges();
                    })
                  );
                }
                _triggerRenderFrame() {
                  this._frameId === void 0 &&
                    (this._frameId = this._requestFrame());
                }
              }
              class Gd extends s.E {
                constructor(e, i, l) {
                  super(),
                    (this._renderFrameCallback = () => {
                      const u = Math.min(
                        (ne() - this._easeStart) / this._easeOptions.duration,
                        1
                      );
                      this._onEaseFrame(this._easeOptions.easing(u)),
                        u < 1 && this._easeFrameId
                          ? (this._easeFrameId = this._requestRenderFrame(
                              this._renderFrameCallback
                            ))
                          : this.stop();
                    }),
                    (this._moving = !1),
                    (this._zooming = !1),
                    (this.transform = e),
                    (this._bearingSnap = l.bearingSnap),
                    (this.cameraHelper = i),
                    this.on("moveend", () => {
                      delete this._requestedCameraState;
                    });
                }
                migrateProjection(e, i) {
                  e.apply(this.transform),
                    (this.transform = e),
                    (this.cameraHelper = i);
                }
                getCenter() {
                  return new s.U(
                    this.transform.center.lng,
                    this.transform.center.lat
                  );
                }
                setCenter(e, i) {
                  return this.jumpTo({ center: e }, i);
                }
                getCenterElevation() {
                  return this.transform.elevation;
                }
                setCenterElevation(e, i) {
                  return this.jumpTo({ elevation: e }, i), this;
                }
                getCenterClampedToGround() {
                  return this._centerClampedToGround;
                }
                setCenterClampedToGround(e) {
                  this._centerClampedToGround = e;
                }
                panBy(e, i, l) {
                  return (
                    (e = s.P.convert(e).mult(-1)),
                    this.panTo(this.transform.center, s.e({ offset: e }, i), l)
                  );
                }
                panTo(e, i, l) {
                  return this.easeTo(s.e({ center: e }, i), l);
                }
                getZoom() {
                  return this.transform.zoom;
                }
                setZoom(e, i) {
                  return this.jumpTo({ zoom: e }, i), this;
                }
                zoomTo(e, i, l) {
                  return this.easeTo(s.e({ zoom: e }, i), l);
                }
                zoomIn(e, i) {
                  return this.zoomTo(this.getZoom() + 1, e, i), this;
                }
                zoomOut(e, i) {
                  return this.zoomTo(this.getZoom() - 1, e, i), this;
                }
                getVerticalFieldOfView() {
                  return this.transform.fov;
                }
                setVerticalFieldOfView(e, i) {
                  return (
                    e != this.transform.fov &&
                      (this.transform.setFov(e),
                      this.fire(new s.l("movestart", i))
                        .fire(new s.l("move", i))
                        .fire(new s.l("moveend", i))),
                    this
                  );
                }
                getBearing() {
                  return this.transform.bearing;
                }
                setBearing(e, i) {
                  return this.jumpTo({ bearing: e }, i), this;
                }
                getPadding() {
                  return this.transform.padding;
                }
                setPadding(e, i) {
                  return this.jumpTo({ padding: e }, i), this;
                }
                rotateTo(e, i, l) {
                  return this.easeTo(s.e({ bearing: e }, i), l);
                }
                resetNorth(e, i) {
                  return this.rotateTo(0, s.e({ duration: 1e3 }, e), i), this;
                }
                resetNorthPitch(e, i) {
                  return (
                    this.easeTo(
                      s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e),
                      i
                    ),
                    this
                  );
                }
                snapToNorth(e, i) {
                  return Math.abs(this.getBearing()) < this._bearingSnap
                    ? this.resetNorth(e, i)
                    : this;
                }
                getPitch() {
                  return this.transform.pitch;
                }
                setPitch(e, i) {
                  return this.jumpTo({ pitch: e }, i), this;
                }
                getRoll() {
                  return this.transform.roll;
                }
                setRoll(e, i) {
                  return this.jumpTo({ roll: e }, i), this;
                }
                cameraForBounds(e, i) {
                  e = At.convert(e).adjustAntiMeridian();
                  const l = (i && i.bearing) || 0;
                  return this._cameraForBoxAndBearing(
                    e.getNorthWest(),
                    e.getSouthEast(),
                    l,
                    i
                  );
                }
                _cameraForBoxAndBearing(e, i, l, u) {
                  const d = { top: 0, bottom: 0, right: 0, left: 0 };
                  if (
                    typeof (u = s.e(
                      {
                        padding: d,
                        offset: [0, 0],
                        maxZoom: this.transform.maxZoom,
                      },
                      u
                    )).padding == "number"
                  ) {
                    const k = u.padding;
                    u.padding = { top: k, bottom: k, right: k, left: k };
                  }
                  const g = s.e(d, u.padding);
                  u.padding = g;
                  const w = this.transform,
                    S = new At(e, i);
                  return this.cameraHelper.cameraForBoxAndBearing(
                    u,
                    g,
                    S,
                    l,
                    w
                  );
                }
                fitBounds(e, i, l) {
                  return this._fitInternal(this.cameraForBounds(e, i), i, l);
                }
                fitScreenCoordinates(e, i, l, u, d) {
                  return this._fitInternal(
                    this._cameraForBoxAndBearing(
                      this.transform.screenPointToLocation(s.P.convert(e)),
                      this.transform.screenPointToLocation(s.P.convert(i)),
                      l,
                      u
                    ),
                    u,
                    d
                  );
                }
                _fitInternal(e, i, l) {
                  return e
                    ? (delete (i = s.e(e, i)).padding,
                      i.linear ? this.easeTo(i, l) : this.flyTo(i, l))
                    : this;
                }
                jumpTo(e, i) {
                  this.stop();
                  const l = this._getTransformForUpdate();
                  let u = !1,
                    d = !1,
                    g = !1;
                  const w = l.zoom;
                  this.cameraHelper.handleJumpToCenterZoom(l, e);
                  const S = l.zoom !== w;
                  return (
                    "elevation" in e &&
                      l.elevation !== +e.elevation &&
                      l.setElevation(+e.elevation),
                    "bearing" in e &&
                      l.bearing !== +e.bearing &&
                      ((u = !0), l.setBearing(+e.bearing)),
                    "pitch" in e &&
                      l.pitch !== +e.pitch &&
                      ((d = !0), l.setPitch(+e.pitch)),
                    "roll" in e &&
                      l.roll !== +e.roll &&
                      ((g = !0), l.setRoll(+e.roll)),
                    e.padding == null ||
                      l.isPaddingEqual(e.padding) ||
                      l.setPadding(e.padding),
                    this._applyUpdatedTransform(l),
                    this.fire(new s.l("movestart", i)).fire(new s.l("move", i)),
                    S &&
                      this.fire(new s.l("zoomstart", i))
                        .fire(new s.l("zoom", i))
                        .fire(new s.l("zoomend", i)),
                    u &&
                      this.fire(new s.l("rotatestart", i))
                        .fire(new s.l("rotate", i))
                        .fire(new s.l("rotateend", i)),
                    d &&
                      this.fire(new s.l("pitchstart", i))
                        .fire(new s.l("pitch", i))
                        .fire(new s.l("pitchend", i)),
                    g &&
                      this.fire(new s.l("rollstart", i))
                        .fire(new s.l("roll", i))
                        .fire(new s.l("rollend", i)),
                    this.fire(new s.l("moveend", i))
                  );
                }
                calculateCameraOptionsFromTo(e, i, l, u = 0) {
                  const d = s.a5.fromLngLat(e, i),
                    g = s.a5.fromLngLat(l, u),
                    w = g.x - d.x,
                    S = g.y - d.y,
                    k = g.z - d.z,
                    z = Math.hypot(w, S, k);
                  if (z === 0)
                    throw new Error(
                      "Can't calculate camera options with same From and To"
                    );
                  const V = Math.hypot(w, S),
                    F = s.ao(
                      this.transform.cameraToCenterDistance /
                        z /
                        this.transform.tileSize
                    ),
                    $ = (180 * Math.atan2(w, -S)) / Math.PI;
                  let J = (180 * Math.acos(V / z)) / Math.PI;
                  return (
                    (J = k < 0 ? 90 - J : 90 + J),
                    {
                      center: g.toLngLat(),
                      elevation: u,
                      zoom: F,
                      pitch: J,
                      bearing: $,
                    }
                  );
                }
                calculateCameraOptionsFromCameraLngLatAltRotation(
                  e,
                  i,
                  l,
                  u,
                  d
                ) {
                  const g = this.transform.calculateCenterFromCameraLngLatAlt(
                    e,
                    i,
                    l,
                    u
                  );
                  return {
                    center: g.center,
                    elevation: g.elevation,
                    zoom: g.zoom,
                    bearing: l,
                    pitch: u,
                    roll: d,
                  };
                }
                easeTo(e, i) {
                  this._stop(!1, e.easeId),
                    ((e = s.e(
                      { offset: [0, 0], duration: 500, easing: s.cr },
                      e
                    )).animate === !1 ||
                      (!e.essential && re.prefersReducedMotion)) &&
                      (e.duration = 0);
                  const l = this._getTransformForUpdate(),
                    u = this.getBearing(),
                    d = l.pitch,
                    g = l.roll,
                    w =
                      "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
                    S = "pitch" in e ? +e.pitch : d,
                    k = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
                    z = "padding" in e ? e.padding : l.padding,
                    V = s.P.convert(e.offset);
                  let F, $;
                  e.around &&
                    ((F = s.U.convert(e.around)),
                    ($ = l.locationToScreenPoint(F)));
                  const J = {
                      moving: this._moving,
                      zooming: this._zooming,
                      rotating: this._rotating,
                      pitching: this._pitching,
                      rolling: this._rolling,
                    },
                    ae = this.cameraHelper.handleEaseTo(l, {
                      bearing: w,
                      pitch: S,
                      roll: k,
                      padding: z,
                      around: F,
                      aroundPoint: $,
                      offsetAsPoint: V,
                      offset: e.offset,
                      zoom: e.zoom,
                      center: e.center,
                    });
                  return (
                    (this._rotating = this._rotating || u !== w),
                    (this._pitching = this._pitching || S !== d),
                    (this._rolling = this._rolling || k !== g),
                    (this._padding = !l.isPaddingEqual(z)),
                    (this._zooming = this._zooming || ae.isZooming),
                    (this._easeId = e.easeId),
                    this._prepareEase(i, e.noMoveStart, J),
                    this.terrain && this._prepareElevation(ae.elevationCenter),
                    this._ease(
                      (oe) => {
                        ae.easeFunc(oe),
                          this.terrain &&
                            !e.freezeElevation &&
                            this._updateElevation(oe),
                          this._applyUpdatedTransform(l),
                          this._fireMoveEvents(i);
                      },
                      (oe) => {
                        this.terrain &&
                          e.freezeElevation &&
                          this._finalizeElevation(),
                          this._afterEase(i, oe);
                      },
                      e
                    ),
                    this
                  );
                }
                _prepareEase(e, i, l = {}) {
                  (this._moving = !0),
                    i || l.moving || this.fire(new s.l("movestart", e)),
                    this._zooming &&
                      !l.zooming &&
                      this.fire(new s.l("zoomstart", e)),
                    this._rotating &&
                      !l.rotating &&
                      this.fire(new s.l("rotatestart", e)),
                    this._pitching &&
                      !l.pitching &&
                      this.fire(new s.l("pitchstart", e)),
                    this._rolling &&
                      !l.rolling &&
                      this.fire(new s.l("rollstart", e));
                }
                _prepareElevation(e) {
                  (this._elevationCenter = e),
                    (this._elevationStart = this.transform.elevation),
                    (this._elevationTarget =
                      this.terrain.getElevationForLngLatZoom(
                        e,
                        this.transform.tileZoom
                      )),
                    (this._elevationFreeze = !0);
                }
                _updateElevation(e) {
                  (this._elevationStart !== void 0 &&
                    this._elevationCenter !== void 0) ||
                    this._prepareElevation(this.transform.center),
                    this.transform.setMinElevationForCurrentTile(
                      this.terrain.getMinTileElevationForLngLatZoom(
                        this._elevationCenter,
                        this.transform.tileZoom
                      )
                    );
                  const i = this.terrain.getElevationForLngLatZoom(
                    this._elevationCenter,
                    this.transform.tileZoom
                  );
                  if (e < 1 && i !== this._elevationTarget) {
                    const l = this._elevationTarget - this._elevationStart;
                    (this._elevationStart +=
                      e * (l - (i - (l * e + this._elevationStart)) / (1 - e))),
                      (this._elevationTarget = i);
                  }
                  this.transform.setElevation(
                    s.F.number(this._elevationStart, this._elevationTarget, e)
                  );
                }
                _finalizeElevation() {
                  (this._elevationFreeze = !1),
                    this.getCenterClampedToGround() &&
                      this.transform.recalculateZoomAndCenter(this.terrain);
                }
                _getTransformForUpdate() {
                  return this.transformCameraUpdate || this.terrain
                    ? (this._requestedCameraState ||
                        (this._requestedCameraState = this.transform.clone()),
                      this._requestedCameraState)
                    : this.transform;
                }
                _elevateCameraIfInsideTerrain(e) {
                  if (!this.terrain && e.elevation >= 0 && e.pitch <= 90)
                    return {};
                  const i = e.getCameraLngLat(),
                    l = e.getCameraAltitude(),
                    u = this.terrain
                      ? this.terrain.getElevationForLngLatZoom(i, e.zoom)
                      : 0;
                  if (l < u) {
                    const d = this.calculateCameraOptionsFromTo(
                      i,
                      u,
                      e.center,
                      e.elevation
                    );
                    return { pitch: d.pitch, zoom: d.zoom };
                  }
                  return {};
                }
                _applyUpdatedTransform(e) {
                  const i = [];
                  if (
                    (i.push((u) => this._elevateCameraIfInsideTerrain(u)),
                    this.transformCameraUpdate &&
                      i.push((u) => this.transformCameraUpdate(u)),
                    !i.length)
                  )
                    return;
                  const l = e.clone();
                  for (const u of i) {
                    const d = l.clone(),
                      {
                        center: g,
                        zoom: w,
                        roll: S,
                        pitch: k,
                        bearing: z,
                        elevation: V,
                      } = u(d);
                    g && d.setCenter(g),
                      V !== void 0 && d.setElevation(V),
                      w !== void 0 && d.setZoom(w),
                      S !== void 0 && d.setRoll(S),
                      k !== void 0 && d.setPitch(k),
                      z !== void 0 && d.setBearing(z),
                      l.apply(d);
                  }
                  this.transform.apply(l);
                }
                _fireMoveEvents(e) {
                  this.fire(new s.l("move", e)),
                    this._zooming && this.fire(new s.l("zoom", e)),
                    this._rotating && this.fire(new s.l("rotate", e)),
                    this._pitching && this.fire(new s.l("pitch", e)),
                    this._rolling && this.fire(new s.l("roll", e));
                }
                _afterEase(e, i) {
                  if (this._easeId && i && this._easeId === i) return;
                  delete this._easeId;
                  const l = this._zooming,
                    u = this._rotating,
                    d = this._pitching,
                    g = this._rolling;
                  (this._moving = !1),
                    (this._zooming = !1),
                    (this._rotating = !1),
                    (this._pitching = !1),
                    (this._rolling = !1),
                    (this._padding = !1),
                    l && this.fire(new s.l("zoomend", e)),
                    u && this.fire(new s.l("rotateend", e)),
                    d && this.fire(new s.l("pitchend", e)),
                    g && this.fire(new s.l("rollend", e)),
                    this.fire(new s.l("moveend", e));
                }
                flyTo(e, i) {
                  if (!e.essential && re.prefersReducedMotion) {
                    const ot = s.S(e, [
                      "center",
                      "zoom",
                      "bearing",
                      "pitch",
                      "roll",
                      "elevation",
                      "padding",
                    ]);
                    return this.jumpTo(ot, i);
                  }
                  this.stop(),
                    (e = s.e(
                      { offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.cr },
                      e
                    ));
                  const l = this._getTransformForUpdate(),
                    u = l.bearing,
                    d = l.pitch,
                    g = l.roll,
                    w = l.padding,
                    S =
                      "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
                    k = "pitch" in e ? +e.pitch : d,
                    z = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
                    V = "padding" in e ? e.padding : l.padding,
                    F = s.P.convert(e.offset);
                  let $ = l.centerPoint.add(F);
                  const J = l.screenPointToLocation($),
                    ae = this.cameraHelper.handleFlyTo(l, {
                      bearing: S,
                      pitch: k,
                      roll: z,
                      padding: V,
                      locationAtOffset: J,
                      offsetAsPoint: F,
                      center: e.center,
                      minZoom: e.minZoom,
                      zoom: e.zoom,
                    });
                  let oe = e.curve;
                  const se = Math.max(l.width, l.height),
                    fe = se / ae.scaleOfZoom,
                    be = ae.pixelPathLength;
                  typeof ae.scaleOfMinZoom == "number" &&
                    (oe = Math.sqrt((se / ae.scaleOfMinZoom / be) * 2));
                  const pe = oe * oe;
                  function we(ot) {
                    const Zt =
                      (fe * fe - se * se + (ot ? -1 : 1) * pe * pe * be * be) /
                      (2 * (ot ? fe : se) * pe * be);
                    return Math.log(Math.sqrt(Zt * Zt + 1) - Zt);
                  }
                  function Pe(ot) {
                    return (Math.exp(ot) - Math.exp(-ot)) / 2;
                  }
                  function ve(ot) {
                    return (Math.exp(ot) + Math.exp(-ot)) / 2;
                  }
                  const Re = we(!1);
                  let it = function (ot) {
                      return ve(Re) / ve(Re + oe * ot);
                    },
                    Qe = function (ot) {
                      return (
                        (se *
                          ((ve(Re) * (Pe((Zt = Re + oe * ot)) / ve(Zt)) -
                            Pe(Re)) /
                            pe)) /
                        be
                      );
                      var Zt;
                    },
                    tt = (we(!0) - Re) / oe;
                  if (Math.abs(be) < 2e-6 || !isFinite(tt)) {
                    if (Math.abs(se - fe) < 1e-6) return this.easeTo(e, i);
                    const ot = fe < se ? -1 : 1;
                    (tt = Math.abs(Math.log(fe / se)) / oe),
                      (Qe = () => 0),
                      (it = (Zt) => Math.exp(ot * oe * Zt));
                  }
                  return (
                    (e.duration =
                      "duration" in e
                        ? +e.duration
                        : (1e3 * tt) /
                          ("screenSpeed" in e
                            ? +e.screenSpeed / oe
                            : +e.speed)),
                    e.maxDuration &&
                      e.duration > e.maxDuration &&
                      (e.duration = 0),
                    (this._zooming = !0),
                    (this._rotating = u !== S),
                    (this._pitching = k !== d),
                    (this._rolling = z !== g),
                    (this._padding = !l.isPaddingEqual(V)),
                    this._prepareEase(i, !1),
                    this.terrain && this._prepareElevation(ae.targetCenter),
                    this._ease(
                      (ot) => {
                        const Zt = ot * tt,
                          Ht = 1 / it(Zt),
                          Pt = Qe(Zt);
                        this._rotating && l.setBearing(s.F.number(u, S, ot)),
                          this._pitching && l.setPitch(s.F.number(d, k, ot)),
                          this._rolling && l.setRoll(s.F.number(g, z, ot)),
                          this._padding &&
                            (l.interpolatePadding(w, V, ot),
                            ($ = l.centerPoint.add(F))),
                          ae.easeFunc(ot, Ht, Pt, $),
                          this.terrain &&
                            !e.freezeElevation &&
                            this._updateElevation(ot),
                          this._applyUpdatedTransform(l),
                          this._fireMoveEvents(i);
                      },
                      () => {
                        this.terrain &&
                          e.freezeElevation &&
                          this._finalizeElevation(),
                          this._afterEase(i);
                      },
                      e
                    ),
                    this
                  );
                }
                isEasing() {
                  return !!this._easeFrameId;
                }
                stop() {
                  return this._stop();
                }
                _stop(e, i) {
                  var l;
                  if (
                    (this._easeFrameId &&
                      (this._cancelRenderFrame(this._easeFrameId),
                      delete this._easeFrameId,
                      delete this._onEaseFrame),
                    this._onEaseEnd)
                  ) {
                    const u = this._onEaseEnd;
                    delete this._onEaseEnd, u.call(this, i);
                  }
                  return (
                    e ||
                      (l = this.handlers) === null ||
                      l === void 0 ||
                      l.stop(!1),
                    this
                  );
                }
                _ease(e, i, l) {
                  l.animate === !1 || l.duration === 0
                    ? (e(1), i())
                    : ((this._easeStart = ne()),
                      (this._easeOptions = l),
                      (this._onEaseFrame = e),
                      (this._onEaseEnd = i),
                      (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback
                      )));
                }
                _normalizeBearing(e, i) {
                  e = s.V(e, -180, 180);
                  const l = Math.abs(e - i);
                  return (
                    Math.abs(e - 360 - i) < l && (e -= 360),
                    Math.abs(e + 360 - i) < l && (e += 360),
                    e
                  );
                }
                queryTerrainElevation(e) {
                  return this.terrain
                    ? this.terrain.getElevationForLngLatZoom(
                        s.U.convert(e),
                        this.transform.tileZoom
                      )
                    : null;
                }
              }
              const il = {
                compact: !0,
                customAttribution:
                  '<a href="https://maplibre.org/" target="_blank">MapLibre</a>',
              };
              class Ui {
                constructor(e = il) {
                  (this._toggleAttribution = () => {
                    this._container.classList.contains("maplibregl-compact") &&
                      (this._container.classList.contains(
                        "maplibregl-compact-show"
                      )
                        ? (this._container.setAttribute("open", ""),
                          this._container.classList.remove(
                            "maplibregl-compact-show"
                          ))
                        : (this._container.classList.add(
                            "maplibregl-compact-show"
                          ),
                          this._container.removeAttribute("open")));
                  }),
                    (this._updateData = (i) => {
                      !i ||
                        (i.sourceDataType !== "metadata" &&
                          i.sourceDataType !== "visibility" &&
                          i.dataType !== "style" &&
                          i.type !== "terrain") ||
                        this._updateAttributions();
                    }),
                    (this._updateCompact = () => {
                      this._map.getCanvasContainer().offsetWidth <= 640 ||
                      this._compact
                        ? this._compact === !1
                          ? this._container.setAttribute("open", "")
                          : this._container.classList.contains(
                              "maplibregl-compact"
                            ) ||
                            this._container.classList.contains(
                              "maplibregl-attrib-empty"
                            ) ||
                            (this._container.setAttribute("open", ""),
                            this._container.classList.add(
                              "maplibregl-compact",
                              "maplibregl-compact-show"
                            ))
                        : (this._container.setAttribute("open", ""),
                          this._container.classList.contains(
                            "maplibregl-compact"
                          ) &&
                            this._container.classList.remove(
                              "maplibregl-compact",
                              "maplibregl-compact-show"
                            ));
                    }),
                    (this._updateCompactMinimize = () => {
                      this._container.classList.contains(
                        "maplibregl-compact"
                      ) &&
                        this._container.classList.contains(
                          "maplibregl-compact-show"
                        ) &&
                        this._container.classList.remove(
                          "maplibregl-compact-show"
                        );
                    }),
                    (this.options = e);
                }
                getDefaultPosition() {
                  return "bottom-right";
                }
                onAdd(e) {
                  return (
                    (this._map = e),
                    (this._compact = this.options.compact),
                    (this._container = Y.create(
                      "details",
                      "maplibregl-ctrl maplibregl-ctrl-attrib"
                    )),
                    (this._compactButton = Y.create(
                      "summary",
                      "maplibregl-ctrl-attrib-button",
                      this._container
                    )),
                    this._compactButton.addEventListener(
                      "click",
                      this._toggleAttribution
                    ),
                    this._setElementTitle(
                      this._compactButton,
                      "ToggleAttribution"
                    ),
                    (this._innerContainer = Y.create(
                      "div",
                      "maplibregl-ctrl-attrib-inner",
                      this._container
                    )),
                    this._updateAttributions(),
                    this._updateCompact(),
                    this._map.on("styledata", this._updateData),
                    this._map.on("sourcedata", this._updateData),
                    this._map.on("terrain", this._updateData),
                    this._map.on("resize", this._updateCompact),
                    this._map.on("drag", this._updateCompactMinimize),
                    this._container
                  );
                }
                onRemove() {
                  Y.remove(this._container),
                    this._map.off("styledata", this._updateData),
                    this._map.off("sourcedata", this._updateData),
                    this._map.off("terrain", this._updateData),
                    this._map.off("resize", this._updateCompact),
                    this._map.off("drag", this._updateCompactMinimize),
                    (this._map = void 0),
                    (this._compact = void 0),
                    (this._attribHTML = void 0);
                }
                _setElementTitle(e, i) {
                  const l = this._map._getUIString(`AttributionControl.${i}`);
                  (e.title = l), e.setAttribute("aria-label", l);
                }
                _updateAttributions() {
                  if (!this._map.style) return;
                  let e = [];
                  if (
                    (this.options.customAttribution &&
                      (Array.isArray(this.options.customAttribution)
                        ? (e = e.concat(
                            this.options.customAttribution.map((u) =>
                              typeof u != "string" ? "" : u
                            )
                          ))
                        : typeof this.options.customAttribution == "string" &&
                          e.push(this.options.customAttribution)),
                    this._map.style.stylesheet)
                  ) {
                    const u = this._map.style.stylesheet;
                    (this.styleOwner = u.owner), (this.styleId = u.id);
                  }
                  const i = this._map.style.tileManagers;
                  for (const u in i) {
                    const d = i[u];
                    if (d.used || d.usedForTerrain) {
                      const g = d.getSource();
                      g.attribution &&
                        e.indexOf(g.attribution) < 0 &&
                        e.push(g.attribution);
                    }
                  }
                  (e = e.filter((u) => String(u).trim())),
                    e.sort((u, d) => u.length - d.length),
                    (e = e.filter((u, d) => {
                      for (let g = d + 1; g < e.length; g++)
                        if (e[g].indexOf(u) >= 0) return !1;
                      return !0;
                    }));
                  const l = e.join(" | ");
                  l !== this._attribHTML &&
                    ((this._attribHTML = l),
                    e.length
                      ? ((this._innerContainer.innerHTML = Y.sanitize(l)),
                        this._container.classList.remove(
                          "maplibregl-attrib-empty"
                        ))
                      : this._container.classList.add(
                          "maplibregl-attrib-empty"
                        ),
                    this._updateCompact(),
                    (this._editLink = null));
                }
              }
              class Tu {
                constructor(e = {}) {
                  (this._updateCompact = () => {
                    const i = this._container.children;
                    if (i.length) {
                      const l = i[0];
                      this._map.getCanvasContainer().offsetWidth <= 640 ||
                      this._compact
                        ? this._compact !== !1 &&
                          l.classList.add("maplibregl-compact")
                        : l.classList.remove("maplibregl-compact");
                    }
                  }),
                    (this.options = e);
                }
                getDefaultPosition() {
                  return "bottom-left";
                }
                onAdd(e) {
                  (this._map = e),
                    (this._compact = this.options && this.options.compact),
                    (this._container = Y.create("div", "maplibregl-ctrl"));
                  const i = Y.create("a", "maplibregl-ctrl-logo");
                  return (
                    (i.target = "_blank"),
                    (i.rel = "noopener nofollow"),
                    (i.href = "https://maplibre.org/"),
                    i.setAttribute(
                      "aria-label",
                      this._map._getUIString("LogoControl.Title")
                    ),
                    i.setAttribute("rel", "noopener nofollow"),
                    this._container.appendChild(i),
                    (this._container.style.display = "block"),
                    this._map.on("resize", this._updateCompact),
                    this._updateCompact(),
                    this._container
                  );
                }
                onRemove() {
                  Y.remove(this._container),
                    this._map.off("resize", this._updateCompact),
                    (this._map = void 0),
                    (this._compact = void 0);
                }
              }
              class Aa {
                constructor() {
                  (this._queue = []),
                    (this._id = 0),
                    (this._cleared = !1),
                    (this._currentlyRunning = !1);
                }
                add(e) {
                  const i = ++this._id;
                  return (
                    this._queue.push({ callback: e, id: i, cancelled: !1 }), i
                  );
                }
                remove(e) {
                  const i = this._currentlyRunning,
                    l = i ? this._queue.concat(i) : this._queue;
                  for (const u of l)
                    if (u.id === e) return void (u.cancelled = !0);
                }
                run(e = 0) {
                  if (this._currentlyRunning)
                    throw new Error(
                      "Attempting to run(), but is already running."
                    );
                  const i = (this._currentlyRunning = this._queue);
                  this._queue = [];
                  for (const l of i)
                    if (!l.cancelled && (l.callback(e), this._cleared)) break;
                  (this._cleared = !1), (this._currentlyRunning = !1);
                }
                clear() {
                  this._currentlyRunning && (this._cleared = !0),
                    (this._queue = []);
                }
              }
              var $d = s.aN([
                { name: "a_pos3d", type: "Int16", components: 3 },
              ]);
              class bf extends s.E {
                constructor(e) {
                  super(),
                    (this._lastTilesetChange = ne()),
                    (this.tileManager = e),
                    (this._tiles = {}),
                    (this._renderableTilesKeys = []),
                    (this._sourceTileCache = {}),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.deltaZoom = 1),
                    (this.tileSize = e._source.tileSize * 2 ** this.deltaZoom),
                    (e.usedForTerrain = !0),
                    (e.tileSize = this.tileSize);
                }
                destruct() {
                  (this.tileManager.usedForTerrain = !1),
                    (this.tileManager.tileSize = null);
                }
                getSource() {
                  return this.tileManager._source;
                }
                update(e, i) {
                  this.tileManager.update(e, i),
                    (this._renderableTilesKeys = []);
                  const l = {};
                  for (const u of Ur(e, {
                    tileSize: this.tileSize,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    reparseOverscaled: !1,
                    terrain: i,
                    calculateTileZoom:
                      this.tileManager._source.calculateTileZoom,
                  }))
                    (l[u.key] = !0),
                      this._renderableTilesKeys.push(u.key),
                      this._tiles[u.key] ||
                        ((u.terrainRttPosMatrix32f = new Float64Array(16)),
                        s.c0(u.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1),
                        (this._tiles[u.key] = new W(u, this.tileSize)),
                        (this._lastTilesetChange = ne()));
                  for (const u in this._tiles) l[u] || delete this._tiles[u];
                }
                freeRtt(e) {
                  for (const i in this._tiles) {
                    const l = this._tiles[i];
                    (!e ||
                      l.tileID.equals(e) ||
                      l.tileID.isChildOf(e) ||
                      e.isChildOf(l.tileID)) &&
                      (l.rtt = []);
                  }
                }
                getRenderableTiles() {
                  return this._renderableTilesKeys.map((e) =>
                    this.getTileByID(e)
                  );
                }
                getTileByID(e) {
                  return this._tiles[e];
                }
                getTerrainCoords(e, i) {
                  return i
                    ? this._getTerrainCoordsForTileRanges(e, i)
                    : this._getTerrainCoordsForRegularTile(e);
                }
                _getTerrainCoordsForRegularTile(e) {
                  const i = {};
                  for (const l of this._renderableTilesKeys) {
                    const u = this._tiles[l].tileID,
                      d = e.clone(),
                      g = s.bd();
                    if (u.canonical.equals(e.canonical))
                      s.c0(g, 0, s.a3, s.a3, 0, 0, 1);
                    else if (u.canonical.isChildOf(e.canonical)) {
                      const w = u.canonical.z - e.canonical.z,
                        S = u.canonical.x - ((u.canonical.x >> w) << w),
                        k = u.canonical.y - ((u.canonical.y >> w) << w),
                        z = s.a3 >> w;
                      s.c0(g, 0, z, z, 0, 0, 1), s.N(g, g, [-S * z, -k * z, 0]);
                    } else {
                      if (!e.canonical.isChildOf(u.canonical)) continue;
                      {
                        const w = e.canonical.z - u.canonical.z,
                          S = e.canonical.x - ((e.canonical.x >> w) << w),
                          k = e.canonical.y - ((e.canonical.y >> w) << w),
                          z = s.a3 >> w;
                        s.c0(g, 0, s.a3, s.a3, 0, 0, 1),
                          s.N(g, g, [S * z, k * z, 0]),
                          s.O(g, g, [1 / 2 ** w, 1 / 2 ** w, 0]);
                      }
                    }
                    (d.terrainRttPosMatrix32f = new Float32Array(g)),
                      (i[l] = d);
                  }
                  return i;
                }
                _getTerrainCoordsForTileRanges(e, i) {
                  const l = {};
                  for (const u of this._renderableTilesKeys) {
                    const d = this._tiles[u].tileID;
                    if (!this._isWithinTileRanges(d, i)) continue;
                    const g = e.clone(),
                      w = s.bd();
                    if (d.canonical.z === e.canonical.z) {
                      const S = e.canonical.x - d.canonical.x,
                        k = e.canonical.y - d.canonical.y;
                      s.c0(w, 0, s.a3, s.a3, 0, 0, 1),
                        s.N(w, w, [S * s.a3, k * s.a3, 0]);
                    } else if (d.canonical.z > e.canonical.z) {
                      const S = d.canonical.z - e.canonical.z,
                        k = d.canonical.x - ((d.canonical.x >> S) << S),
                        z = d.canonical.y - ((d.canonical.y >> S) << S),
                        V = e.canonical.x - (d.canonical.x >> S),
                        F = e.canonical.y - (d.canonical.y >> S),
                        $ = s.a3 >> S;
                      s.c0(w, 0, $, $, 0, 0, 1),
                        s.N(w, w, [-k * $ + V * s.a3, -z * $ + F * s.a3, 0]);
                    } else {
                      const S = e.canonical.z - d.canonical.z,
                        k = e.canonical.x - ((e.canonical.x >> S) << S),
                        z = e.canonical.y - ((e.canonical.y >> S) << S),
                        V = (e.canonical.x >> S) - d.canonical.x,
                        F = (e.canonical.y >> S) - d.canonical.y,
                        $ = s.a3 << S;
                      s.c0(w, 0, $, $, 0, 0, 1),
                        s.N(w, w, [k * s.a3 + V * $, z * s.a3 + F * $, 0]);
                    }
                    (g.terrainRttPosMatrix32f = new Float32Array(w)),
                      (l[u] = g);
                  }
                  return l;
                }
                getSourceTile(e, i) {
                  const l = this.tileManager._source;
                  let u = e.overscaledZ - this.deltaZoom;
                  if ((u > l.maxzoom && (u = l.maxzoom), u < l.minzoom))
                    return null;
                  this._sourceTileCache[e.key] ||
                    (this._sourceTileCache[e.key] = e.scaledTo(u).key);
                  let d = this.tileManager.getTileByID(
                    this._sourceTileCache[e.key]
                  );
                  if ((!d || !d.dem) && i)
                    for (; u >= l.minzoom && (!d || !d.dem); )
                      d = this.tileManager.getTileByID(e.scaledTo(u--).key);
                  return d;
                }
                anyTilesAfterTime(e = Date.now()) {
                  return this._lastTilesetChange >= e;
                }
                _isWithinTileRanges(e, i) {
                  return (
                    i[e.canonical.z] &&
                    e.canonical.x >= i[e.canonical.z].minTileX &&
                    e.canonical.x <= i[e.canonical.z].maxTileX &&
                    e.canonical.y >= i[e.canonical.z].minTileY &&
                    e.canonical.y <= i[e.canonical.z].maxTileY
                  );
                }
              }
              class wf {
                constructor(e, i, l) {
                  (this._meshCache = {}),
                    (this.painter = e),
                    (this.tileManager = new bf(i)),
                    (this.options = l),
                    (this.exaggeration =
                      typeof l.exaggeration == "number" ? l.exaggeration : 1),
                    (this.qualityFactor = 2),
                    (this.meshSize = 128),
                    (this._demMatrixCache = {}),
                    (this.coordsIndex = []),
                    (this._coordsTextureSize = 1024);
                }
                getDEMElevation(e, i, l, u = s.a3) {
                  var d;
                  if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
                  const g = this.getTerrainData(e),
                    w = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
                  if (!w) return 0;
                  const S = s.cv(
                      [],
                      [(i / u) * s.a3, (l / u) * s.a3],
                      g.u_terrain_matrix
                    ),
                    k = [S[0] * w.dim, S[1] * w.dim],
                    z = Math.floor(k[0]),
                    V = Math.floor(k[1]),
                    F = k[0] - z,
                    $ = k[1] - V;
                  return (
                    w.get(z, V) * (1 - F) * (1 - $) +
                    w.get(z + 1, V) * F * (1 - $) +
                    w.get(z, V + 1) * (1 - F) * $ +
                    w.get(z + 1, V + 1) * F * $
                  );
                }
                getElevationForLngLatZoom(e, i) {
                  if (!s.cw(i, e.wrap())) return 0;
                  const {
                    tileID: l,
                    mercatorX: u,
                    mercatorY: d,
                  } = this._getOverscaledTileIDFromLngLatZoom(e, i);
                  return this.getElevation(l, u % s.a3, d % s.a3, s.a3);
                }
                getElevation(e, i, l, u = s.a3) {
                  return this.getDEMElevation(e, i, l, u) * this.exaggeration;
                }
                getTerrainData(e) {
                  if (!this._emptyDemTexture) {
                    const u = this.painter.context,
                      d = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
                    (this._emptyDepthTexture = new s.T(u, d, u.gl.RGBA, {
                      premultiply: !1,
                    })),
                      (this._emptyDemUnpack = [0, 0, 0, 0]),
                      (this._emptyDemTexture = new s.T(
                        u,
                        new s.R({ width: 1, height: 1 }),
                        u.gl.RGBA,
                        { premultiply: !1 }
                      )),
                      this._emptyDemTexture.bind(
                        u.gl.NEAREST,
                        u.gl.CLAMP_TO_EDGE
                      ),
                      (this._emptyDemMatrix = s.am([]));
                  }
                  const i = this.tileManager.getSourceTile(e, !0);
                  if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
                    const u = this.painter.context;
                    (i.demTexture = this.painter.getTileTexture(i.dem.stride)),
                      i.demTexture
                        ? i.demTexture.update(i.dem.getPixels(), {
                            premultiply: !1,
                          })
                        : (i.demTexture = new s.T(
                            u,
                            i.dem.getPixels(),
                            u.gl.RGBA,
                            { premultiply: !1 }
                          )),
                      i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE),
                      (i.needsTerrainPrepare = !1);
                  }
                  const l = i && i + i.tileID.key + e.key;
                  if (l && !this._demMatrixCache[l]) {
                    const u = this.tileManager.getSource().maxzoom;
                    let d = e.canonical.z - i.tileID.canonical.z;
                    e.overscaledZ > e.canonical.z &&
                      (e.canonical.z >= u
                        ? (d = e.canonical.z - u)
                        : s.w(
                            "cannot calculate elevation if elevation maxzoom > source.maxzoom"
                          ));
                    const g = e.canonical.x - ((e.canonical.x >> d) << d),
                      w = e.canonical.y - ((e.canonical.y >> d) << d),
                      S = s.cx(new Float64Array(16), [
                        1 / (s.a3 << d),
                        1 / (s.a3 << d),
                        0,
                      ]);
                    s.N(S, S, [g * s.a3, w * s.a3, 0]),
                      (this._demMatrixCache[e.key] = { matrix: S, coord: e });
                  }
                  return {
                    u_depth: 2,
                    u_terrain: 3,
                    u_terrain_dim: (i && i.dem && i.dem.dim) || 1,
                    u_terrain_matrix: l
                      ? this._demMatrixCache[e.key].matrix
                      : this._emptyDemMatrix,
                    u_terrain_unpack:
                      (i && i.dem && i.dem.getUnpackVector()) ||
                      this._emptyDemUnpack,
                    u_terrain_exaggeration: this.exaggeration,
                    texture: ((i && i.demTexture) || this._emptyDemTexture)
                      .texture,
                    depthTexture: (
                      this._fboDepthTexture || this._emptyDepthTexture
                    ).texture,
                    tile: i,
                  };
                }
                getFramebuffer(e) {
                  const i = this.painter,
                    l = i.width / devicePixelRatio,
                    u = i.height / devicePixelRatio;
                  return (
                    !this._fbo ||
                      (this._fbo.width === l && this._fbo.height === u) ||
                      (this._fbo.destroy(),
                      this._fboCoordsTexture.destroy(),
                      this._fboDepthTexture.destroy(),
                      delete this._fbo,
                      delete this._fboDepthTexture,
                      delete this._fboCoordsTexture),
                    this._fboCoordsTexture ||
                      ((this._fboCoordsTexture = new s.T(
                        i.context,
                        { width: l, height: u, data: null },
                        i.context.gl.RGBA,
                        { premultiply: !1 }
                      )),
                      this._fboCoordsTexture.bind(
                        i.context.gl.NEAREST,
                        i.context.gl.CLAMP_TO_EDGE
                      )),
                    this._fboDepthTexture ||
                      ((this._fboDepthTexture = new s.T(
                        i.context,
                        { width: l, height: u, data: null },
                        i.context.gl.RGBA,
                        { premultiply: !1 }
                      )),
                      this._fboDepthTexture.bind(
                        i.context.gl.NEAREST,
                        i.context.gl.CLAMP_TO_EDGE
                      )),
                    this._fbo ||
                      ((this._fbo = i.context.createFramebuffer(l, u, !0, !1)),
                      this._fbo.depthAttachment.set(
                        i.context.createRenderbuffer(
                          i.context.gl.DEPTH_COMPONENT16,
                          l,
                          u
                        )
                      )),
                    this._fbo.colorAttachment.set(
                      e === "coords"
                        ? this._fboCoordsTexture.texture
                        : this._fboDepthTexture.texture
                    ),
                    this._fbo
                  );
                }
                getCoordsTexture() {
                  const e = this.painter.context;
                  if (this._coordsTexture) return this._coordsTexture;
                  const i = new Uint8Array(
                    this._coordsTextureSize * this._coordsTextureSize * 4
                  );
                  for (let d = 0, g = 0; d < this._coordsTextureSize; d++)
                    for (let w = 0; w < this._coordsTextureSize; w++, g += 4)
                      (i[g + 0] = 255 & w),
                        (i[g + 1] = 255 & d),
                        (i[g + 2] = ((w >> 8) << 4) | (d >> 8)),
                        (i[g + 3] = 0);
                  const l = new s.R(
                      {
                        width: this._coordsTextureSize,
                        height: this._coordsTextureSize,
                      },
                      new Uint8Array(i.buffer)
                    ),
                    u = new s.T(e, l, e.gl.RGBA, { premultiply: !1 });
                  return (
                    u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
                    (this._coordsTexture = u),
                    u
                  );
                }
                pointCoordinate(e) {
                  this.painter.maybeDrawDepthAndCoords(!0);
                  const i = new Uint8Array(4),
                    l = this.painter.context,
                    u = l.gl,
                    d = Math.round(
                      (e.x * this.painter.pixelRatio) / devicePixelRatio
                    ),
                    g = Math.round(
                      (e.y * this.painter.pixelRatio) / devicePixelRatio
                    ),
                    w = Math.round(this.painter.height / devicePixelRatio);
                  l.bindFramebuffer.set(
                    this.getFramebuffer("coords").framebuffer
                  ),
                    u.readPixels(
                      d,
                      w - g - 1,
                      1,
                      1,
                      u.RGBA,
                      u.UNSIGNED_BYTE,
                      i
                    ),
                    l.bindFramebuffer.set(null);
                  const S = i[0] + ((i[2] >> 4) << 8),
                    k = i[1] + ((15 & i[2]) << 8),
                    z = this.coordsIndex[255 - i[3]],
                    V = z && this.tileManager.getTileByID(z);
                  if (!V) return null;
                  const F = this._coordsTextureSize,
                    $ = (1 << V.tileID.canonical.z) * F;
                  return new s.a5(
                    (V.tileID.canonical.x * F + S) / $ + V.tileID.wrap,
                    (V.tileID.canonical.y * F + k) / $,
                    this.getElevation(V.tileID, S, k, F)
                  );
                }
                depthAtPoint(e) {
                  const i = new Uint8Array(4),
                    l = this.painter.context,
                    u = l.gl;
                  return (
                    l.bindFramebuffer.set(
                      this.getFramebuffer("depth").framebuffer
                    ),
                    u.readPixels(
                      e.x,
                      this.painter.height / devicePixelRatio - e.y - 1,
                      1,
                      1,
                      u.RGBA,
                      u.UNSIGNED_BYTE,
                      i
                    ),
                    l.bindFramebuffer.set(null),
                    (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
                  );
                }
                getTerrainMesh(e) {
                  var i;
                  const l =
                      ((i = this.painter.style.projection) === null ||
                      i === void 0
                        ? void 0
                        : i.transitionState) > 0,
                    u = l && e.canonical.y === 0,
                    d = l && e.canonical.y === (1 << e.canonical.z) - 1,
                    g = `m_${u ? "n" : ""}_${d ? "s" : ""}`;
                  if (this._meshCache[g]) return this._meshCache[g];
                  const w = this.painter.context,
                    S = new s.cy(),
                    k = new s.aR(),
                    z = this.meshSize,
                    V = s.a3 / z,
                    F = z * z;
                  for (let ve = 0; ve <= z; ve++)
                    for (let Re = 0; Re <= z; Re++)
                      S.emplaceBack(Re * V, ve * V, 0);
                  for (let ve = 0; ve < F; ve += z + 1)
                    for (let Re = 0; Re < z; Re++)
                      k.emplaceBack(Re + ve, z + Re + ve + 1, z + Re + ve + 2),
                        k.emplaceBack(Re + ve, z + Re + ve + 2, Re + ve + 1);
                  const $ = S.length,
                    J = $ + (z + 1),
                    ae = (z + 1) * z,
                    oe = u ? s.bk : 0,
                    se = u ? 0 : 1,
                    fe = d ? s.bl : s.a3,
                    be = d ? 0 : 1;
                  for (let ve = 0; ve <= z; ve++) S.emplaceBack(ve * V, oe, se);
                  for (let ve = 0; ve <= z; ve++) S.emplaceBack(ve * V, fe, be);
                  for (let ve = 0; ve < z; ve++)
                    k.emplaceBack(ae + ve, J + ve, J + ve + 1),
                      k.emplaceBack(ae + ve, J + ve + 1, ae + ve + 1),
                      k.emplaceBack(0 + ve, $ + ve + 1, $ + ve),
                      k.emplaceBack(0 + ve, 0 + ve + 1, $ + ve + 1);
                  const pe = S.length,
                    we = pe + 2 * (z + 1);
                  for (const ve of [0, 1])
                    for (let Re = 0; Re <= z; Re++)
                      for (const it of [0, 1])
                        S.emplaceBack(ve * s.a3, Re * V, it);
                  for (let ve = 0; ve < 2 * z; ve += 2)
                    k.emplaceBack(pe + ve, pe + ve + 1, pe + ve + 3),
                      k.emplaceBack(pe + ve, pe + ve + 3, pe + ve + 2),
                      k.emplaceBack(we + ve, we + ve + 3, we + ve + 1),
                      k.emplaceBack(we + ve, we + ve + 2, we + ve + 3);
                  const Pe = new Cn(
                    w.createVertexBuffer(S, $d.members),
                    w.createIndexBuffer(k),
                    s.aQ.simpleSegment(0, 0, S.length, k.length)
                  );
                  return (this._meshCache[g] = Pe), Pe;
                }
                getMeshFrameDelta(e) {
                  return (2 * Math.PI * s.bx) / Math.pow(2, Math.max(e, 0)) / 5;
                }
                getMinTileElevationForLngLatZoom(e, i) {
                  var l;
                  const { tileID: u } = this._getOverscaledTileIDFromLngLatZoom(
                    e,
                    i
                  );
                  return (l = this.getMinMaxElevation(u).minElevation) !==
                    null && l !== void 0
                    ? l
                    : 0;
                }
                getMinMaxElevation(e) {
                  const i = this.getTerrainData(e).tile,
                    l = { minElevation: null, maxElevation: null };
                  return (
                    i &&
                      i.dem &&
                      ((l.minElevation = i.dem.min * this.exaggeration),
                      (l.maxElevation = i.dem.max * this.exaggeration)),
                    l
                  );
                }
                _getOverscaledTileIDFromLngLatZoom(e, i) {
                  const l = s.a5.fromLngLat(e.wrap()),
                    u = (1 << i) * s.a3,
                    d = l.x * u,
                    g = l.y * u,
                    w = Math.floor(d / s.a3),
                    S = Math.floor(g / s.a3);
                  return {
                    tileID: new s.a0(i, 0, i, w, S),
                    mercatorX: d,
                    mercatorY: g,
                  };
                }
              }
              class Tf {
                constructor(e, i, l) {
                  (this._context = e),
                    (this._size = i),
                    (this._tileSize = l),
                    (this._objects = []),
                    (this._recentlyUsed = []),
                    (this._stamp = 0);
                }
                destruct() {
                  for (const e of this._objects)
                    e.texture.destroy(), e.fbo.destroy();
                }
                _createObject(e) {
                  const i = this._context.createFramebuffer(
                      this._tileSize,
                      this._tileSize,
                      !0,
                      !0
                    ),
                    l = new s.T(
                      this._context,
                      {
                        width: this._tileSize,
                        height: this._tileSize,
                        data: null,
                      },
                      this._context.gl.RGBA
                    );
                  return (
                    l.bind(
                      this._context.gl.LINEAR,
                      this._context.gl.CLAMP_TO_EDGE
                    ),
                    this._context.extTextureFilterAnisotropic &&
                      this._context.gl.texParameterf(
                        this._context.gl.TEXTURE_2D,
                        this._context.extTextureFilterAnisotropic
                          .TEXTURE_MAX_ANISOTROPY_EXT,
                        this._context.extTextureFilterAnisotropicMax
                      ),
                    i.depthAttachment.set(
                      this._context.createRenderbuffer(
                        this._context.gl.DEPTH_STENCIL,
                        this._tileSize,
                        this._tileSize
                      )
                    ),
                    i.colorAttachment.set(l.texture),
                    { id: e, fbo: i, texture: l, stamp: -1, inUse: !1 }
                  );
                }
                getObjectForId(e) {
                  return this._objects[e];
                }
                useObject(e) {
                  (e.inUse = !0),
                    (this._recentlyUsed = this._recentlyUsed.filter(
                      (i) => e.id !== i
                    )),
                    this._recentlyUsed.push(e.id);
                }
                stampObject(e) {
                  e.stamp = ++this._stamp;
                }
                getOrCreateFreeObject() {
                  for (const i of this._recentlyUsed)
                    if (!this._objects[i].inUse) return this._objects[i];
                  if (this._objects.length >= this._size)
                    throw new Error(
                      "No free RenderPool available, call freeAllObjects() required!"
                    );
                  const e = this._createObject(this._objects.length);
                  return this._objects.push(e), e;
                }
                freeObject(e) {
                  e.inUse = !1;
                }
                freeAllObjects() {
                  for (const e of this._objects) this.freeObject(e);
                }
                isFull() {
                  return (
                    !(this._objects.length < this._size) &&
                    this._objects.some((e) => !e.inUse) === !1
                  );
                }
              }
              const qa = {
                background: !0,
                fill: !0,
                line: !0,
                raster: !0,
                hillshade: !0,
                "color-relief": !0,
              };
              class ti {
                constructor(e, i) {
                  (this.painter = e),
                    (this.terrain = i),
                    (this.pool = new Tf(
                      e.context,
                      30,
                      i.tileManager.tileSize * i.qualityFactor
                    ));
                }
                destruct() {
                  this.pool.destruct();
                }
                getTexture(e) {
                  return this.pool.getObjectForId(
                    e.rtt[this._stacks.length - 1].id
                  ).texture;
                }
                prepareForRender(e, i) {
                  (this._stacks = []),
                    (this._prevType = null),
                    (this._rttTiles = []),
                    (this._renderableTiles =
                      this.terrain.tileManager.getRenderableTiles()),
                    (this._renderableLayerIds = e._order.filter(
                      (l) => !e._layers[l].isHidden(i)
                    )),
                    (this._coordsAscending = {});
                  for (const l in e.tileManagers) {
                    this._coordsAscending[l] = {};
                    const u = e.tileManagers[l].getVisibleCoordinates(),
                      d = e.tileManagers[l].getSource(),
                      g = d instanceof ar ? d.terrainTileRanges : null;
                    for (const w of u) {
                      const S = this.terrain.tileManager.getTerrainCoords(w, g);
                      for (const k in S)
                        this._coordsAscending[l][k] ||
                          (this._coordsAscending[l][k] = []),
                          this._coordsAscending[l][k].push(S[k]);
                    }
                  }
                  this._coordsAscendingStr = {};
                  for (const l of e._order) {
                    const u = e._layers[l],
                      d = u.source;
                    if (qa[u.type] && !this._coordsAscendingStr[d]) {
                      this._coordsAscendingStr[d] = {};
                      for (const g in this._coordsAscending[d])
                        this._coordsAscendingStr[d][g] = this._coordsAscending[
                          d
                        ][g]
                          .map((w) => w.key)
                          .sort()
                          .join();
                    }
                  }
                  for (const l of this._renderableTiles)
                    for (const u in this._coordsAscendingStr) {
                      const d = this._coordsAscendingStr[u][l.tileID.key];
                      d && d !== l.rttCoords[u] && (l.rtt = []);
                    }
                }
                renderLayer(e, i) {
                  if (e.isHidden(this.painter.transform.zoom)) return !1;
                  const l = Object.assign(Object.assign({}, i), {
                      isRenderingToTexture: !0,
                    }),
                    u = e.type,
                    d = this.painter,
                    g =
                      this._renderableLayerIds[
                        this._renderableLayerIds.length - 1
                      ] === e.id;
                  if (
                    qa[u] &&
                    ((this._prevType && qa[this._prevType]) ||
                      this._stacks.push([]),
                    (this._prevType = u),
                    this._stacks[this._stacks.length - 1].push(e.id),
                    !g)
                  )
                    return !0;
                  if (qa[this._prevType] || (qa[u] && g)) {
                    this._prevType = u;
                    const w = this._stacks.length - 1,
                      S = this._stacks[w] || [];
                    for (const k of this._renderableTiles) {
                      if (
                        (this.pool.isFull() &&
                          (hu(this.painter, this.terrain, this._rttTiles, l),
                          (this._rttTiles = []),
                          this.pool.freeAllObjects()),
                        this._rttTiles.push(k),
                        k.rtt[w])
                      ) {
                        const V = this.pool.getObjectForId(k.rtt[w].id);
                        if (V.stamp === k.rtt[w].stamp) {
                          this.pool.useObject(V);
                          continue;
                        }
                      }
                      const z = this.pool.getOrCreateFreeObject();
                      this.pool.useObject(z),
                        this.pool.stampObject(z),
                        (k.rtt[w] = { id: z.id, stamp: z.stamp }),
                        d.context.bindFramebuffer.set(z.fbo.framebuffer),
                        d.context.clear({
                          color: s.bi.transparent,
                          stencil: 0,
                        }),
                        (d.currentStencilSource = void 0);
                      for (let V = 0; V < S.length; V++) {
                        const F = d.style._layers[S[V]],
                          $ = F.source
                            ? this._coordsAscending[F.source][k.tileID.key]
                            : [k.tileID];
                        d.context.viewport.set([
                          0,
                          0,
                          z.fbo.width,
                          z.fbo.height,
                        ]),
                          d._renderTileClippingMasks(F, $, !0),
                          d.renderLayer(
                            d,
                            d.style.tileManagers[F.source],
                            F,
                            $,
                            l
                          ),
                          F.source &&
                            (k.rttCoords[F.source] =
                              this._coordsAscendingStr[F.source][k.tileID.key]);
                      }
                    }
                    return (
                      hu(this.painter, this.terrain, this._rttTiles, l),
                      (this._rttTiles = []),
                      this.pool.freeAllObjects(),
                      qa[u]
                    );
                  }
                  return !1;
                }
              }
              const ci = {
                  "AttributionControl.ToggleAttribution": "Toggle attribution",
                  "AttributionControl.MapFeedback": "Map feedback",
                  "FullscreenControl.Enter": "Enter fullscreen",
                  "FullscreenControl.Exit": "Exit fullscreen",
                  "GeolocateControl.FindMyLocation": "Find my location",
                  "GeolocateControl.LocationNotAvailable":
                    "Location not available",
                  "LogoControl.Title": "MapLibre logo",
                  "Map.Title": "Map",
                  "Marker.Title": "Map marker",
                  "NavigationControl.ResetBearing": "Reset bearing to north",
                  "NavigationControl.ZoomIn": "Zoom in",
                  "NavigationControl.ZoomOut": "Zoom out",
                  "Popup.Close": "Close popup",
                  "ScaleControl.Feet": "ft",
                  "ScaleControl.Meters": "m",
                  "ScaleControl.Kilometers": "km",
                  "ScaleControl.Miles": "mi",
                  "ScaleControl.NauticalMiles": "nm",
                  "GlobeControl.Enable": "Enable globe",
                  "GlobeControl.Disable": "Disable globe",
                  "TerrainControl.Enable": "Enable terrain",
                  "TerrainControl.Disable": "Disable terrain",
                  "CooperativeGesturesHandler.WindowsHelpText":
                    "Use Ctrl + scroll to zoom the map",
                  "CooperativeGesturesHandler.MacHelpText":
                    "Use ‚åò + scroll to zoom the map",
                  "CooperativeGesturesHandler.MobileHelpText":
                    "Use two fingers to move the map",
                },
                Hd = B,
                Ss = {
                  hash: !1,
                  interactive: !0,
                  bearingSnap: 7,
                  attributionControl: il,
                  maplibreLogo: !1,
                  refreshExpiredTiles: !0,
                  canvasContextAttributes: {
                    antialias: !1,
                    preserveDrawingBuffer: !1,
                    powerPreference: "high-performance",
                    failIfMajorPerformanceCaveat: !1,
                    desynchronized: !1,
                    contextType: void 0,
                  },
                  scrollZoom: !0,
                  minZoom: -2,
                  maxZoom: 22,
                  minPitch: 0,
                  maxPitch: 60,
                  boxZoom: !0,
                  dragRotate: !0,
                  dragPan: !0,
                  keyboard: !0,
                  doubleClickZoom: !0,
                  touchZoomRotate: !0,
                  touchPitch: !0,
                  cooperativeGestures: !1,
                  trackResize: !0,
                  center: [0, 0],
                  elevation: 0,
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  roll: 0,
                  renderWorldCopies: !0,
                  maxTileCacheSize: null,
                  maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                  transformRequest: null,
                  transformCameraUpdate: null,
                  transformConstrain: null,
                  fadeDuration: 300,
                  crossSourceCollisions: !0,
                  clickTolerance: 3,
                  localIdeographFontFamily: "sans-serif",
                  pitchWithRotate: !0,
                  rollEnabled: !1,
                  validateStyle: !0,
                  maxCanvasSize: [4096, 4096],
                  cancelPendingTileRequestsWhileZooming: !0,
                  centerClampedToGround: !0,
                },
                Jl = {
                  showCompass: !0,
                  showZoom: !0,
                  visualizePitch: !1,
                  visualizeRoll: !0,
                };
              class Su {
                constructor(e, i, l = !1) {
                  (this.mousedown = (d) => {
                    this.startMove(d, Y.mousePos(this.element, d)),
                      Y.addEventListener(window, "mousemove", this.mousemove),
                      Y.addEventListener(window, "mouseup", this.mouseup);
                  }),
                    (this.mousemove = (d) => {
                      this.move(d, Y.mousePos(this.element, d));
                    }),
                    (this.mouseup = (d) => {
                      this._rotatePitchHandler.dragEnd(d), this.offTemp();
                    }),
                    (this.touchstart = (d) => {
                      d.targetTouches.length !== 1
                        ? this.reset()
                        : ((this._startPos = this._lastPos =
                            Y.touchPos(this.element, d.targetTouches)[0]),
                          this.startMove(d, this._startPos),
                          Y.addEventListener(
                            window,
                            "touchmove",
                            this.touchmove,
                            { passive: !1 }
                          ),
                          Y.addEventListener(
                            window,
                            "touchend",
                            this.touchend
                          ));
                    }),
                    (this.touchmove = (d) => {
                      d.targetTouches.length !== 1
                        ? this.reset()
                        : ((this._lastPos = Y.touchPos(
                            this.element,
                            d.targetTouches
                          )[0]),
                          this.move(d, this._lastPos));
                    }),
                    (this.touchend = (d) => {
                      d.targetTouches.length === 0 &&
                        this._startPos &&
                        this._lastPos &&
                        this._startPos.dist(this._lastPos) <
                          this._clickTolerance &&
                        this.element.click(),
                        delete this._startPos,
                        delete this._lastPos,
                        this.offTemp();
                    }),
                    (this.reset = () => {
                      this._rotatePitchHandler.reset(),
                        delete this._startPos,
                        delete this._lastPos,
                        this.offTemp();
                    }),
                    (this._clickTolerance = 10),
                    (this.element = i);
                  const u = new _u();
                  (this._rotatePitchHandler = new hr({
                    clickTolerance: 3,
                    move: (d, g) => {
                      const w = i.getBoundingClientRect(),
                        S = new s.P(
                          (w.bottom - w.top) / 2,
                          (w.right - w.left) / 2
                        );
                      return {
                        bearingDelta: s.cq(new s.P(d.x, g.y), g, S),
                        pitchDelta: l ? -0.5 * (g.y - d.y) : void 0,
                      };
                    },
                    moveStateManager: u,
                    enable: !0,
                    assignEvents: () => {},
                  })),
                    (this.map = e),
                    Y.addEventListener(i, "mousedown", this.mousedown),
                    Y.addEventListener(i, "touchstart", this.touchstart, {
                      passive: !1,
                    }),
                    Y.addEventListener(i, "touchcancel", this.reset);
                }
                startMove(e, i) {
                  this._rotatePitchHandler.dragStart(e, i), Y.disableDrag();
                }
                move(e, i) {
                  const l = this.map,
                    { bearingDelta: u, pitchDelta: d } =
                      this._rotatePitchHandler.dragMove(e, i) || {};
                  u && l.setBearing(l.getBearing() + u),
                    d && l.setPitch(l.getPitch() + d);
                }
                off() {
                  const e = this.element;
                  Y.removeEventListener(e, "mousedown", this.mousedown),
                    Y.removeEventListener(e, "touchstart", this.touchstart, {
                      passive: !1,
                    }),
                    Y.removeEventListener(window, "touchmove", this.touchmove, {
                      passive: !1,
                    }),
                    Y.removeEventListener(window, "touchend", this.touchend),
                    Y.removeEventListener(e, "touchcancel", this.reset),
                    this.offTemp();
                }
                offTemp() {
                  Y.enableDrag(),
                    Y.removeEventListener(window, "mousemove", this.mousemove),
                    Y.removeEventListener(window, "mouseup", this.mouseup),
                    Y.removeEventListener(window, "touchmove", this.touchmove, {
                      passive: !1,
                    }),
                    Y.removeEventListener(window, "touchend", this.touchend);
                }
              }
              let io;
              function Ql(h, e, i, l = !1) {
                if (
                  l ||
                  !i.getCoveringTilesDetailsProvider().allowWorldCopies()
                )
                  return h == null ? void 0 : h.wrap();
                const u = new s.U(h.lng, h.lat);
                if (((h = new s.U(h.lng, h.lat)), e)) {
                  const d = new s.U(h.lng - 360, h.lat),
                    g = new s.U(h.lng + 360, h.lat),
                    w = i.locationToScreenPoint(h).distSqr(e);
                  i.locationToScreenPoint(d).distSqr(e) < w
                    ? (h = d)
                    : i.locationToScreenPoint(g).distSqr(e) < w && (h = g);
                }
                for (; Math.abs(h.lng - i.center.lng) > 180; ) {
                  const d = i.locationToScreenPoint(h);
                  if (d.x >= 0 && d.y >= 0 && d.x <= i.width && d.y <= i.height)
                    break;
                  h.lng > i.center.lng ? (h.lng -= 360) : (h.lng += 360);
                }
                return h.lng !== u.lng &&
                  i.isPointOnMapSurface(i.locationToScreenPoint(h))
                  ? h
                  : u;
              }
              const Wo = {
                center: "translate(-50%,-50%)",
                top: "translate(-50%,0)",
                "top-left": "translate(0,0)",
                "top-right": "translate(-100%,0)",
                bottom: "translate(-50%,-100%)",
                "bottom-left": "translate(0,-100%)",
                "bottom-right": "translate(-100%,-100%)",
                left: "translate(0,-50%)",
                right: "translate(-100%,-50%)",
              };
              function ec(h, e, i) {
                const l = h.classList;
                for (const u in Wo) l.remove(`maplibregl-${i}-anchor-${u}`);
                l.add(`maplibregl-${i}-anchor-${e}`);
              }
              class al extends s.E {
                constructor(e) {
                  if (
                    (super(),
                    (this._onKeyPress = (i) => {
                      const l = i.code,
                        u = i.charCode || i.keyCode;
                      (l !== "Space" &&
                        l !== "Enter" &&
                        u !== 32 &&
                        u !== 13) ||
                        this.togglePopup();
                    }),
                    (this._onMapClick = (i) => {
                      const l = i.originalEvent.target,
                        u = this._element;
                      this._popup &&
                        (l === u || u.contains(l)) &&
                        this.togglePopup();
                    }),
                    (this._update = (i) => {
                      if (!this._map) return;
                      const l = this._map.loaded() && !this._map.isMoving();
                      ((i == null ? void 0 : i.type) === "terrain" ||
                        ((i == null ? void 0 : i.type) === "render" && !l)) &&
                        this._map.once("render", this._update),
                        (this._lngLat = Ql(
                          this._lngLat,
                          this._flatPos,
                          this._map.transform
                        )),
                        (this._flatPos = this._pos =
                          this._map.project(this._lngLat)._add(this._offset)),
                        this._map.terrain &&
                          (this._flatPos = this._map.transform
                            .locationToScreenPoint(this._lngLat)
                            ._add(this._offset));
                      let u = "";
                      this._rotationAlignment === "viewport" ||
                      this._rotationAlignment === "auto"
                        ? (u = `rotateZ(${this._rotation}deg)`)
                        : this._rotationAlignment === "map" &&
                          (u = `rotateZ(${
                            this._rotation - this._map.getBearing()
                          }deg)`);
                      let d = "";
                      this._pitchAlignment === "viewport" ||
                      this._pitchAlignment === "auto"
                        ? (d = "rotateX(0deg)")
                        : this._pitchAlignment === "map" &&
                          (d = `rotateX(${this._map.getPitch()}deg)`),
                        this._subpixelPositioning ||
                          (i && i.type !== "moveend") ||
                          (this._pos = this._pos.round()),
                        Y.setTransform(
                          this._element,
                          `${Wo[this._anchor]} translate(${this._pos.x}px, ${
                            this._pos.y
                          }px) ${d} ${u}`
                        ),
                        re
                          .frameAsync(new AbortController())
                          .then(() => {
                            this._updateOpacity(i && i.type === "moveend");
                          })
                          .catch(() => {});
                    }),
                    (this._onMove = (i) => {
                      if (!this._isDragging) {
                        const l =
                          this._clickTolerance || this._map._clickTolerance;
                        this._isDragging =
                          i.point.dist(this._pointerdownPos) >= l;
                      }
                      this._isDragging &&
                        ((this._pos = i.point.sub(this._positionDelta)),
                        (this._lngLat = this._map.unproject(this._pos)),
                        this.setLngLat(this._lngLat),
                        (this._element.style.pointerEvents = "none"),
                        this._state === "pending" &&
                          ((this._state = "active"),
                          this.fire(new s.l("dragstart"))),
                        this.fire(new s.l("drag")));
                    }),
                    (this._onUp = () => {
                      (this._element.style.pointerEvents = "auto"),
                        (this._positionDelta = null),
                        (this._pointerdownPos = null),
                        (this._isDragging = !1),
                        this._map.off("mousemove", this._onMove),
                        this._map.off("touchmove", this._onMove),
                        this._state === "active" &&
                          this.fire(new s.l("dragend")),
                        (this._state = "inactive");
                    }),
                    (this._addDragHandler = (i) => {
                      this._element.contains(i.originalEvent.target) &&
                        (i.preventDefault(),
                        (this._positionDelta = i.point
                          .sub(this._pos)
                          .add(this._offset)),
                        (this._pointerdownPos = i.point),
                        (this._state = "pending"),
                        this._map.on("mousemove", this._onMove),
                        this._map.on("touchmove", this._onMove),
                        this._map.once("mouseup", this._onUp),
                        this._map.once("touchend", this._onUp));
                    }),
                    (this._anchor = (e && e.anchor) || "center"),
                    (this._color = (e && e.color) || "#3FB1CE"),
                    (this._scale = (e && e.scale) || 1),
                    (this._draggable = (e && e.draggable) || !1),
                    (this._clickTolerance = (e && e.clickTolerance) || 0),
                    (this._subpixelPositioning =
                      (e && e.subpixelPositioning) || !1),
                    (this._isDragging = !1),
                    (this._state = "inactive"),
                    (this._rotation = (e && e.rotation) || 0),
                    (this._rotationAlignment =
                      (e && e.rotationAlignment) || "auto"),
                    (this._pitchAlignment =
                      e && e.pitchAlignment && e.pitchAlignment !== "auto"
                        ? e.pitchAlignment
                        : this._rotationAlignment),
                    this.setOpacity(
                      e == null ? void 0 : e.opacity,
                      e == null ? void 0 : e.opacityWhenCovered
                    ),
                    e && e.element)
                  )
                    (this._element = e.element),
                      (this._offset = s.P.convert((e && e.offset) || [0, 0]));
                  else {
                    (this._defaultMarker = !0),
                      (this._element = Y.create("div"));
                    const i = Y.createNS("http://www.w3.org/2000/svg", "svg"),
                      l = 41,
                      u = 27;
                    i.setAttributeNS(null, "display", "block"),
                      i.setAttributeNS(null, "height", `${l}px`),
                      i.setAttributeNS(null, "width", `${u}px`),
                      i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
                    const d = Y.createNS("http://www.w3.org/2000/svg", "g");
                    d.setAttributeNS(null, "stroke", "none"),
                      d.setAttributeNS(null, "stroke-width", "1"),
                      d.setAttributeNS(null, "fill", "none"),
                      d.setAttributeNS(null, "fill-rule", "evenodd");
                    const g = Y.createNS("http://www.w3.org/2000/svg", "g");
                    g.setAttributeNS(null, "fill-rule", "nonzero");
                    const w = Y.createNS("http://www.w3.org/2000/svg", "g");
                    w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                      w.setAttributeNS(null, "fill", "#000000");
                    const S = [
                      { rx: "10.5", ry: "5.25002273" },
                      { rx: "10.5", ry: "5.25002273" },
                      { rx: "9.5", ry: "4.77275007" },
                      { rx: "8.5", ry: "4.29549936" },
                      { rx: "7.5", ry: "3.81822308" },
                      { rx: "6.5", ry: "3.34094679" },
                      { rx: "5.5", ry: "2.86367051" },
                      { rx: "4.5", ry: "2.38636864" },
                    ];
                    for (const se of S) {
                      const fe = Y.createNS(
                        "http://www.w3.org/2000/svg",
                        "ellipse"
                      );
                      fe.setAttributeNS(null, "opacity", "0.04"),
                        fe.setAttributeNS(null, "cx", "10.5"),
                        fe.setAttributeNS(null, "cy", "5.80029008"),
                        fe.setAttributeNS(null, "rx", se.rx),
                        fe.setAttributeNS(null, "ry", se.ry),
                        w.appendChild(fe);
                    }
                    const k = Y.createNS("http://www.w3.org/2000/svg", "g");
                    k.setAttributeNS(null, "fill", this._color);
                    const z = Y.createNS("http://www.w3.org/2000/svg", "path");
                    z.setAttributeNS(
                      null,
                      "d",
                      "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"
                    ),
                      k.appendChild(z);
                    const V = Y.createNS("http://www.w3.org/2000/svg", "g");
                    V.setAttributeNS(null, "opacity", "0.25"),
                      V.setAttributeNS(null, "fill", "#000000");
                    const F = Y.createNS("http://www.w3.org/2000/svg", "path");
                    F.setAttributeNS(
                      null,
                      "d",
                      "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"
                    ),
                      V.appendChild(F);
                    const $ = Y.createNS("http://www.w3.org/2000/svg", "g");
                    $.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                      $.setAttributeNS(null, "fill", "#FFFFFF");
                    const J = Y.createNS("http://www.w3.org/2000/svg", "g");
                    J.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                    const ae = Y.createNS(
                      "http://www.w3.org/2000/svg",
                      "circle"
                    );
                    ae.setAttributeNS(null, "fill", "#000000"),
                      ae.setAttributeNS(null, "opacity", "0.25"),
                      ae.setAttributeNS(null, "cx", "5.5"),
                      ae.setAttributeNS(null, "cy", "5.5"),
                      ae.setAttributeNS(null, "r", "5.4999962");
                    const oe = Y.createNS(
                      "http://www.w3.org/2000/svg",
                      "circle"
                    );
                    oe.setAttributeNS(null, "fill", "#FFFFFF"),
                      oe.setAttributeNS(null, "cx", "5.5"),
                      oe.setAttributeNS(null, "cy", "5.5"),
                      oe.setAttributeNS(null, "r", "5.4999962"),
                      J.appendChild(ae),
                      J.appendChild(oe),
                      g.appendChild(w),
                      g.appendChild(k),
                      g.appendChild(V),
                      g.appendChild($),
                      g.appendChild(J),
                      i.appendChild(g),
                      i.setAttributeNS(null, "height", l * this._scale + "px"),
                      i.setAttributeNS(null, "width", u * this._scale + "px"),
                      this._element.appendChild(i),
                      (this._offset = s.P.convert((e && e.offset) || [0, -14]));
                  }
                  if (
                    (this._element.classList.add("maplibregl-marker"),
                    this._element.addEventListener("dragstart", (i) => {
                      i.preventDefault();
                    }),
                    this._element.addEventListener("mousedown", (i) => {
                      i.preventDefault();
                    }),
                    ec(this._element, this._anchor, "marker"),
                    e && e.className)
                  )
                    for (const i of e.className.split(" "))
                      this._element.classList.add(i);
                  this._popup = null;
                }
                addTo(e) {
                  return (
                    this.remove(),
                    (this._map = e),
                    this._element.hasAttribute("aria-label") ||
                      this._element.setAttribute(
                        "aria-label",
                        e._getUIString("Marker.Title")
                      ),
                    this._element.hasAttribute("role") ||
                      this._element.setAttribute("role", "button"),
                    e.getCanvasContainer().appendChild(this._element),
                    e.on("move", this._update),
                    e.on("moveend", this._update),
                    e.on("terrain", this._update),
                    e.on("projectiontransition", this._update),
                    this.setDraggable(this._draggable),
                    this._update(),
                    this._map.on("click", this._onMapClick),
                    this
                  );
                }
                remove() {
                  return (
                    this._opacityTimeout &&
                      (clearTimeout(this._opacityTimeout),
                      delete this._opacityTimeout),
                    this._map &&
                      (this._map.off("click", this._onMapClick),
                      this._map.off("move", this._update),
                      this._map.off("moveend", this._update),
                      this._map.off("terrain", this._update),
                      this._map.off("projectiontransition", this._update),
                      this._map.off("mousedown", this._addDragHandler),
                      this._map.off("touchstart", this._addDragHandler),
                      this._map.off("mouseup", this._onUp),
                      this._map.off("touchend", this._onUp),
                      this._map.off("mousemove", this._onMove),
                      this._map.off("touchmove", this._onMove),
                      delete this._map),
                    Y.remove(this._element),
                    this._popup && this._popup.remove(),
                    this
                  );
                }
                getLngLat() {
                  return this._lngLat;
                }
                setLngLat(e) {
                  return (
                    (this._lngLat = s.U.convert(e)),
                    (this._pos = null),
                    this._popup && this._popup.setLngLat(this._lngLat),
                    this._update(),
                    this
                  );
                }
                getElement() {
                  return this._element;
                }
                setPopup(e) {
                  if (
                    (this._popup &&
                      (this._popup.remove(),
                      (this._popup = null),
                      this._element.removeEventListener(
                        "keypress",
                        this._onKeyPress
                      ),
                      this._originalTabIndex ||
                        this._element.removeAttribute("tabindex")),
                    e)
                  ) {
                    if (!("offset" in e.options)) {
                      const u = Math.abs(13.5) / Math.SQRT2;
                      e.options.offset = this._defaultMarker
                        ? {
                            top: [0, 0],
                            "top-left": [0, 0],
                            "top-right": [0, 0],
                            bottom: [0, -38.1],
                            "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                            "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                            left: [13.5, -1 * (38.1 - 13.5)],
                            right: [-13.5, -1 * (38.1 - 13.5)],
                          }
                        : this._offset;
                    }
                    (this._popup = e),
                      (this._originalTabIndex =
                        this._element.getAttribute("tabindex")),
                      this._originalTabIndex ||
                        this._element.setAttribute("tabindex", "0"),
                      this._element.addEventListener(
                        "keypress",
                        this._onKeyPress
                      );
                  }
                  return this;
                }
                setSubpixelPositioning(e) {
                  return (this._subpixelPositioning = e), this;
                }
                getPopup() {
                  return this._popup;
                }
                togglePopup() {
                  const e = this._popup;
                  return this._element.style.opacity ===
                    this._opacityWhenCovered
                    ? this
                    : e
                    ? (e.isOpen()
                        ? e.remove()
                        : (e.setLngLat(this._lngLat), e.addTo(this._map)),
                      this)
                    : this;
                }
                _updateOpacity(e = !1) {
                  var i, l;
                  const u =
                      (i = this._map) === null || i === void 0
                        ? void 0
                        : i.terrain,
                    d = this._map.transform.isLocationOccluded(this._lngLat);
                  if (!u || d) {
                    const $ = d ? this._opacityWhenCovered : this._opacity;
                    return void (
                      this._element.style.opacity !== $ &&
                      (this._element.style.opacity = $)
                    );
                  }
                  if (e) this._opacityTimeout = null;
                  else {
                    if (this._opacityTimeout) return;
                    this._opacityTimeout = setTimeout(() => {
                      this._opacityTimeout = null;
                    }, 100);
                  }
                  const g = this._map,
                    w = g.terrain.depthAtPoint(this._pos),
                    S = g.terrain.getElevationForLngLatZoom(
                      this._lngLat,
                      g.transform.tileZoom
                    );
                  if (
                    g.transform.lngLatToCameraDepth(this._lngLat, S) - w <
                    0.006
                  )
                    return void (this._element.style.opacity = this._opacity);
                  const k = -this._offset.y / g.transform.pixelsPerMeter,
                    z = Math.sin((g.getPitch() * Math.PI) / 180) * k,
                    V = g.terrain.depthAtPoint(
                      new s.P(this._pos.x, this._pos.y - this._offset.y)
                    ),
                    F =
                      g.transform.lngLatToCameraDepth(this._lngLat, S + z) - V >
                      0.006;
                  !((l = this._popup) === null || l === void 0) &&
                    l.isOpen() &&
                    F &&
                    this._popup.remove(),
                    (this._element.style.opacity = F
                      ? this._opacityWhenCovered
                      : this._opacity);
                }
                getOffset() {
                  return this._offset;
                }
                setOffset(e) {
                  return (this._offset = s.P.convert(e)), this._update(), this;
                }
                addClassName(e) {
                  this._element.classList.add(e);
                }
                removeClassName(e) {
                  this._element.classList.remove(e);
                }
                toggleClassName(e) {
                  return this._element.classList.toggle(e);
                }
                setDraggable(e) {
                  return (
                    (this._draggable = !!e),
                    this._map &&
                      (e
                        ? (this._map.on("mousedown", this._addDragHandler),
                          this._map.on("touchstart", this._addDragHandler))
                        : (this._map.off("mousedown", this._addDragHandler),
                          this._map.off("touchstart", this._addDragHandler))),
                    this
                  );
                }
                isDraggable() {
                  return this._draggable;
                }
                setRotation(e) {
                  return (this._rotation = e || 0), this._update(), this;
                }
                getRotation() {
                  return this._rotation;
                }
                setRotationAlignment(e) {
                  return (
                    (this._rotationAlignment = e || "auto"),
                    this._update(),
                    this
                  );
                }
                getRotationAlignment() {
                  return this._rotationAlignment;
                }
                setPitchAlignment(e) {
                  return (
                    (this._pitchAlignment =
                      e && e !== "auto" ? e : this._rotationAlignment),
                    this._update(),
                    this
                  );
                }
                getPitchAlignment() {
                  return this._pitchAlignment;
                }
                setOpacity(e, i) {
                  return (
                    (this._opacity === void 0 ||
                      (e === void 0 && i === void 0)) &&
                      ((this._opacity = "1"),
                      (this._opacityWhenCovered = "0.2")),
                    e !== void 0 && (this._opacity = e),
                    i !== void 0 && (this._opacityWhenCovered = i),
                    this._map && this._updateOpacity(!0),
                    this
                  );
                }
              }
              const Cu = {
                positionOptions: {
                  enableHighAccuracy: !1,
                  maximumAge: 0,
                  timeout: 6e3,
                },
                fitBoundsOptions: { maxZoom: 15 },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
              };
              let Cs = 0,
                Xo = !1;
              const Pu = { maxWidth: 100, unit: "metric" };
              function tc(h, e, i) {
                const l = (i && i.maxWidth) || 100,
                  u = h._container.clientHeight / 2,
                  d = h._container.clientWidth / 2,
                  g = h.unproject([d - l / 2, u]),
                  w = h.unproject([d + l / 2, u]),
                  S = Math.round(h.project(w).x - h.project(g).x),
                  k = Math.min(l, S, h._container.clientWidth),
                  z = g.distanceTo(w);
                if (i && i.unit === "imperial") {
                  const V = 3.2808 * z;
                  V > 5280
                    ? Yo(e, k, V / 5280, h._getUIString("ScaleControl.Miles"))
                    : Yo(e, k, V, h._getUIString("ScaleControl.Feet"));
                } else i && i.unit === "nautical" ? Yo(e, k, z / 1852, h._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? Yo(e, k, z / 1e3, h._getUIString("ScaleControl.Kilometers")) : Yo(e, k, z, h._getUIString("ScaleControl.Meters"));
              }
              function Yo(h, e, i, l) {
                const u = (function (d) {
                  const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
                  let w = d / g;
                  return (
                    (w =
                      w >= 10
                        ? 10
                        : w >= 5
                        ? 5
                        : w >= 3
                        ? 3
                        : w >= 2
                        ? 2
                        : w >= 1
                        ? 1
                        : (function (S) {
                            const k = Math.pow(
                              10,
                              Math.ceil(-Math.log(S) / Math.LN10)
                            );
                            return Math.round(S * k) / k;
                          })(w)),
                    g * w
                  );
                })(i);
                (h.style.width = e * (u / i) + "px"),
                  (h.innerHTML = `${u}&nbsp;${l}`);
              }
              const Iu = {
                  closeButton: !0,
                  closeOnClick: !0,
                  focusAfterOpen: !0,
                  className: "",
                  maxWidth: "240px",
                  subpixelPositioning: !1,
                  locationOccludedOpacity: void 0,
                },
                rc = [
                  "a[href]",
                  "[tabindex]:not([tabindex='-1'])",
                  "[contenteditable]:not([contenteditable='false'])",
                  "button:not([disabled])",
                  "input:not([disabled])",
                  "select:not([disabled])",
                  "textarea:not([disabled])",
                ].join(", ");
              function nc(h) {
                if (h) {
                  if (typeof h == "number") {
                    const e = Math.round(Math.abs(h) / Math.SQRT2);
                    return {
                      center: new s.P(0, 0),
                      top: new s.P(0, h),
                      "top-left": new s.P(e, e),
                      "top-right": new s.P(-e, e),
                      bottom: new s.P(0, -h),
                      "bottom-left": new s.P(e, -e),
                      "bottom-right": new s.P(-e, -e),
                      left: new s.P(h, 0),
                      right: new s.P(-h, 0),
                    };
                  }
                  if (h instanceof s.P || Array.isArray(h)) {
                    const e = s.P.convert(h);
                    return {
                      center: e,
                      top: e,
                      "top-left": e,
                      "top-right": e,
                      bottom: e,
                      "bottom-left": e,
                      "bottom-right": e,
                      left: e,
                      right: e,
                    };
                  }
                  return {
                    center: s.P.convert(h.center || [0, 0]),
                    top: s.P.convert(h.top || [0, 0]),
                    "top-left": s.P.convert(h["top-left"] || [0, 0]),
                    "top-right": s.P.convert(h["top-right"] || [0, 0]),
                    bottom: s.P.convert(h.bottom || [0, 0]),
                    "bottom-left": s.P.convert(h["bottom-left"] || [0, 0]),
                    "bottom-right": s.P.convert(h["bottom-right"] || [0, 0]),
                    left: s.P.convert(h.left || [0, 0]),
                    right: s.P.convert(h.right || [0, 0]),
                  };
                }
                return nc(new s.P(0, 0));
              }
              const Mu = B;
              (T.AJAXError = s.cC),
                (T.Event = s.l),
                (T.Evented = s.E),
                (T.LngLat = s.U),
                (T.MercatorCoordinate = s.a5),
                (T.Point = s.P),
                (T.addProtocol = s.cD),
                (T.config = s.a),
                (T.removeProtocol = s.cE),
                (T.AttributionControl = Ui),
                (T.BoxZoomHandler = Ld),
                (T.CanvasSource = tr),
                (T.CooperativeGesturesHandler = Ma),
                (T.DoubleClickZoomHandler = rl),
                (T.DragPanHandler = bu),
                (T.DragRotateHandler = wu),
                (T.EdgeInsets = Ar),
                (T.FullscreenControl = class extends s.E {
                  constructor(h = {}) {
                    super(),
                      (this._onFullscreenChange = () => {
                        var e;
                        let i =
                          window.document.fullscreenElement ||
                          window.document.mozFullScreenElement ||
                          window.document.webkitFullscreenElement ||
                          window.document.msFullscreenElement;
                        for (
                          ;
                          !(
                            (e = i == null ? void 0 : i.shadowRoot) === null ||
                            e === void 0
                          ) && e.fullscreenElement;

                        )
                          i = i.shadowRoot.fullscreenElement;
                        (i === this._container) !== this._fullscreen &&
                          this._handleFullscreenChange();
                      }),
                      (this._onClickFullscreen = () => {
                        this._isFullscreen()
                          ? this._exitFullscreen()
                          : this._requestFullscreen();
                      }),
                      (this._fullscreen = !1),
                      h &&
                        h.container &&
                        (h.container instanceof HTMLElement
                          ? (this._container = h.container)
                          : s.w(
                              "Full screen control 'container' must be a DOM element."
                            )),
                      "onfullscreenchange" in document
                        ? (this._fullscreenchange = "fullscreenchange")
                        : "onmozfullscreenchange" in document
                        ? (this._fullscreenchange = "mozfullscreenchange")
                        : "onwebkitfullscreenchange" in document
                        ? (this._fullscreenchange = "webkitfullscreenchange")
                        : "onmsfullscreenchange" in document &&
                          (this._fullscreenchange = "MSFullscreenChange");
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      this._container ||
                        (this._container = this._map.getContainer()),
                      (this._controlContainer = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-group"
                      )),
                      this._setupUI(),
                      this._controlContainer
                    );
                  }
                  onRemove() {
                    Y.remove(this._controlContainer),
                      (this._map = null),
                      window.document.removeEventListener(
                        this._fullscreenchange,
                        this._onFullscreenChange
                      );
                  }
                  _setupUI() {
                    const h = (this._fullscreenButton = Y.create(
                      "button",
                      "maplibregl-ctrl-fullscreen",
                      this._controlContainer
                    ));
                    Y.create("span", "maplibregl-ctrl-icon", h).setAttribute(
                      "aria-hidden",
                      "true"
                    ),
                      (h.type = "button"),
                      this._updateTitle(),
                      this._fullscreenButton.addEventListener(
                        "click",
                        this._onClickFullscreen
                      ),
                      window.document.addEventListener(
                        this._fullscreenchange,
                        this._onFullscreenChange
                      );
                  }
                  _updateTitle() {
                    const h = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", h),
                      (this._fullscreenButton.title = h);
                  }
                  _getTitle() {
                    return this._map._getUIString(
                      this._isFullscreen()
                        ? "FullscreenControl.Exit"
                        : "FullscreenControl.Enter"
                    );
                  }
                  _isFullscreen() {
                    return this._fullscreen;
                  }
                  _handleFullscreenChange() {
                    (this._fullscreen = !this._fullscreen),
                      this._fullscreenButton.classList.toggle(
                        "maplibregl-ctrl-shrink"
                      ),
                      this._fullscreenButton.classList.toggle(
                        "maplibregl-ctrl-fullscreen"
                      ),
                      this._updateTitle(),
                      this._fullscreen
                        ? (this.fire(new s.l("fullscreenstart")),
                          (this._prevCooperativeGesturesEnabled =
                            this._map.cooperativeGestures.isEnabled()),
                          this._map.cooperativeGestures.disable())
                        : (this.fire(new s.l("fullscreenend")),
                          this._prevCooperativeGesturesEnabled &&
                            this._map.cooperativeGestures.enable());
                  }
                  _exitFullscreen() {
                    window.document.exitFullscreen
                      ? window.document.exitFullscreen()
                      : window.document.mozCancelFullScreen
                      ? window.document.mozCancelFullScreen()
                      : window.document.msExitFullscreen
                      ? window.document.msExitFullscreen()
                      : window.document.webkitCancelFullScreen
                      ? window.document.webkitCancelFullScreen()
                      : this._togglePseudoFullScreen();
                  }
                  _requestFullscreen() {
                    this._container.requestFullscreen
                      ? this._container.requestFullscreen()
                      : this._container.mozRequestFullScreen
                      ? this._container.mozRequestFullScreen()
                      : this._container.msRequestFullscreen
                      ? this._container.msRequestFullscreen()
                      : this._container.webkitRequestFullscreen
                      ? this._container.webkitRequestFullscreen()
                      : this._togglePseudoFullScreen();
                  }
                  _togglePseudoFullScreen() {
                    this._container.classList.toggle(
                      "maplibregl-pseudo-fullscreen"
                    ),
                      this._handleFullscreenChange(),
                      this._map.resize();
                  }
                }),
                (T.GeoJSONSource = vr),
                (T.GeolocateControl = class extends s.E {
                  constructor(h) {
                    super(),
                      (this._onSuccess = (e) => {
                        if (this._map) {
                          if (this._isOutOfMapMaxBounds(e))
                            return (
                              this._setErrorState(),
                              this.fire(new s.l("outofmaxbounds", e)),
                              this._updateMarker(),
                              void this._finish()
                            );
                          if (this.options.trackUserLocation)
                            switch (
                              ((this._lastKnownPosition = e), this._watchState)
                            ) {
                              case "WAITING_ACTIVE":
                              case "ACTIVE_LOCK":
                              case "ACTIVE_ERROR":
                                (this._watchState = "ACTIVE_LOCK"),
                                  this._geolocateButton.classList.remove(
                                    "maplibregl-ctrl-geolocate-waiting"
                                  ),
                                  this._geolocateButton.classList.remove(
                                    "maplibregl-ctrl-geolocate-active-error"
                                  ),
                                  this._geolocateButton.classList.add(
                                    "maplibregl-ctrl-geolocate-active"
                                  );
                                break;
                              case "BACKGROUND":
                              case "BACKGROUND_ERROR":
                                (this._watchState = "BACKGROUND"),
                                  this._geolocateButton.classList.remove(
                                    "maplibregl-ctrl-geolocate-waiting"
                                  ),
                                  this._geolocateButton.classList.remove(
                                    "maplibregl-ctrl-geolocate-background-error"
                                  ),
                                  this._geolocateButton.classList.add(
                                    "maplibregl-ctrl-geolocate-background"
                                  );
                                break;
                              default:
                                throw new Error(
                                  `Unexpected watchState ${this._watchState}`
                                );
                            }
                          this.options.showUserLocation &&
                            this._watchState !== "OFF" &&
                            this._updateMarker(e),
                            (this.options.trackUserLocation &&
                              this._watchState !== "ACTIVE_LOCK") ||
                              this._updateCamera(e),
                            this.options.showUserLocation &&
                              this._dotElement.classList.remove(
                                "maplibregl-user-location-dot-stale"
                              ),
                            this.fire(new s.l("geolocate", e)),
                            this._finish();
                        }
                      }),
                      (this._updateCamera = (e) => {
                        const i = new s.U(
                            e.coords.longitude,
                            e.coords.latitude
                          ),
                          l = e.coords.accuracy,
                          u = this._map.getBearing(),
                          d = s.e(
                            { bearing: u },
                            this.options.fitBoundsOptions
                          ),
                          g = At.fromLngLat(i, l);
                        this._map.fitBounds(g, d, { geolocateSource: !0 });
                      }),
                      (this._updateMarker = (e) => {
                        if (e) {
                          const i = new s.U(
                            e.coords.longitude,
                            e.coords.latitude
                          );
                          this._accuracyCircleMarker
                            .setLngLat(i)
                            .addTo(this._map),
                            this._userLocationDotMarker
                              .setLngLat(i)
                              .addTo(this._map),
                            (this._accuracy = e.coords.accuracy),
                            this._updateCircleRadiusIfNeeded();
                        } else
                          this._userLocationDotMarker.remove(),
                            this._accuracyCircleMarker.remove();
                      }),
                      (this._onUpdate = () => {
                        this._updateCircleRadiusIfNeeded();
                      }),
                      (this._onError = (e) => {
                        if (this._map) {
                          if (e.code === 1) {
                            (this._watchState = "OFF"),
                              this._geolocateButton.classList.remove(
                                "maplibregl-ctrl-geolocate-waiting"
                              ),
                              this._geolocateButton.classList.remove(
                                "maplibregl-ctrl-geolocate-active"
                              ),
                              this._geolocateButton.classList.remove(
                                "maplibregl-ctrl-geolocate-active-error"
                              ),
                              this._geolocateButton.classList.remove(
                                "maplibregl-ctrl-geolocate-background"
                              ),
                              this._geolocateButton.classList.remove(
                                "maplibregl-ctrl-geolocate-background-error"
                              ),
                              (this._geolocateButton.disabled = !0);
                            const i = this._map._getUIString(
                              "GeolocateControl.LocationNotAvailable"
                            );
                            (this._geolocateButton.title = i),
                              this._geolocateButton.setAttribute(
                                "aria-label",
                                i
                              ),
                              this._geolocationWatchID !== void 0 &&
                                this._clearWatch();
                          } else {
                            if (e.code === 3 && Xo) return;
                            this._setErrorState();
                          }
                          this._watchState !== "OFF" &&
                            this.options.showUserLocation &&
                            this._dotElement.classList.add(
                              "maplibregl-user-location-dot-stale"
                            ),
                            this.fire(new s.l("error", e)),
                            this._finish();
                        }
                      }),
                      (this._finish = () => {
                        this._timeoutId && clearTimeout(this._timeoutId),
                          (this._timeoutId = void 0);
                      }),
                      (this._setupUI = () => {
                        this._map &&
                          (this._container.addEventListener(
                            "contextmenu",
                            (e) => e.preventDefault()
                          ),
                          (this._geolocateButton = Y.create(
                            "button",
                            "maplibregl-ctrl-geolocate",
                            this._container
                          )),
                          Y.create(
                            "span",
                            "maplibregl-ctrl-icon",
                            this._geolocateButton
                          ).setAttribute("aria-hidden", "true"),
                          (this._geolocateButton.type = "button"),
                          (this._geolocateButton.disabled = !0));
                      }),
                      (this._finishSetupUI = (e) => {
                        if (this._map) {
                          if (e === !1) {
                            s.w(
                              "Geolocation support is not available so the GeolocateControl will be disabled."
                            );
                            const i = this._map._getUIString(
                              "GeolocateControl.LocationNotAvailable"
                            );
                            (this._geolocateButton.disabled = !0),
                              (this._geolocateButton.title = i),
                              this._geolocateButton.setAttribute(
                                "aria-label",
                                i
                              );
                          } else {
                            const i = this._map._getUIString(
                              "GeolocateControl.FindMyLocation"
                            );
                            (this._geolocateButton.disabled = !1),
                              (this._geolocateButton.title = i),
                              this._geolocateButton.setAttribute(
                                "aria-label",
                                i
                              );
                          }
                          this.options.trackUserLocation &&
                            (this._geolocateButton.setAttribute(
                              "aria-pressed",
                              "false"
                            ),
                            (this._watchState = "OFF")),
                            this.options.showUserLocation &&
                              ((this._dotElement = Y.create(
                                "div",
                                "maplibregl-user-location-dot"
                              )),
                              (this._userLocationDotMarker = new al({
                                element: this._dotElement,
                              })),
                              (this._circleElement = Y.create(
                                "div",
                                "maplibregl-user-location-accuracy-circle"
                              )),
                              (this._accuracyCircleMarker = new al({
                                element: this._circleElement,
                                pitchAlignment: "map",
                              })),
                              this.options.trackUserLocation &&
                                (this._watchState = "OFF"),
                              this._map.on("zoom", this._onUpdate),
                              this._map.on("move", this._onUpdate),
                              this._map.on("rotate", this._onUpdate),
                              this._map.on("pitch", this._onUpdate)),
                            this._geolocateButton.addEventListener(
                              "click",
                              () => this.trigger()
                            ),
                            (this._setup = !0),
                            this.options.trackUserLocation &&
                              this._map.on("movestart", (i) => {
                                const l =
                                  (i == null ? void 0 : i[0]) instanceof
                                  ResizeObserverEntry;
                                i.geolocateSource ||
                                  this._watchState !== "ACTIVE_LOCK" ||
                                  l ||
                                  this._map.isZooming() ||
                                  ((this._watchState = "BACKGROUND"),
                                  this._geolocateButton.classList.add(
                                    "maplibregl-ctrl-geolocate-background"
                                  ),
                                  this._geolocateButton.classList.remove(
                                    "maplibregl-ctrl-geolocate-active"
                                  ),
                                  this.fire(new s.l("trackuserlocationend")),
                                  this.fire(new s.l("userlocationlostfocus")));
                              });
                        }
                      }),
                      (this.options = s.e({}, Cu, h));
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      (this._container = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-group"
                      )),
                      this._setupUI(),
                      (function () {
                        return s._(this, arguments, void 0, function* (e = !1) {
                          if (io !== void 0 && !e) return io;
                          if (window.navigator.permissions === void 0)
                            return (io = !!window.navigator.geolocation), io;
                          try {
                            io =
                              (yield window.navigator.permissions.query({
                                name: "geolocation",
                              })).state !== "denied";
                          } catch {
                            io = !!window.navigator.geolocation;
                          }
                          return io;
                        });
                      })().then((e) => this._finishSetupUI(e)),
                      this._container
                    );
                  }
                  onRemove() {
                    this._geolocationWatchID !== void 0 &&
                      (window.navigator.geolocation.clearWatch(
                        this._geolocationWatchID
                      ),
                      (this._geolocationWatchID = void 0)),
                      this.options.showUserLocation &&
                        this._userLocationDotMarker &&
                        this._userLocationDotMarker.remove(),
                      this.options.showAccuracyCircle &&
                        this._accuracyCircleMarker &&
                        this._accuracyCircleMarker.remove(),
                      Y.remove(this._container),
                      this._map.off("zoom", this._onUpdate),
                      this._map.off("move", this._onUpdate),
                      this._map.off("rotate", this._onUpdate),
                      this._map.off("pitch", this._onUpdate),
                      (this._map = void 0),
                      (Cs = 0),
                      (Xo = !1);
                  }
                  _isOutOfMapMaxBounds(h) {
                    const e = this._map.getMaxBounds(),
                      i = h.coords;
                    return (
                      e &&
                      (i.longitude < e.getWest() ||
                        i.longitude > e.getEast() ||
                        i.latitude < e.getSouth() ||
                        i.latitude > e.getNorth())
                    );
                  }
                  _setErrorState() {
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-active-error"
                          );
                        break;
                      case "ACTIVE_LOCK":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-active-error"
                          ),
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-waiting"
                          );
                        break;
                      case "BACKGROUND":
                        (this._watchState = "BACKGROUND_ERROR"),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-background-error"
                          ),
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-waiting"
                          );
                        break;
                      case "ACTIVE_ERROR":
                      case "BACKGROUND_ERROR":
                      case "OFF":
                      case void 0:
                        break;
                      default:
                        throw new Error(
                          `Unexpected watchState ${this._watchState}`
                        );
                    }
                  }
                  _updateCircleRadiusIfNeeded() {
                    const h = this._userLocationDotMarker.getLngLat();
                    if (
                      !(
                        this.options.showUserLocation &&
                        this.options.showAccuracyCircle &&
                        this._accuracy &&
                        h
                      )
                    )
                      return;
                    const e = this._map.project(h),
                      i = this._map.unproject([e.x + 100, e.y]),
                      l = h.distanceTo(i) / 100,
                      u = (2 * this._accuracy) / l;
                    (this._circleElement.style.width = `${u.toFixed(2)}px`),
                      (this._circleElement.style.height = `${u.toFixed(2)}px`);
                  }
                  trigger() {
                    if (!this._setup)
                      return (
                        s.w(
                          "Geolocate control triggered before added to a map"
                        ),
                        !1
                      );
                    if (this.options.trackUserLocation) {
                      switch (this._watchState) {
                        case "OFF":
                          (this._watchState = "WAITING_ACTIVE"),
                            this.fire(new s.l("trackuserlocationstart"));
                          break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                          Cs--,
                            (Xo = !1),
                            (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-active"
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-background"
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-background-error"
                            ),
                            this.fire(new s.l("trackuserlocationend"));
                          break;
                        case "BACKGROUND":
                          (this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-background"
                            ),
                            this._lastKnownPosition &&
                              this._updateCamera(this._lastKnownPosition),
                            this.fire(new s.l("trackuserlocationstart")),
                            this.fire(new s.l("userlocationfocus"));
                          break;
                        default:
                          throw new Error(
                            `Unexpected watchState ${this._watchState}`
                          );
                      }
                      switch (this._watchState) {
                        case "WAITING_ACTIVE":
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "maplibregl-ctrl-geolocate-active"
                            );
                          break;
                        case "ACTIVE_LOCK":
                          this._geolocateButton.classList.add(
                            "maplibregl-ctrl-geolocate-active"
                          );
                          break;
                        case "OFF":
                          break;
                        default:
                          throw new Error(
                            `Unexpected watchState ${this._watchState}`
                          );
                      }
                      if (
                        this._watchState === "OFF" &&
                        this._geolocationWatchID !== void 0
                      )
                        this._clearWatch();
                      else if (this._geolocationWatchID === void 0) {
                        let h;
                        this._geolocateButton.classList.add(
                          "maplibregl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.setAttribute(
                            "aria-pressed",
                            "true"
                          ),
                          Cs++,
                          Cs > 1
                            ? ((h = { maximumAge: 6e5, timeout: 0 }), (Xo = !0))
                            : ((h = this.options.positionOptions), (Xo = !1)),
                          (this._geolocationWatchID =
                            window.navigator.geolocation.watchPosition(
                              this._onSuccess,
                              this._onError,
                              h
                            ));
                      }
                    } else
                      window.navigator.geolocation.getCurrentPosition(
                        this._onSuccess,
                        this._onError,
                        this.options.positionOptions
                      ),
                        (this._timeoutId = setTimeout(this._finish, 1e4));
                    return !0;
                  }
                  _clearWatch() {
                    window.navigator.geolocation.clearWatch(
                      this._geolocationWatchID
                    ),
                      (this._geolocationWatchID = void 0),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-waiting"
                      ),
                      this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false"
                      ),
                      this.options.showUserLocation && this._updateMarker(null);
                  }
                }),
                (T.GlobeControl = class {
                  constructor() {
                    (this._toggleProjection = () => {
                      var h;
                      const e =
                        (h = this._map.getProjection()) === null || h === void 0
                          ? void 0
                          : h.type;
                      this._map.setProjection(
                        e !== "mercator" && e
                          ? { type: "mercator" }
                          : { type: "globe" }
                      ),
                        this._updateGlobeIcon();
                    }),
                      (this._updateGlobeIcon = () => {
                        var h;
                        this._globeButton.classList.remove(
                          "maplibregl-ctrl-globe"
                        ),
                          this._globeButton.classList.remove(
                            "maplibregl-ctrl-globe-enabled"
                          ),
                          ((h = this._map.getProjection()) === null ||
                          h === void 0
                            ? void 0
                            : h.type) === "globe"
                            ? (this._globeButton.classList.add(
                                "maplibregl-ctrl-globe-enabled"
                              ),
                              (this._globeButton.title = this._map._getUIString(
                                "GlobeControl.Disable"
                              )))
                            : (this._globeButton.classList.add(
                                "maplibregl-ctrl-globe"
                              ),
                              (this._globeButton.title = this._map._getUIString(
                                "GlobeControl.Enable"
                              )));
                      });
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      (this._container = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-group"
                      )),
                      (this._globeButton = Y.create(
                        "button",
                        "maplibregl-ctrl-globe",
                        this._container
                      )),
                      Y.create(
                        "span",
                        "maplibregl-ctrl-icon",
                        this._globeButton
                      ).setAttribute("aria-hidden", "true"),
                      (this._globeButton.type = "button"),
                      this._globeButton.addEventListener(
                        "click",
                        this._toggleProjection
                      ),
                      this._updateGlobeIcon(),
                      this._map.on("styledata", this._updateGlobeIcon),
                      this._container
                    );
                  }
                  onRemove() {
                    Y.remove(this._container),
                      this._map.off("styledata", this._updateGlobeIcon),
                      this._globeButton.removeEventListener(
                        "click",
                        this._toggleProjection
                      ),
                      (this._map = void 0);
                  }
                }),
                (T.Hash = pu),
                (T.ImageSource = ar),
                (T.KeyboardHandler = Vd),
                (T.LngLatBounds = At),
                (T.LogoControl = Tu),
                (T.Map = class extends Gd {
                  constructor(h) {
                    var e, i;
                    s.cz.mark(s.cA.create);
                    const l = Object.assign(
                      Object.assign(Object.assign({}, Ss), h),
                      {
                        canvasContextAttributes: Object.assign(
                          Object.assign({}, Ss.canvasContextAttributes),
                          h.canvasContextAttributes
                        ),
                      }
                    );
                    if (
                      l.minZoom != null &&
                      l.maxZoom != null &&
                      l.minZoom > l.maxZoom
                    )
                      throw new Error(
                        "maxZoom must be greater than or equal to minZoom"
                      );
                    if (
                      l.minPitch != null &&
                      l.maxPitch != null &&
                      l.minPitch > l.maxPitch
                    )
                      throw new Error(
                        "maxPitch must be greater than or equal to minPitch"
                      );
                    if (l.minPitch != null && l.minPitch < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (l.maxPitch != null && l.maxPitch > 180)
                      throw new Error(
                        "maxPitch must be less than or equal to 180"
                      );
                    const u = new ea(),
                      d = new va();
                    if (
                      (l.minZoom !== void 0 && u.setMinZoom(l.minZoom),
                      l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom),
                      l.minPitch !== void 0 && u.setMinPitch(l.minPitch),
                      l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch),
                      l.renderWorldCopies !== void 0 &&
                        u.setRenderWorldCopies(l.renderWorldCopies),
                      l.transformConstrain !== null &&
                        u.setConstrain(l.transformConstrain),
                      super(u, d, { bearingSnap: l.bearingSnap }),
                      (this._idleTriggered = !1),
                      (this._crossFadingFactor = 1),
                      (this._renderTaskQueue = new Aa()),
                      (this._controls = []),
                      (this._mapId = s.ab()),
                      (this._contextLost = (w) => {
                        w.preventDefault(),
                          this._frameRequest &&
                            (this._frameRequest.abort(),
                            (this._frameRequest = null)),
                          this.fire(
                            new s.l("webglcontextlost", { originalEvent: w })
                          );
                      }),
                      (this._contextRestored = (w) => {
                        this._setupPainter(),
                          this.resize(),
                          this._update(),
                          this.fire(
                            new s.l("webglcontextrestored", {
                              originalEvent: w,
                            })
                          );
                      }),
                      (this._onMapScroll = (w) => {
                        if (w.target === this._container)
                          return (
                            (this._container.scrollTop = 0),
                            (this._container.scrollLeft = 0),
                            !1
                          );
                      }),
                      (this._onWindowOnline = () => {
                        this._update();
                      }),
                      (this._interactive = l.interactive),
                      (this._maxTileCacheSize = l.maxTileCacheSize),
                      (this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels),
                      (this._canvasContextAttributes = Object.assign(
                        {},
                        l.canvasContextAttributes
                      )),
                      (this._trackResize = l.trackResize === !0),
                      (this._bearingSnap = l.bearingSnap),
                      (this._centerClampedToGround = l.centerClampedToGround),
                      (this._refreshExpiredTiles =
                        l.refreshExpiredTiles === !0),
                      (this._fadeDuration = l.fadeDuration),
                      (this._crossSourceCollisions =
                        l.crossSourceCollisions === !0),
                      (this._collectResourceTiming =
                        l.collectResourceTiming === !0),
                      (this._locale = Object.assign(
                        Object.assign({}, ci),
                        l.locale
                      )),
                      (this._clickTolerance = l.clickTolerance),
                      (this._overridePixelRatio = l.pixelRatio),
                      (this._maxCanvasSize = l.maxCanvasSize),
                      (this.transformCameraUpdate = l.transformCameraUpdate),
                      (this.transformConstrain = l.transformConstrain),
                      (this.cancelPendingTileRequestsWhileZooming =
                        l.cancelPendingTileRequestsWhileZooming === !0),
                      (this._imageQueueHandle = Ue.addThrottleControl(() =>
                        this.isMoving()
                      )),
                      (this._requestManager = new Be(l.transformRequest)),
                      typeof l.container == "string")
                    ) {
                      if (
                        ((this._container = document.getElementById(
                          l.container
                        )),
                        !this._container)
                      )
                        throw new Error(
                          `Container '${l.container}' not found.`
                        );
                    } else {
                      if (!(l.container instanceof HTMLElement))
                        throw new Error(
                          "Invalid type: 'container' must be a String or HTMLElement."
                        );
                      this._container = l.container;
                    }
                    if (
                      (l.maxBounds && this.setMaxBounds(l.maxBounds),
                      this._setupContainer(),
                      this._setupPainter(),
                      this.on("move", () => this._update(!1)),
                      this.on("moveend", () => this._update(!1)),
                      this.on("zoom", () => this._update(!0)),
                      this.on("terrain", () => {
                        (this.painter.terrainFacilitator.dirty = !0),
                          this._update(!0);
                      }),
                      this.once("idle", () => {
                        this._idleTriggered = !0;
                      }),
                      typeof window < "u")
                    ) {
                      addEventListener("online", this._onWindowOnline, !1);
                      let w = !1;
                      const S = du((k) => {
                        this._trackResize &&
                          !this._removed &&
                          (this.resize(k), this.redraw());
                      }, 50);
                      (this._resizeObserver = new ResizeObserver((k) => {
                        w ? S(k) : (w = !0);
                      })),
                        this._resizeObserver.observe(this._container);
                    }
                    (this.handlers = new nl(this, l)),
                      (this._hash =
                        l.hash &&
                        new pu(
                          (typeof l.hash == "string" && l.hash) || void 0
                        ).addTo(this)),
                      (this._hash && this._hash._onHashChange()) ||
                        (this.jumpTo({
                          center: l.center,
                          elevation: l.elevation,
                          zoom: l.zoom,
                          bearing: l.bearing,
                          pitch: l.pitch,
                          roll: l.roll,
                        }),
                        l.bounds &&
                          (this.resize(),
                          this.fitBounds(
                            l.bounds,
                            s.e({}, l.fitBoundsOptions, { duration: 0 })
                          )));
                    const g =
                      typeof l.style == "string" ||
                      ((i =
                        (e = l.style) === null || e === void 0
                          ? void 0
                          : e.projection) === null || i === void 0
                        ? void 0
                        : i.type) !== "globe";
                    this.resize(null, g),
                      (this._localIdeographFontFamily =
                        l.localIdeographFontFamily),
                      (this._validateStyle = l.validateStyle),
                      l.style &&
                        this.setStyle(l.style, {
                          localIdeographFontFamily: l.localIdeographFontFamily,
                        }),
                      l.attributionControl &&
                        this.addControl(
                          new Ui(
                            typeof l.attributionControl == "boolean"
                              ? void 0
                              : l.attributionControl
                          )
                        ),
                      l.maplibreLogo &&
                        this.addControl(new Tu(), l.logoPosition),
                      this.on("style.load", () => {
                        if (
                          (g || this._resizeTransform(),
                          this.transform.unmodified)
                        ) {
                          const w = s.S(this.style.stylesheet, [
                            "center",
                            "zoom",
                            "bearing",
                            "pitch",
                            "roll",
                          ]);
                          this.jumpTo(w);
                        }
                      }),
                      this.on("data", (w) => {
                        this._update(w.dataType === "style"),
                          this.fire(new s.l(`${w.dataType}data`, w));
                      }),
                      this.on("dataloading", (w) => {
                        this.fire(new s.l(`${w.dataType}dataloading`, w));
                      }),
                      this.on("dataabort", (w) => {
                        this.fire(new s.l("sourcedataabort", w));
                      });
                  }
                  _getMapId() {
                    return this._mapId;
                  }
                  setGlobalStateProperty(h, e) {
                    return (
                      this.style.setGlobalStateProperty(h, e), this._update(!0)
                    );
                  }
                  getGlobalState() {
                    return this.style.getGlobalState();
                  }
                  addControl(h, e) {
                    if (
                      (e === void 0 &&
                        (e = h.getDefaultPosition
                          ? h.getDefaultPosition()
                          : "top-right"),
                      !h || !h.onAdd)
                    )
                      return this.fire(
                        new s.k(
                          new Error(
                            "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const i = h.onAdd(this);
                    this._controls.push(h);
                    const l = this._controlPositions[e];
                    return (
                      e.indexOf("bottom") !== -1
                        ? l.insertBefore(i, l.firstChild)
                        : l.appendChild(i),
                      this
                    );
                  }
                  removeControl(h) {
                    if (!h || !h.onRemove)
                      return this.fire(
                        new s.k(
                          new Error(
                            "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const e = this._controls.indexOf(h);
                    return (
                      e > -1 && this._controls.splice(e, 1),
                      h.onRemove(this),
                      this
                    );
                  }
                  hasControl(h) {
                    return this._controls.indexOf(h) > -1;
                  }
                  coveringTiles(h) {
                    return Ur(this.transform, h);
                  }
                  calculateCameraOptionsFromTo(h, e, i, l) {
                    return (
                      l == null &&
                        this.terrain &&
                        (l = this.terrain.getElevationForLngLatZoom(
                          i,
                          this.transform.tileZoom
                        )),
                      super.calculateCameraOptionsFromTo(h, e, i, l)
                    );
                  }
                  resize(h, e = !0) {
                    const [i, l] = this._containerDimensions(),
                      u = this._getClampedPixelRatio(i, l);
                    if (
                      (this._resizeCanvas(i, l, u),
                      this.painter.resize(i, l, u),
                      this.painter.overLimit())
                    ) {
                      const g = this.painter.context.gl;
                      this._maxCanvasSize = [
                        g.drawingBufferWidth,
                        g.drawingBufferHeight,
                      ];
                      const w = this._getClampedPixelRatio(i, l);
                      this._resizeCanvas(i, l, w), this.painter.resize(i, l, w);
                    }
                    this._resizeTransform(e);
                    const d = !this._moving;
                    return (
                      d &&
                        (this.stop(),
                        this.fire(new s.l("movestart", h)).fire(
                          new s.l("move", h)
                        )),
                      this.fire(new s.l("resize", h)),
                      d && this.fire(new s.l("moveend", h)),
                      this
                    );
                  }
                  _resizeTransform(h = !0) {
                    var e;
                    const [i, l] = this._containerDimensions();
                    this.transform.resize(i, l, h),
                      (e = this._requestedCameraState) === null ||
                        e === void 0 ||
                        e.resize(i, l, h);
                  }
                  _getClampedPixelRatio(h, e) {
                    const { 0: i, 1: l } = this._maxCanvasSize,
                      u = this.getPixelRatio(),
                      d = h * u,
                      g = e * u;
                    return Math.min(d > i ? i / d : 1, g > l ? l / g : 1) * u;
                  }
                  getPixelRatio() {
                    var h;
                    return (h = this._overridePixelRatio) !== null &&
                      h !== void 0
                      ? h
                      : devicePixelRatio;
                  }
                  setPixelRatio(h) {
                    (this._overridePixelRatio = h), this.resize();
                  }
                  getBounds() {
                    return this.transform.getBounds();
                  }
                  getMaxBounds() {
                    return this.transform.getMaxBounds();
                  }
                  setMaxBounds(h) {
                    return (
                      this.transform.setMaxBounds(At.convert(h)), this._update()
                    );
                  }
                  setMinZoom(h) {
                    if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom)
                      return (
                        this.transform.setMinZoom(h),
                        this._update(),
                        this.getZoom() < h && this.setZoom(h),
                        this
                      );
                    throw new Error(
                      "minZoom must be between -2 and the current maxZoom, inclusive"
                    );
                  }
                  getMinZoom() {
                    return this.transform.minZoom;
                  }
                  setMaxZoom(h) {
                    if ((h = h ?? 22) >= this.transform.minZoom)
                      return (
                        this.transform.setMaxZoom(h),
                        this._update(),
                        this.getZoom() > h && this.setZoom(h),
                        this
                      );
                    throw new Error(
                      "maxZoom must be greater than the current minZoom"
                    );
                  }
                  getMaxZoom() {
                    return this.transform.maxZoom;
                  }
                  setMinPitch(h) {
                    if ((h = h ?? 0) < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (h >= 0 && h <= this.transform.maxPitch)
                      return (
                        this.transform.setMinPitch(h),
                        this._update(),
                        this.getPitch() < h && this.setPitch(h),
                        this
                      );
                    throw new Error(
                      "minPitch must be between 0 and the current maxPitch, inclusive"
                    );
                  }
                  getMinPitch() {
                    return this.transform.minPitch;
                  }
                  setMaxPitch(h) {
                    if ((h = h ?? 60) > 180)
                      throw new Error(
                        "maxPitch must be less than or equal to 180"
                      );
                    if (h >= this.transform.minPitch)
                      return (
                        this.transform.setMaxPitch(h),
                        this._update(),
                        this.getPitch() > h && this.setPitch(h),
                        this
                      );
                    throw new Error(
                      "maxPitch must be greater than the current minPitch"
                    );
                  }
                  getMaxPitch() {
                    return this.transform.maxPitch;
                  }
                  getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                  }
                  setRenderWorldCopies(h) {
                    return (
                      this.transform.setRenderWorldCopies(h), this._update()
                    );
                  }
                  setTransformConstrain(h) {
                    return this.transform.setConstrain(h), this._update();
                  }
                  project(h) {
                    return this.transform.locationToScreenPoint(
                      s.U.convert(h),
                      this.style && this.terrain
                    );
                  }
                  unproject(h) {
                    return this.transform.screenPointToLocation(
                      s.P.convert(h),
                      this.terrain
                    );
                  }
                  isMoving() {
                    var h;
                    return (
                      this._moving ||
                      ((h = this.handlers) === null || h === void 0
                        ? void 0
                        : h.isMoving())
                    );
                  }
                  isZooming() {
                    var h;
                    return (
                      this._zooming ||
                      ((h = this.handlers) === null || h === void 0
                        ? void 0
                        : h.isZooming())
                    );
                  }
                  isRotating() {
                    var h;
                    return (
                      this._rotating ||
                      ((h = this.handlers) === null || h === void 0
                        ? void 0
                        : h.isRotating())
                    );
                  }
                  _createDelegatedListener(h, e, i) {
                    if (h === "mouseenter" || h === "mouseover") {
                      let l = !1;
                      return {
                        layers: e,
                        listener: i,
                        delegates: {
                          mousemove: (d) => {
                            const g = e.filter((S) => this.getLayer(S)),
                              w =
                                g.length !== 0
                                  ? this.queryRenderedFeatures(d.point, {
                                      layers: g,
                                    })
                                  : [];
                            w.length
                              ? l ||
                                ((l = !0),
                                i.call(
                                  this,
                                  new na(h, this, d.originalEvent, {
                                    features: w,
                                  })
                                ))
                              : (l = !1);
                          },
                          mouseout: () => {
                            l = !1;
                          },
                        },
                      };
                    }
                    if (h === "mouseleave" || h === "mouseout") {
                      let l = !1;
                      return {
                        layers: e,
                        listener: i,
                        delegates: {
                          mousemove: (g) => {
                            const w = e.filter((S) => this.getLayer(S));
                            (w.length !== 0
                              ? this.queryRenderedFeatures(g.point, {
                                  layers: w,
                                })
                              : []
                            ).length
                              ? (l = !0)
                              : l &&
                                ((l = !1),
                                i.call(this, new na(h, this, g.originalEvent)));
                          },
                          mouseout: (g) => {
                            l &&
                              ((l = !1),
                              i.call(this, new na(h, this, g.originalEvent)));
                          },
                        },
                      };
                    }
                    {
                      const l = (u) => {
                        const d = e.filter((w) => this.getLayer(w)),
                          g =
                            d.length !== 0
                              ? this.queryRenderedFeatures(u.point, {
                                  layers: d,
                                })
                              : [];
                        g.length &&
                          ((u.features = g),
                          i.call(this, u),
                          delete u.features);
                      };
                      return { layers: e, listener: i, delegates: { [h]: l } };
                    }
                  }
                  _saveDelegatedListener(h, e) {
                    (this._delegatedListeners = this._delegatedListeners || {}),
                      (this._delegatedListeners[h] =
                        this._delegatedListeners[h] || []),
                      this._delegatedListeners[h].push(e);
                  }
                  _removeDelegatedListener(h, e, i) {
                    if (
                      !this._delegatedListeners ||
                      !this._delegatedListeners[h]
                    )
                      return;
                    const l = this._delegatedListeners[h];
                    for (let u = 0; u < l.length; u++) {
                      const d = l[u];
                      if (
                        d.listener === i &&
                        d.layers.length === e.length &&
                        d.layers.every((g) => e.includes(g))
                      ) {
                        for (const g in d.delegates)
                          this.off(g, d.delegates[g]);
                        return void l.splice(u, 1);
                      }
                    }
                  }
                  on(h, e, i) {
                    if (i === void 0) return super.on(h, e);
                    const l = typeof e == "string" ? [e] : e,
                      u = this._createDelegatedListener(h, l, i);
                    this._saveDelegatedListener(h, u);
                    for (const d in u.delegates) this.on(d, u.delegates[d]);
                    return {
                      unsubscribe: () => {
                        this._removeDelegatedListener(h, l, i);
                      },
                    };
                  }
                  once(h, e, i) {
                    if (i === void 0) return super.once(h, e);
                    const l = typeof e == "string" ? [e] : e,
                      u = this._createDelegatedListener(h, l, i);
                    for (const d in u.delegates) {
                      const g = u.delegates[d];
                      u.delegates[d] = (...w) => {
                        this._removeDelegatedListener(h, l, i), g(...w);
                      };
                    }
                    this._saveDelegatedListener(h, u);
                    for (const d in u.delegates) this.once(d, u.delegates[d]);
                    return this;
                  }
                  off(h, e, i) {
                    return i === void 0
                      ? super.off(h, e)
                      : (this._removeDelegatedListener(
                          h,
                          typeof e == "string" ? [e] : e,
                          i
                        ),
                        this);
                  }
                  queryRenderedFeatures(h, e) {
                    if (!this.style) return [];
                    let i;
                    const l = h instanceof s.P || Array.isArray(h),
                      u = l
                        ? h
                        : [
                            [0, 0],
                            [this.transform.width, this.transform.height],
                          ];
                    if (
                      ((e = e || (l ? {} : h) || {}),
                      u instanceof s.P || typeof u[0] == "number")
                    )
                      i = [s.P.convert(u)];
                    else {
                      const d = s.P.convert(u[0]),
                        g = s.P.convert(u[1]);
                      i = [d, new s.P(g.x, d.y), g, new s.P(d.x, g.y), d];
                    }
                    return this.style.queryRenderedFeatures(
                      i,
                      e,
                      this.transform
                    );
                  }
                  querySourceFeatures(h, e) {
                    return this.style.querySourceFeatures(h, e);
                  }
                  setStyle(h, e) {
                    return (e = s.e(
                      {},
                      {
                        localIdeographFontFamily:
                          this._localIdeographFontFamily,
                        validate: this._validateStyle,
                      },
                      e
                    )).diff !== !1 &&
                      e.localIdeographFontFamily ===
                        this._localIdeographFontFamily &&
                      this.style &&
                      h
                      ? (this._diffStyle(h, e), this)
                      : ((this._localIdeographFontFamily =
                          e.localIdeographFontFamily),
                        this._updateStyle(h, e));
                  }
                  setTransformRequest(h) {
                    return this._requestManager.setTransformRequest(h), this;
                  }
                  _getUIString(h) {
                    const e = this._locale[h];
                    if (e == null) throw new Error(`Missing UI string '${h}'`);
                    return e;
                  }
                  _updateStyle(h, e) {
                    var i, l;
                    if (e.transformStyle && this.style && !this.style._loaded)
                      return void this.style.once("style.load", () =>
                        this._updateStyle(h, e)
                      );
                    const u =
                      this.style && e.transformStyle
                        ? this.style.serialize()
                        : void 0;
                    return (
                      this.style &&
                        (this.style.setEventedParent(null),
                        this.style._remove(!h)),
                      h
                        ? ((this.style = new Us(this, e || {})),
                          this.style.setEventedParent(this, {
                            style: this.style,
                          }),
                          typeof h == "string"
                            ? this.style.loadURL(h, e, u)
                            : this.style.loadJSON(h, e, u),
                          this)
                        : ((l =
                            (i = this.style) === null || i === void 0
                              ? void 0
                              : i.projection) === null ||
                            l === void 0 ||
                            l.destroy(),
                          delete this.style,
                          this)
                    );
                  }
                  _lazyInitEmptyStyle() {
                    this.style ||
                      ((this.style = new Us(this, {})),
                      this.style.setEventedParent(this, { style: this.style }),
                      this.style.loadEmpty());
                  }
                  _diffStyle(h, e) {
                    if (typeof h == "string") {
                      const i = this._requestManager.transformRequest(
                        h,
                        "Style"
                      );
                      s.j(i, new AbortController())
                        .then((l) => {
                          this._updateDiff(l.data, e);
                        })
                        .catch((l) => {
                          l && this.fire(new s.k(l));
                        });
                    } else typeof h == "object" && this._updateDiff(h, e);
                  }
                  _updateDiff(h, e) {
                    try {
                      this.style.setState(h, e) && this._update(!0);
                    } catch (i) {
                      s.w(
                        `Unable to perform style diff: ${
                          i.message || i.error || i
                        }.  Rebuilding the style from scratch.`
                      ),
                        this._updateStyle(h, e);
                    }
                  }
                  getStyle() {
                    if (this.style) return this.style.serialize();
                  }
                  isStyleLoaded() {
                    return this.style
                      ? this.style.loaded()
                      : s.w("There is no style added to the map.");
                  }
                  addSource(h, e) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addSource(h, e),
                      this._update(!0)
                    );
                  }
                  isSourceLoaded(h) {
                    const e = this.style && this.style.tileManagers[h];
                    if (e !== void 0) return e.loaded();
                    this.fire(
                      new s.k(
                        new Error(`There is no tile manager with ID '${h}'`)
                      )
                    );
                  }
                  setTerrain(h) {
                    if (
                      (this.style._checkLoaded(),
                      this._terrainDataCallback &&
                        this.style.off("data", this._terrainDataCallback),
                      h)
                    ) {
                      const e = this.style.tileManagers[h.source];
                      if (!e)
                        throw new Error(
                          `cannot load terrain, because there exists no source with ID: ${h.source}`
                        );
                      this.terrain === null && e.reload();
                      for (const i in this.style._layers) {
                        const l = this.style._layers[i];
                        l.type === "hillshade" &&
                          l.source === h.source &&
                          s.w(
                            "You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."
                          ),
                          l.type === "color-relief" &&
                            l.source === h.source &&
                            s.w(
                              "You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."
                            );
                      }
                      (this.terrain = new wf(this.painter, e, h)),
                        (this.painter.renderToTexture = new ti(
                          this.painter,
                          this.terrain
                        )),
                        this.transform.setMinElevationForCurrentTile(
                          this.terrain.getMinTileElevationForLngLatZoom(
                            this.transform.center,
                            this.transform.tileZoom
                          )
                        ),
                        this.transform.setElevation(
                          this.terrain.getElevationForLngLatZoom(
                            this.transform.center,
                            this.transform.tileZoom
                          )
                        ),
                        (this._terrainDataCallback = (i) => {
                          var l;
                          i.dataType === "style"
                            ? this.terrain.tileManager.freeRtt()
                            : i.dataType === "source" &&
                              i.tile &&
                              (i.sourceId !== h.source ||
                                this._elevationFreeze ||
                                (this.transform.setMinElevationForCurrentTile(
                                  this.terrain.getMinTileElevationForLngLatZoom(
                                    this.transform.center,
                                    this.transform.tileZoom
                                  )
                                ),
                                this._centerClampedToGround &&
                                  this.transform.setElevation(
                                    this.terrain.getElevationForLngLatZoom(
                                      this.transform.center,
                                      this.transform.tileZoom
                                    )
                                  )),
                              ((l = i.source) === null || l === void 0
                                ? void 0
                                : l.type) === "image"
                                ? this.terrain.tileManager.freeRtt()
                                : this.terrain.tileManager.freeRtt(
                                    i.tile.tileID
                                  ));
                        }),
                        this.style.on("data", this._terrainDataCallback);
                    } else
                      this.terrain && this.terrain.tileManager.destruct(),
                        (this.terrain = null),
                        this.painter.renderToTexture &&
                          this.painter.renderToTexture.destruct(),
                        (this.painter.renderToTexture = null),
                        this.transform.setMinElevationForCurrentTile(0),
                        this._centerClampedToGround &&
                          this.transform.setElevation(0);
                    return this.fire(new s.l("terrain", { terrain: h })), this;
                  }
                  getTerrain() {
                    var h, e;
                    return (e =
                      (h = this.terrain) === null || h === void 0
                        ? void 0
                        : h.options) !== null && e !== void 0
                      ? e
                      : null;
                  }
                  areTilesLoaded() {
                    const h = this.style && this.style.tileManagers;
                    for (const e in h) {
                      const i = h[e]._tiles;
                      for (const l in i) {
                        const u = i[l];
                        if (u.state !== "loaded" && u.state !== "errored")
                          return !1;
                      }
                    }
                    return !0;
                  }
                  removeSource(h) {
                    return this.style.removeSource(h), this._update(!0);
                  }
                  getSource(h) {
                    return this.style.getSource(h);
                  }
                  setSourceTileLodParams(h, e, i) {
                    if (i) {
                      const l = this.getSource(i);
                      if (!l)
                        throw new Error(
                          `There is no source with ID "${i}", cannot set LOD parameters`
                        );
                      l.calculateTileZoom = Ot(Math.max(1, h), Math.max(1, e));
                    } else
                      for (const l in this.style.tileManagers)
                        this.style.tileManagers[
                          l
                        ].getSource().calculateTileZoom = Ot(
                          Math.max(1, h),
                          Math.max(1, e)
                        );
                    return this._update(!0), this;
                  }
                  refreshTiles(h, e) {
                    const i = this.style.tileManagers[h];
                    if (!i)
                      throw new Error(
                        `There is no tile manager with ID "${h}", cannot refresh tile`
                      );
                    e === void 0
                      ? i.reload(!0)
                      : i.refreshTiles(e.map((l) => new s.a8(l.z, l.x, l.y)));
                  }
                  addImage(h, e, i = {}) {
                    const {
                      pixelRatio: l = 1,
                      sdf: u = !1,
                      stretchX: d,
                      stretchY: g,
                      content: w,
                      textFitWidth: S,
                      textFitHeight: k,
                    } = i;
                    if (
                      (this._lazyInitEmptyStyle(),
                      !(e instanceof HTMLImageElement || s.b(e)))
                    ) {
                      if (e.width === void 0 || e.height === void 0)
                        return this.fire(
                          new s.k(
                            new Error(
                              "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                            )
                          )
                        );
                      {
                        const { width: z, height: V, data: F } = e,
                          $ = e;
                        return (
                          this.style.addImage(h, {
                            data: new s.R(
                              { width: z, height: V },
                              new Uint8Array(F)
                            ),
                            pixelRatio: l,
                            stretchX: d,
                            stretchY: g,
                            content: w,
                            textFitWidth: S,
                            textFitHeight: k,
                            sdf: u,
                            version: 0,
                            userImage: $,
                          }),
                          $.onAdd && $.onAdd(this, h),
                          this
                        );
                      }
                    }
                    {
                      const {
                        width: z,
                        height: V,
                        data: F,
                      } = re.getImageData(e);
                      this.style.addImage(h, {
                        data: new s.R({ width: z, height: V }, F),
                        pixelRatio: l,
                        stretchX: d,
                        stretchY: g,
                        content: w,
                        textFitWidth: S,
                        textFitHeight: k,
                        sdf: u,
                        version: 0,
                      });
                    }
                  }
                  updateImage(h, e) {
                    const i = this.style.getImage(h);
                    if (!i)
                      return this.fire(
                        new s.k(
                          new Error(
                            "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."
                          )
                        )
                      );
                    const l =
                        e instanceof HTMLImageElement || s.b(e)
                          ? re.getImageData(e)
                          : e,
                      { width: u, height: d, data: g } = l;
                    if (u === void 0 || d === void 0)
                      return this.fire(
                        new s.k(
                          new Error(
                            "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                          )
                        )
                      );
                    if (u !== i.data.width || d !== i.data.height)
                      return this.fire(
                        new s.k(
                          new Error(
                            "The width and height of the updated image must be that same as the previous version of the image"
                          )
                        )
                      );
                    const w = !(e instanceof HTMLImageElement || s.b(e));
                    return (
                      i.data.replace(g, w), this.style.updateImage(h, i), this
                    );
                  }
                  getImage(h) {
                    return this.style.getImage(h);
                  }
                  hasImage(h) {
                    return h
                      ? !!this.style.getImage(h)
                      : (this.fire(
                          new s.k(new Error("Missing required image id"))
                        ),
                        !1);
                  }
                  removeImage(h) {
                    this.style.removeImage(h);
                  }
                  loadImage(h) {
                    return Ue.getImage(
                      this._requestManager.transformRequest(h, "Image"),
                      new AbortController()
                    );
                  }
                  listImages() {
                    return this.style.listImages();
                  }
                  addLayer(h, e) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addLayer(h, e),
                      this._update(!0)
                    );
                  }
                  moveLayer(h, e) {
                    return this.style.moveLayer(h, e), this._update(!0);
                  }
                  removeLayer(h) {
                    return this.style.removeLayer(h), this._update(!0);
                  }
                  getLayer(h) {
                    return this.style.getLayer(h);
                  }
                  getLayersOrder() {
                    return this.style.getLayersOrder();
                  }
                  setLayerZoomRange(h, e, i) {
                    return (
                      this.style.setLayerZoomRange(h, e, i), this._update(!0)
                    );
                  }
                  setFilter(h, e, i = {}) {
                    return this.style.setFilter(h, e, i), this._update(!0);
                  }
                  getFilter(h) {
                    return this.style.getFilter(h);
                  }
                  setPaintProperty(h, e, i, l = {}) {
                    return (
                      this.style.setPaintProperty(h, e, i, l), this._update(!0)
                    );
                  }
                  getPaintProperty(h, e) {
                    return this.style.getPaintProperty(h, e);
                  }
                  setLayoutProperty(h, e, i, l = {}) {
                    return (
                      this.style.setLayoutProperty(h, e, i, l), this._update(!0)
                    );
                  }
                  getLayoutProperty(h, e) {
                    return this.style.getLayoutProperty(h, e);
                  }
                  setGlyphs(h, e = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setGlyphs(h, e),
                      this._update(!0)
                    );
                  }
                  getGlyphs() {
                    return this.style.getGlyphsUrl();
                  }
                  addSprite(h, e, i = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addSprite(h, e, i, (l) => {
                        l || this._update(!0);
                      }),
                      this
                    );
                  }
                  removeSprite(h) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.removeSprite(h),
                      this._update(!0)
                    );
                  }
                  getSprite() {
                    return this.style.getSprite();
                  }
                  setSprite(h, e = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setSprite(h, e, (i) => {
                        i || this._update(!0);
                      }),
                      this
                    );
                  }
                  setLight(h, e = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setLight(h, e),
                      this._update(!0)
                    );
                  }
                  getLight() {
                    return this.style.getLight();
                  }
                  setSky(h, e = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setSky(h, e),
                      this._update(!0)
                    );
                  }
                  getSky() {
                    return this.style.getSky();
                  }
                  setFeatureState(h, e) {
                    return this.style.setFeatureState(h, e), this._update();
                  }
                  removeFeatureState(h, e) {
                    return this.style.removeFeatureState(h, e), this._update();
                  }
                  getFeatureState(h) {
                    return this.style.getFeatureState(h);
                  }
                  getContainer() {
                    return this._container;
                  }
                  getCanvasContainer() {
                    return this._canvasContainer;
                  }
                  getCanvas() {
                    return this._canvas;
                  }
                  _containerDimensions() {
                    let h = 0,
                      e = 0;
                    return (
                      this._container &&
                        ((h = this._container.clientWidth || 400),
                        (e = this._container.clientHeight || 300)),
                      [h, e]
                    );
                  }
                  _setupContainer() {
                    const h = this._container;
                    h.classList.add("maplibregl-map");
                    const e = (this._canvasContainer = Y.create(
                      "div",
                      "maplibregl-canvas-container",
                      h
                    ));
                    this._interactive &&
                      e.classList.add("maplibregl-interactive"),
                      (this._canvas = Y.create(
                        "canvas",
                        "maplibregl-canvas",
                        e
                      )),
                      this._canvas.addEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      this._canvas.addEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvas.setAttribute(
                        "tabindex",
                        this._interactive ? "0" : "-1"
                      ),
                      this._canvas.setAttribute(
                        "aria-label",
                        this._getUIString("Map.Title")
                      ),
                      this._canvas.setAttribute("role", "region");
                    const i = this._containerDimensions(),
                      l = this._getClampedPixelRatio(i[0], i[1]);
                    this._resizeCanvas(i[0], i[1], l);
                    const u = (this._controlContainer = Y.create(
                        "div",
                        "maplibregl-control-container",
                        h
                      )),
                      d = (this._controlPositions = {});
                    [
                      "top-left",
                      "top-right",
                      "bottom-left",
                      "bottom-right",
                    ].forEach((g) => {
                      d[g] = Y.create("div", `maplibregl-ctrl-${g} `, u);
                    }),
                      this._container.addEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      );
                  }
                  _resizeCanvas(h, e, i) {
                    (this._canvas.width = Math.floor(i * h)),
                      (this._canvas.height = Math.floor(i * e)),
                      (this._canvas.style.width = `${h}px`),
                      (this._canvas.style.height = `${e}px`);
                  }
                  _setupPainter() {
                    const h = Object.assign(
                      Object.assign({}, this._canvasContextAttributes),
                      {
                        alpha: !0,
                        depth: !0,
                        stencil: !0,
                        premultipliedAlpha: !0,
                      }
                    );
                    let e = null;
                    this._canvas.addEventListener(
                      "webglcontextcreationerror",
                      (l) => {
                        (e = { requestedAttributes: h }),
                          l &&
                            ((e.statusMessage = l.statusMessage),
                            (e.type = l.type));
                      },
                      { once: !0 }
                    );
                    let i = null;
                    if (
                      ((i = this._canvasContextAttributes.contextType
                        ? this._canvas.getContext(
                            this._canvasContextAttributes.contextType,
                            h
                          )
                        : this._canvas.getContext("webgl2", h) ||
                          this._canvas.getContext("webgl", h)),
                      !i)
                    ) {
                      const l = "Failed to initialize WebGL";
                      throw e
                        ? ((e.message = l), new Error(JSON.stringify(e)))
                        : new Error(l);
                    }
                    (this.painter = new Pd(i, this.transform)),
                      xe.testSupport(i);
                  }
                  migrateProjection(h, e) {
                    super.migrateProjection(h, e),
                      (this.painter.transform = h),
                      this.fire(
                        new s.l("projectiontransition", {
                          newProjection: this.style.projection.name,
                        })
                      );
                  }
                  loaded() {
                    return (
                      !this._styleDirty &&
                      !this._sourcesDirty &&
                      !!this.style &&
                      this.style.loaded()
                    );
                  }
                  _update(h) {
                    return this.style && this.style._loaded
                      ? ((this._styleDirty = this._styleDirty || h),
                        (this._sourcesDirty = !0),
                        this.triggerRepaint(),
                        this)
                      : this;
                  }
                  _requestRenderFrame(h) {
                    return this._update(), this._renderTaskQueue.add(h);
                  }
                  _cancelRenderFrame(h) {
                    this._renderTaskQueue.remove(h);
                  }
                  _render(h) {
                    var e, i, l, u, d;
                    const g = this._idleTriggered ? this._fadeDuration : 0,
                      w =
                        ((e = this.style.projection) === null || e === void 0
                          ? void 0
                          : e.transitionState) > 0;
                    if (
                      (this.painter.context.setDirty(),
                      this.painter.setBaseState(),
                      this._renderTaskQueue.run(h),
                      this._removed)
                    )
                      return;
                    let S = !1;
                    if (this.style && this._styleDirty) {
                      this._styleDirty = !1;
                      const V = this.transform.zoom,
                        F = ne();
                      this.style.zoomHistory.update(V, F);
                      const $ = new s.G(V, {
                          now: F,
                          fadeDuration: g,
                          zoomHistory: this.style.zoomHistory,
                          transition: this.style.getTransition(),
                        }),
                        J = $.crossFadingFactor();
                      (J === 1 && J === this._crossFadingFactor) ||
                        ((S = !0), (this._crossFadingFactor = J)),
                        this.style.update($);
                    }
                    const k =
                      ((i = this.style.projection) === null || i === void 0
                        ? void 0
                        : i.transitionState) >
                        0 !==
                      w;
                    (l = this.style.projection) === null ||
                      l === void 0 ||
                      l.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                      this.transform.setTransitionState(
                        (u = this.style.projection) === null || u === void 0
                          ? void 0
                          : u.transitionState,
                        (d = this.style.projection) === null || d === void 0
                          ? void 0
                          : d.latitudeErrorCorrectionRadians
                      ),
                      this.style &&
                        (this._sourcesDirty || k) &&
                        ((this._sourcesDirty = !1),
                        this.style._updateSources(this.transform)),
                      this.terrain
                        ? (this.terrain.tileManager.update(
                            this.transform,
                            this.terrain
                          ),
                          this.transform.setMinElevationForCurrentTile(
                            this.terrain.getMinTileElevationForLngLatZoom(
                              this.transform.center,
                              this.transform.tileZoom
                            )
                          ),
                          !this._elevationFreeze &&
                            this._centerClampedToGround &&
                            this.transform.setElevation(
                              this.terrain.getElevationForLngLatZoom(
                                this.transform.center,
                                this.transform.tileZoom
                              )
                            ))
                        : (this.transform.setMinElevationForCurrentTile(0),
                          this._centerClampedToGround &&
                            this.transform.setElevation(0)),
                      (this._placementDirty =
                        this.style &&
                        this.style._updatePlacement(
                          this.transform,
                          this.showCollisionBoxes,
                          g,
                          this._crossSourceCollisions,
                          k
                        )),
                      this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showOverdrawInspector: this._showOverdrawInspector,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: g,
                        showPadding: this.showPadding,
                      }),
                      this.fire(new s.l("render")),
                      this.loaded() &&
                        !this._loaded &&
                        ((this._loaded = !0),
                        s.cz.mark(s.cA.load),
                        this.fire(new s.l("load"))),
                      this.style &&
                        (this.style.hasTransitions() || S) &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this._placementDirty &&
                        this.style._releaseSymbolFadeTiles();
                    const z =
                      this._sourcesDirty ||
                      this._styleDirty ||
                      this._placementDirty;
                    return (
                      z || this._repaint
                        ? this.triggerRepaint()
                        : !this.isMoving() &&
                          this.loaded() &&
                          this.fire(new s.l("idle")),
                      !this._loaded ||
                        this._fullyLoaded ||
                        z ||
                        ((this._fullyLoaded = !0), s.cz.mark(s.cA.fullLoad)),
                      this
                    );
                  }
                  redraw() {
                    return (
                      this.style &&
                        (this._frameRequest &&
                          (this._frameRequest.abort(),
                          (this._frameRequest = null)),
                        this._render(0)),
                      this
                    );
                  }
                  remove() {
                    var h;
                    this._hash && this._hash.remove();
                    for (const i of this._controls) i.onRemove(this);
                    (this._controls = []),
                      this._frameRequest &&
                        (this._frameRequest.abort(),
                        (this._frameRequest = null)),
                      this._renderTaskQueue.clear(),
                      this.painter.destroy(),
                      this.handlers.destroy(),
                      delete this.handlers,
                      this.setStyle(null),
                      typeof window < "u" &&
                        removeEventListener("online", this._onWindowOnline, !1),
                      Ue.removeThrottleControl(this._imageQueueHandle),
                      (h = this._resizeObserver) === null ||
                        h === void 0 ||
                        h.disconnect();
                    const e =
                      this.painter.context.gl.getExtension(
                        "WEBGL_lose_context"
                      );
                    e != null && e.loseContext && e.loseContext(),
                      this._canvas.removeEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvas.removeEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      Y.remove(this._canvasContainer),
                      Y.remove(this._controlContainer),
                      this._container.removeEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      ),
                      this._container.classList.remove("maplibregl-map"),
                      s.cz.clearMetrics(),
                      (this._removed = !0),
                      this.fire(new s.l("remove"));
                  }
                  triggerRepaint() {
                    this.style &&
                      !this._frameRequest &&
                      ((this._frameRequest = new AbortController()),
                      re.frame(
                        this._frameRequest,
                        (h) => {
                          s.cz.frame(h), (this._frameRequest = null);
                          try {
                            this._render(h);
                          } catch (e) {
                            if (
                              !s.cB(e) &&
                              !(function (i) {
                                return i.message === vd;
                              })(e)
                            )
                              throw e;
                          }
                        },
                        () => {}
                      ));
                  }
                  get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                  }
                  set showTileBoundaries(h) {
                    this._showTileBoundaries !== h &&
                      ((this._showTileBoundaries = h), this._update());
                  }
                  get showPadding() {
                    return !!this._showPadding;
                  }
                  set showPadding(h) {
                    this._showPadding !== h &&
                      ((this._showPadding = h), this._update());
                  }
                  get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                  }
                  set showCollisionBoxes(h) {
                    this._showCollisionBoxes !== h &&
                      ((this._showCollisionBoxes = h),
                      h
                        ? this.style._generateCollisionBoxes()
                        : this._update());
                  }
                  get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                  }
                  set showOverdrawInspector(h) {
                    this._showOverdrawInspector !== h &&
                      ((this._showOverdrawInspector = h), this._update());
                  }
                  get repaint() {
                    return !!this._repaint;
                  }
                  set repaint(h) {
                    this._repaint !== h &&
                      ((this._repaint = h), this.triggerRepaint());
                  }
                  get vertices() {
                    return !!this._vertices;
                  }
                  set vertices(h) {
                    (this._vertices = h), this._update();
                  }
                  get version() {
                    return Hd;
                  }
                  getCameraTargetElevation() {
                    return this.transform.elevation;
                  }
                  getProjection() {
                    return this.style.getProjection();
                  }
                  setProjection(h) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setProjection(h),
                      this._update(!0)
                    );
                  }
                }),
                (T.MapMouseEvent = na),
                (T.MapTouchEvent = Xi),
                (T.MapWheelEvent = zd),
                (T.Marker = al),
                (T.NavigationControl = class {
                  constructor(h) {
                    (this._updateZoomButtons = () => {
                      const e = this._map.getZoom(),
                        i = e === this._map.getMaxZoom(),
                        l = e === this._map.getMinZoom();
                      (this._zoomInButton.disabled = i),
                        (this._zoomOutButton.disabled = l),
                        this._zoomInButton.setAttribute(
                          "aria-disabled",
                          i.toString()
                        ),
                        this._zoomOutButton.setAttribute(
                          "aria-disabled",
                          l.toString()
                        );
                    }),
                      (this._rotateCompassArrow = () => {
                        this._compassIcon.style.transform =
                          this.options.visualizePitch &&
                          this.options.visualizeRoll
                            ? `scale(${
                                1 /
                                Math.pow(
                                  Math.cos(this._map.transform.pitchInRadians),
                                  0.5
                                )
                              }) rotateZ(${-this._map.transform
                                .roll}deg) rotateX(${
                                this._map.transform.pitch
                              }deg) rotateZ(${-this._map.transform.bearing}deg)`
                            : this.options.visualizePitch
                            ? `scale(${
                                1 /
                                Math.pow(
                                  Math.cos(this._map.transform.pitchInRadians),
                                  0.5
                                )
                              }) rotateX(${
                                this._map.transform.pitch
                              }deg) rotateZ(${-this._map.transform.bearing}deg)`
                            : this.options.visualizeRoll
                            ? `rotate(${
                                -this._map.transform.bearing -
                                this._map.transform.roll
                              }deg)`
                            : `rotate(${-this._map.transform.bearing}deg)`;
                      }),
                      (this._setButtonTitle = (e, i) => {
                        const l = this._map._getUIString(
                          `NavigationControl.${i}`
                        );
                        (e.title = l), e.setAttribute("aria-label", l);
                      }),
                      (this.options = s.e({}, Jl, h)),
                      (this._container = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-group"
                      )),
                      this._container.addEventListener("contextmenu", (e) =>
                        e.preventDefault()
                      ),
                      this.options.showZoom &&
                        ((this._zoomInButton = this._createButton(
                          "maplibregl-ctrl-zoom-in",
                          (e) => this._map.zoomIn({}, { originalEvent: e })
                        )),
                        Y.create(
                          "span",
                          "maplibregl-ctrl-icon",
                          this._zoomInButton
                        ).setAttribute("aria-hidden", "true"),
                        (this._zoomOutButton = this._createButton(
                          "maplibregl-ctrl-zoom-out",
                          (e) => this._map.zoomOut({}, { originalEvent: e })
                        )),
                        Y.create(
                          "span",
                          "maplibregl-ctrl-icon",
                          this._zoomOutButton
                        ).setAttribute("aria-hidden", "true")),
                      this.options.showCompass &&
                        ((this._compass = this._createButton(
                          "maplibregl-ctrl-compass",
                          (e) => {
                            this.options.visualizePitch
                              ? this._map.resetNorthPitch(
                                  {},
                                  { originalEvent: e }
                                )
                              : this._map.resetNorth({}, { originalEvent: e });
                          }
                        )),
                        (this._compassIcon = Y.create(
                          "span",
                          "maplibregl-ctrl-icon",
                          this._compass
                        )),
                        this._compassIcon.setAttribute("aria-hidden", "true"));
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      this.options.showZoom &&
                        (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        this._map.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                      this.options.showCompass &&
                        (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch &&
                          this._map.on("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll &&
                          this._map.on("roll", this._rotateCompassArrow),
                        this._map.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        (this._handler = new Su(
                          this._map,
                          this._compass,
                          this.options.visualizePitch
                        ))),
                      this._container
                    );
                  }
                  onRemove() {
                    Y.remove(this._container),
                      this.options.showZoom &&
                        this._map.off("zoom", this._updateZoomButtons),
                      this.options.showCompass &&
                        (this.options.visualizePitch &&
                          this._map.off("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll &&
                          this._map.off("roll", this._rotateCompassArrow),
                        this._map.off("rotate", this._rotateCompassArrow),
                        this._handler.off(),
                        delete this._handler),
                      delete this._map;
                  }
                  _createButton(h, e) {
                    const i = Y.create("button", h, this._container);
                    return (
                      (i.type = "button"), i.addEventListener("click", e), i
                    );
                  }
                }),
                (T.Popup = class extends s.E {
                  constructor(h) {
                    super(),
                      (this._updateOpacity = () => {
                        this.options.locationOccludedOpacity !== void 0 &&
                          (this._container.style.opacity =
                            this._map.transform.isLocationOccluded(
                              this.getLngLat()
                            )
                              ? `${this.options.locationOccludedOpacity}`
                              : "");
                      }),
                      (this.remove = () => (
                        this._content && Y.remove(this._content),
                        this._container &&
                          (Y.remove(this._container), delete this._container),
                        this._map &&
                          (this._map.off("move", this._update),
                          this._map.off("move", this._onClose),
                          this._map.off("click", this._onClose),
                          this._map.off("remove", this.remove),
                          this._map.off("mousemove", this._onMouseMove),
                          this._map.off("mouseup", this._onMouseUp),
                          this._map.off("drag", this._onDrag),
                          this._map._canvasContainer.classList.remove(
                            "maplibregl-track-pointer"
                          ),
                          delete this._map,
                          this.fire(new s.l("close"))),
                        this
                      )),
                      (this._onMouseUp = (e) => {
                        this._update(e.point);
                      }),
                      (this._onMouseMove = (e) => {
                        this._update(e.point);
                      }),
                      (this._onDrag = (e) => {
                        this._update(e.point);
                      }),
                      (this._update = (e) => {
                        if (
                          !this._map ||
                          (!this._lngLat && !this._trackPointer) ||
                          !this._content
                        )
                          return;
                        if (!this._container) {
                          if (
                            ((this._container = Y.create(
                              "div",
                              "maplibregl-popup",
                              this._map.getContainer()
                            )),
                            (this._tip = Y.create(
                              "div",
                              "maplibregl-popup-tip",
                              this._container
                            )),
                            this._container.appendChild(this._content),
                            this.options.className)
                          )
                            for (const g of this.options.className.split(" "))
                              this._container.classList.add(g);
                          this._closeButton &&
                            this._closeButton.setAttribute(
                              "aria-label",
                              this._map._getUIString("Popup.Close")
                            ),
                            this._trackPointer &&
                              this._container.classList.add(
                                "maplibregl-popup-track-pointer"
                              );
                        }
                        if (
                          (this.options.maxWidth &&
                            this._container.style.maxWidth !==
                              this.options.maxWidth &&
                            (this._container.style.maxWidth =
                              this.options.maxWidth),
                          (this._lngLat = Ql(
                            this._lngLat,
                            this._flatPos,
                            this._map.transform,
                            this._trackPointer
                          )),
                          this._trackPointer && !e)
                        )
                          return;
                        const i =
                          (this._flatPos =
                          this._pos =
                            this._trackPointer && e
                              ? e
                              : this._map.project(this._lngLat));
                        this._map.terrain &&
                          (this._flatPos =
                            this._trackPointer && e
                              ? e
                              : this._map.transform.locationToScreenPoint(
                                  this._lngLat
                                ));
                        let l = this.options.anchor;
                        const u = nc(this.options.offset);
                        if (!l) {
                          const g = this._container.offsetWidth,
                            w = this._container.offsetHeight;
                          let S;
                          (S =
                            i.y + u.bottom.y < w
                              ? ["top"]
                              : i.y > this._map.transform.height - w
                              ? ["bottom"]
                              : []),
                            i.x < g / 2
                              ? S.push("left")
                              : i.x > this._map.transform.width - g / 2 &&
                                S.push("right"),
                            (l = S.length === 0 ? "bottom" : S.join("-"));
                        }
                        let d = i.add(u[l]);
                        this.options.subpixelPositioning || (d = d.round()),
                          Y.setTransform(
                            this._container,
                            `${Wo[l]} translate(${d.x}px,${d.y}px)`
                          ),
                          ec(this._container, l, "popup"),
                          this._updateOpacity();
                      }),
                      (this._onClose = () => {
                        this.remove();
                      }),
                      (this.options = s.e(Object.create(Iu), h));
                  }
                  addTo(h) {
                    return (
                      this._map && this.remove(),
                      (this._map = h),
                      this.options.closeOnClick &&
                        this._map.on("click", this._onClose),
                      this.options.closeOnMove &&
                        this._map.on("move", this._onClose),
                      this._map.on("remove", this.remove),
                      this._update(),
                      this._focusFirstElement(),
                      this._trackPointer
                        ? (this._map.on("mousemove", this._onMouseMove),
                          this._map.on("mouseup", this._onMouseUp),
                          this._container &&
                            this._container.classList.add(
                              "maplibregl-popup-track-pointer"
                            ),
                          this._map._canvasContainer.classList.add(
                            "maplibregl-track-pointer"
                          ))
                        : this._map.on("move", this._update),
                      this.fire(new s.l("open")),
                      this
                    );
                  }
                  isOpen() {
                    return !!this._map;
                  }
                  getLngLat() {
                    return this._lngLat;
                  }
                  setLngLat(h) {
                    return (
                      (this._lngLat = s.U.convert(h)),
                      (this._pos = null),
                      (this._flatPos = null),
                      (this._trackPointer = !1),
                      this._update(),
                      this._map &&
                        (this._map.on("move", this._update),
                        this._map.off("mousemove", this._onMouseMove),
                        this._container &&
                          this._container.classList.remove(
                            "maplibregl-popup-track-pointer"
                          ),
                        this._map._canvasContainer.classList.remove(
                          "maplibregl-track-pointer"
                        )),
                      this
                    );
                  }
                  trackPointer() {
                    return (
                      (this._trackPointer = !0),
                      (this._pos = null),
                      (this._flatPos = null),
                      this._update(),
                      this._map &&
                        (this._map.off("move", this._update),
                        this._map.on("mousemove", this._onMouseMove),
                        this._map.on("drag", this._onDrag),
                        this._container &&
                          this._container.classList.add(
                            "maplibregl-popup-track-pointer"
                          ),
                        this._map._canvasContainer.classList.add(
                          "maplibregl-track-pointer"
                        )),
                      this
                    );
                  }
                  getElement() {
                    return this._container;
                  }
                  setText(h) {
                    return this.setDOMContent(document.createTextNode(h));
                  }
                  setHTML(h) {
                    const e = document.createDocumentFragment(),
                      i = document.createElement("body");
                    let l;
                    for (i.innerHTML = h; (l = i.firstChild), l; )
                      e.appendChild(l);
                    return this.setDOMContent(e);
                  }
                  getMaxWidth() {
                    var h;
                    return (h = this._container) === null || h === void 0
                      ? void 0
                      : h.style.maxWidth;
                  }
                  setMaxWidth(h) {
                    return (this.options.maxWidth = h), this._update(), this;
                  }
                  setDOMContent(h) {
                    if (this._content)
                      for (; this._content.hasChildNodes(); )
                        this._content.firstChild &&
                          this._content.removeChild(this._content.firstChild);
                    else
                      this._content = Y.create(
                        "div",
                        "maplibregl-popup-content",
                        this._container
                      );
                    return (
                      this._content.appendChild(h),
                      this._createCloseButton(),
                      this._update(),
                      this._focusFirstElement(),
                      this
                    );
                  }
                  addClassName(h) {
                    return (
                      this._container && this._container.classList.add(h), this
                    );
                  }
                  removeClassName(h) {
                    return (
                      this._container && this._container.classList.remove(h),
                      this
                    );
                  }
                  setOffset(h) {
                    return (this.options.offset = h), this._update(), this;
                  }
                  toggleClassName(h) {
                    if (this._container)
                      return this._container.classList.toggle(h);
                  }
                  setSubpixelPositioning(h) {
                    this.options.subpixelPositioning = h;
                  }
                  _createCloseButton() {
                    this.options.closeButton &&
                      ((this._closeButton = Y.create(
                        "button",
                        "maplibregl-popup-close-button",
                        this._content
                      )),
                      (this._closeButton.type = "button"),
                      (this._closeButton.innerHTML = "&#215;"),
                      this._closeButton.addEventListener(
                        "click",
                        this._onClose
                      ));
                  }
                  _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                      return;
                    const h = this._container.querySelector(rc);
                    h && h.focus();
                  }
                }),
                (T.RasterDEMTileSource = jt),
                (T.RasterTileSource = Nt),
                (T.ScaleControl = class {
                  constructor(h) {
                    (this._onMove = () => {
                      tc(this._map, this._container, this.options);
                    }),
                      (this.setUnit = (e) => {
                        (this.options.unit = e),
                          tc(this._map, this._container, this.options);
                      }),
                      (this.options = Object.assign(Object.assign({}, Pu), h));
                  }
                  getDefaultPosition() {
                    return "bottom-left";
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      (this._container = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-scale",
                        h.getContainer()
                      )),
                      this._map.on("move", this._onMove),
                      this._onMove(),
                      this._container
                    );
                  }
                  onRemove() {
                    Y.remove(this._container),
                      this._map.off("move", this._onMove),
                      (this._map = void 0);
                  }
                }),
                (T.ScrollZoomHandler = qd),
                (T.Style = Us),
                (T.TerrainControl = class {
                  constructor(h) {
                    (this._toggleTerrain = () => {
                      this._map.getTerrain()
                        ? this._map.setTerrain(null)
                        : this._map.setTerrain(this.options),
                        this._updateTerrainIcon();
                    }),
                      (this._updateTerrainIcon = () => {
                        this._terrainButton.classList.remove(
                          "maplibregl-ctrl-terrain"
                        ),
                          this._terrainButton.classList.remove(
                            "maplibregl-ctrl-terrain-enabled"
                          ),
                          this._map.terrain
                            ? (this._terrainButton.classList.add(
                                "maplibregl-ctrl-terrain-enabled"
                              ),
                              (this._terrainButton.title =
                                this._map._getUIString(
                                  "TerrainControl.Disable"
                                )))
                            : (this._terrainButton.classList.add(
                                "maplibregl-ctrl-terrain"
                              ),
                              (this._terrainButton.title =
                                this._map._getUIString(
                                  "TerrainControl.Enable"
                                )));
                      }),
                      (this.options = h);
                  }
                  onAdd(h) {
                    return (
                      (this._map = h),
                      (this._container = Y.create(
                        "div",
                        "maplibregl-ctrl maplibregl-ctrl-group"
                      )),
                      (this._terrainButton = Y.create(
                        "button",
                        "maplibregl-ctrl-terrain",
                        this._container
                      )),
                      Y.create(
                        "span",
                        "maplibregl-ctrl-icon",
                        this._terrainButton
                      ).setAttribute("aria-hidden", "true"),
                      (this._terrainButton.type = "button"),
                      this._terrainButton.addEventListener(
                        "click",
                        this._toggleTerrain
                      ),
                      this._updateTerrainIcon(),
                      this._map.on("terrain", this._updateTerrainIcon),
                      this._container
                    );
                  }
                  onRemove() {
                    Y.remove(this._container),
                      this._map.off("terrain", this._updateTerrainIcon),
                      (this._map = void 0);
                  }
                }),
                (T.TwoFingersTouchPitchHandler = Nd),
                (T.TwoFingersTouchRotateHandler = Yl),
                (T.TwoFingersTouchZoomHandler = Od),
                (T.TwoFingersTouchZoomRotateHandler = Zd),
                (T.VectorTileSource = Lt),
                (T.VideoSource = pr),
                (T.addSourceType = (h, e) =>
                  s._(void 0, void 0, void 0, function* () {
                    if (Sr(h))
                      throw new Error(
                        `A source type called "${h}" already exists.`
                      );
                    ((i, l) => {
                      Dt[i] = l;
                    })(h, e);
                  })),
                (T.clearPrewarmedResources = function () {
                  const h = Ft;
                  h &&
                    (h.isPreloaded() && h.numActive() === 1
                      ? (h.release(mt), (Ft = null))
                      : console.warn(
                          "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"
                        ));
                }),
                (T.createTileMesh = Ka),
                (T.getMaxParallelImageRequests = function () {
                  return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
                }),
                (T.getRTLTextPluginStatus = function () {
                  return D().getRTLTextPluginStatus();
                }),
                (T.getVersion = function () {
                  return Mu;
                }),
                (T.getWorkerCount = function () {
                  return ct.workerCount;
                }),
                (T.getWorkerUrl = function () {
                  return s.a.WORKER_URL;
                }),
                (T.importScriptInWorkers = function (h) {
                  return It().broadcast("IS", h);
                }),
                (T.isTimeFrozen = function () {
                  return ue.isFrozen();
                }),
                (T.now = ne),
                (T.prewarm = function () {
                  at().acquire(mt);
                }),
                (T.restoreNow = function () {
                  ue.restoreNow();
                }),
                (T.setMaxParallelImageRequests = function (h) {
                  s.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
                }),
                (T.setNow = function (h) {
                  ue.setNow(h);
                }),
                (T.setRTLTextPlugin = function (h, e) {
                  return D().setRTLTextPlugin(h, e);
                }),
                (T.setWorkerCount = function (h) {
                  ct.workerCount = h;
                }),
                (T.setWorkerUrl = function (h) {
                  s.a.WORKER_URL = h;
                });
            });
          var L = f;
          return L;
        });
      })(Sp)),
    Sp.exports
  );
}
var z6 = E6();
const _p = J0(z6);
class jv {
  constructor(o) {
    Ir(this, "gm");
    Ir(this, "markers", new Map());
    Ir(this, "canvases", new Map());
    Ir(this, "canvasSize");
    Ir(this, "canvasOpacity", 0.8);
    (this.input = o), (this.gm = new ps(this.input.tileSize));
    const f = ey(o.img);
    this.canvasSize = Math.ceil(2e3 / f);
  }
  place([o, f]) {
    const x = this.gm.latLonToPixelsFloor(o, f, this.input.zoom),
      A = this.getMarkerId(x),
      L = this.gm.latLonToPixelBoundsLatLon(o, f, this.input.zoom),
      T = this.input.map;
    if (this.input.markerFn && !this.markers.has(A)) {
      const ee = this.input.markerFn();
      ee.setLngLat({ lat: L.min[0], lng: (L.max[1] + L.min[1]) / 2 }).addTo(T),
        this.markers.set(A, ee);
    }
    const { key: s, pos: B, innerPos: N } = this.getCanvasPos(x);
    let K = this.canvases.get(s);
    if (!K) {
      const ee = this.canvasSize,
        re = B.x * ee,
        ue = B.y * ee,
        ne = re + ee - 1,
        Y = ue + ee - 1,
        xe = this.gm.pixelsToLatLon(re, Y + 1, this.input.zoom),
        Ie = this.gm.pixelsToLatLon(ne + 1, ue, this.input.zoom);
      (K = new L6({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: b_({ min: xe, max: Ie }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity,
        },
      })),
        K.addTo(this.input.map),
        this.canvases.set(s, K);
    }
    K.place(N.x, N.y);
  }
  clear() {
    const o = this.input.map;
    for (const f of this.canvases.values()) f.removeFrom(o), f.removeDOM();
    this.canvases.clear();
    for (const f of this.markers.values()) f.remove();
    this.markers.clear();
  }
  clearAndPlace(o) {
    this.clear(), this.place(o);
  }
  remove([o, f]) {
    let x = !1;
    const A = this.gm.latLonToPixelsFloor(o, f, this.input.zoom),
      { key: L, innerPos: T } = this.getCanvasPos(A),
      s = this.canvases.get(L);
    s &&
      ((x = s.remove(T.x, T.y)),
      s.annotationsCount() === 0 &&
        (this.canvases.delete(L), s.removeFrom(this.input.map), s.removeDOM()));
    const B = this.getMarkerId(A),
      N = this.markers.get(B);
    return N == null || N.remove(), this.markers.delete(B), x;
  }
  setCanvasOpacity(o) {
    this.canvasOpacity = o;
    for (const f of this.canvases.values()) f.setOpacity(o);
  }
  getMarkerId([o, f]) {
    return `${this.input.id}:${o},${f}`;
  }
  getCanvasPos([o, f]) {
    const x = {
        x: Math.floor(o / this.canvasSize),
        y: Math.floor(f / this.canvasSize),
      },
      A = { x: o % this.canvasSize, y: f % this.canvasSize },
      L = `${x.x},${x.y}`;
    return { pos: x, innerPos: A, key: L };
  }
}
class L6 {
  constructor(o) {
    Ir(this, "annotations", new Set());
    Ir(this, "canvas");
    Ir(this, "imgSize");
    Ir(this, "maps", new Set());
    Ir(this, "pendingRepaint", !1);
    (this.input = o),
      (this.imgSize = ey(o.img)),
      (this.canvas = document.createElement("canvas")),
      (this.canvas.width = this.input.canvasSize * this.imgSize),
      (this.canvas.height = this.input.canvasSize * this.imgSize);
  }
  place(o, f) {
    const x = this.getPixelKey(o, f);
    if (this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const L = o * this.imgSize,
        T = f * this.imgSize;
      A.drawImage(this.input.img, L, T);
    }
    return this.annotations.add(x), this.triggerRepaint(), !0;
  }
  remove(o, f) {
    const x = this.getPixelKey(o, f);
    if (!this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const L = o * this.imgSize,
        T = f * this.imgSize;
      A.clearRect(L, T, this.imgSize, this.imgSize);
    }
    return this.annotations.delete(x), this.triggerRepaint(), !0;
  }
  addTo(o) {
    const f = this.input.id;
    o.getSource(f) ||
      o.addSource(f, {
        type: "canvas",
        canvas: this.canvas,
        coordinates: this.input.coordinates,
        animate: !1,
      }),
      o.getLayer(f) ||
        o.addLayer({
          id: f,
          type: "raster",
          source: f,
          paint: this.input.layerPaint,
        }),
      this.maps.add(o);
  }
  removeFrom(o) {
    const { id: f } = this.input;
    o.getLayer(f) && o.removeLayer(f),
      o.getSource(f) && o.removeSource(f),
      this.maps.delete(o);
  }
  removeDOM() {
    this.canvas.remove();
  }
  annotationsCount() {
    return this.annotations.size;
  }
  setOpacity(o) {
    for (const f of this.maps.values())
      f.setPaintProperty(this.input.id, "raster-opacity", o);
  }
  getPixelKey(o, f) {
    return `${o},${f}`;
  }
  triggerRepaint() {
    this.pendingRepaint ||
      ((this.pendingRepaint = !0),
      requestAnimationFrame(() => {
        for (const o of this.maps.values()) {
          const f = o.getSource(this.input.id);
          f.play(),
            o.once("render", () => {
              f.pause(), (this.pendingRepaint = !1);
            });
        }
      }));
  }
}
function ey(_) {
  return Math.max(_.naturalWidth, _.naturalHeight);
}
function D6() {
  return (
    window.matchMedia("(display-mode: standalone)").matches ||
    ("standalone" in window.navigator && window.navigator.standalone === !0)
  );
}
function R6(_) {
  const o = { opaque: !0 },
    f = _.searchParams.get("lat"),
    x = _.searchParams.get("lng");
  f && x && (o.pos = { lat: parseFloat(f), lng: parseFloat(x) });
  const A = _.searchParams.get("zoom");
  A && (o.zoom = parseFloat(A));
  const L = _.searchParams.get("season");
  L && (o.season = parseInt(L));
  const T = _.searchParams.get("opaque");
  return (
    T && (o.opaque = T !== "0"),
    _.searchParams.get("select") && (o.select = !0),
    _.searchParams.get("twitch-migration") && (o.twitchMigration = !0),
    (o.newUser = !!_.searchParams.get("new-user")),
    (o.discordLinked = !!_.searchParams.get("discord-linked")),
    (o.alliance = !!_.searchParams.get("alliance")),
    o
  );
}
function F6(_, o) {
  return (
    (_ = new URL(_)),
    o.pos !== void 0 &&
      (_.searchParams.set("lat", o.pos.lat.toString()),
      _.searchParams.set("lng", o.pos.lng.toString())),
    o.zoom !== void 0 && _.searchParams.set("zoom", o.zoom.toString()),
    o.season !== void 0 && _.searchParams.set("season", o.season.toString()),
    o.opaque !== void 0 && _.searchParams.set("opaque", o.opaque ? "1" : "0"),
    o.newUser !== void 0 &&
      _.searchParams.set("new-user", o.newUser ? "1" : "0"),
    o.alliance !== void 0 &&
      _.searchParams.set("alliance", o.alliance ? "1" : "0"),
    o.select && _.searchParams.set("alliance", "1"),
    _
  );
}
const Cp = Si({ shouldReload: !0 });
var B6 = me(
  '<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function O6(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15),
    x = Je(!1),
    A = Je(Si(o.description)),
    L = Je(void 0);
  Fn(() => {
    const Ee = (De) => {
      var Ae;
      De.key === "Escape" && ((Ae = f()) == null || Ae.close());
    };
    return (
      document.addEventListener("keydown", Ee),
      () => document.removeEventListener("keydown", Ee)
    );
  });
  var T = B6(),
    s = M(T),
    B = M(s),
    N = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee);
  {
    let Ee = ut(() => V0());
    T0(re, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return y(Ee);
      },
      max: 512,
      get value() {
        return y(A);
      },
      set value(De) {
        te(A, De, !0);
      },
      get validate() {
        return y(L);
      },
      set validate(De) {
        te(L, De, !0);
      },
    });
  }
  P(ee);
  var ue = q(ee, 2),
    ne = M(ue);
  ne.__click = () => {
    var Ee;
    (Ee = f()) == null || Ee.close();
  };
  var Y = M(ne, !0);
  P(ne);
  var xe = q(ne, 2),
    Ie = M(xe, !0);
  P(xe),
    P(ue),
    P(K),
    P(s),
    yn(2),
    P(T),
    Eo(
      T,
      (Ee) => f(Ee),
      () => f()
    ),
    Ne(
      (Ee, De, Ae) => {
        le(N, Ee),
          (ne.disabled = y(x)),
          le(Y, De),
          (xe.disabled = y(x)),
          le(Ie, Ae);
      },
      [() => Tb(), () => Gh(), () => ES()]
    ),
    Zn("submit", K, async () => {
      var Ee, De, Ae;
      try {
        if (!((Ee = y(L)) != null && Ee())) return;
        te(x, !0),
          o.description !== y(A) && (await Jr.updateAllianceDescription(y(A))),
          await ((De = o.onsuccess) == null ? void 0 : De.call(o, y(A))),
          (Ae = f()) == null || Ae.close();
      } catch (qe) {
        xr.error(qe.message);
      } finally {
        te(x, !1);
      }
    }),
    G(_, T),
    Rr();
}
Bn(["click"]);
var N6 = me(
    '<span class="loading loading-spinner loading-md center-absolute absolute"></span>'
  ),
  j6 = me(
    '<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function V6(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(""),
    A = Je(!1);
  const L = ut(() => di.url.origin + `/join?id=${y(x)}`);
  $r(() => {
    f() &&
      Jr.getAllianceInvites()
        .then((Ue) => {
          te(x, Ue[0], !0);
        })
        .catch((Ue) => {
          xr.error(Ue.message);
        });
  }),
    Fn(() => {
      const Ue = (Be) => {
        Be.key === "Escape" && f(!1);
      };
      return (
        document.addEventListener("keydown", Ue),
        () => document.removeEventListener("keydown", Ue)
      );
    });
  var T = j6(),
    s = M(T),
    B = q(M(s), 2),
    N = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K, !0);
  P(K);
  var re = q(K, 2),
    ue = M(re);
  let ne;
  var Y = M(ue);
  Oa(Y);
  var xe = q(Y, 2),
    Ie = M(xe);
  let Ee;
  Ie.__click = () => {
    navigator.clipboard.writeText(y(L).toString()),
      te(A, !0),
      setTimeout(() => {
        te(A, !1);
      }, 1e3);
  };
  var De = M(Ie, !0);
  P(Ie), P(xe), P(ue);
  var Ae = q(ue, 2);
  {
    var qe = (Ue) => {
      var Be = N6();
      G(Ue, Be);
    };
    Me(Ae, (Ue) => {
      y(x) || Ue(qe);
    });
  }
  P(re),
    P(s),
    yn(2),
    P(T),
    yi(T, () => (Ue) => {
      $r(() => {
        f() ? Ue.show() : Ue.close();
      });
    }),
    Ne(
      (Ue, Be, ke, $e) => {
        le(N, Ue),
          le(ee, Be),
          (ne = Br(
            ue,
            1,
            "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5",
            null,
            ne,
            { invisible: !y(x) }
          )),
          x0(Y, ke),
          (Ee = Br(Ie, 1, "btn btn-primary", null, Ee, {
            "btn-success": y(A),
          })),
          le(De, $e);
      },
      [
        () => zT(),
        () => RT(),
        () => y(L).toString(),
        () => (y(A) ? g_() : Sm()),
      ]
    ),
    Zn("close", T, () => f(!1)),
    G(_, T),
    Rr();
}
Bn(["click"]);
var q6 = Lr(
  '<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>'
);
function km(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = q6();
  dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...f,
  })),
    G(_, x);
}
var U6 = me('<span class="text-success">(Verified)</span>'),
  Z6 = me('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  G6 = me("<button><!></button>"),
  $6 = me(
    '<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>'
  );
function Hh(_, o) {
  Dr(o, !0);
  const f = !!o.id;
  var x = $6(),
    A = M(x),
    L = M(A),
    T = M(L);
  P(L);
  var s = q(L, 2);
  {
    var B = (re) => {
      var ue = U6();
      G(re, ue);
    };
    Me(s, (re) => {
      f && re(B);
    });
  }
  P(A);
  var N = q(A, 2);
  {
    var K = (re) => {
        var ue = Z6(),
          ne = M(ue);
        km(ne, { class: "size-4 opacity-70" }),
          P(ue),
          Ne(
            (Y) => gr(ue, "href", Y),
            [() => `https://discord.com/users/${encodeURIComponent(o.id)}`]
          ),
          G(re, ue);
      },
      ee = (re) => {
        var ue = G6();
        ue.__click = async () => {
          await navigator.clipboard.writeText(o.username), xr.info(FC());
        };
        var ne = M(ue);
        km(ne, { class: "size-4 opacity-70" }), P(ue), G(re, ue);
      };
    Me(N, (re) => {
      f ? re(K) : re(ee, !1);
    });
  }
  P(x), Ne(() => le(T, `Discord: ${o.username ?? ""}`)), G(_, x), Rr();
}
Bn(["click"]);
var H6 = me('<input type="radio" class="tab max-[380px]:px-3"/>'),
  W6 = me('<div class="tabs tabs-border w-max font-medium"></div>');
function T_(_, o) {
  Dr(o, !0);
  const f = [];
  let x = Et(o, "value", 15, "today"),
    A = [
      { value: "today", label: Qp() },
      { value: "week", label: XT() },
      { value: "month", label: JT() },
      { value: "all-time", label: tS() },
    ];
  var L = W6();
  oi(
    L,
    21,
    () => A,
    (T) => T.value,
    (T, s) => {
      var B = H6();
      Oa(B);
      var N;
      Ne(() => {
        gr(B, "aria-label", y(s).label),
          N !== (N = y(s).value) && (B.value = (B.__value = y(s).value) ?? "");
      }),
        h_(f, [], B, () => (y(s).value, x()), x),
        G(T, B);
    }
  ),
    P(L),
    G(_, L),
    Rr();
}
const X6 = typeof window < "u" ? window : void 0;
function Y6(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot; ) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f;
  }
  return o;
}
var kc, uh, _0;
let K6 =
  ((_0 = class {
    constructor(o = {}) {
      Er(this, kc);
      Er(this, uh);
      const { window: f = X6, document: x = f == null ? void 0 : f.document } =
        o;
      f !== void 0 &&
        ($i(this, kc, x),
        $i(
          this,
          uh,
          y0((A) => {
            const L = eh(f, "focusin", A),
              T = eh(f, "focusout", A);
            return () => {
              L(), T();
            };
          })
        ));
    }
    get current() {
      var o;
      return (
        (o = He(this, uh)) == null || o.call(this),
        He(this, kc) ? Y6(He(this, kc)) : null
      );
    }
  }),
  (kc = new WeakMap()),
  (uh = new WeakMap()),
  _0);
new K6();
function J6(_) {
  return typeof _ == "function";
}
function Q6(_, o) {
  if (J6(_)) {
    const x = _();
    return x === void 0 ? o : x;
  }
  return _ === void 0 ? o : _;
}
function eA(_, o) {
  let f = Je(null);
  const x = ut(() => Q6(o, 250));
  function A(...L) {
    if (y(f)) y(f).timeout && clearTimeout(y(f).timeout);
    else {
      let T, s;
      const B = new Promise((N, K) => {
        (T = N), (s = K);
      });
      te(
        f,
        { timeout: null, runner: null, promise: B, resolve: T, reject: s },
        !0
      );
    }
    return (
      (y(f).runner = async () => {
        if (!y(f)) return;
        const T = y(f);
        te(f, null);
        try {
          T.resolve(await _.apply(this, L));
        } catch (s) {
          T.reject(s);
        }
      }),
      (y(f).timeout = setTimeout(y(f).runner, y(x))),
      y(f).promise
    );
  }
  return (
    (A.cancel = async () => {
      ((!y(f) || y(f).timeout === null) &&
        (await new Promise((L) => setTimeout(L, 0)),
        !y(f) || y(f).timeout === null)) ||
        (clearTimeout(y(f).timeout), y(f).reject("Cancelled"), te(f, null));
    }),
    (A.runScheduledNow = async () => {
      var L, T;
      ((!y(f) || !y(f).timeout) &&
        (await new Promise((s) => setTimeout(s, 0)), !y(f) || !y(f).timeout)) ||
        (clearTimeout(y(f).timeout),
        (y(f).timeout = null),
        await ((T = (L = y(f)).runner) == null ? void 0 : T.call(L)));
    }),
    Object.defineProperty(A, "pending", {
      enumerable: !0,
      get() {
        var L;
        return !!((L = y(f)) != null && L.timeout);
      },
    }),
    A
  );
}
function tA(_, o) {
  switch (_) {
    case "post":
      $r(o);
      break;
    case "pre":
      s_(o);
      break;
  }
}
function ty(_, o, f, x = {}) {
  const { lazy: A = !1 } = x;
  let L = !A,
    T = Array.isArray(_) ? [] : void 0;
  tA(o, () => {
    const s = Array.isArray(_) ? _.map((N) => N()) : _();
    if (!L) {
      (L = !0), (T = s);
      return;
    }
    const B = yl(() => f(s, T));
    return (T = s), B;
  });
}
function Fs(_, o, f) {
  ty(_, "post", o, f);
}
function rA(_, o, f) {
  ty(_, "pre", o, f);
}
Fs.pre = rA;
function nA() {}
var vl, Ls;
class iA {
  constructor(o, f = 250) {
    Er(this, vl, Je());
    Er(this, Ls);
    te(He(this, vl), o(), !0),
      (this.cancel = this.cancel.bind(this)),
      (this.setImmediately = this.setImmediately.bind(this)),
      (this.updateImmediately = this.updateImmediately.bind(this)),
      $i(
        this,
        Ls,
        eA(() => {
          te(He(this, vl), o(), !0);
        }, f)
      ),
      Fs(o, () => {
        He(this, Ls).call(this).catch(nA);
      });
  }
  get current() {
    return y(He(this, vl));
  }
  get pending() {
    return He(this, Ls).pending;
  }
  cancel() {
    He(this, Ls).cancel();
  }
  updateImmediately() {
    return He(this, Ls).runScheduledNow();
  }
  setImmediately(o) {
    this.cancel(), te(He(this, vl), o, !0);
  }
}
(vl = new WeakMap()), (Ls = new WeakMap());
var aA = me(
    '<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'
  ),
  oA = me(
    '<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
  ),
  sA = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  lA = me("<button><!></button>"),
  cA = me(
    '<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'
  ),
  uA = me(
    '<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'
  ),
  hA = me('<div><!> <div class="mt-4"><!></div></div>');
function dA(_, o) {
  Dr(o, !0);
  let f = Et(o, "reload", 15),
    x = Je(!0),
    A = Je([]),
    L = Je(0),
    T = Je("today"),
    s = {};
  f(B);
  function B() {
    const Y = y(T);
    Jr.allianceLeaderboard(Y)
      .then((xe) => {
        te(A, xe), (s = { [Y]: xe }), te(x, !1);
      })
      .catch((xe) => {
        xr.error(xe.message);
      });
  }
  Fs(
    () => [y(T)],
    () => {
      const Y = y(T),
        xe = s[Y];
      if (xe) {
        te(A, xe), te(x, !1);
        return;
      }
      te(x, !0),
        Jr.allianceLeaderboard(Y)
          .then((Ie) => {
            te(A, Ie), (s[Y] = Ie), te(x, !1);
          })
          .catch((Ie) => {
            xr.error(Ie.message);
          });
    }
  );
  var N = hA(),
    K = M(N);
  T_(K, {
    get value() {
      return y(T);
    },
    set value(Y) {
      te(T, Y, !0);
    },
  });
  var ee = q(K, 2),
    re = M(ee);
  {
    var ue = (Y) => {
        var xe = aA();
        G(Y, xe);
      },
      ne = (Y) => {
        var xe = Jt(),
          Ie = _t(xe);
        {
          var Ee = (Ae) => {
              var qe = oA(),
                Ue = M(qe),
                Be = q(Ue);
              {
                var ke = (Le) => {
                    var nt = ji();
                    Ne((dt) => le(nt, dt), [() => Qp().toLowerCase()]),
                      G(Le, nt);
                  },
                  $e = (Le) => {
                    var nt = Jt(),
                      dt = _t(nt);
                    {
                      var je = (bt) => {
                          var Xe = ji();
                          Ne((Ve) => le(Xe, Ve), [() => y_()]), G(bt, Xe);
                        },
                        Ge = (bt) => {
                          var Xe = Jt(),
                            Ve = _t(Xe);
                          {
                            var Ke = (Fe) => {
                              var ft = ji();
                              Ne((lt) => le(ft, lt), [() => x_()]), G(Fe, ft);
                            };
                            Me(
                              Ve,
                              (Fe) => {
                                y(T) === "month" && Fe(Ke);
                              },
                              !0
                            );
                          }
                          G(bt, Xe);
                        };
                      Me(
                        dt,
                        (bt) => {
                          y(T) === "week" ? bt(je) : bt(Ge, !1);
                        },
                        !0
                      );
                    }
                    G(Le, nt);
                  };
                Me(Be, (Le) => {
                  y(T) === "today" ? Le(ke) : Le($e, !1);
                });
              }
              P(qe),
                Ne((Le) => le(Ue, `${Le ?? ""} `), [() => v_()]),
                G(Ae, qe);
            },
            De = (Ae) => {
              var qe = uA(),
                Ue = M(qe),
                Be = M(Ue),
                ke = q(M(Be)),
                $e = M(ke, !0);
              P(ke);
              var Le = q(ke),
                nt = M(Le, !0);
              P(Le), P(Be), P(Ue);
              var dt = q(Ue);
              oi(
                dt,
                31,
                () => y(A),
                (je) => je.userId,
                (je, Ge, bt) => {
                  const Xe = ut(() => {
                    var At;
                    return (
                      ((At = kt.data) == null ? void 0 : At.id) === y(Ge).userId
                    );
                  });
                  var Ve = cA();
                  let Ke;
                  var Fe = M(Ve),
                    ft = M(Fe, !0);
                  P(Fe);
                  var lt = q(Fe),
                    yt = M(lt),
                    mt = M(yt);
                  mo(mt, {
                    class: "size-10 border",
                    get userId() {
                      return y(Ge).userId;
                    },
                    get pictureUrl() {
                      return y(Ge).picture;
                    },
                  });
                  var ct = q(mt, 2),
                    qt = M(ct),
                    Ft = q(qt),
                    Ye = M(Ft);
                  P(Ft), P(ct);
                  var at = q(ct, 2);
                  {
                    var xt = (At) => {
                      const Xt = ut(() => ko(y(Ge).equippedFlag));
                      var Lt = sA(),
                        Nt = M(Lt, !0);
                      P(Lt),
                        Ne(() => {
                          gr(Lt, "data-tip", y(Xt).name), le(Nt, y(Xt).flag);
                        }),
                        G(At, Lt);
                    };
                    Me(at, (At) => {
                      y(Ge).equippedFlag && At(xt);
                    });
                  }
                  var It = q(at, 2);
                  {
                    var Tt = (At) => {
                      Hh(At, {
                        get username() {
                          return y(Ge).discord;
                        },
                        get id() {
                          return y(Ge).discordId;
                        },
                      });
                    };
                    Me(It, (At) => {
                      y(Ge).discord && At(Tt);
                    });
                  }
                  P(yt), P(lt);
                  var Mt = q(lt),
                    Wt = M(Mt),
                    Bt = q(Wt);
                  {
                    var Gt = (At) => {
                      var Xt = lA();
                      let Lt;
                      Xt.__click = () => {
                        o.onlastpixelclick({
                          lat: y(Ge).lastLatitude ?? 0,
                          lng: y(Ge).lastLongitude ?? 0,
                        });
                      };
                      var Nt = M(Xt);
                      $p(Nt, { class: "size-4" }),
                        P(Xt),
                        Ne(
                          (jt) => {
                            (Lt = Br(
                              Xt,
                              1,
                              "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4",
                              null,
                              Lt,
                              { tooltip: y(L) > 640 }
                            )),
                              gr(Xt, "data-tip", jt);
                          },
                          [() => Db()]
                        ),
                        G(At, Xt);
                    };
                    Me(Bt, (At) => {
                      y(Ge).lastLatitude && y(Ge).lastLongitude && At(Gt);
                    });
                  }
                  P(Mt),
                    P(Ve),
                    Ne(
                      (At, Xt) => {
                        var Lt;
                        (Ke = Br(Ve, 1, "", null, Ke, {
                          "bg-base-200": y(Xe),
                        })),
                          le(ft, y(bt) + 1),
                          Br(ct, 1, `font-semibold ${At ?? ""} flex gap-1`),
                          le(
                            qt,
                            `${
                              (y(Xe)
                                ? ((Lt = kt.data) == null ? void 0 : Lt.name) ??
                                  y(Ge).name
                                : y(Ge).name) ?? ""
                            } `
                          ),
                          le(Ye, `#${y(Ge).userId ?? ""}`),
                          le(Wt, `${Xt ?? ""} `);
                      },
                      [
                        () => Ni(y(Ge).userId),
                        () => y(Ge).pixelsPainted.toLocaleString("en-US"),
                      ]
                    ),
                    _l(
                      Ve,
                      () => gl,
                      () => ({ duration: 200 })
                    ),
                    G(je, Ve);
                }
              ),
                P(dt),
                P(qe),
                Ne(
                  (je, Ge) => {
                    le($e, je), le(nt, Ge);
                  },
                  [() => d_(), () => c_()]
                ),
                G(Ae, qe);
            };
          Me(
            Ie,
            (Ae) => {
              y(A).length === 0 ? Ae(Ee) : Ae(De, !1);
            },
            !0
          );
        }
        G(Y, xe);
      };
    Me(re, (Y) => {
      y(x) ? Y(ue) : Y(ne, !1);
    });
  }
  P(ee), P(N), Yp("innerWidth", (Y) => te(L, Y, !0)), G(_, N), Rr();
}
Bn(["click"]);
var pA = Lr(
  '<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>'
);
function S_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = pA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var fA = me('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  mA = me(
    '<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>',
    1
  ),
  _A = me(
    '<li><button class="btn btn-ghost text-base-content/80"> </button></li>'
  ),
  gA = me(
    '<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'
  ),
  vA = me(
    '<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'
  ),
  yA = me(
    '<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'
  ),
  xA = me('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  bA = me(
    '<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'
  ),
  wA = me(
    '<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>'
  );
function TA(_, o) {
  Dr(o, !0);
  let f = Si({ data: [], page: 0, hasNextPage: !0, loading: !1 }),
    x = Si({ data: [], page: 0, hasNextPage: !0, loading: !1 });
  var A = wA(),
    L = M(A),
    T = M(L);
  T.__click = () => o.onclickback();
  var s = M(T);
  A0(s, { class: "size-5" }), P(T);
  var B = q(T, 2),
    N = M(B, !0);
  P(B), P(L);
  var K = q(L, 2),
    ee = M(K);
  Oa(ee);
  var re = q(ee, 2),
    ue = M(re),
    ne = M(ue);
  oi(
    ne,
    21,
    () => f.data,
    ($e) => $e.id,
    ($e, Le, nt) => {
      const dt = ut(() => {
        var xt;
        return ((xt = kt.data) == null ? void 0 : xt.id) === y(Le).id;
      });
      var je = gA(),
        Ge = M(je),
        bt = M(Ge),
        Xe = M(bt);
      mo(Xe, {
        class: "size-10 border",
        get userId() {
          return y(Le).id;
        },
        get pictureUrl() {
          return y(Le).picture;
        },
      });
      var Ve = q(Xe, 2),
        Ke = M(Ve);
      P(Ve);
      var Fe = q(Ve, 2);
      {
        var ft = (xt) => {
          var It = fA();
          G(xt, It);
        };
        Me(Fe, (xt) => {
          y(Le).role === "admin" && xt(ft);
        });
      }
      P(bt), P(Ge);
      var lt = q(Ge),
        yt = M(lt),
        mt = M(yt),
        ct = M(mt);
      S_(ct, { class: "size-4" }), P(mt);
      var qt = q(mt, 2),
        Ft = M(qt);
      {
        var Ye = (xt) => {
            var It = mA(),
              Tt = _t(It),
              Mt = M(Tt);
            Mt.__click = async () => {
              try {
                (y(Le).loading = !0),
                  await Jr.giveAllianceAdmin(y(Le).id),
                  (y(Le).role = "admin");
              } catch {
                xr.error(oP());
              } finally {
                y(Le).loading = !1;
              }
            };
            var Wt = M(Mt, !0);
            P(Mt), P(Tt);
            var Bt = q(Tt, 2),
              Gt = M(Bt);
            Gt.__click = async () => {
              try {
                (y(Le).loading = !0),
                  await Jr.banAllianceUser(y(Le).id),
                  (f.data = f.data.filter((Xt) => Xt.id !== y(Le).id));
              } catch {
                xr.error(DS());
              } finally {
                y(Le).loading = !1;
              }
            };
            var At = M(Gt, !0);
            P(Gt),
              P(Bt),
              Ne(
                (Xt, Lt) => {
                  (Mt.disabled = y(Le).loading),
                    le(Wt, Xt),
                    (Gt.disabled = y(Le).loading),
                    le(At, Lt);
                },
                [() => gS(), () => q0()]
              ),
              G(xt, It);
          },
          at = (xt) => {
            var It = _A(),
              Tt = M(It);
            Tt.disabled = !0;
            var Mt = M(Tt, !0);
            P(Tt), P(It), Ne((Wt) => le(Mt, Wt), [() => wS()]), G(xt, It);
          };
        Me(Ft, (xt) => {
          y(Le).role === "member" ? xt(Ye) : xt(at, !1);
        });
      }
      P(qt),
        P(yt),
        P(lt),
        P(je),
        Ne(
          (xt) => {
            var It;
            Br(Ve, 1, `font-semibold ${xt ?? ""}`),
              le(
                Ke,
                `${
                  (y(dt)
                    ? ((It = kt.data) == null ? void 0 : It.name) ?? y(Le).name
                    : y(Le).name) ?? ""
                } #${y(Le).id ?? ""}`
              );
          },
          [() => Ni(y(Le).id)]
        ),
        G($e, je);
    }
  ),
    P(ne),
    P(ue);
  var Y = q(ue, 2);
  {
    var xe = ($e) => {
      var Le = Jt(),
        nt = _t(Le);
      th(
        nt,
        () => f.page,
        (dt) => {
          var je = vA();
          yi(je, () => (Ge) => {
            const bt = new IntersectionObserver((Xe) => {
              Xe[0].isIntersecting &&
                !f.loading &&
                ((f.loading = !0),
                Jr.getAllianceMembers(f.page)
                  .then((Ve) => {
                    (f.data = [...f.data, ...Ve.data]),
                      (f.hasNextPage = Ve.hasNext),
                      f.page++;
                  })
                  .catch((Ve) => {
                    xr.error(Ve.message);
                  })
                  .finally(() => {
                    f.loading = !1;
                  }));
            });
            return (
              bt.observe(Ge),
              () => {
                bt.disconnect();
              }
            );
          }),
            G(dt, je);
        }
      ),
        G($e, Le);
    };
    Me(Y, ($e) => {
      f.hasNextPage && $e(xe);
    });
  }
  P(re);
  var Ie = q(re, 2),
    Ee = q(Ie, 2),
    De = M(Ee),
    Ae = M(De);
  oi(
    Ae,
    21,
    () => x.data,
    ($e) => $e.id,
    ($e, Le, nt) => {
      var dt = yA(),
        je = M(dt),
        Ge = M(je),
        bt = M(Ge);
      mo(bt, {
        class: "size-10 border",
        get userId() {
          return y(Le).id;
        },
        get pictureUrl() {
          return y(Le).picture;
        },
      });
      var Xe = q(bt, 2),
        Ve = M(Xe);
      P(Xe), P(Ge), P(je);
      var Ke = q(je),
        Fe = M(Ke);
      Fe.__click = () => {
        Jr.unbanAllianceUser(y(Le).id)
          .then(() => {
            x.data = x.data.filter((lt) => lt.id !== y(Le).id);
          })
          .catch((lt) => xr.error(lt.message))
          .finally(() => {
            y(Le).loading = !1;
          });
      };
      var ft = M(Fe, !0);
      P(Fe),
        P(Ke),
        P(dt),
        Ne(
          (lt, yt) => {
            Br(Xe, 1, `font-semibold ${lt ?? ""}`),
              le(Ve, `${y(Le).name ?? ""} #${y(Le).id ?? ""}`),
              (Fe.disabled = y(Le).loading),
              le(ft, yt);
          },
          [() => Ni(y(Le).id), () => CS()]
        ),
        G($e, dt);
    }
  ),
    P(Ae),
    P(De);
  var qe = q(De, 2);
  {
    var Ue = ($e) => {
      var Le = xA(),
        nt = M(Le, !0);
      P(Le), Ne((dt) => le(nt, dt), [() => MS()]), G($e, Le);
    };
    Me(qe, ($e) => {
      !x.hasNextPage && x.data.length === 0 && $e(Ue);
    });
  }
  var Be = q(qe, 2);
  {
    var ke = ($e) => {
      var Le = Jt(),
        nt = _t(Le);
      th(
        nt,
        () => x.page,
        (dt) => {
          var je = bA();
          yi(je, () => (Ge) => {
            const bt = new IntersectionObserver((Xe) => {
              Xe[0].isIntersecting &&
                !x.loading &&
                ((x.loading = !0),
                Jr.getAllianceBannedMembers(x.page)
                  .then((Ve) => {
                    (x.data = [...x.data, ...Ve.data]),
                      (x.hasNextPage = Ve.hasNext),
                      x.page++;
                  })
                  .catch((Ve) => {
                    xr.error(Ve.message);
                  })
                  .finally(() => {
                    x.loading = !1;
                  }));
            });
            return (
              bt.observe(Ge),
              () => {
                bt.disconnect();
              }
            );
          }),
            G(dt, je);
        }
      ),
        G($e, Le);
    };
    Me(Be, ($e) => {
      x.hasNextPage && $e(ke);
    });
  }
  P(Ee),
    P(K),
    P(A),
    Ne(
      ($e, Le, nt) => {
        le(N, $e), gr(ee, "aria-label", Le), gr(Ie, "aria-label", nt);
      },
      [() => I0(), () => BS(), () => u_()]
    ),
    G(_, A),
    Rr();
}
Bn(["click"]);
var SA = me('<span class="label"> </span>'),
  CA = me('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  PA = me('<p class="text-error ml-3 text-sm"> </p>'),
  IA = me(
    '<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>'
  );
function Em(_, o) {
  Dr(o, !0);
  let f = Et(o, "value", 15),
    x = Et(o, "validate", 15),
    A = Je("");
  const L = ut(() => {
    var Ie;
    return ((Ie = f()) == null ? void 0 : Ie.length) ?? 0;
  });
  x(T);
  function T() {
    return o.min !== void 0 && y(L) < o.min
      ? (te(A, y(L) === 0 ? "Required" : `Min. characters: ${o.min}`, !0), !1)
      : o.max !== void 0 && y(L) > o.max
      ? (te(A, `Max. characters: ${o.max}`), !1)
      : !0;
  }
  $r(() => {
    var Ie;
    o.max !== void 0 &&
      y(L) > o.max &&
      f((Ie = f()) == null ? void 0 : Ie.substring(0, o.max));
  });
  var s = IA(),
    B = M(s);
  let N;
  var K = M(B);
  {
    var ee = (Ie) => {
      var Ee = SA(),
        De = M(Ee, !0);
      P(Ee), Ne(() => le(De, o.label)), G(Ie, Ee);
    };
    Me(K, (Ie) => {
      o.label && Ie(ee);
    });
  }
  var re = q(K, 2);
  Oa(re);
  var ue = q(re, 2);
  {
    var ne = (Ie) => {
      var Ee = CA(),
        De = M(Ee, !0);
      P(Ee), Ne(() => le(De, o.max - y(L))), G(Ie, Ee);
    };
    Me(ue, (Ie) => {
      o.max !== void 0 && Ie(ne);
    });
  }
  P(B);
  var Y = q(B, 2);
  {
    var xe = (Ie) => {
      var Ee = PA(),
        De = M(Ee, !0);
      P(Ee), Ne(() => le(De, y(A))), G(Ie, Ee);
    };
    Me(Y, (Ie) => {
      y(A) && Ie(xe);
    });
  }
  P(s),
    Ne(() => {
      (N = Br(B, 1, "input w-full", null, N, { "input-error": !!y(A) })),
        gr(re, "placeholder", o.placeholder),
        gr(re, "maxlength", o.max);
    }),
    $h(re, f),
    G(_, s),
    Rr();
}
var MA = me(
  '<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function AA(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15),
    x = Je(!1),
    A = Je(""),
    L = Je(void 0);
  Fn(() => {
    const Ee = (De) => {
      var Ae;
      De.key === "Escape" && ((Ae = f()) == null || Ae.close());
    };
    return (
      document.addEventListener("keydown", Ee),
      () => document.removeEventListener("keydown", Ee)
    );
  });
  var T = MA(),
    s = M(T),
    B = M(s),
    N = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee);
  {
    let Ee = ut(() => Mm()),
      De = ut(() => hS());
    Em(re, {
      get label() {
        return y(Ee);
      },
      get placeholder() {
        return y(De);
      },
      min: 1,
      max: 16,
      get value() {
        return y(A);
      },
      set value(Ae) {
        te(A, Ae, !0);
      },
      get validate() {
        return y(L);
      },
      set validate(Ae) {
        te(L, Ae, !0);
      },
    });
  }
  P(ee);
  var ue = q(ee, 2),
    ne = M(ue);
  ne.__click = () => {
    var Ee;
    (Ee = f()) == null || Ee.close();
  };
  var Y = M(ne, !0);
  P(ne);
  var xe = q(ne, 2),
    Ie = M(xe, !0);
  P(xe),
    P(ue),
    P(K),
    P(s),
    yn(2),
    P(T),
    Eo(
      T,
      (Ee) => f(Ee),
      () => f()
    ),
    Ne(
      (Ee, De, Ae) => {
        le(N, Ee),
          (ne.disabled = y(x)),
          le(Y, De),
          (xe.disabled = y(x)),
          le(Ie, Ae);
      },
      [() => lS(), () => Gh(), () => fS()]
    ),
    Zn("submit", K, async () => {
      var Ee, De;
      try {
        if (!((Ee = y(L)) != null && Ee())) return;
        te(x, !0);
        const { id: Ae } = await Jr.createAlliance(y(A));
        await o.onsuccess(Ae), (De = f()) == null || De.close();
      } catch (Ae) {
        xr.error(Ae.message);
      } finally {
        te(x, !1);
      }
    }),
    G(_, T),
    Rr();
}
Bn(["click"]);
var kA = Lr(
  '<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>'
);
function Wh(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = kA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var EA = Lr(
    '<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'
  ),
  zA = Lr(
    '<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>'
  );
function zm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        var B = EA();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      },
      T = (s) => {
        var B = zA();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      };
    Me(A, (s) => {
      o.filled ? s(L) : s(T, !1);
    });
  }
  G(_, x);
}
var LA = Lr(
  '<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>'
);
function DA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = LA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var RA = Lr(
  '<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>'
);
function FA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = RA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var BA = Lr(
  '<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>'
);
function OA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = BA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var NA = Lr(
  '<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>'
);
function ef(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = NA();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
function jA(_, o = "_blank") {
  return _.replaceAll(
    /https?:\/\/[^\s]+/g,
    (f) => `<a href="${f}"${o ? ` target="${o}"` : ""}>${f}</a>`
  );
}
var VA = me(
    '<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'
  ),
  qA = me('<div class="tooltip"><button class="btn"><!></button></div>'),
  UA = me(
    '<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'
  ),
  ZA = me(
    '<section class="text-base-content/80 highlight-link"><!> <!></section>'
  ),
  GA = me('<span class="font-semibold"> </span>'),
  $A = me('<button class="text-primary font-semibold underline"> </button>'),
  HA = me('<span class="text-primary underline"> </span>'),
  WA = me('<span class="text-primary underline"> </span>'),
  XA = me('<button class="text-base-content/80 p-1"><!></button>'),
  YA = me(
    '<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'
  ),
  KA = me(
    '<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>',
    1
  ),
  JA = me(
    '<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>',
    1
  ),
  QA = me('<div class="h-full"><!></div>');
function ek(_, o) {
  Dr(o, !0);
  let f = Je(void 0),
    x = Je(!0),
    A = Je(void 0),
    L = Je(!1),
    T = Je(void 0),
    s = Je(!1),
    B = Je(!1),
    N = Je(() => {});
  Fs(
    () => o.open,
    () => {
      o.open && Cp.shouldReload && K();
    }
  ),
    Fn(() => {
      const Y = setInterval(() => {
        Cp.shouldReload = !0;
      }, 1e4);
      return () => {
        clearTimeout(Y);
      };
    });
  async function K() {
    try {
      te(f, await Jr.getAlliance(), !0),
        y(f) && y(N)(),
        te(x, !1),
        (Cp.shouldReload = !1);
    } catch (Y) {
      xr.error(Y.message);
    }
  }
  var ee = QA(),
    re = M(ee);
  {
    var ue = (Y) => {
        var xe = VA();
        G(Y, xe);
      },
      ne = (Y) => {
        var xe = Jt(),
          Ie = _t(xe);
        {
          var Ee = (Ae) => {
              TA(Ae, { onclickback: () => te(B, !1) });
            },
            De = (Ae) => {
              var qe = Jt(),
                Ue = _t(qe);
              {
                var Be = ($e) => {
                    var Le = KA(),
                      nt = _t(Le),
                      dt = M(nt),
                      je = M(dt, !0);
                    P(dt);
                    var Ge = q(dt, 2),
                      bt = M(Ge),
                      Xe = M(bt),
                      Ve = M(Xe);
                    S_(Ve, { class: "size-4" }), P(Xe);
                    var Ke = q(Xe, 2),
                      Fe = M(Ke),
                      ft = M(Fe);
                    ft.__click = async () => {
                      try {
                        te(L, !0),
                          await Jr.leaveAlliance(),
                          te(x, !0),
                          await K();
                      } catch (Te) {
                        xr.error(Te.message);
                      } finally {
                        te(L, !1);
                      }
                    };
                    var lt = M(ft, !0);
                    P(ft), P(Fe), P(Ke), P(bt);
                    var yt = q(bt, 2);
                    {
                      var mt = (Te) => {
                        var O = qA(),
                          E = M(O);
                        E.__click = () => {
                          te(s, !0);
                        };
                        var D = M(E);
                        OA(D, { class: "size-4" }),
                          P(E),
                          P(O),
                          Ne((j) => gr(O, "data-tip", j), [() => qT()]),
                          G(Te, O);
                      };
                      Me(yt, (Te) => {
                        y(f).role == "admin" && Te(mt);
                      });
                    }
                    P(Ge), P(nt);
                    var ct = q(nt, 2);
                    {
                      var qt = (Te) => {
                        var O = ZA(),
                          E = M(O);
                        Gp(E, () => jA(y(f).description || V0()));
                        var D = q(E, 2);
                        {
                          var j = (H) => {
                            var W = UA();
                            W.__click = () => {
                              var ge;
                              (ge = y(T)) == null || ge.show();
                            };
                            var ce = M(W);
                            zm(ce, { class: "size-4" }), P(W), G(H, W);
                          };
                          Me(D, (H) => {
                            y(f).role === "admin" && H(j);
                          });
                        }
                        P(O), G(Te, O);
                      };
                      Me(ct, (Te) => {
                        (y(f).description || y(f).role === "admin") && Te(qt);
                      });
                    }
                    var Ft = q(ct, 2),
                      Ye = M(Ft),
                      at = M(Ye);
                    Wh(at, { class: "inline size-4" });
                    var xt = q(at, 2),
                      It = M(xt),
                      Tt = q(It),
                      Mt = M(Tt, !0);
                    P(Tt), P(xt), P(Ye);
                    var Wt = q(Ye, 2),
                      Bt = M(Wt);
                    ef(Bt, { class: "inline size-4" });
                    var Gt = q(Bt, 2),
                      At = M(Gt),
                      Xt = q(At);
                    {
                      var Lt = (Te) => {
                          var O = GA(),
                            E = M(O, !0);
                          P(O),
                            Ne(
                              (D) => le(E, D),
                              [() => y(f).members.toLocaleString("en-US")]
                            ),
                            G(Te, O);
                        },
                        Nt = (Te) => {
                          var O = $A();
                          O.__click = () => te(B, !0);
                          var E = M(O, !0);
                          P(O),
                            Ne(
                              (D) => le(E, D),
                              [() => y(f).members.toLocaleString("en-US")]
                            ),
                            G(Te, O);
                        };
                      Me(Xt, (Te) => {
                        y(f).role === "member" ? Te(Lt) : Te(Nt, !1);
                      });
                    }
                    P(Gt), P(Wt);
                    var jt = q(Wt, 2);
                    {
                      var mr = (Te) => {
                        var O = YA(),
                          E = M(O);
                        DA(E, { class: "inline size-4" });
                        var D = q(E, 2),
                          j = M(D),
                          H = q(j);
                        H.__click = () => {
                          var We;
                          (We = y(f)) != null && We.hq
                            ? o.onhqclick({
                                lat: y(f).hq.latitude,
                                lng: y(f).hq.longitude,
                              })
                            : o.onhqchange();
                        };
                        var W = M(H);
                        {
                          var ce = (We) => {
                              var Ze = HA(),
                                Ct = M(Ze);
                              P(Ze),
                                Ne(
                                  (_e, Vt) =>
                                    le(Ct, `${_e ?? ""}, ${Vt ?? ""}`),
                                  [
                                    () => y(f).hq.latitude.toFixed(3),
                                    () => y(f).hq.longitude.toFixed(3),
                                  ]
                                ),
                                G(We, Ze);
                            },
                            ge = (We) => {
                              var Ze = WA(),
                                Ct = M(Ze, !0);
                              P(Ze),
                                Ne((_e) => le(Ct, _e), [() => gT()]),
                                G(We, Ze);
                            };
                          Me(W, (We) => {
                            y(f).hq ? We(ce) : We(ge, !1);
                          });
                        }
                        P(H), P(D);
                        var de = q(D, 2);
                        {
                          var Se = (We) => {
                            var Ze = XA();
                            Ze.__click = function (..._e) {
                              var Vt;
                              (Vt = o.onhqchange) == null || Vt.apply(this, _e);
                            };
                            var Ct = M(Ze);
                            zm(Ct, { class: "text-base-content/50 size-4" }),
                              P(Ze),
                              G(We, Ze);
                          };
                          Me(de, (We) => {
                            y(f).role === "admin" && We(Se);
                          });
                        }
                        P(O),
                          Ne((We) => le(j, `${We ?? ""}: `), [() => fT()]),
                          G(Te, O);
                      };
                      Me(jt, (Te) => {
                        (y(f).hq || y(f).role === "admin") && Te(mr);
                      });
                    }
                    P(Ft);
                    var ir = q(Ft, 2),
                      vr = M(ir),
                      ar = M(vr, !0);
                    P(vr);
                    var pr = q(vr, 2),
                      tr = M(pr);
                    dA(tr, {
                      get allianceId() {
                        return y(f).id;
                      },
                      get onlastpixelclick() {
                        return o.onlastpixelclick;
                      },
                      get reload() {
                        return y(N);
                      },
                      set reload(Te) {
                        te(N, Te, !0);
                      },
                    }),
                      P(pr),
                      P(ir);
                    var Dt = q(ir, 2);
                    O6(Dt, {
                      get description() {
                        return y(f).description;
                      },
                      onsuccess: async (Te) => {
                        y(f) && (y(f).description = Te);
                      },
                      get ref() {
                        return y(T);
                      },
                      set ref(Te) {
                        te(T, Te, !0);
                      },
                    });
                    var Sr = q(Dt, 2);
                    V6(Sr, {
                      get open() {
                        return y(s);
                      },
                      set open(Te) {
                        te(s, Te, !0);
                      },
                    }),
                      Ne(
                        (Te, O, E, D, j) => {
                          le(je, y(f).name),
                            (ft.disabled = y(L)),
                            le(lt, Te),
                            le(It, `${O ?? ""}: `),
                            le(Mt, E),
                            le(At, `${D ?? ""}: `),
                            le(ar, j);
                        },
                        [
                          () => hT(),
                          () => c_(),
                          () => y(f).pixelsPainted.toLocaleString("en-US"),
                          () => I0(),
                          () => m_(),
                        ]
                      ),
                      G($e, Le);
                  },
                  ke = ($e) => {
                    var Le = JA(),
                      nt = _t(Le),
                      dt = M(nt),
                      je = M(dt);
                    P(dt);
                    var Ge = q(dt, 2),
                      bt = M(Ge);
                    FA(bt, { class: "size-5" });
                    var Xe = q(bt, 1, !0);
                    P(Ge);
                    var Ve = q(Ge, 2),
                      Ke = M(Ve),
                      Fe = M(Ke, !0);
                    P(Ke), P(Ve);
                    var ft = q(Ve, 2);
                    ft.__click = () => {
                      var ct;
                      (ct = y(A)) == null || ct.show();
                    };
                    var lt = M(ft);
                    k0(lt, { class: "size-6" });
                    var yt = q(lt);
                    P(ft), P(nt);
                    var mt = q(nt, 2);
                    AA(mt, {
                      onsuccess: K,
                      get ref() {
                        return y(A);
                      },
                      set ref(ct) {
                        te(A, ct, !0);
                      },
                    }),
                      Ne(
                        (ct, qt, Ft, Ye) => {
                          le(je, `${ct ?? ""}:`),
                            le(Xe, qt),
                            le(Fe, Ft),
                            le(yt, ` ${Ye ?? ""}`);
                        },
                        [() => xT(), () => TT(), () => PT(), () => AT()]
                      ),
                      G($e, Le);
                  };
                Me(
                  Ue,
                  ($e) => {
                    y(f) ? $e(Be) : $e(ke, !1);
                  },
                  !0
                );
              }
              G(Ae, qe);
            };
          Me(
            Ie,
            (Ae) => {
              y(B) ? Ae(Ee) : Ae(De, !1);
            },
            !0
          );
        }
        G(Y, xe);
      };
    Me(re, (Y) => {
      y(x) ? Y(ue) : Y(ne, !1);
    });
  }
  P(ee), G(_, ee), Rr();
}
Bn(["click"]);
var tk = Lr(
  '<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>'
);
function tf(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = tk();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var rk = me(
  '<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function nk(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const ee = (re) => {
      re.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", ee),
      () => document.removeEventListener("keydown", ee)
    );
  });
  var x = rk(),
    A = M(x),
    L = q(M(A), 2),
    T = M(L);
  tf(T, { class: "size-5 max-sm:size-6" });
  var s = q(T, 2),
    B = M(s, !0);
  P(s), P(L);
  var N = q(L, 2),
    K = M(N);
  ek(K, {
    get open() {
      return f();
    },
    get onhqchange() {
      return o.onhqchange;
    },
    get onhqclick() {
      return o.onhqclick;
    },
    get onlastpixelclick() {
      return o.onlastpixelclick;
    },
  }),
    P(N),
    P(A),
    yn(2),
    P(x),
    yi(x, () => (ee) => {
      $r(() => {
        f()
          ? (ee.show(),
            di.url.searchParams.get("alliance") &&
              (di.url.searchParams.delete("alliance"), Ep(di.url.toString())))
          : ee.close();
      });
    }),
    Ne((ee) => le(B, ee), [() => Kp()]),
    Zn("close", x, () => f(!1)),
    oa(
      2,
      N,
      () => Ha,
      () => ({ duration: 300 })
    ),
    G(_, x),
    Rr();
}
function ik(_, o, f) {
  return new Promise((x, A) => {
    _.once("render", () => {
      const L = _.getCanvas().toDataURL(),
        T = document.createElement("img");
      (T.src = L),
        (T.onload = () => {
          const s = document.createElement("canvas");
          (s.width = T.width), (s.height = T.height);
          const B = s.getContext("2d");
          if (B) {
            B.drawImage(T, 0, 0);
            const [N, K, ee, re] = B.getImageData(o, f, 1, 1).data;
            x([N, K, ee, re]);
          } else A(new Error("Could not get 2d context from canvas"));
          T.remove(), s.remove();
        });
    }),
      _.triggerRepaint();
  });
}
function C_(_, o) {
  return new Promise((f, x) => {
    _.once("render", () => {
      const A = _.getCanvas();
      let L = A;
      if ((o != null && o.maxWidth) || (o != null && o.maxHeight)) {
        const T = A.width,
          s = A.height,
          B = (o == null ? void 0 : o.maxWidth) ?? T,
          N = (o == null ? void 0 : o.maxHeight) ?? s;
        L = document.createElement("canvas");
        const K = Math.min(B / T, N / s);
        (L.width = Math.floor(T * K)), (L.height = Math.floor(s * K));
        const ee = L.getContext("2d");
        ee && ee.drawImage(A, 0, 0, L.width, L.height);
      }
      try {
        L.toBlob(
          (T) => {
            T && f(T);
          },
          (o == null ? void 0 : o.type) ?? "image/png",
          (o == null ? void 0 : o.quality) ?? 1
        );
      } catch (T) {
        x(T);
      } finally {
        L !== A && L.remove();
      }
    });
  });
}
var ak = Lr(
  '<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>'
);
function ok(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = ak();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var sk = Lr(
  '<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>'
);
function ry(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = sk();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
const Ic = { hour: 3600 * 1e3, min: 60 * 1e3, sec: 1e3 };
function Lp(_) {
  const o = Math.floor(_ / Ic.hour);
  _ -= o * Ic.hour;
  const f = Math.floor(_ / Ic.min);
  _ -= f * Ic.min;
  const A = Math.floor(_ / Ic.sec)
    .toString()
    .padStart(2, "0");
  return o > 0 ? `${o}:${f.toString().padStart(2, "0")}:${A}` : `${f}:${A}`;
}
function lk(_) {
  const o = _.getFullYear(),
    f = String(_.getMonth() + 1).padStart(2, "0"),
    x = String(_.getDate()).padStart(2, "0"),
    A = String(_.getHours()).padStart(2, "0"),
    L = String(_.getMinutes()).padStart(2, "0"),
    T = String(_.getSeconds()).padStart(2, "0");
  return `${o}-${f}-${x} ${A}:${L}:${T}`;
}
var ck = me(
    '<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'
  ),
  uk = me('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  hk = me(
    '<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'
  ),
  dk = me(
    '<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'
  ),
  pk = me(
    '<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function fk(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(!1);
  Fn(() => {
    const Ue = (Be) => {
      Be.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", Ue),
      () => document.removeEventListener("keydown", Ue)
    );
  });
  let A = Je(null),
    L = Je("");
  const T = ut(() => {
    const Ue = new URL(o.url.toString()),
      Be = Ue.searchParams.get("lat"),
      ke = Ue.searchParams.get("lng");
    if (Be && ke) return { lat: parseFloat(Be), lng: parseFloat(ke) };
  });
  $r(() => {
    f()
      ? (o.hideHover(),
        setTimeout(async () => {
          C_(o.map)
            .then((Ue) => {
              te(A, Ue, !0), te(L, URL.createObjectURL(y(A)), !0);
            })
            .finally(() => {
              o.showHover();
            });
        }, 500))
      : y(L) && (URL.revokeObjectURL(y(L)), te(A, null), te(L, ""));
  });
  var s = pk(),
    B = M(s),
    N = q(M(B), 2),
    K = M(N);
  ry(K, { class: "size-5" });
  var ee = q(K);
  P(N);
  var re = q(N, 2),
    ue = M(re);
  Oa(ue);
  var ne = q(ue, 2),
    Y = M(ne);
  let xe;
  Y.__click = () => {
    navigator.clipboard.writeText(o.url.toString()),
      te(x, !0),
      setTimeout(() => {
        te(x, !1);
      }, 1e3);
  };
  var Ie = M(Y, !0);
  P(Y), P(ne), P(re);
  var Ee = q(re, 2);
  {
    var De = (Ue) => {
      var Be = ck(),
        ke = M(Be),
        $e = M(ke);
      P(ke);
      var Le = q(ke);
      P(Be),
        Ne(
          (nt) => {
            le($e, `${nt ?? ""}:`),
              le(Le, ` ${y(T).lat ?? ""}, ${y(T).lng ?? ""}`);
          },
          [() => Y0()]
        ),
        G(Ue, Be);
    };
    Me(Ee, (Ue) => {
      y(T) && Ue(De);
    });
  }
  var Ae = q(Ee, 2);
  {
    var qe = (Ue) => {
      const Be = ut(() => {
        var yt;
        return (yt = o.map) == null ? void 0 : yt.getCanvas();
      });
      var ke = dk(),
        $e = M(ke),
        Le = M($e);
      ok(Le, { class: "inline size-5" });
      var nt = q(Le);
      P($e);
      var dt = q($e, 2);
      {
        var je = (yt) => {
            var mt = uk();
            Ne(() => {
              gr(mt, "src", y(L)),
                gr(mt, "width", y(Be).width),
                gr(mt, "height", y(Be).height);
            }),
              G(yt, mt);
          },
          Ge = (yt) => {
            var mt = hk();
            Ne(() => Oc(mt, `aspect-ratio: ${y(Be).width / y(Be).height}`)),
              G(yt, mt);
          };
        Me(dt, (yt) => {
          y(L) ? yt(je) : yt(Ge, !1);
        });
      }
      var bt = q(dt, 2),
        Xe = M(bt);
      Xe.__click = async () => {
        y(A) &&
          (await navigator.clipboard.write([
            new ClipboardItem({ "image/png": y(A) }),
          ]),
          xr.info(dI()));
      };
      var Ve = M(Xe);
      p_(Ve, { class: "size-5" });
      var Ke = q(Ve);
      P(Xe);
      var Fe = q(Xe, 2),
        ft = M(Fe);
      S0(ft, { class: "size-5" });
      var lt = q(ft);
      P(Fe),
        P(bt),
        P(ke),
        Ne(
          (yt, mt, ct, qt) => {
            le(nt, ` ${yt ?? ""}`),
              le(Ke, ` ${mt ?? ""}`),
              gr(Fe, "href", y(L)),
              gr(Fe, "download", `openplace_${ct ?? ""}.png`),
              le(lt, ` ${qt ?? ""}`);
          },
          [
            () => oI(),
            () => Sm(),
            () => lk(new Date()).replaceAll(" ", "_").replaceAll(":", "-"),
            () => cI(),
          ]
        ),
        oa(
          2,
          ke,
          () => Ha,
          () => ({ duration: 300 })
        ),
        G(Ue, ke);
    };
    Me(Ae, (Ue) => {
      f() && Ue(qe);
    });
  }
  P(B),
    yn(2),
    P(s),
    yi(s, () => (Ue) => {
      $r(() => {
        f() ? Ue.show() : Ue.close();
      });
    }),
    Ne(
      (Ue, Be, ke) => {
        le(ee, ` ${Ue ?? ""}`),
          x0(ue, Be),
          (xe = Br(Y, 1, "btn btn-primary", null, xe, { "btn-success": y(x) })),
          le(Ie, ke);
      },
      [() => bC(), () => o.url.toString(), () => (y(x) ? g_() : Sm())]
    ),
    Zn("close", s, () => f(!1)),
    G(_, s),
    Rr();
}
Bn(["click"]);
var mk = Lr(
  '<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>'
);
function _k(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = mk();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var gk = me(
    '<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'
  ),
  vk = me(
    '<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>'
  );
function P_(_, o) {
  Dr(o, !1);
  const f = [G5(), q5(), W5(), K5(), e3(), n3(), o3()];
  D0();
  var x = vk(),
    A = M(x),
    L = M(A);
  _k(L, { class: "size-5" });
  var T = q(L, 2),
    s = M(T),
    B = q(s),
    N = M(B, !0);
  P(B), P(T), P(A);
  var K = q(A, 2),
    ee = M(K);
  oi(
    ee,
    5,
    () => f,
    Hp,
    (Ee, De) => {
      var Ae = gk(),
        qe = M(Ae, !0);
      P(Ae), Ne(() => le(qe, y(De))), G(Ee, Ae);
    }
  ),
    P(ee);
  var re = q(ee, 2),
    ue = M(re, !0);
  P(re);
  var ne = q(re, 2),
    Y = M(ne),
    xe = q(Y),
    Ie = M(xe, !0);
  P(xe),
    yn(),
    P(ne),
    P(K),
    P(x),
    Ne(
      (Ee, De, Ae, qe, Ue) => {
        le(s, `${Ee ?? ""} `),
          le(N, De),
          le(ue, Ae),
          le(Y, `${qe ?? ""} `),
          le(Ie, Ue);
      },
      [() => F5(), () => N5(), () => c3(), () => j4(), () => U4()]
    ),
    G(_, x),
    Rr();
}
var yk = me(
  '<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">üìë Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function xk(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const N = (K) => {
      K.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", N),
      () => document.removeEventListener("keydown", N)
    );
  });
  var x = yk(),
    A = M(x),
    L = q(M(A), 2),
    T = q(M(L), 2),
    s = M(T);
  P_(s, {}), P(T);
  var B = q(T, 2);
  (B.__click = () => {
    f(!1);
  }),
    P(L),
    P(A),
    yn(2),
    P(x),
    yi(x, () => (N) => {
      $r(() => {
        f() ? N.show() : N.close();
      });
    }),
    Zn("close", x, () => f(!1)),
    G(_, x),
    Rr();
}
Bn(["click"]);
var bk = me(
  '<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>'
);
function wk(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const Y = (xe) => {
      xe.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", Y),
      () => document.removeEventListener("keydown", Y)
    );
  });
  var x = bk(),
    A = M(x),
    L = M(A),
    T = M(L),
    s = M(T),
    B = M(s, !0);
  P(s);
  var N = q(s, 2);
  f_(N, { hasText: !0, size: "medium" }), P(T), P(L);
  var K = q(L, 2),
    ee = M(K);
  P_(ee, {}), P(K);
  var re = q(K, 2),
    ue = M(re);
  ue.__click = () => {
    di.url.searchParams.delete("new-user"), Ep(di.url.toString());
  };
  var ne = M(ue, !0);
  P(ue),
    P(re),
    P(A),
    P(x),
    yi(x, () => (Y) => {
      $r(() => {
        f() ? Y.show() : Y.close();
      });
    }),
    Ne(
      (Y, xe) => {
        le(B, Y), le(ne, xe);
      },
      [() => L5(), () => d3()]
    ),
    Zn("close", x, () => f(!1)),
    G(_, x),
    Rr();
}
Bn(["click"]);
function Tk() {
  const _ = navigator.userAgent,
    o = navigator.vendor;
  return /Chrome/.test(_) && /Google Inc/.test(o)
    ? "Chrome"
    : /Safari/.test(_) && /Apple Computer/.test(o)
    ? "Safari"
    : /Firefox/.test(_)
    ? "Firefox"
    : /Edge/.test(_)
    ? "Edge"
    : /Opera|OPR/.test(_)
    ? "Opera"
    : "Unknown";
}
var Sk = Lr(
  '<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>'
);
function Ck(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Sk();
  dr(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f,
  })),
    G(_, x);
}
var Pk = Lr(
  '<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>'
);
function Lm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Pk();
  dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var Ik = Lr(
  '<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>'
);
function Mk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Ik();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...f,
  })),
    G(_, x);
}
var Ak = Lr(
  '<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>'
);
function Dp(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Ak();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var kk = Lr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1
  .75-.75h1.239Z"></path></svg>`);
function Ek(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = kk();
  dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...f,
  })),
    G(_, x);
}
var zk = Lr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);
function Lk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = zk();
  dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...f,
  })),
    G(_, x);
}
var Dk = me(
    ' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>',
    1
  ),
  Rk = me('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  Fk = me(
    '<span class="link cursor-auto">edge://settings/system/manageSystem</span>.',
    1
  ),
  Bk = me(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  Ok = me(
    '<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/ZRC4DnP9Z2" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'
  ),
  Nk = me(
    '<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>'
  );
function jk(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const ee = (re) => {
      re.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", ee),
      () => document.removeEventListener("keydown", ee)
    );
  });
  const x = Tk();
  var A = Nk(),
    L = M(A),
    T = q(M(L), 2);
  {
    var s = (ee) => {
      var re = Ok(),
        ue = M(re),
        ne = M(ue);
      f_(ne, { hasText: !0, size: "medium" });
      var Y = q(ne, 2),
        xe = M(Y),
        Ie = q(xe, 4);
      yn(), P(Y);
      var Ee = q(Y, 2),
        De = M(Ee),
        Ae = M(De),
        qe = M(Ae);
      Lm(qe, { class: "text-base-content mr-0.5 inline size-4" }), yn(2), P(Ae);
      var Ue = q(Ae, 4),
        Be = M(Ue);
      Ck(Be, { class: "size-4.5 mr-0.5 inline" }), yn(2), P(Ue);
      var ke = q(Ue, 4),
        $e = M(ke);
      Mk($e, { class: "mr-0.5 inline size-3.5" }), yn(2), P(ke);
      var Le = q(ke, 4),
        nt = M(Le);
      Lk(nt, { class: "mr-0.5 inline size-3.5" }), yn(2), P(Le);
      var dt = q(Le, 4),
        je = M(dt);
      Ek(je, { class: "mr-0.5 inline size-3.5" }),
        yn(2),
        P(dt),
        P(De),
        P(Ee),
        P(ue);
      var Ge = q(ue, 2),
        bt = M(Ge),
        Xe = M(bt, !0);
      P(bt);
      var Ve = q(bt, 2);
      P(Ge);
      var Ke = q(Ge, 2),
        Fe = M(Ke),
        ft = M(Fe, !0);
      P(Fe);
      var lt = q(Fe, 2),
        yt = M(lt),
        mt = q(yt),
        ct = M(mt);
      Dp(ct, { class: "size-5" }), P(mt);
      var qt = q(mt);
      P(lt);
      var Ft = q(lt, 2),
        Ye = M(Ft),
        at = q(Ye),
        xt = M(at, !0);
      P(at);
      var It = q(at);
      P(Ft), P(Ke);
      var Tt = q(Ke, 2),
        Mt = M(Tt),
        Wt = M(Mt, !0);
      P(Mt);
      var Bt = q(Mt, 2),
        Gt = M(Bt);
      {
        var At = (j) => {
            var H = Dk(),
              W = _t(H);
            yn(), Ne((ce) => le(W, `${ce ?? ""}: `), [() => II()]), G(j, H);
          },
          Xt = (j) => {
            var H = Bk(),
              W = _t(H),
              ce = q(W),
              ge = M(ce, !0);
            P(ce);
            var de = q(ce),
              Se = q(de);
            {
              var We = (Ct) => {
                  var _e = Rk();
                  yn(), G(Ct, _e);
                },
                Ze = (Ct) => {
                  var _e = Jt(),
                    Vt = _t(_e);
                  {
                    var cr = (Ot) => {
                      var ur = Fk();
                      yn(), G(Ot, ur);
                    };
                    Me(
                      Vt,
                      (Ot) => {
                        x === "Edge" && Ot(cr);
                      },
                      !0
                    );
                  }
                  G(Ct, _e);
                };
              Me(Se, (Ct) => {
                x === "Chrome" ? Ct(We) : Ct(Ze, !1);
              });
            }
            Ne(
              (Ct, _e, Vt) => {
                le(W, `${Ct ?? ""} `), le(ge, _e), le(de, ` ${Vt ?? ""} `);
              },
              [() => vI(), () => bI(), () => SI()]
            ),
              G(j, H);
          };
        Me(Gt, (j) => {
          x !== "Chrome" && x !== "Edge" ? j(At) : j(Xt, !1);
        });
      }
      P(Bt), P(Tt);
      var Lt = q(Tt, 2),
        Nt = M(Lt);
      P_(Nt, {}), P(Lt);
      var jt = q(Lt, 4),
        mr = q(M(jt), 2),
        ir = M(mr, !0);
      P(mr);
      var vr = q(mr, 2),
        ar = M(vr, !0);
      P(vr);
      var pr = q(vr, 2),
        tr = M(pr, !0);
      P(pr);
      var Dt = q(pr, 2),
        Sr = M(Dt, !0);
      P(Dt);
      var Te = q(Dt, 2),
        O = M(Te, !0);
      P(Te);
      var E = q(Te, 2),
        D = M(E, !0);
      P(E),
        P(jt),
        P(re),
        Ne(
          (j, H, W, ce, ge, de, Se, We, Ze, Ct, _e, Vt, cr, Ot, ur, Nr, Ur) => {
            le(xe, `${j ?? ""} `),
              le(
                Ie,
                ` ¬©
						${H ?? ""} `
              ),
              le(Xe, W),
              gr(
                Ve,
                "src",
                da.language === "pt"
                  ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9"
                  : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"
              ),
              le(ft, ce),
              le(yt, `${ge ?? ""} `),
              le(qt, ` ${de ?? ""}`),
              le(Ye, `${Se ?? ""} `),
              le(xt, We),
              le(It, ` ${Ze ?? ""}`),
              le(Wt, Ct),
              gr(mr, "href", `${di.url.origin ?? ""}/terms/terms-of-service`),
              le(ir, _e),
              gr(vr, "href", `${di.url.origin ?? ""}/terms/privacy`),
              le(ar, Vt),
              gr(pr, "href", cr),
              le(tr, Ot),
              le(Sr, ur),
              le(O, Nr),
              le(D, Ur);
          },
          [
            () => N2(),
            () => q2(),
            () => G2(),
            () => W2(),
            () => K2(),
            () => ew(),
            () => nw(),
            () => ow(),
            () => cw(),
            () => mI(),
            () => LI(),
            () => FI(),
            () => E0(di.url.origin),
            () => G0(),
            () => W0(),
            () => D4(),
            () => B4(),
          ]
        ),
        oa(
          2,
          re,
          () => Ha,
          () => ({ duration: 300 })
        ),
        G(ee, re);
    };
    Me(T, (ee) => {
      f() && ee(s);
    });
  }
  P(L);
  var B = q(L, 2),
    N = M(B),
    K = M(N, !0);
  P(N),
    P(B),
    P(A),
    yi(A, () => (ee) => {
      $r(() => {
        f() ? ee.show() : ee.close();
      });
    }),
    Ne((ee) => le(K, ee), [() => ds()]),
    Zn("close", A, () => f(!1)),
    G(_, A),
    Rr();
}
function Xh(_) {
  return _ !== null && typeof _ == "object";
}
const Vk = ["string", "number", "bigint", "boolean"];
function Dm(_) {
  return _ == null || Vk.includes(typeof _)
    ? !0
    : Array.isArray(_)
    ? _.every((o) => Dm(o))
    : typeof _ == "object"
    ? Object.getPrototypeOf(_) === Object.prototype
    : !1;
}
const Rp = Symbol("box"),
  ny = Symbol("is-writable");
function Xr(_, o) {
  const f = ut(_);
  return o
    ? {
        [Rp]: !0,
        [ny]: !0,
        get current() {
          return y(f);
        },
        set current(x) {
          o(x);
        },
      }
    : {
        [Rp]: !0,
        get current() {
          return _();
        },
      };
}
function qk(_) {
  return Xh(_) && Rp in _;
}
function Vv(_) {
  let o = Je(Si(_));
  return {
    [Rp]: !0,
    [ny]: !0,
    get current() {
      return y(o);
    },
    set current(f) {
      te(o, f, !0);
    },
  };
}
function Uk(..._) {
  return function (o) {
    var f;
    for (const x of _)
      if (x) {
        if (o.defaultPrevented) return;
        typeof x == "function"
          ? x.call(this, o)
          : (f = x.current) == null || f.call(this, o);
      }
  };
}
var qv = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  Zk = /\n/g,
  Gk = /^\s*/,
  $k = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  Hk = /^:\s*/,
  Wk = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  Xk = /^[;\s]*/,
  Yk = /^\s+|\s+$/g,
  Kk = `
`,
  Uv = "/",
  Zv = "*",
  fl = "",
  Jk = "comment",
  Qk = "declaration";
function eE(_, o) {
  if (typeof _ != "string")
    throw new TypeError("First argument must be a string");
  if (!_) return [];
  o = o || {};
  var f = 1,
    x = 1;
  function A(ne) {
    var Y = ne.match(Zk);
    Y && (f += Y.length);
    var xe = ne.lastIndexOf(Kk);
    x = ~xe ? ne.length - xe : x + ne.length;
  }
  function L() {
    var ne = { line: f, column: x };
    return function (Y) {
      return (Y.position = new T(ne)), N(), Y;
    };
  }
  function T(ne) {
    (this.start = ne),
      (this.end = { line: f, column: x }),
      (this.source = o.source);
  }
  T.prototype.content = _;
  function s(ne) {
    var Y = new Error(o.source + ":" + f + ":" + x + ": " + ne);
    if (
      ((Y.reason = ne),
      (Y.filename = o.source),
      (Y.line = f),
      (Y.column = x),
      (Y.source = _),
      !o.silent)
    )
      throw Y;
  }
  function B(ne) {
    var Y = ne.exec(_);
    if (Y) {
      var xe = Y[0];
      return A(xe), (_ = _.slice(xe.length)), Y;
    }
  }
  function N() {
    B(Gk);
  }
  function K(ne) {
    var Y;
    for (ne = ne || []; (Y = ee()); ) Y !== !1 && ne.push(Y);
    return ne;
  }
  function ee() {
    var ne = L();
    if (!(Uv != _.charAt(0) || Zv != _.charAt(1))) {
      for (
        var Y = 2;
        fl != _.charAt(Y) && (Zv != _.charAt(Y) || Uv != _.charAt(Y + 1));

      )
        ++Y;
      if (((Y += 2), fl === _.charAt(Y - 1)))
        return s("End of comment missing");
      var xe = _.slice(2, Y - 2);
      return (
        (x += 2),
        A(xe),
        (_ = _.slice(Y)),
        (x += 2),
        ne({ type: Jk, comment: xe })
      );
    }
  }
  function re() {
    var ne = L(),
      Y = B($k);
    if (Y) {
      if ((ee(), !B(Hk))) return s("property missing ':'");
      var xe = B(Wk),
        Ie = ne({
          type: Qk,
          property: Gv(Y[0].replace(qv, fl)),
          value: xe ? Gv(xe[0].replace(qv, fl)) : fl,
        });
      return B(Xk), Ie;
    }
  }
  function ue() {
    var ne = [];
    K(ne);
    for (var Y; (Y = re()); ) Y !== !1 && (ne.push(Y), K(ne));
    return ne;
  }
  return N(), ue();
}
function Gv(_) {
  return _ ? _.replace(Yk, fl) : fl;
}
function tE(_, o) {
  let f = null;
  if (!_ || typeof _ != "string") return f;
  const x = eE(_),
    A = typeof o == "function";
  return (
    x.forEach((L) => {
      if (L.type !== "declaration") return;
      const { property: T, value: s } = L;
      A ? o(T, s, L) : s && ((f = f || {}), (f[T] = s));
    }),
    f
  );
}
const rE = /\d/,
  nE = ["-", "_", "/", "."];
function iE(_ = "") {
  if (!rE.test(_)) return _ !== _.toLowerCase();
}
function aE(_) {
  const o = [];
  let f = "",
    x,
    A;
  for (const L of _) {
    const T = nE.includes(L);
    if (T === !0) {
      o.push(f), (f = ""), (x = void 0);
      continue;
    }
    const s = iE(L);
    if (A === !1) {
      if (x === !1 && s === !0) {
        o.push(f), (f = L), (x = s);
        continue;
      }
      if (x === !0 && s === !1 && f.length > 1) {
        const B = f.at(-1);
        o.push(f.slice(0, Math.max(0, f.length - 1))), (f = B + L), (x = s);
        continue;
      }
    }
    (f += L), (x = s), (A = T);
  }
  return o.push(f), o;
}
function iy(_) {
  return _
    ? aE(_)
        .map((o) => sE(o))
        .join("")
    : "";
}
function oE(_) {
  return lE(iy(_ || ""));
}
function sE(_) {
  return _ ? _[0].toUpperCase() + _.slice(1) : "";
}
function lE(_) {
  return _ ? _[0].toLowerCase() + _.slice(1) : "";
}
function gp(_) {
  if (!_) return {};
  const o = {};
  function f(x, A) {
    if (
      x.startsWith("-moz-") ||
      x.startsWith("-webkit-") ||
      x.startsWith("-ms-") ||
      x.startsWith("-o-")
    ) {
      o[iy(x)] = A;
      return;
    }
    if (x.startsWith("--")) {
      o[x] = A;
      return;
    }
    o[oE(x)] = A;
  }
  return tE(_, f), o;
}
function cE(..._) {
  return (...o) => {
    for (const f of _) typeof f == "function" && f(...o);
  };
}
function uE(_, o) {
  const f = RegExp(_, "g");
  return (x) => {
    if (typeof x != "string")
      throw new TypeError(
        `expected an argument of type string, but got ${typeof x}`
      );
    return x.match(f) ? x.replace(f, o) : x;
  };
}
const hE = uE(/[A-Z]/, (_) => `-${_.toLowerCase()}`);
function dE(_) {
  if (!_ || typeof _ != "object" || Array.isArray(_))
    throw new TypeError(
      `expected an argument of type object, but got ${typeof _}`
    );
  return Object.keys(_).map((o) => `${hE(o)}: ${_[o]};`).join(`
`);
}
function ay(_ = {}) {
  return dE(_).replace(
    `
`,
    " "
  );
}
const pE = [
    "onabort",
    "onanimationcancel",
    "onanimationend",
    "onanimationiteration",
    "onanimationstart",
    "onauxclick",
    "onbeforeinput",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncompositionend",
    "oncompositionstart",
    "oncompositionupdate",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onfocusin",
    "onfocusout",
    "onformdata",
    "ongotpointercapture",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onlostpointercapture",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpointercancel",
    "onpointerdown",
    "onpointerenter",
    "onpointerleave",
    "onpointermove",
    "onpointerout",
    "onpointerover",
    "onpointerup",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onselectionchange",
    "onselectstart",
    "onslotchange",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "ontouchcancel",
    "ontouchend",
    "ontouchmove",
    "ontouchstart",
    "ontransitioncancel",
    "ontransitionend",
    "ontransitionrun",
    "ontransitionstart",
    "onvolumechange",
    "onwaiting",
    "onwebkitanimationend",
    "onwebkitanimationiteration",
    "onwebkitanimationstart",
    "onwebkittransitionend",
    "onwheel",
  ],
  fE = new Set(pE);
function mE(_) {
  return fE.has(_);
}
function Ba(..._) {
  const o = { ..._[0] };
  for (let f = 1; f < _.length; f++) {
    const x = _[f];
    if (x) {
      for (const A of Object.keys(x)) {
        const L = o[A],
          T = x[A],
          s = typeof L == "function",
          B = typeof T == "function";
        if (s && mE(A)) {
          const N = L,
            K = T;
          o[A] = Uk(N, K);
        } else if (s && B) o[A] = cE(L, T);
        else if (A === "class") {
          const N = Dm(L),
            K = Dm(T);
          N && K ? (o[A] = Qu(L, T)) : N ? (o[A] = Qu(L)) : K && (o[A] = Qu(T));
        } else if (A === "style") {
          const N = typeof L == "object",
            K = typeof T == "object",
            ee = typeof L == "string",
            re = typeof T == "string";
          if (N && K) o[A] = { ...L, ...T };
          else if (N && re) {
            const ue = gp(T);
            o[A] = { ...L, ...ue };
          } else if (ee && K) {
            const ue = gp(L);
            o[A] = { ...ue, ...T };
          } else if (ee && re) {
            const ue = gp(L),
              ne = gp(T);
            o[A] = { ...ue, ...ne };
          } else
            N
              ? (o[A] = L)
              : K
              ? (o[A] = T)
              : ee
              ? (o[A] = L)
              : re && (o[A] = T);
        } else o[A] = T !== void 0 ? T : L;
      }
      for (const A of Object.getOwnPropertySymbols(x)) {
        const L = o[A],
          T = x[A];
        o[A] = T !== void 0 ? T : L;
      }
    }
  }
  return (
    typeof o.style == "object" &&
      (o.style = ay(o.style).replaceAll(
        `
`,
        " "
      )),
    o.hidden === !1 && ((o.hidden = void 0), delete o.hidden),
    o.disabled === !1 && ((o.disabled = void 0), delete o.disabled),
    o
  );
}
const oy = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)",
};
ay(oy);
const _E = typeof window < "u" ? window : void 0;
function gE(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot; ) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f;
  }
  return o;
}
var Ec, hh;
class vE {
  constructor(o = {}) {
    Er(this, Ec);
    Er(this, hh);
    const { window: f = _E, document: x = f == null ? void 0 : f.document } = o;
    f !== void 0 &&
      ($i(this, Ec, x),
      $i(
        this,
        hh,
        y0((A) => {
          const L = eh(f, "focusin", A),
            T = eh(f, "focusout", A);
          return () => {
            L(), T();
          };
        })
      ));
  }
  get current() {
    var o;
    return (
      (o = He(this, hh)) == null || o.call(this),
      He(this, Ec) ? gE(He(this, Ec)) : null
    );
  }
}
(Ec = new WeakMap()), (hh = new WeakMap());
new vE();
var dh, ls;
class I_ {
  constructor(o) {
    Er(this, dh);
    Er(this, ls);
    $i(this, dh, o), $i(this, ls, Symbol(o));
  }
  get key() {
    return He(this, ls);
  }
  exists() {
    return nb(He(this, ls));
  }
  get() {
    const o = Mv(He(this, ls));
    if (o === void 0) throw new Error(`Context "${He(this, dh)}" not found`);
    return o;
  }
  getOr(o) {
    const f = Mv(He(this, ls));
    return f === void 0 ? o : f;
  }
  set(o) {
    return ib(He(this, ls), o);
  }
}
(dh = new WeakMap()), (ls = new WeakMap());
function yE(_, o) {
  switch (_) {
    case "post":
      $r(o);
      break;
    case "pre":
      s_(o);
      break;
  }
}
function sy(_, o, f, x = {}) {
  const { lazy: A = !1 } = x;
  let L = !A,
    T = Array.isArray(_) ? [] : void 0;
  yE(o, () => {
    const s = Array.isArray(_) ? _.map((N) => N()) : _();
    if (!L) {
      (L = !0), (T = s);
      return;
    }
    const B = yl(() => f(s, T));
    return (T = s), B;
  });
}
function xl(_, o, f) {
  sy(_, "post", o, f);
}
function xE(_, o, f) {
  sy(_, "pre", o, f);
}
xl.pre = xE;
var ph, Op;
class bE {
  constructor(o, f) {
    Er(this, ph, () => {});
    Er(
      this,
      Op,
      ut(() => He(this, ph).call(this))
    );
    let x;
    f !== void 0 && (x = f),
      $i(this, ph, () => {
        try {
          return x;
        } finally {
          x = o();
        }
      });
  }
  get current() {
    return y(He(this, Op));
  }
}
(ph = new WeakMap()), (Op = new WeakMap());
function wE(_, o) {
  return setTimeout(o, _);
}
function wc(_) {
  g0().then(_);
}
const TE = 1,
  SE = 9,
  CE = 11;
function PE(_) {
  return Xh(_) && _.nodeType === TE && typeof _.nodeName == "string";
}
function ly(_) {
  return Xh(_) && _.nodeType === SE;
}
function IE(_) {
  var o;
  return (
    Xh(_) &&
    ((o = _.constructor) == null ? void 0 : o.name) === "VisualViewport"
  );
}
function ME(_) {
  return Xh(_) && _.nodeType !== void 0;
}
function AE(_) {
  return ME(_) && _.nodeType === CE && "host" in _;
}
function kE(_) {
  return ly(_)
    ? _
    : IE(_)
    ? _.document
    : (_ == null ? void 0 : _.ownerDocument) ?? document;
}
function cy(_) {
  var o;
  return AE(_)
    ? cy(_.host)
    : ly(_)
    ? _.defaultView ?? window
    : PE(_)
    ? ((o = _.ownerDocument) == null ? void 0 : o.defaultView) ?? window
    : window;
}
function EE(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot; ) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f;
  }
  return o;
}
var fh;
class zE {
  constructor(o) {
    Ir(this, "element");
    Er(
      this,
      fh,
      ut(() =>
        this.element.current
          ? this.element.current.getRootNode() ?? document
          : document
      )
    );
    Ir(this, "getDocument", () => kE(this.root));
    Ir(this, "getWindow", () => this.getDocument().defaultView ?? window);
    Ir(this, "getActiveElement", () => EE(this.root));
    Ir(this, "isActiveElement", (o) => o === this.getActiveElement());
    Ir(this, "querySelector", (o) =>
      this.root ? this.root.querySelector(o) : null
    );
    Ir(this, "querySelectorAll", (o) =>
      this.root ? this.root.querySelectorAll(o) : []
    );
    Ir(this, "setTimeout", (o, f) => this.getWindow().setTimeout(o, f));
    Ir(this, "clearTimeout", (o) => this.getWindow().clearTimeout(o));
    typeof o == "function" ? (this.element = Xr(o)) : (this.element = o);
  }
  get root() {
    return y(He(this, fh));
  }
  set root(o) {
    te(He(this, fh), o);
  }
  getElementById(o) {
    return this.root.getElementById(o);
  }
}
fh = new WeakMap();
function Wa(_, o) {
  return {
    [Kb()]: (f) =>
      qk(_)
        ? ((_.current = f),
          yl(() => (o == null ? void 0 : o(f))),
          () => {
            ("isConnected" in f && f.isConnected) ||
              ((_.current = null), o == null || o(null));
          })
        : (_(f),
          yl(() => (o == null ? void 0 : o(f))),
          () => {
            ("isConnected" in f && f.isConnected) ||
              (_(null), o == null || o(null));
          }),
  };
}
function Rm(_) {
  return _ ? "true" : "false";
}
function $v(_) {
  return _ ? "" : void 0;
}
function LE(_) {
  return _ ? !0 : void 0;
}
var zc, mh;
class DE {
  constructor(o) {
    Er(this, zc);
    Er(this, mh);
    Ir(this, "attrs");
    $i(this, zc, o.getVariant ? o.getVariant() : null),
      $i(
        this,
        mh,
        He(this, zc) ? `data-${He(this, zc)}-` : `data-${o.component}-`
      ),
      (this.getAttr = this.getAttr.bind(this)),
      (this.selector = this.selector.bind(this)),
      (this.attrs = Object.fromEntries(
        o.parts.map((f) => [f, this.getAttr(f)])
      ));
  }
  getAttr(o, f) {
    return f ? `data-${f}-${o}` : `${He(this, mh)}${o}`;
  }
  selector(o, f) {
    return `[${this.getAttr(o, f)}]`;
  }
}
(zc = new WeakMap()), (mh = new WeakMap());
function uy(_) {
  const o = new DE(_);
  return { ...o.attrs, selector: o.selector, getAttr: o.getAttr };
}
const RE = "ArrowDown",
  FE = "ArrowLeft",
  BE = "ArrowRight",
  OE = "ArrowUp",
  NE = "End",
  jE = "Enter",
  VE = "Home",
  qE = "p",
  UE = "n",
  ZE = "j",
  GE = "k",
  $E = "h",
  HE = "l";
function nh() {}
function Xa(_, o) {
  return `bits-${_}`;
}
function WE(_) {
  if (!_) return null;
  for (const o of _.childNodes) if (o.nodeType !== Node.COMMENT_NODE) return o;
  return null;
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 });
function XE(_ = "bits") {
  return (
    globalThis.bitsIdCounter.current++,
    `${_}-${globalThis.bitsIdCounter.current}`
  );
}
function YE(_, o) {
  let f = _.nextElementSibling;
  for (; f; ) {
    if (f.matches(o)) return f;
    f = f.nextElementSibling;
  }
}
function KE(_, o) {
  let f = _.previousElementSibling;
  for (; f; ) {
    if (f.matches(o)) return f;
    f = f.previousElementSibling;
  }
}
function hy(_) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(_);
  const o = _.length;
  let f = -1,
    x,
    A = "";
  const L = _.charCodeAt(0);
  if (o === 1 && L === 45) return "\\" + _;
  for (; ++f < o; ) {
    if (((x = _.charCodeAt(f)), x === 0)) {
      A += "ÔøΩ";
      continue;
    }
    if (
      (x >= 1 && x <= 31) ||
      x === 127 ||
      (f === 0 && x >= 48 && x <= 57) ||
      (f === 1 && x >= 48 && x <= 57 && L === 45)
    ) {
      A += "\\" + x.toString(16) + " ";
      continue;
    }
    if (
      x >= 128 ||
      x === 45 ||
      x === 95 ||
      (x >= 48 && x <= 57) ||
      (x >= 65 && x <= 90) ||
      (x >= 97 && x <= 122)
    ) {
      A += _.charAt(f);
      continue;
    }
    A += "\\" + _.charAt(f);
  }
  return A;
}
const ml = "data-value",
  wa = uy({
    component: "command",
    parts: [
      "root",
      "list",
      "input",
      "separator",
      "loading",
      "empty",
      "group",
      "group-items",
      "group-heading",
      "item",
      "viewport",
      "input-label",
    ],
  }),
  Tc = wa.selector("group"),
  hm = wa.selector("group-items"),
  Hv = wa.selector("group-heading"),
  dy = wa.selector("item"),
  dm = `${wa.selector("item")}:not([aria-disabled="true"])`,
  wl = new I_("Command.Root"),
  JE = new I_("Command.List"),
  ih = new I_("Command.Group"),
  Wv = {
    search: "",
    value: "",
    filtered: { count: 0, items: new Map(), groups: new Set() },
  };
var Lc,
  Dc,
  _h,
  gh,
  vh,
  yh,
  xh,
  bh,
  Tr,
  py,
  Pp,
  Bm,
  Ip,
  Mp,
  Ap,
  zs,
  fy,
  my,
  Om,
  Xu,
  Nm,
  jm,
  _y,
  Yu,
  Vm,
  qm,
  gy,
  Ku,
  Ju,
  wh;
const R_ = class R_ {
  constructor(o) {
    Er(this, Tr);
    Ir(this, "opts");
    Ir(this, "attachment");
    Er(this, Lc, !1);
    Er(this, Dc, !0);
    Ir(this, "sortAfterTick", !1);
    Ir(this, "sortAndFilterAfterTick", !1);
    Ir(this, "allItems", new Set());
    Ir(this, "allGroups", new Map());
    Ir(this, "allIds", new Map());
    Er(this, _h, Je(0));
    Er(this, gh, Je(null));
    Er(this, vh, Je(null));
    Er(this, yh, Je(null));
    Er(this, xh, Je(Wv));
    Er(this, bh, Je(Si(Wv)));
    Er(
      this,
      wh,
      ut(() => ({
        id: this.opts.id.current,
        role: "application",
        [wa.root]: "",
        tabindex: -1,
        onkeydown: this.onkeydown,
        ...this.attachment,
      }))
    );
    (this.opts = o), (this.attachment = Wa(this.opts.ref));
    const f = { ...this._commandState, value: this.opts.value.current ?? "" };
    (this._commandState = f),
      (this.commandState = f),
      (this.onkeydown = this.onkeydown.bind(this));
  }
  static create(o) {
    return wl.set(new R_(o));
  }
  get key() {
    return y(He(this, _h));
  }
  set key(o) {
    te(He(this, _h), o, !0);
  }
  get viewportNode() {
    return y(He(this, gh));
  }
  set viewportNode(o) {
    te(He(this, gh), o, !0);
  }
  get inputNode() {
    return y(He(this, vh));
  }
  set inputNode(o) {
    te(He(this, vh), o, !0);
  }
  get labelNode() {
    return y(He(this, yh));
  }
  set labelNode(o) {
    te(He(this, yh), o, !0);
  }
  get commandState() {
    return y(He(this, xh));
  }
  set commandState(o) {
    te(He(this, xh), o);
  }
  get _commandState() {
    return y(He(this, bh));
  }
  set _commandState(o) {
    te(He(this, bh), o, !0);
  }
  setState(o, f, x) {
    Object.is(this._commandState[o], f) ||
      ((this._commandState[o] = f),
      o === "search"
        ? (Or(this, Tr, Ap).call(this), Or(this, Tr, Ip).call(this))
        : o === "value" && (x || Or(this, Tr, fy).call(this)),
      Or(this, Tr, Pp).call(this));
  }
  setValue(o, f) {
    o !== this.opts.value.current &&
      o === "" &&
      wc(() => {
        this.key++;
      }),
      this.setState("value", o, f),
      (this.opts.value.current = o);
  }
  getValidItems() {
    const o = this.opts.ref.current;
    return o ? Array.from(o.querySelectorAll(dm)).filter((x) => !!x) : [];
  }
  getVisibleItems() {
    const o = this.opts.ref.current;
    return o ? Array.from(o.querySelectorAll(dy)).filter((x) => !!x) : [];
  }
  get itemsGrid() {
    var s, B, N, K;
    if (!this.isGrid) return [];
    const o = this.opts.columns.current ?? 1,
      f = this.getVisibleItems(),
      x = [[]];
    let A = (s = f[0]) == null ? void 0 : s.getAttribute("data-group"),
      L = 0,
      T = 0;
    for (let ee = 0; ee < f.length; ee++) {
      const re = f[ee],
        ue = re == null ? void 0 : re.getAttribute("data-group");
      A !== ue
        ? ((A = ue),
          (L = 1),
          T++,
          x.push([{ index: ee, firstRowOfGroup: !0, ref: re }]))
        : (L++,
          L > o && (T++, (L = 1), x.push([])),
          (K = x[T]) == null ||
            K.push({
              index: ee,
              firstRowOfGroup:
                ((N = (B = x[T]) == null ? void 0 : B[0]) == null
                  ? void 0
                  : N.firstRowOfGroup) ?? ee === 0,
              ref: re,
            }));
    }
    return x;
  }
  updateSelectedToIndex(o) {
    const f = this.getValidItems()[o];
    f && this.setValue(f.getAttribute(ml) ?? "");
  }
  updateSelectedByItem(o) {
    const f = Or(this, Tr, zs).call(this),
      x = this.getValidItems(),
      A = x.findIndex((T) => T === f);
    let L = x[A + o];
    this.opts.loop.current &&
      (L = A + o < 0 ? x[x.length - 1] : A + o === x.length ? x[0] : x[A + o]),
      L && this.setValue(L.getAttribute(ml) ?? "");
  }
  updateSelectedByGroup(o) {
    const f = Or(this, Tr, zs).call(this);
    let x = f == null ? void 0 : f.closest(Tc),
      A;
    for (; x && !A; )
      (x = o > 0 ? YE(x, Tc) : KE(x, Tc)),
        (A = x == null ? void 0 : x.querySelector(dm));
    A ? this.setValue(A.getAttribute(ml) ?? "") : this.updateSelectedByItem(o);
  }
  registerValue(o, f) {
    var x;
    return (
      (o && o === ((x = this.allIds.get(o)) == null ? void 0 : x.value)) ||
        this.allIds.set(o, { value: o, keywords: f }),
      this._commandState.filtered.items.set(
        o,
        Or(this, Tr, Bm).call(this, o, f)
      ),
      this.sortAfterTick ||
        ((this.sortAfterTick = !0),
        wc(() => {
          Or(this, Tr, Ip).call(this), (this.sortAfterTick = !1);
        })),
      () => {
        this.allIds.delete(o);
      }
    );
  }
  registerItem(o, f) {
    return (
      this.allItems.add(o),
      f &&
        (this.allGroups.has(f)
          ? this.allGroups.get(f).add(o)
          : this.allGroups.set(f, new Set([o]))),
      this.sortAndFilterAfterTick ||
        ((this.sortAndFilterAfterTick = !0),
        wc(() => {
          Or(this, Tr, Ap).call(this),
            Or(this, Tr, Ip).call(this),
            (this.sortAndFilterAfterTick = !1);
        })),
      Or(this, Tr, Pp).call(this),
      () => {
        const x = Or(this, Tr, zs).call(this);
        this.allItems.delete(o),
          this.commandState.filtered.items.delete(o),
          Or(this, Tr, Ap).call(this),
          (x == null ? void 0 : x.getAttribute("id")) === o &&
            Or(this, Tr, Mp).call(this),
          Or(this, Tr, Pp).call(this);
      }
    );
  }
  registerGroup(o) {
    return (
      this.allGroups.has(o) || this.allGroups.set(o, new Set()),
      () => {
        this.allIds.delete(o), this.allGroups.delete(o);
      }
    );
  }
  get isGrid() {
    return this.opts.columns.current !== null;
  }
  onkeydown(o) {
    const f = this.opts.vimBindings.current && o.ctrlKey;
    switch (o.key) {
      case UE:
      case ZE: {
        f &&
          (this.isGrid
            ? Or(this, Tr, Nm).call(this, o)
            : Or(this, Tr, Xu).call(this, o));
        break;
      }
      case HE: {
        f && this.isGrid && Or(this, Tr, Xu).call(this, o);
        break;
      }
      case RE:
        this.isGrid
          ? Or(this, Tr, Nm).call(this, o)
          : Or(this, Tr, Xu).call(this, o);
        break;
      case BE:
        if (!this.isGrid) break;
        Or(this, Tr, Xu).call(this, o);
        break;
      case qE:
      case GE: {
        f &&
          (this.isGrid
            ? Or(this, Tr, qm).call(this, o)
            : Or(this, Tr, Ju).call(this, o));
        break;
      }
      case $E: {
        f && this.isGrid && Or(this, Tr, Ju).call(this, o);
        break;
      }
      case OE:
        this.isGrid
          ? Or(this, Tr, qm).call(this, o)
          : Or(this, Tr, Ju).call(this, o);
        break;
      case FE:
        if (!this.isGrid) break;
        Or(this, Tr, Ju).call(this, o);
        break;
      case VE:
        o.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case NE:
        o.preventDefault(), Or(this, Tr, Om).call(this);
        break;
      case jE:
        if (!o.isComposing && o.keyCode !== 229) {
          o.preventDefault();
          const x = Or(this, Tr, zs).call(this);
          x && (x == null || x.click());
        }
    }
  }
  get props() {
    return y(He(this, wh));
  }
  set props(o) {
    te(He(this, wh), o);
  }
};
(Lc = new WeakMap()),
  (Dc = new WeakMap()),
  (_h = new WeakMap()),
  (gh = new WeakMap()),
  (vh = new WeakMap()),
  (yh = new WeakMap()),
  (xh = new WeakMap()),
  (bh = new WeakMap()),
  (Tr = new WeakSet()),
  (py = function () {
    return Yb(this._commandState);
  }),
  (Pp = function () {
    He(this, Lc) ||
      ($i(this, Lc, !0),
      wc(() => {
        var x, A;
        $i(this, Lc, !1);
        const o = Or(this, Tr, py).call(this);
        !Object.is(this.commandState, o) &&
          ((this.commandState = o),
          (A = (x = this.opts.onStateChange) == null ? void 0 : x.current) ==
            null || A.call(x, o));
      }));
  }),
  (Bm = function (o, f) {
    const x = this.opts.filter.current ?? xy;
    return o ? x(o, this._commandState.search, f) : 0;
  }),
  (Ip = function () {
    var T;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      (!this._commandState.value || !He(this, Dc)) &&
        Or(this, Tr, Mp).call(this);
      return;
    }
    const o = this._commandState.filtered.items,
      f = [];
    for (const s of this._commandState.filtered.groups) {
      const B = this.allGroups.get(s);
      let N = 0;
      if (!B) {
        f.push([s, N]);
        continue;
      }
      for (const K of B) {
        const ee = o.get(K);
        N = Math.max(ee ?? 0, N);
      }
      f.push([s, N]);
    }
    const x = this.viewportNode,
      A = this.getValidItems().sort((s, B) => {
        const N = s.getAttribute("data-value"),
          K = B.getAttribute("data-value"),
          ee = o.get(N) ?? 0;
        return (o.get(K) ?? 0) - ee;
      });
    for (const s of A) {
      const B = s.closest(hm);
      if (B) {
        const N = s.parentElement === B ? s : s.closest(`${hm} > *`);
        N && B.appendChild(N);
      } else {
        const N = s.parentElement === x ? s : s.closest(`${hm} > *`);
        N && (x == null || x.appendChild(N));
      }
    }
    const L = f.sort((s, B) => B[1] - s[1]);
    for (const s of L) {
      const B =
        x == null ? void 0 : x.querySelector(`${Tc}[${ml}="${hy(s[0])}"]`);
      (T = B == null ? void 0 : B.parentElement) == null || T.appendChild(B);
    }
    Or(this, Tr, Mp).call(this);
  }),
  (Mp = function () {
    wc(() => {
      const o = this.getValidItems().find(
          (A) => A.getAttribute("aria-disabled") !== "true"
        ),
        f = o == null ? void 0 : o.getAttribute(ml),
        x = He(this, Dc) && this.opts.disableInitialScroll.current;
      this.setValue(f ?? "", x), $i(this, Dc, !1);
    });
  }),
  (Ap = function () {
    var f, x;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      this._commandState.filtered.count = this.allItems.size;
      return;
    }
    this._commandState.filtered.groups = new Set();
    let o = 0;
    for (const A of this.allItems) {
      const L = ((f = this.allIds.get(A)) == null ? void 0 : f.value) ?? "",
        T = ((x = this.allIds.get(A)) == null ? void 0 : x.keywords) ?? [],
        s = Or(this, Tr, Bm).call(this, L, T);
      this._commandState.filtered.items.set(A, s), s > 0 && o++;
    }
    for (const [A, L] of this.allGroups)
      for (const T of L) {
        const s = this._commandState.filtered.items.get(T);
        if (s && s > 0) {
          this._commandState.filtered.groups.add(A);
          break;
        }
      }
    this._commandState.filtered.count = o;
  }),
  (zs = function () {
    const o = this.opts.ref.current;
    if (!o) return;
    const f = o.querySelector(`${dm}[data-selected]`);
    if (f) return f;
  }),
  (fy = function () {
    wc(() => {
      var x, A, L, T, s;
      const o = Or(this, Tr, zs).call(this);
      if (!o) return;
      const f = (x = o.parentElement) == null ? void 0 : x.parentElement;
      if (f) {
        if (this.isGrid) {
          const B = Or(this, Tr, my).call(this, o);
          if ((o.scrollIntoView({ block: "nearest" }), B)) {
            const N =
              (A = o == null ? void 0 : o.closest(Tc)) == null
                ? void 0
                : A.querySelector(Hv);
            N == null || N.scrollIntoView({ block: "nearest" });
            return;
          }
        } else {
          const B = WE(f);
          if (
            B &&
            ((L = B.dataset) == null ? void 0 : L.value) ===
              ((T = o.dataset) == null ? void 0 : T.value)
          ) {
            const N =
              (s = o == null ? void 0 : o.closest(Tc)) == null
                ? void 0
                : s.querySelector(Hv);
            N == null || N.scrollIntoView({ block: "nearest" });
            return;
          }
        }
        o.scrollIntoView({ block: "nearest" });
      }
    });
  }),
  (my = function (o) {
    const f = this.itemsGrid;
    if (f.length === 0) return !1;
    for (let x = 0; x < f.length; x++) {
      const A = f[x];
      if (A !== void 0)
        for (let L = 0; L < A.length; L++) {
          const T = A[L];
          if (!(T === void 0 || T.ref !== o)) return T.firstRowOfGroup;
        }
    }
    return !1;
  }),
  (Om = function () {
    return this.updateSelectedToIndex(this.getValidItems().length - 1);
  }),
  (Xu = function (o) {
    o.preventDefault(),
      o.metaKey
        ? Or(this, Tr, Om).call(this)
        : o.altKey
        ? this.updateSelectedByGroup(1)
        : this.updateSelectedByItem(1);
  }),
  (Nm = function (o) {
    this.opts.columns.current !== null &&
      (o.preventDefault(),
      o.metaKey
        ? this.updateSelectedByGroup(1)
        : this.updateSelectedByItem(Or(this, Tr, _y).call(this, o)));
  }),
  (jm = function (o, f) {
    if (f.length === 0) return null;
    for (let x = 0; x < f.length; x++) {
      const A = f[x];
      if (A !== void 0)
        for (let L = 0; L < A.length; L++) {
          const T = A[L];
          if (!(T === void 0 || T.ref !== o))
            return { columnIndex: L, rowIndex: x };
        }
    }
    return null;
  }),
  (_y = function (o) {
    const f = this.itemsGrid,
      x = Or(this, Tr, zs).call(this);
    if (!x) return 0;
    const A = Or(this, Tr, jm).call(this, x, f);
    if (!A) return 0;
    let L = null;
    const T = o.altKey ? 1 : 0;
    if (o.altKey && A.rowIndex === f.length - 2 && !this.opts.loop.current)
      L = Or(this, Tr, Yu).call(this, {
        start: f.length - 1,
        end: f.length,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      });
    else if (A.rowIndex === f.length - 1) {
      if (!this.opts.loop.current) return 0;
      L = Or(this, Tr, Yu).call(this, {
        start: 0 + T,
        end: A.rowIndex,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      });
    } else
      (L = Or(this, Tr, Yu).call(this, {
        start: A.rowIndex + 1 + T,
        end: f.length,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      })),
        L === null &&
          this.opts.loop.current &&
          (L = Or(this, Tr, Yu).call(this, {
            start: 0,
            end: A.rowIndex,
            expectedColumnIndex: A.columnIndex,
            grid: f,
          }));
    return Or(this, Tr, Vm).call(this, x, L);
  }),
  (Yu = function ({ start: o, end: f, grid: x, expectedColumnIndex: A }) {
    var T;
    let L = null;
    for (let s = o; s < f; s++) {
      const B = x[s];
      if (
        ((L = ((T = B[A]) == null ? void 0 : T.ref) ?? null),
        L !== null && vp(L))
      ) {
        L = null;
        continue;
      }
      if (L === null)
        for (let N = B.length - 1; N >= 0; N--) {
          const K = B[B.length - 1];
          if (!(K === void 0 || vp(K.ref))) {
            L = K.ref;
            break;
          }
        }
      break;
    }
    return L;
  }),
  (Vm = function (o, f) {
    if (f === null) return 0;
    const x = this.getValidItems(),
      A = x.findIndex((T) => T === o);
    return x.findIndex((T) => T === f) - A;
  }),
  (qm = function (o) {
    this.opts.columns.current !== null &&
      (o.preventDefault(),
      o.metaKey
        ? this.updateSelectedByGroup(-1)
        : this.updateSelectedByItem(Or(this, Tr, gy).call(this, o)));
  }),
  (gy = function (o) {
    const f = this.itemsGrid,
      x = Or(this, Tr, zs).call(this);
    if (x === void 0) return 0;
    const A = Or(this, Tr, jm).call(this, x, f);
    if (A === null) return 0;
    let L = null;
    const T = o.altKey ? 1 : 0;
    if (o.altKey && A.rowIndex === 1 && this.opts.loop.current === !1)
      L = Or(this, Tr, Ku).call(this, {
        start: 0,
        end: 0,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      });
    else if (A.rowIndex === 0) {
      if (this.opts.loop.current === !1) return 0;
      L = Or(this, Tr, Ku).call(this, {
        start: f.length - 1 - T,
        end: A.rowIndex + 1,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      });
    } else
      (L = Or(this, Tr, Ku).call(this, {
        start: A.rowIndex - 1 - T,
        end: 0,
        expectedColumnIndex: A.columnIndex,
        grid: f,
      })),
        L === null &&
          this.opts.loop.current &&
          (L = Or(this, Tr, Ku).call(this, {
            start: f.length - 1,
            end: A.rowIndex + 1,
            expectedColumnIndex: A.columnIndex,
            grid: f,
          }));
    return Or(this, Tr, Vm).call(this, x, L);
  }),
  (Ku = function ({ start: o, end: f, grid: x, expectedColumnIndex: A }) {
    var T;
    let L = null;
    for (let s = o; s >= f; s--) {
      const B = x[s];
      if (B !== void 0) {
        if (
          ((L = ((T = B[A]) == null ? void 0 : T.ref) ?? null),
          L !== null && vp(L))
        ) {
          L = null;
          continue;
        }
        if (L === null)
          for (let N = B.length - 1; N >= 0; N--) {
            const K = B[B.length - 1];
            if (!(K === void 0 || vp(K.ref))) {
              L = K.ref;
              break;
            }
          }
        break;
      }
    }
    return L;
  }),
  (Ju = function (o) {
    o.preventDefault(),
      o.metaKey
        ? this.updateSelectedToIndex(0)
        : o.altKey
        ? this.updateSelectedByGroup(-1)
        : this.updateSelectedByItem(-1);
  }),
  (wh = new WeakMap());
let Fm = R_;
function vp(_) {
  return _.getAttribute("aria-disabled") === "true";
}
var Th, Sh, Ch;
const F_ = class F_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(
      this,
      Th,
      ut(
        () =>
          (this.root._commandState.filtered.count === 0 &&
            He(this, Sh) === !1) ||
          this.opts.forceMount.current
      )
    );
    Er(this, Sh, !0);
    Er(
      this,
      Ch,
      ut(() => ({
        id: this.opts.id.current,
        role: "presentation",
        [wa.empty]: "",
        ...this.attachment,
      }))
    );
    (this.opts = o),
      (this.root = f),
      (this.attachment = Wa(this.opts.ref)),
      s_(() => {
        $i(this, Sh, !1);
      });
  }
  static create(o) {
    return new F_(o, wl.get());
  }
  get shouldRender() {
    return y(He(this, Th));
  }
  set shouldRender(o) {
    te(He(this, Th), o);
  }
  get props() {
    return y(He(this, Ch));
  }
  set props(o) {
    te(He(this, Ch), o);
  }
};
(Th = new WeakMap()), (Sh = new WeakMap()), (Ch = new WeakMap());
let Um = F_;
var Ph, Ih, Mh, Ah;
const B_ = class B_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(
      this,
      Ph,
      ut(() =>
        this.opts.forceMount.current ||
        this.root.opts.shouldFilter.current === !1 ||
        !this.root.commandState.search
          ? !0
          : this.root._commandState.filtered.groups.has(this.trueValue)
      )
    );
    Er(this, Ih, Je(null));
    Er(this, Mh, Je(""));
    Er(
      this,
      Ah,
      ut(() => ({
        id: this.opts.id.current,
        role: "presentation",
        hidden: this.shouldRender ? void 0 : !0,
        "data-value": this.trueValue,
        [wa.group]: "",
        ...this.attachment,
      }))
    );
    (this.opts = o),
      (this.root = f),
      (this.attachment = Wa(this.opts.ref)),
      (this.trueValue = o.value.current ?? o.id.current),
      xl(
        () => this.trueValue,
        () => this.root.registerGroup(this.trueValue)
      ),
      $r(() =>
        this.opts.value.current
          ? ((this.trueValue = this.opts.value.current),
            this.root.registerValue(this.opts.value.current))
          : this.headingNode && this.headingNode.textContent
          ? ((this.trueValue = this.headingNode.textContent
              .trim()
              .toLowerCase()),
            this.root.registerValue(this.trueValue))
          : ((this.trueValue = `-----${this.opts.id.current}`),
            this.root.registerValue(this.trueValue))
      );
  }
  static create(o) {
    return ih.set(new B_(o, wl.get()));
  }
  get shouldRender() {
    return y(He(this, Ph));
  }
  set shouldRender(o) {
    te(He(this, Ph), o);
  }
  get headingNode() {
    return y(He(this, Ih));
  }
  set headingNode(o) {
    te(He(this, Ih), o, !0);
  }
  get trueValue() {
    return y(He(this, Mh));
  }
  set trueValue(o) {
    te(He(this, Mh), o, !0);
  }
  get props() {
    return y(He(this, Ah));
  }
  set props(o) {
    te(He(this, Ah), o);
  }
};
(Ph = new WeakMap()),
  (Ih = new WeakMap()),
  (Mh = new WeakMap()),
  (Ah = new WeakMap());
let Zm = B_;
var kh;
const O_ = class O_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "group");
    Ir(this, "attachment");
    Er(
      this,
      kh,
      ut(() => ({
        id: this.opts.id.current,
        [wa["group-heading"]]: "",
        ...this.attachment,
      }))
    );
    (this.opts = o),
      (this.group = f),
      (this.attachment = Wa(
        this.opts.ref,
        (x) => (this.group.headingNode = x)
      ));
  }
  static create(o) {
    return new O_(o, ih.get());
  }
  get props() {
    return y(He(this, kh));
  }
  set props(o) {
    te(He(this, kh), o);
  }
};
kh = new WeakMap();
let Gm = O_;
var Eh;
const N_ = class N_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "group");
    Ir(this, "attachment");
    Er(
      this,
      Eh,
      ut(() => {
        var o;
        return {
          id: this.opts.id.current,
          role: "group",
          [wa["group-items"]]: "",
          "aria-labelledby":
            ((o = this.group.headingNode) == null ? void 0 : o.id) ?? void 0,
          ...this.attachment,
        };
      })
    );
    (this.opts = o), (this.group = f), (this.attachment = Wa(this.opts.ref));
  }
  static create(o) {
    return new N_(o, ih.get());
  }
  get props() {
    return y(He(this, Eh));
  }
  set props(o) {
    te(He(this, Eh), o);
  }
};
Eh = new WeakMap();
let $m = N_;
var Np, zh;
const j_ = class j_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(
      this,
      Np,
      ut(() => {
        var f;
        const o =
          (f = this.root.viewportNode) == null
            ? void 0
            : f.querySelector(
                `${dy}[${ml}="${hy(this.root.opts.value.current)}"]`
              );
        if (o != null) return o.getAttribute("id") ?? void 0;
      })
    );
    Er(
      this,
      zh,
      ut(() => {
        var o, f;
        return {
          id: this.opts.id.current,
          type: "text",
          [wa.input]: "",
          autocomplete: "off",
          autocorrect: "off",
          spellcheck: !1,
          "aria-autocomplete": "list",
          role: "combobox",
          "aria-expanded": Rm(!0),
          "aria-controls":
            ((o = this.root.viewportNode) == null ? void 0 : o.id) ?? void 0,
          "aria-labelledby":
            ((f = this.root.labelNode) == null ? void 0 : f.id) ?? void 0,
          "aria-activedescendant": y(He(this, Np)),
          ...this.attachment,
        };
      })
    );
    (this.opts = o),
      (this.root = f),
      (this.attachment = Wa(this.opts.ref, (x) => (this.root.inputNode = x))),
      xl(
        () => this.opts.ref.current,
        () => {
          const x = this.opts.ref.current;
          x && this.opts.autofocus.current && wE(10, () => x.focus());
        }
      ),
      xl(
        () => this.opts.value.current,
        () => {
          this.root.commandState.search !== this.opts.value.current &&
            this.root.setState("search", this.opts.value.current);
        }
      );
  }
  static create(o) {
    return new j_(o, wl.get());
  }
  get props() {
    return y(He(this, zh));
  }
  set props(o) {
    te(He(this, zh), o);
  }
};
(Np = new WeakMap()), (zh = new WeakMap());
let Hm = j_;
var Ds, jp, Lh, Dh, Rh, bl, vy, Xm, Fh;
const V_ = class V_ {
  constructor(o, f) {
    Er(this, bl);
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(this, Ds, null);
    Er(
      this,
      jp,
      ut(() => {
        var o;
        return (
          this.opts.forceMount.current ||
          ((o = He(this, Ds)) == null ? void 0 : o.opts.forceMount.current) ===
            !0
        );
      })
    );
    Er(
      this,
      Lh,
      ut(() => {
        if (
          (this.opts.ref.current,
          y(He(this, jp)) ||
            this.root.opts.shouldFilter.current === !1 ||
            !this.root.commandState.search)
        )
          return !0;
        const o = this.root.commandState.filtered.items.get(this.trueValue);
        return o === void 0 ? !1 : o > 0;
      })
    );
    Er(
      this,
      Dh,
      ut(
        () =>
          this.root.opts.value.current === this.trueValue &&
          this.trueValue !== ""
      )
    );
    Er(this, Rh, Je(""));
    Er(
      this,
      Fh,
      ut(() => {
        var o;
        return {
          id: this.opts.id.current,
          "aria-disabled": Rm(this.opts.disabled.current),
          "aria-selected": Rm(this.isSelected),
          "data-disabled": $v(this.opts.disabled.current),
          "data-selected": $v(this.isSelected),
          "data-value": this.trueValue,
          "data-group": (o = He(this, Ds)) == null ? void 0 : o.trueValue,
          [wa.item]: "",
          role: "option",
          onpointermove: this.onpointermove,
          onclick: this.onclick,
          ...this.attachment,
        };
      })
    );
    (this.opts = o),
      (this.root = f),
      $i(this, Ds, ih.getOr(null)),
      (this.trueValue = o.value.current),
      (this.attachment = Wa(this.opts.ref)),
      xl(
        [
          () => this.trueValue,
          () => {
            var x;
            return (x = He(this, Ds)) == null ? void 0 : x.trueValue;
          },
          () => this.opts.forceMount.current,
        ],
        () => {
          var x;
          if (!(this.opts.forceMount.current || !this.trueValue))
            return this.root.registerItem(
              this.trueValue,
              (x = He(this, Ds)) == null ? void 0 : x.trueValue
            );
        }
      ),
      xl([() => this.opts.value.current, () => this.opts.ref.current], () => {
        var x, A;
        this.opts.value.current
          ? (this.trueValue = this.opts.value.current)
          : (x = this.opts.ref.current) != null &&
            x.textContent &&
            (this.trueValue = this.opts.ref.current.textContent.trim()),
          this.trueValue &&
            (this.root.registerValue(
              this.trueValue,
              o.keywords.current.map((L) => L.trim())
            ),
            (A = this.opts.ref.current) == null ||
              A.setAttribute(ml, this.trueValue));
      }),
      (this.onclick = this.onclick.bind(this)),
      (this.onpointermove = this.onpointermove.bind(this));
  }
  static create(o) {
    const f = ih.getOr(null);
    return new V_({ ...o, group: f }, wl.get());
  }
  get shouldRender() {
    return y(He(this, Lh));
  }
  set shouldRender(o) {
    te(He(this, Lh), o);
  }
  get isSelected() {
    return y(He(this, Dh));
  }
  set isSelected(o) {
    te(He(this, Dh), o);
  }
  get trueValue() {
    return y(He(this, Rh));
  }
  set trueValue(o) {
    te(He(this, Rh), o, !0);
  }
  onpointermove(o) {
    this.opts.disabled.current ||
      this.root.opts.disablePointerSelection.current ||
      Or(this, bl, Xm).call(this);
  }
  onclick(o) {
    this.opts.disabled.current || Or(this, bl, vy).call(this);
  }
  get props() {
    return y(He(this, Fh));
  }
  set props(o) {
    te(He(this, Fh), o);
  }
};
(Ds = new WeakMap()),
  (jp = new WeakMap()),
  (Lh = new WeakMap()),
  (Dh = new WeakMap()),
  (Rh = new WeakMap()),
  (bl = new WeakSet()),
  (vy = function () {
    var o;
    this.opts.disabled.current ||
      (Or(this, bl, Xm).call(this),
      (o = this.opts.onSelect) == null || o.current());
  }),
  (Xm = function () {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0);
  }),
  (Fh = new WeakMap());
let Wm = V_;
var Bh;
const q_ = class q_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(
      this,
      Bh,
      ut(() => ({
        id: this.opts.id.current,
        role: "listbox",
        "aria-label": this.opts.ariaLabel.current,
        [wa.list]: "",
        ...this.attachment,
      }))
    );
    (this.opts = o), (this.root = f), (this.attachment = Wa(this.opts.ref));
  }
  static create(o) {
    return JE.set(new q_(o, wl.get()));
  }
  get props() {
    return y(He(this, Bh));
  }
  set props(o) {
    te(He(this, Bh), o);
  }
};
Bh = new WeakMap();
let Ym = q_;
var Oh;
const U_ = class U_ {
  constructor(o, f) {
    Ir(this, "opts");
    Ir(this, "root");
    Ir(this, "attachment");
    Er(
      this,
      Oh,
      ut(() => {
        var o;
        return {
          id: this.opts.id.current,
          [wa["input-label"]]: "",
          for: (o = this.opts.for) == null ? void 0 : o.current,
          style: oy,
          ...this.attachment,
        };
      })
    );
    (this.opts = o),
      (this.root = f),
      (this.attachment = Wa(this.opts.ref, (x) => (this.root.labelNode = x)));
  }
  static create(o) {
    return new U_(o, wl.get());
  }
  get props() {
    return y(He(this, Oh));
  }
  set props(o) {
    te(He(this, Oh), o);
  }
};
Oh = new WeakMap();
let Km = U_;
var QE = me("<label><!></label>");
function e8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const T = Km.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (K) => A(K)
      ),
    }),
    s = ut(() => Ba(L, T.props));
  var B = QE();
  dr(B, () => ({ ...y(s) }));
  var N = M(B);
  si(N, () => o.children ?? sa), P(B), G(_, B), Rr();
}
var t8 = me("<!> <!>", 1),
  r8 = me("<div><!> <!></div>");
function n8(_, o) {
  const f = _o();
  Dr(o, !0);
  const x = (je) => {
    e8(je, {
      children: (Ge, bt) => {
        yn();
        var Xe = ji();
        Ne(() => le(Xe, re())), G(Ge, Xe);
      },
      $$slots: { default: !0 },
    });
  };
  let A = Et(o, "id", 19, () => Xa(f)),
    L = Et(o, "ref", 15, null),
    T = Et(o, "value", 15, ""),
    s = Et(o, "onValueChange", 3, nh),
    B = Et(o, "onStateChange", 3, nh),
    N = Et(o, "loop", 3, !1),
    K = Et(o, "shouldFilter", 3, !0),
    ee = Et(o, "filter", 3, xy),
    re = Et(o, "label", 3, ""),
    ue = Et(o, "vimBindings", 3, !0),
    ne = Et(o, "disablePointerSelection", 3, !1),
    Y = Et(o, "disableInitialScroll", 3, !1),
    xe = Et(o, "columns", 3, null),
    Ie = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "onStateChange",
      "loop",
      "shouldFilter",
      "filter",
      "label",
      "vimBindings",
      "disablePointerSelection",
      "disableInitialScroll",
      "columns",
      "children",
      "child",
    ]);
  const Ee = Fm.create({
      id: Xr(() => A()),
      ref: Xr(
        () => L(),
        (je) => L(je)
      ),
      filter: Xr(() => ee()),
      shouldFilter: Xr(() => K()),
      loop: Xr(() => N()),
      value: Xr(
        () => T(),
        (je) => {
          T() !== je && (T(je), s()(je));
        }
      ),
      vimBindings: Xr(() => ue()),
      disablePointerSelection: Xr(() => ne()),
      disableInitialScroll: Xr(() => Y()),
      onStateChange: Xr(() => B()),
      columns: Xr(() => xe()),
    }),
    De = (je) => Ee.updateSelectedToIndex(je),
    Ae = (je) => Ee.updateSelectedByGroup(je),
    qe = (je) => Ee.updateSelectedByItem(je),
    Ue = () => Ee.getValidItems(),
    Be = ut(() => Ba(Ie, Ee.props));
  var ke = {
      updateSelectedToIndex: De,
      updateSelectedByGroup: Ae,
      updateSelectedByItem: qe,
      getValidItems: Ue,
    },
    $e = Jt(),
    Le = _t($e);
  {
    var nt = (je) => {
        var Ge = t8(),
          bt = _t(Ge);
        x(bt);
        var Xe = q(bt, 2);
        si(
          Xe,
          () => o.child,
          () => ({ props: y(Be) })
        ),
          G(je, Ge);
      },
      dt = (je) => {
        var Ge = r8();
        dr(Ge, () => ({ ...y(Be) }));
        var bt = M(Ge);
        x(bt);
        var Xe = q(bt, 2);
        si(Xe, () => o.children ?? sa), P(Ge), G(je, Ge);
      };
    Me(Le, (je) => {
      o.child ? je(nt) : je(dt, !1);
    });
  }
  return G(_, $e), Rr(ke);
}
var i8 = me("<div><!></div>");
function a8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = Et(o, "forceMount", 3, !1),
    T = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount",
    ]);
  const s = Um.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (re) => A(re)
      ),
      forceMount: Xr(() => L()),
    }),
    B = ut(() => Ba(s.props, T));
  var N = Jt(),
    K = _t(N);
  {
    var ee = (re) => {
      var ue = Jt(),
        ne = _t(ue);
      {
        var Y = (Ie) => {
            var Ee = Jt(),
              De = _t(Ee);
            si(
              De,
              () => o.child,
              () => ({ props: y(B) })
            ),
              G(Ie, Ee);
          },
          xe = (Ie) => {
            var Ee = i8();
            dr(Ee, () => ({ ...y(B) }));
            var De = M(Ee);
            si(De, () => o.children ?? sa), P(Ee), G(Ie, Ee);
          };
        Me(ne, (Ie) => {
          o.child ? Ie(Y) : Ie(xe, !1);
        });
      }
      G(re, ue);
    };
    Me(K, (re) => {
      s.shouldRender && re(ee);
    });
  }
  G(_, N), Rr();
}
var o8 = me("<div><!></div>");
function s8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = Et(o, "value", 3, ""),
    T = Et(o, "forceMount", 3, !1),
    s = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "forceMount",
      "children",
      "child",
    ]);
  const B = Zm.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (ne) => A(ne)
      ),
      forceMount: Xr(() => T()),
      value: Xr(() => L()),
    }),
    N = ut(() => Ba(s, B.props));
  var K = Jt(),
    ee = _t(K);
  {
    var re = (ne) => {
        var Y = Jt(),
          xe = _t(Y);
        si(
          xe,
          () => o.child,
          () => ({ props: y(N) })
        ),
          G(ne, Y);
      },
      ue = (ne) => {
        var Y = o8();
        dr(Y, () => ({ ...y(N) }));
        var xe = M(Y);
        si(xe, () => o.children ?? sa), P(Y), G(ne, Y);
      };
    Me(ee, (ne) => {
      o.child ? ne(re) : ne(ue, !1);
    });
  }
  G(_, K), Rr();
}
var l8 = me("<div><!></div>");
function c8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
    ]);
  const T = Gm.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (re) => A(re)
      ),
    }),
    s = ut(() => Ba(L, T.props));
  var B = Jt(),
    N = _t(B);
  {
    var K = (re) => {
        var ue = Jt(),
          ne = _t(ue);
        si(
          ne,
          () => o.child,
          () => ({ props: y(s) })
        ),
          G(re, ue);
      },
      ee = (re) => {
        var ue = l8();
        dr(ue, () => ({ ...y(s) }));
        var ne = M(ue);
        si(ne, () => o.children ?? sa), P(ue), G(re, ue);
      };
    Me(N, (re) => {
      o.child ? re(K) : re(ee, !1);
    });
  }
  G(_, B), Rr();
}
var u8 = me("<div><!></div>"),
  h8 = me('<div style="display: contents;"><!></div>');
function d8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
    ]);
  const T = $m.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (re) => A(re)
      ),
    }),
    s = ut(() => Ba(L, T.props));
  var B = h8(),
    N = M(B);
  {
    var K = (re) => {
        var ue = Jt(),
          ne = _t(ue);
        si(
          ne,
          () => o.child,
          () => ({ props: y(s) })
        ),
          G(re, ue);
      },
      ee = (re) => {
        var ue = u8();
        dr(ue, () => ({ ...y(s) }));
        var ne = M(ue);
        si(ne, () => o.children ?? sa), P(ue), G(re, ue);
      };
    Me(N, (re) => {
      o.child ? re(K) : re(ee, !1);
    });
  }
  P(B), G(_, B), Rr();
}
var p8 = me("<input/>");
function f8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "value", 15, ""),
    A = Et(o, "autofocus", 3, !1),
    L = Et(o, "id", 19, () => Xa(f)),
    T = Et(o, "ref", 15, null),
    s = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "autofocus",
      "id",
      "ref",
      "child",
    ]);
  const B = Hm.create({
      id: Xr(() => L()),
      ref: Xr(
        () => T(),
        (ne) => T(ne)
      ),
      value: Xr(
        () => x(),
        (ne) => {
          x(ne);
        }
      ),
      autofocus: Xr(() => A() ?? !1),
    }),
    N = ut(() => Ba(s, B.props));
  var K = Jt(),
    ee = _t(K);
  {
    var re = (ne) => {
        var Y = Jt(),
          xe = _t(Y);
        si(
          xe,
          () => o.child,
          () => ({ props: y(N) })
        ),
          G(ne, Y);
      },
      ue = (ne) => {
        var Y = p8();
        dr(Y, () => ({ ...y(N) }), void 0, void 0, void 0, void 0, !0),
          $h(Y, x),
          G(ne, Y);
      };
    Me(ee, (ne) => {
      o.child ? ne(re) : ne(ue, !1);
    });
  }
  G(_, K), Rr();
}
var m8 = me("<div><!></div>"),
  _8 = me('<div style="display: contents;" data-item-wrapper=""><!></div>');
function g8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = Et(o, "value", 3, ""),
    T = Et(o, "disabled", 3, !1),
    s = Et(o, "onSelect", 3, nh),
    B = Et(o, "forceMount", 3, !1),
    N = Et(o, "keywords", 19, () => []),
    K = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords",
    ]);
  const ee = Wm.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (Y) => A(Y)
      ),
      value: Xr(() => L()),
      disabled: Xr(() => T()),
      onSelect: Xr(() => s()),
      forceMount: Xr(() => B()),
      keywords: Xr(() => N()),
    }),
    re = ut(() => Ba(K, ee.props));
  var ue = Jt(),
    ne = _t(ue);
  th(
    ne,
    () => ee.root.key,
    (Y) => {
      var xe = _8(),
        Ie = M(xe);
      {
        var Ee = (De) => {
          var Ae = Jt(),
            qe = _t(Ae);
          {
            var Ue = (ke) => {
                var $e = Jt(),
                  Le = _t($e);
                si(
                  Le,
                  () => o.child,
                  () => ({ props: y(re) })
                ),
                  G(ke, $e);
              },
              Be = (ke) => {
                var $e = m8();
                dr($e, () => ({ ...y(re) }));
                var Le = M($e);
                si(Le, () => o.children ?? sa), P($e), G(ke, $e);
              };
            Me(qe, (ke) => {
              o.child ? ke(Ue) : ke(Be, !1);
            });
          }
          G(De, Ae);
        };
        Me(Ie, (De) => {
          ee.shouldRender && De(Ee);
        });
      }
      P(xe), Ne(() => gr(xe, "data-value", ee.trueValue)), G(Y, xe);
    }
  ),
    G(_, ue),
    Rr();
}
var v8 = me("<div><!></div>");
function y8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "aria-label",
    ]);
  const T = Ym.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (K) => A(K)
      ),
      ariaLabel: Xr(() => o["aria-label"] ?? "Suggestions..."),
    }),
    s = ut(() => Ba(L, T.props));
  var B = Jt(),
    N = _t(B);
  th(
    N,
    () => T.root._commandState.search === "",
    (K) => {
      var ee = Jt(),
        re = _t(ee);
      {
        var ue = (Y) => {
            var xe = Jt(),
              Ie = _t(xe);
            si(
              Ie,
              () => o.child,
              () => ({ props: y(s) })
            ),
              G(Y, xe);
          },
          ne = (Y) => {
            var xe = v8();
            dr(xe, () => ({ ...y(s) }));
            var Ie = M(xe);
            si(Ie, () => o.children ?? sa), P(xe), G(Y, xe);
          };
        Me(re, (Y) => {
          o.child ? Y(ue) : Y(ne, !1);
        });
      }
      G(K, ee);
    }
  ),
    G(_, B),
    Rr();
}
const Xv = 1,
  x8 = 0.9,
  b8 = 0.8,
  w8 = 0.17,
  pm = 0.1,
  fm = 0.999,
  T8 = 0.9999,
  S8 = 0.99,
  C8 = /[\\/_+.#"@[({&]/,
  P8 = /[\\/_+.#"@[({&]/g,
  I8 = /[\s-]/,
  yy = /[\s-]/g;
function Jm(_, o, f, x, A, L, T) {
  if (L === o.length) return A === _.length ? Xv : S8;
  const s = `${A},${L}`;
  if (T[s] !== void 0) return T[s];
  const B = x.charAt(L);
  let N = f.indexOf(B, A),
    K = 0,
    ee,
    re,
    ue,
    ne;
  for (; N >= 0; )
    (ee = Jm(_, o, f, x, N + 1, L + 1, T)),
      ee > K &&
        (N === A
          ? (ee *= Xv)
          : C8.test(_.charAt(N - 1))
          ? ((ee *= b8),
            (ue = _.slice(A, N - 1).match(P8)),
            ue && A > 0 && (ee *= fm ** ue.length))
          : I8.test(_.charAt(N - 1))
          ? ((ee *= x8),
            (ne = _.slice(A, N - 1).match(yy)),
            ne && A > 0 && (ee *= fm ** ne.length))
          : ((ee *= w8), A > 0 && (ee *= fm ** (N - A))),
        _.charAt(N) !== o.charAt(L) && (ee *= T8)),
      ((ee < pm && f.charAt(N - 1) === x.charAt(L + 1)) ||
        (x.charAt(L + 1) === x.charAt(L) && f.charAt(N - 1) !== x.charAt(L))) &&
        ((re = Jm(_, o, f, x, N + 1, L + 2, T)),
        re * pm > ee && (ee = re * pm)),
      ee > K && (K = ee),
      (N = f.indexOf(B, N + 1));
  return (T[s] = K), K;
}
function Yv(_) {
  return _.toLowerCase().replace(yy, " ");
}
function xy(_, o, f) {
  return (
    (_ =
      f && f.length > 0 ? `${`${_} ${f == null ? void 0 : f.join(" ")}`}` : _),
    Jm(_, o, Yv(_), Yv(o), 0, 0, {})
  );
}
const M8 = 18,
  by = 40,
  A8 = `${by}px`,
  k8 = [
    "[data-lastpass-icon-root]",
    "com-1password-button",
    "[data-dashlanecreated]",
    '[style$="2147483647 !important;"]',
  ].join(",");
function E8({
  containerRef: _,
  inputRef: o,
  pushPasswordManagerStrategy: f,
  isFocused: x,
  domContext: A,
}) {
  let L = Je(!1),
    T = Je(!1),
    s = Je(!1);
  function B() {
    const K = f.current;
    return K === "none" ? !1 : K === "increase-width" && y(L) && y(T);
  }
  function N() {
    const K = _.current,
      ee = o.current;
    if (!K || !ee || y(s) || f.current === "none") return;
    const re = K,
      ue = re.getBoundingClientRect().left + re.offsetWidth,
      ne = re.getBoundingClientRect().top + re.offsetHeight / 2,
      Y = ue - M8,
      xe = ne;
    (A.querySelectorAll(k8).length === 0 &&
      A.getDocument().elementFromPoint(Y, xe) === K) ||
      (te(L, !0), te(s, !0));
  }
  return (
    $r(() => {
      const K = _.current;
      if (!K || f.current === "none") return;
      function ee() {
        const ne = cy(K).innerWidth - K.getBoundingClientRect().right;
        te(T, ne >= by);
      }
      ee();
      const re = setInterval(ee, 1e3);
      return () => {
        clearInterval(re);
      };
    }),
    $r(() => {
      const K = x.current || A.getActiveElement() === o.current;
      if (f.current === "none" || !K) return;
      const ee = setTimeout(N, 0),
        re = setTimeout(N, 2e3),
        ue = setTimeout(N, 5e3),
        ne = setTimeout(() => {
          te(s, !0);
        }, 6e3);
      return () => {
        clearTimeout(ee), clearTimeout(re), clearTimeout(ue), clearTimeout(ne);
      };
    }),
    {
      get hasPwmBadge() {
        return y(L);
      },
      get willPushPwmBadge() {
        return B();
      },
      PWM_BADGE_SPACE_WIDTH: A8,
    }
  );
}
const wy = uy({ component: "pin-input", parts: ["root", "cell"] }),
  z8 = [
    "Backspace",
    "Delete",
    "ArrowLeft",
    "ArrowRight",
    "ArrowUp",
    "ArrowDown",
    "Home",
    "End",
    "Escape",
    "Enter",
    "Tab",
    "Shift",
    "Control",
    "Meta",
  ];
var Ga,
  Rc,
  cs,
  Fa,
  $a,
  Fc,
  Ao,
  us,
  Rs,
  Bc,
  Vp,
  Nh,
  jh,
  qp,
  Up,
  Ty,
  Vh,
  qh,
  Zp,
  Uh;
const Z_ = class Z_ {
  constructor(o) {
    Er(this, Up);
    Ir(this, "opts");
    Ir(this, "attachment");
    Er(this, Ga, Vv(null));
    Er(this, Rc, Je(!1));
    Ir(this, "inputAttachment", Wa(He(this, Ga)));
    Er(this, cs, Vv(!1));
    Er(this, Fa, Je(null));
    Er(this, $a, Je(null));
    Er(this, Fc, new bE(() => this.opts.value.current ?? ""));
    Er(
      this,
      Ao,
      ut(() =>
        typeof this.opts.pattern.current == "string"
          ? new RegExp(this.opts.pattern.current)
          : this.opts.pattern.current
      )
    );
    Er(this, us, Je(Si({ prev: [null, null, "none"], willSyntheticBlur: !1 })));
    Er(this, Rs);
    Er(this, Bc);
    Ir(this, "domContext");
    Ir(this, "onkeydown", (o) => {
      const f = o.key;
      z8.includes(f) ||
        o.ctrlKey ||
        o.metaKey ||
        (f &&
          y(He(this, Ao)) &&
          !y(He(this, Ao)).test(f) &&
          o.preventDefault());
    });
    Er(
      this,
      Vp,
      ut(() => ({
        position: "relative",
        cursor: this.opts.disabled.current ? "default" : "text",
        userSelect: "none",
        WebkitUserSelect: "none",
        pointerEvents: "none",
      }))
    );
    Er(
      this,
      Nh,
      ut(() => ({
        id: this.opts.id.current,
        [wy.root]: "",
        style: y(He(this, Vp)),
        ...this.attachment,
      }))
    );
    Er(
      this,
      jh,
      ut(() => ({
        style: { position: "absolute", inset: 0, pointerEvents: "none" },
      }))
    );
    Er(
      this,
      qp,
      ut(() => ({
        position: "absolute",
        inset: 0,
        width: He(this, Rs).willPushPwmBadge
          ? `calc(100% + ${He(this, Rs).PWM_BADGE_SPACE_WIDTH})`
          : "100%",
        clipPath: He(this, Rs).willPushPwmBadge
          ? `inset(0 ${He(this, Rs).PWM_BADGE_SPACE_WIDTH} 0 0)`
          : void 0,
        height: "100%",
        display: "flex",
        textAlign: this.opts.textAlign.current,
        opacity: "1",
        color: "transparent",
        pointerEvents: "all",
        background: "transparent",
        caretColor: "transparent",
        border: "0 solid transparent",
        outline: "0 solid transparent",
        boxShadow: "none",
        lineHeight: "1",
        letterSpacing: "-.5em",
        fontSize: "var(--bits-pin-input-root-height)",
        fontFamily: "monospace",
        fontVariantNumeric: "tabular-nums",
      }))
    );
    Er(this, Vh, () => {
      var Y;
      const o = He(this, Ga).current,
        f = this.opts.ref.current;
      if (!o || !f) return;
      if (this.domContext.getActiveElement() !== o) {
        te(He(this, Fa), null), te(He(this, $a), null);
        return;
      }
      const x = o.selectionStart,
        A = o.selectionEnd,
        L = o.selectionDirection ?? "none",
        T = o.maxLength,
        s = o.value,
        B = y(He(this, us)).prev;
      let N = -1,
        K = -1,
        ee;
      if (s.length !== 0 && x !== null && A !== null) {
        const xe = x === A,
          Ie = x === s.length && s.length < T;
        if (xe && !Ie) {
          const Ee = x;
          if (Ee === 0) (N = 0), (K = 1), (ee = "forward");
          else if (Ee === T) (N = Ee - 1), (K = Ee), (ee = "backward");
          else if (T > 1 && s.length > 1) {
            let De = 0;
            if (B[0] !== null && B[1] !== null) {
              ee = Ee < B[0] ? "backward" : "forward";
              const Ae = B[0] === B[1] && B[0] < T;
              ee === "backward" && !Ae && (De = -1);
            }
            (N = De - Ee), (K = De + Ee + 1);
          }
        }
        N !== -1 &&
          K !== -1 &&
          N !== K &&
          ((Y = He(this, Ga).current) == null || Y.setSelectionRange(N, K, ee));
      }
      const re = N !== -1 ? N : x,
        ue = K !== -1 ? K : A,
        ne = ee ?? L;
      te(He(this, Fa), re, !0),
        te(He(this, $a), ue, !0),
        (y(He(this, us)).prev = [re, ue, ne]);
    });
    Ir(this, "oninput", (o) => {
      const f = o.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (f.length > 0 && y(He(this, Ao)) && !y(He(this, Ao)).test(f)) {
        o.preventDefault();
        return;
      }
      typeof He(this, Fc).current == "string" &&
        f.length < He(this, Fc).current.length &&
        this.domContext
          .getDocument()
          .dispatchEvent(new Event("selectionchange")),
        (this.opts.value.current = f);
    });
    Ir(this, "onfocus", (o) => {
      const f = He(this, Ga).current;
      if (f) {
        const x = Math.min(f.value.length, this.opts.maxLength.current - 1),
          A = f.value.length;
        f.setSelectionRange(x, A),
          te(He(this, Fa), x, !0),
          te(He(this, $a), A, !0);
      }
      He(this, cs).current = !0;
    });
    Ir(this, "onpaste", (o) => {
      var K, ee, re, ue;
      const f = He(this, Ga).current;
      if (!f) return;
      const x = (ne) => {
          const Y = f.selectionStart === null ? void 0 : f.selectionStart,
            xe = f.selectionEnd === null ? void 0 : f.selectionEnd,
            Ie = Y !== xe,
            Ee = this.opts.value.current;
          return (
            Ie
              ? Ee.slice(0, Y) + ne + Ee.slice(xe)
              : Ee.slice(0, Y) + ne + Ee.slice(Y)
          ).slice(0, this.opts.maxLength.current);
        },
        A = (ne) =>
          ne.length > 0 && y(He(this, Ao)) && !y(He(this, Ao)).test(ne);
      if (
        !((K = this.opts.pasteTransformer) != null && K.current) &&
        (!He(this, Bc).isIOS || !o.clipboardData || !f)
      ) {
        const ne = x(
          (ee = o.clipboardData) == null ? void 0 : ee.getData("text/plain")
        );
        A(ne) && o.preventDefault();
        return;
      }
      const L =
          ((re = o.clipboardData) == null
            ? void 0
            : re.getData("text/plain")) ?? "",
        T =
          (ue = this.opts.pasteTransformer) != null && ue.current
            ? this.opts.pasteTransformer.current(L)
            : L;
      o.preventDefault();
      const s = x(T);
      if (A(s)) return;
      (f.value = s), (this.opts.value.current = s);
      const B = Math.min(s.length, this.opts.maxLength.current - 1),
        N = s.length;
      f.setSelectionRange(B, N),
        te(He(this, Fa), B, !0),
        te(He(this, $a), N, !0);
    });
    Ir(this, "onmouseover", (o) => {
      te(He(this, Rc), !0);
    });
    Ir(this, "onmouseleave", (o) => {
      te(He(this, Rc), !1);
    });
    Ir(this, "onblur", (o) => {
      if (y(He(this, us)).willSyntheticBlur) {
        y(He(this, us)).willSyntheticBlur = !1;
        return;
      }
      He(this, cs).current = !1;
    });
    Er(
      this,
      qh,
      ut(() => {
        var o;
        return {
          id: this.opts.inputId.current,
          style: y(He(this, qp)),
          autocomplete: this.opts.autocomplete.current || "one-time-code",
          "data-pin-input-input": "",
          "data-pin-input-input-mss": y(He(this, Fa)),
          "data-pin-input-input-mse": y(He(this, $a)),
          inputmode: this.opts.inputmode.current,
          pattern: (o = y(He(this, Ao))) == null ? void 0 : o.source,
          maxlength: this.opts.maxLength.current,
          value: this.opts.value.current,
          disabled: LE(this.opts.disabled.current),
          onpaste: this.onpaste,
          oninput: this.oninput,
          onkeydown: this.onkeydown,
          onmouseover: this.onmouseover,
          onmouseleave: this.onmouseleave,
          onfocus: this.onfocus,
          onblur: this.onblur,
          ...this.inputAttachment,
        };
      })
    );
    Er(
      this,
      Zp,
      ut(() =>
        Array.from({ length: this.opts.maxLength.current }).map((o, f) => {
          const x =
              He(this, cs).current &&
              y(He(this, Fa)) !== null &&
              y(He(this, $a)) !== null &&
              ((y(He(this, Fa)) === y(He(this, $a)) && f === y(He(this, Fa))) ||
                (f >= y(He(this, Fa)) && f < y(He(this, $a)))),
            A =
              this.opts.value.current[f] !== void 0
                ? this.opts.value.current[f]
                : null;
          return { char: A, isActive: x, hasFakeCaret: x && A === null };
        })
      )
    );
    Er(
      this,
      Uh,
      ut(() => ({
        cells: y(He(this, Zp)),
        isFocused: He(this, cs).current,
        isHovering: y(He(this, Rc)),
      }))
    );
    var f;
    (this.opts = o),
      (this.attachment = Wa(this.opts.ref)),
      (this.domContext = new zE(o.ref)),
      $i(this, Bc, {
        value: this.opts.value,
        isIOS:
          typeof window < "u" &&
          ((f = window == null ? void 0 : window.CSS) == null
            ? void 0
            : f.supports("-webkit-touch-callout", "none")),
      }),
      $i(
        this,
        Rs,
        E8({
          containerRef: this.opts.ref,
          inputRef: He(this, Ga),
          isFocused: He(this, cs),
          pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
          domContext: this.domContext,
        })
      ),
      Fn(() => {
        const x = He(this, Ga).current,
          A = this.opts.ref.current;
        if (!x || !A) return;
        He(this, Bc).value.current !== x.value &&
          (this.opts.value.current = x.value),
          (y(He(this, us)).prev = [
            x.selectionStart,
            x.selectionEnd,
            x.selectionDirection ?? "none",
          ]);
        const L = eh(
          this.domContext.getDocument(),
          "selectionchange",
          He(this, Vh),
          { capture: !0 }
        );
        He(this, Vh).call(this),
          this.domContext.getActiveElement() === x &&
            (He(this, cs).current = !0),
          this.domContext.getElementById("pin-input-style") ||
            Or(this, Up, Ty).call(this);
        const T = () => {
          A &&
            A.style.setProperty(
              "--bits-pin-input-root-height",
              `${x.clientHeight}px`
            );
        };
        T();
        const s = new ResizeObserver(T);
        return (
          s.observe(x),
          () => {
            L(), s.disconnect();
          }
        );
      }),
      xl([() => this.opts.value.current, () => He(this, Ga).current], () => {
        L8(() => {
          const x = He(this, Ga).current;
          if (!x) return;
          x.dispatchEvent(new Event("input"));
          const A = x.selectionStart,
            L = x.selectionEnd,
            T = x.selectionDirection ?? "none";
          A !== null &&
            L !== null &&
            (te(He(this, Fa), A, !0),
            te(He(this, $a), L, !0),
            (y(He(this, us)).prev = [A, L, T]));
        }, this.domContext);
      }),
      $r(() => {
        const x = this.opts.value.current,
          A = He(this, Fc).current,
          L = this.opts.maxLength.current,
          T = this.opts.onComplete.current;
        A !== void 0 && x !== A && A.length < L && x.length === L && T(x);
      });
  }
  static create(o) {
    return new Z_(o);
  }
  get rootProps() {
    return y(He(this, Nh));
  }
  set rootProps(o) {
    te(He(this, Nh), o);
  }
  get inputWrapperProps() {
    return y(He(this, jh));
  }
  set inputWrapperProps(o) {
    te(He(this, jh), o);
  }
  get inputProps() {
    return y(He(this, qh));
  }
  set inputProps(o) {
    te(He(this, qh), o);
  }
  get snippetProps() {
    return y(He(this, Uh));
  }
  set snippetProps(o) {
    te(He(this, Uh), o);
  }
};
(Ga = new WeakMap()),
  (Rc = new WeakMap()),
  (cs = new WeakMap()),
  (Fa = new WeakMap()),
  ($a = new WeakMap()),
  (Fc = new WeakMap()),
  (Ao = new WeakMap()),
  (us = new WeakMap()),
  (Rs = new WeakMap()),
  (Bc = new WeakMap()),
  (Vp = new WeakMap()),
  (Nh = new WeakMap()),
  (jh = new WeakMap()),
  (qp = new WeakMap()),
  (Up = new WeakSet()),
  (Ty = function () {
    const o = this.domContext.getDocument(),
      f = o.createElement("style");
    if (((f.id = "pin-input-style"), o.head.appendChild(f), f.sheet)) {
      const x =
        "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
      Hu(
        f.sheet,
        "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"
      ),
        Hu(f.sheet, `[data-pin-input-input]:autofill { ${x} }`),
        Hu(f.sheet, `[data-pin-input-input]:-webkit-autofill { ${x} }`),
        Hu(
          f.sheet,
          "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"
        ),
        Hu(
          f.sheet,
          "[data-pin-input-input] + * { pointer-events: all !important; }"
        );
    }
  }),
  (Vh = new WeakMap()),
  (qh = new WeakMap()),
  (Zp = new WeakMap()),
  (Uh = new WeakMap());
let Qm = Z_;
var Zh;
const G_ = class G_ {
  constructor(o) {
    Ir(this, "opts");
    Ir(this, "attachment");
    Er(
      this,
      Zh,
      ut(() => ({
        id: this.opts.id.current,
        [wy.cell]: "",
        "data-active": this.opts.cell.current.isActive ? "" : void 0,
        "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
        ...this.attachment,
      }))
    );
    (this.opts = o), (this.attachment = Wa(this.opts.ref));
  }
  static create(o) {
    return new G_(o);
  }
  get props() {
    return y(He(this, Zh));
  }
  set props(o) {
    te(He(this, Zh), o);
  }
};
Zh = new WeakMap();
let e_ = G_;
function L8(_, o) {
  const f = o.setTimeout(_, 0),
    x = o.setTimeout(_, 10),
    A = o.setTimeout(_, 50);
  return [f, x, A];
}
function Hu(_, o) {
  try {
    _.insertRule(o);
  } catch {
    console.error("pin input could not insert CSS rule:", o);
  }
}
var D8 = me("<div><!> <div><input/></div></div>");
function R8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "inputId", 19, () => `${Xa(f)}-input`),
    L = Et(o, "ref", 15, null),
    T = Et(o, "maxlength", 3, 6),
    s = Et(o, "textalign", 3, "left"),
    B = Et(o, "inputmode", 3, "numeric"),
    N = Et(o, "onComplete", 3, nh),
    K = Et(o, "pushPasswordManagerStrategy", 3, "increase-width"),
    ee = Et(o, "class", 3, ""),
    re = Et(o, "autocomplete", 3, "one-time-code"),
    ue = Et(o, "disabled", 3, !1),
    ne = Et(o, "value", 15, ""),
    Y = Et(o, "onValueChange", 3, nh),
    xe = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "inputId",
      "ref",
      "maxlength",
      "textalign",
      "pattern",
      "inputmode",
      "onComplete",
      "pushPasswordManagerStrategy",
      "class",
      "children",
      "autocomplete",
      "disabled",
      "value",
      "onValueChange",
      "pasteTransformer",
    ]);
  const Ie = Qm.create({
      id: Xr(() => x()),
      ref: Xr(
        () => L(),
        ($e) => L($e)
      ),
      inputId: Xr(() => A()),
      autocomplete: Xr(() => re()),
      maxLength: Xr(() => T()),
      textAlign: Xr(() => s()),
      disabled: Xr(() => ue()),
      inputmode: Xr(() => B()),
      pattern: Xr(() => o.pattern),
      onComplete: Xr(() => N()),
      value: Xr(
        () => ne(),
        ($e) => {
          ne($e), Y()($e);
        }
      ),
      pushPasswordManagerStrategy: Xr(() => K()),
      pasteTransformer: Xr(() => o.pasteTransformer),
    }),
    Ee = ut(() => Ba(xe, Ie.inputProps)),
    De = ut(() => Ba(Ie.rootProps, { class: ee() })),
    Ae = ut(() => Ba(Ie.inputWrapperProps, {}));
  var qe = D8();
  dr(qe, () => ({ ...y(De) }));
  var Ue = M(qe);
  si(
    Ue,
    () => o.children ?? sa,
    () => Ie.snippetProps
  );
  var Be = q(Ue, 2);
  dr(Be, () => ({ ...y(Ae) }));
  var ke = M(Be);
  dr(ke, () => ({ ...y(Ee) }), void 0, void 0, void 0, void 0, !0),
    P(Be),
    P(qe),
    G(_, qe),
    Rr();
}
var F8 = me("<div><!></div>");
function B8(_, o) {
  const f = _o();
  Dr(o, !0);
  let x = Et(o, "id", 19, () => Xa(f)),
    A = Et(o, "ref", 15, null),
    L = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "cell",
      "child",
      "children",
    ]);
  const T = e_.create({
      id: Xr(() => x()),
      ref: Xr(
        () => A(),
        (re) => A(re)
      ),
      cell: Xr(() => o.cell),
    }),
    s = ut(() => Ba(L, T.props));
  var B = Jt(),
    N = _t(B);
  {
    var K = (re) => {
        var ue = Jt(),
          ne = _t(ue);
        si(
          ne,
          () => o.child,
          () => ({ props: y(s) })
        ),
          G(re, ue);
      },
      ee = (re) => {
        var ue = F8();
        dr(ue, () => ({ ...y(s) }));
        var ne = M(ue);
        si(ne, () => o.children ?? sa), P(ue), G(re, ue);
      };
    Me(N, (re) => {
      o.child ? re(K) : re(ee, !1);
    });
  }
  G(_, B), Rr();
}
function Nc(..._) {
  return P0(Qu(_));
}
function O8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = Et(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var L = Jt(),
    T = _t(L);
  {
    let s = ut(() =>
      Nc(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        o.class
      )
    );
    Ti(
      T,
      () => n8,
      (B, N) => {
        N(
          B,
          Bs(
            {
              "data-slot": "command",
              get class() {
                return y(s);
              },
            },
            () => A,
            {
              get value() {
                return x();
              },
              set value(K) {
                x(K);
              },
              get ref() {
                return f();
              },
              set ref(K) {
                f(K);
              },
            }
          )
        );
      }
    );
  }
  G(_, L), Rr();
}
var N8 = Lr(
  '<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>'
);
function Os(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = N8();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
function j8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = _t(A);
  {
    let T = ut(() => Nc("py-6 text-center text-sm", o.class));
    Ti(
      L,
      () => a8,
      (s, B) => {
        B(
          s,
          Bs(
            {
              "data-slot": "command-empty",
              get class() {
                return y(T);
              },
            },
            () => x,
            {
              get ref() {
                return f();
              },
              set ref(N) {
                f(N);
              },
            }
          )
        );
      }
    );
  }
  G(_, A), Rr();
}
var V8 = me("<!> <!>", 1);
function q8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "class",
      "children",
      "heading",
      "value",
    ]);
  var A = Jt(),
    L = _t(A);
  {
    let T = ut(() => Nc("text-foreground overflow-hidden p-1", o.class)),
      s = ut(() => o.value ?? o.heading ?? `----${XE()}`);
    Ti(
      L,
      () => s8,
      (B, N) => {
        N(
          B,
          Bs(
            {
              "data-slot": "command-group",
              get class() {
                return y(T);
              },
              get value() {
                return y(s);
              },
            },
            () => x,
            {
              get ref() {
                return f();
              },
              set ref(K) {
                f(K);
              },
              children: (K, ee) => {
                var re = V8(),
                  ue = _t(re);
                {
                  var ne = (xe) => {
                    var Ie = Jt(),
                      Ee = _t(Ie);
                    Ti(
                      Ee,
                      () => c8,
                      (De, Ae) => {
                        Ae(De, {
                          class:
                            "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                          children: (qe, Ue) => {
                            yn();
                            var Be = ji();
                            Ne(() => le(Be, o.heading)), G(qe, Be);
                          },
                          $$slots: { default: !0 },
                        });
                      }
                    ),
                      G(xe, Ie);
                  };
                  Me(ue, (xe) => {
                    o.heading && xe(ne);
                  });
                }
                var Y = q(ue, 2);
                Ti(
                  Y,
                  () => d8,
                  (xe, Ie) => {
                    Ie(xe, {
                      get children() {
                        return o.children;
                      },
                    });
                  }
                ),
                  G(K, re);
              },
              $$slots: { default: !0 },
            }
          )
        );
      }
    );
  }
  G(_, A), Rr();
}
function U8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = _t(A);
  {
    let T = ut(() =>
      Nc(
        "aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        o.class
      )
    );
    Ti(
      L,
      () => g8,
      (s, B) => {
        B(
          s,
          Bs(
            {
              "data-slot": "command-item",
              get class() {
                return y(T);
              },
            },
            () => x,
            {
              get ref() {
                return f();
              },
              set ref(N) {
                f(N);
              },
            }
          )
        );
      }
    );
  }
  G(_, A), Rr();
}
var Z8 = Lr(
  '<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>'
);
function G8(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Z8();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var $8 = me(
  '<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>'
);
function H8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = Et(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var L = $8(),
    T = M(L);
  G8(T, { class: "size-5 opacity-50" });
  var s = q(T, 2);
  {
    let B = ut(() =>
      Nc(
        "placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50",
        o.class
      )
    );
    Ti(
      s,
      () => f8,
      (N, K) => {
        K(
          N,
          Bs(
            {
              "data-slot": "command-input",
              get class() {
                return y(B);
              },
            },
            () => A,
            {
              get ref() {
                return f();
              },
              set ref(ee) {
                f(ee);
              },
              get value() {
                return x();
              },
              set value(ee) {
                x(ee);
              },
            }
          )
        );
      }
    );
  }
  P(L), G(_, L), Rr();
}
function W8(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = _t(A);
  {
    let T = ut(() =>
      Nc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", o.class)
    );
    Ti(
      L,
      () => y8,
      (s, B) => {
        B(
          s,
          Bs(
            {
              "data-slot": "command-list",
              get class() {
                return y(T);
              },
            },
            () => x,
            {
              get ref() {
                return f();
              },
              set ref(N) {
                f(N);
              },
            }
          )
        );
      }
    );
  }
  G(_, A), Rr();
}
var X8 = Lr(
  '<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>'
);
function Y8(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = X8();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var K8 = me("<span> </span> <!>", 1),
  J8 = me('<span class="font-flag ml-0.5"> </span> ', 1),
  Q8 = me(
    '<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'
  ),
  ez = me("<!> <!>", 1),
  tz = me("<!> <!>", 1),
  rz = me('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  nz = me(
    '<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>'
  );
function Kv(_, o) {
  Dr(o, !0);
  let f = Et(o, "countryId", 15, 0),
    x = Et(o, "dropdownDirection", 3, "right"),
    A = Je(null),
    L = Je(null),
    T = Je("");
  function s() {
    g0().then(() => {
      var De;
      (De = document.activeElement) == null || De.blur(), te(T, "");
    });
  }
  var B = nz(),
    N = M(B),
    K = M(N),
    ee = M(K);
  {
    var re = (De) => {
        var Ae = K8(),
          qe = _t(Ae),
          Ue = M(qe, !0);
        P(qe);
        var Be = q(qe, 2);
        Y8(Be, { class: "size-3.5" }),
          Ne((ke) => le(Ue, ke), [() => __()]),
          G(De, Ae);
      },
      ue = (De) => {
        const Ae = ut(() => ko(f()));
        var qe = J8(),
          Ue = _t(qe),
          Be = M(Ue, !0);
        P(Ue);
        var ke = q(Ue);
        Ne(() => {
          le(Be, y(Ae).flag), le(ke, ` ${y(Ae).name ?? ""}`);
        }),
          G(De, qe);
      };
    Me(ee, (De) => {
      f() === 0 ? De(re) : De(ue, !1);
    });
  }
  P(K);
  var ne = q(K, 2);
  let Y;
  var xe = M(ne);
  Ti(
    xe,
    () => O8,
    (De, Ae) => {
      Ae(De, {
        children: (qe, Ue) => {
          var Be = tz(),
            ke = _t(Be);
          Ti(
            ke,
            () => H8,
            (Le, nt) => {
              nt(Le, {
                placeholder: "Country",
                get ref() {
                  return y(A);
                },
                set ref(dt) {
                  te(A, dt);
                },
                get value() {
                  return y(T);
                },
                set value(dt) {
                  te(T, dt, !0);
                },
              });
            }
          );
          var $e = q(ke, 2);
          Ti(
            $e,
            () => W8,
            (Le, nt) => {
              nt(Le, {
                children: (dt, je) => {
                  var Ge = ez(),
                    bt = _t(Ge);
                  Ti(
                    bt,
                    () => j8,
                    (Ve, Ke) => {
                      Ke(Ve, {
                        children: (Fe, ft) => {
                          yn();
                          var lt = ji();
                          Ne((yt) => le(lt, yt), [() => k5()]), G(Fe, lt);
                        },
                        $$slots: { default: !0 },
                      });
                    }
                  );
                  var Xe = q(bt, 2);
                  Ti(
                    Xe,
                    () => q8,
                    (Ve, Ke) => {
                      Ke(Ve, {
                        children: (Fe, ft) => {
                          var lt = Jt(),
                            yt = _t(lt);
                          oi(
                            yt,
                            17,
                            () => pa.countries,
                            (mt) => mt.id,
                            (mt, ct) => {
                              var qt = Jt(),
                                Ft = _t(qt);
                              Ti(
                                Ft,
                                () => U8,
                                (Ye, at) => {
                                  at(Ye, {
                                    get value() {
                                      return y(ct).name;
                                    },
                                    onSelect: () => {
                                      f(y(ct).id), s();
                                    },
                                    children: (xt, It) => {
                                      var Tt = Q8(),
                                        Mt = M(Tt),
                                        Wt = M(Mt, !0);
                                      P(Mt);
                                      var Bt = q(Mt);
                                      P(Tt),
                                        Ne(() => {
                                          le(Wt, y(ct).flag),
                                            le(Bt, ` ${y(ct).name ?? ""}`);
                                        }),
                                        G(xt, Tt);
                                    },
                                    $$slots: { default: !0 },
                                  });
                                }
                              ),
                                G(mt, qt);
                            }
                          ),
                            G(Fe, lt);
                        },
                        $$slots: { default: !0 },
                      });
                    }
                  ),
                    G(dt, Ge);
                },
                $$slots: { default: !0 },
              });
            }
          ),
            G(qe, Be);
        },
        $$slots: { default: !0 },
      });
    }
  ),
    P(ne),
    P(N);
  var Ie = q(N, 2);
  {
    var Ee = (De) => {
      var Ae = rz();
      Ae.__click = () => {
        f(0);
      };
      var qe = M(Ae);
      Os(qe, { class: "size-3.5" }), P(Ae), G(De, Ae);
    };
    Me(Ie, (De) => {
      f() != 0 && De(Ee);
    });
  }
  P(B),
    Eo(
      B,
      (De) => te(L, De),
      () => y(L)
    ),
    Ne(
      () =>
        (Y = Br(
          ne,
          1,
          "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm",
          null,
          Y,
          { "right-1": x() === "left" }
        ))
    ),
    Zn("focus", K, () => {
      y(A).focus();
    }),
    G(_, B),
    Rr();
}
Bn(["click"]);
var iz = Lr(
  '<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>'
);
function az(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = iz();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var oz = Lr(
    '<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'
  ),
  sz = Lr(
    '<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>'
  );
function ah(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        var B = oz();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      },
      T = (s) => {
        var B = sz();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      };
    Me(A, (s) => {
      o.filled ? s(L) : s(T, !1);
    });
  }
  G(_, x);
}
var lz = me(
    '<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'
  ),
  cz = me('<div class="mb-2"><!></div>'),
  uz = me(
    '<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
  ),
  hz = me(
    '<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'
  ),
  dz = me(
    '<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'
  ),
  pz = me(
    '<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
  ),
  fz = me(
    '<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'
  ),
  mz = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  _z = me("<span> </span>"),
  gz = me(
    '<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
  ),
  vz = me(
    '<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
  ),
  yz = me(
    '<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
  ),
  xz = me(
    '<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
  ),
  bz = me(
    '<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'
  ),
  wz = me(
    '<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>',
    1
  );
function Tz(_, o) {
  Dr(o, !0);
  const f = [];
  let x = Je(1e3);
  const A = ut(() => y(x) <= 640);
  let L = Je("today"),
    T = {
      regions: { label: jS(), icon: $p },
      countries: { label: US(), icon: az },
      players: { label: U0(), icon: ef },
      alliances: { label: Z0(), icon: tf },
    },
    s = Je("regions"),
    B = Je(0),
    N = Si({ players: {}, alliances: {}, regions: {}, countries: {} }),
    K = ut(() => {
      var Be, ke, $e;
      return y(s) === "regions"
        ? (ke = (Be = N[y(s)][y(B)]) == null ? void 0 : Be[y(L)]) == null
          ? void 0
          : ke.entries
        : ($e = N[y(s)][y(L)]) == null
        ? void 0
        : $e.entries;
    });
  const ee = 5 * 1e3;
  $r(() => {
    var Le;
    if (!o.open) return;
    const Be = y(L),
      ke = y(s),
      $e = y(B);
    ke === "players" && (!N[ke][Be] || Date.now() - N[ke][Be].time > ee)
      ? Jr.leaderboardPlayers(Be)
          .then((nt) => {
            N[ke][Be] = { time: Date.now(), entries: nt };
          })
          .catch((nt) => xr.error(nt.message))
      : ke === "alliances" && (!N[ke][Be] || Date.now() - N[ke][Be].time > ee)
      ? Jr.leaderboardAlliances(Be)
          .then((nt) => {
            N[ke][Be] = { time: Date.now(), entries: nt };
          })
          .catch((nt) => xr.error(nt.message))
      : ke === "countries" && (!N[ke][Be] || Date.now() - N[ke][Be].time > ee)
      ? Jr.leaderboardCountries(Be)
          .then((nt) => {
            N[ke][Be] = { time: Date.now(), entries: nt };
          })
          .catch((nt) => xr.error(nt.message))
      : ke === "regions" &&
        (!((Le = N[ke][$e]) != null && Le[Be]) ||
          Date.now() - N[ke][$e][Be].time > ee) &&
        Jr.leaderboardRegions(Be, $e)
          .then((nt) => {
            N[ke][$e] || (N[ke][$e] = {}),
              (N[ke][$e][Be] = { time: Date.now(), entries: nt });
          })
          .catch((nt) => xr.error(nt.message));
  });
  var re = wz(),
    ue = _t(re);
  oi(
    ue,
    21,
    () => Object.entries(T),
    ([Be, { label: ke, icon: $e }]) => Be,
    (Be, ke) => {
      var $e = ut(() => v0(y(ke), 2));
      let Le = () => y($e)[0],
        nt = () => y($e)[1].label,
        dt = () => y($e)[1].icon;
      const je = ut(dt);
      var Ge = lz(),
        bt = M(Ge);
      Oa(bt);
      var Xe,
        Ve = q(bt, 2);
      Ti(
        Ve,
        () => y(je),
        (Fe, ft) => {
          ft(Fe, {
            get this() {
              return dt();
            },
            class: "mr-1 size-5 max-sm:hidden",
          });
        }
      );
      var Ke = q(Ve);
      P(Ge),
        Ne(() => {
          gr(bt, "aria-label", nt()),
            Xe !== (Xe = Le()) && (bt.value = (bt.__value = Le()) ?? ""),
            le(Ke, ` ${nt() ?? ""}`);
        }),
        h_(
          f,
          [],
          bt,
          () => (Le(), y(s)),
          (Fe) => te(s, Fe)
        ),
        G(Be, Ge);
    }
  ),
    P(ue);
  var ne = q(ue, 2),
    Y = M(ne);
  T_(Y, {
    get value() {
      return y(L);
    },
    set value(Be) {
      te(L, Be, !0);
    },
  });
  var xe = q(Y, 2);
  {
    var Ie = (Be) => {
      Kv(Be, {
        dropdownDirection: "left",
        get countryId() {
          return y(B);
        },
        set countryId(ke) {
          te(B, ke, !0);
        },
      });
    };
    Me(xe, (Be) => {
      y(s) === "regions" && !y(A) && Be(Ie);
    });
  }
  P(ne);
  var Ee = q(ne, 2);
  {
    var De = (Be) => {
      var ke = cz(),
        $e = M(ke);
      Kv($e, {
        get countryId() {
          return y(B);
        },
        set countryId(Le) {
          te(B, Le, !0);
        },
      }),
        P(ke),
        G(Be, ke);
    };
    Me(Ee, (Be) => {
      y(s) === "regions" && y(A) && Be(De);
    });
  }
  var Ae = q(Ee, 2);
  {
    var qe = (Be) => {
        var ke = uz(),
          $e = M(ke),
          Le = q($e);
        {
          var nt = (je) => {
              var Ge = ji();
              Ne((bt) => le(Ge, bt), [() => Qp().toLowerCase()]), G(je, Ge);
            },
            dt = (je) => {
              var Ge = Jt(),
                bt = _t(Ge);
              {
                var Xe = (Ke) => {
                    var Fe = ji();
                    Ne((ft) => le(Fe, ft), [() => y_()]), G(Ke, Fe);
                  },
                  Ve = (Ke) => {
                    var Fe = Jt(),
                      ft = _t(Fe);
                    {
                      var lt = (yt) => {
                        var mt = ji();
                        Ne((ct) => le(mt, ct), [() => x_()]), G(yt, mt);
                      };
                      Me(
                        ft,
                        (yt) => {
                          y(L) === "month" && yt(lt);
                        },
                        !0
                      );
                    }
                    G(Ke, Fe);
                  };
                Me(
                  bt,
                  (Ke) => {
                    y(L) === "week" ? Ke(Xe) : Ke(Ve, !1);
                  },
                  !0
                );
              }
              G(je, Ge);
            };
          Me(Le, (je) => {
            y(L) === "today" ? je(nt) : je(dt, !1);
          });
        }
        P(ke), Ne((je) => le($e, `${je ?? ""} `), [() => v_()]), G(Be, ke);
      },
      Ue = (Be) => {
        var ke = Jt(),
          $e = _t(ke);
        {
          var Le = (dt) => {
              var je = Jt(),
                Ge = _t(je);
              {
                var bt = (Ve) => {
                    const Ke = ut(() => y(K));
                    var Fe = dz(),
                      ft = M(Fe),
                      lt = M(ft),
                      yt = q(M(lt)),
                      mt = M(yt, !0);
                    P(yt);
                    var ct = q(yt),
                      qt = M(ct),
                      Ft = q(qt, 2),
                      Ye = q(Ft),
                      at = M(Ye);
                    ah(at, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4",
                    }),
                      P(Ye),
                      P(ct),
                      yn(),
                      P(lt),
                      P(ft);
                    var xt = q(ft);
                    oi(
                      xt,
                      31,
                      () => y(Ke),
                      (It) => It.id,
                      (It, Tt, Mt) => {
                        const Wt = ut(() => ko(y(Tt).countryId));
                        var Bt = hz(),
                          Gt = M(Bt),
                          At = M(Gt, !0);
                        P(Gt);
                        var Xt = q(Gt),
                          Lt = M(Xt),
                          Nt = M(Lt, !0);
                        P(Lt);
                        var jt = q(Lt, 2),
                          mr = M(jt),
                          ir = q(mr),
                          vr = M(ir);
                        P(ir), P(jt), P(Xt);
                        var ar = q(Xt),
                          pr = M(ar, !0);
                        P(ar);
                        var tr = q(ar),
                          Dt = M(tr);
                        Dt.__click = () => {
                          o.onvisitclick({
                            lat: y(Tt).lastLatitude,
                            lng: y(Tt).lastLongitude,
                          });
                        };
                        var Sr = M(Dt, !0);
                        P(Dt),
                          P(tr),
                          P(Bt),
                          Ne(
                            (Te, O, E) => {
                              le(At, y(Mt) + 1),
                                gr(Lt, "data-tip", y(Wt).name),
                                le(Nt, y(Wt).flag),
                                Br(jt, 1, `font-semibold ${Te ?? ""}`),
                                le(mr, `${y(Tt).name ?? ""} `),
                                le(vr, `#${y(Tt).number ?? ""}`),
                                le(pr, O),
                                le(Sr, E);
                            },
                            [
                              () => Ni(y(Tt).cityId),
                              () => y(Tt).pixelsPainted.toLocaleString("en-US"),
                              () => Rb(),
                            ]
                          ),
                          _l(
                            Bt,
                            () => gl,
                            () => ({ duration: 200 })
                          ),
                          G(It, Bt);
                      }
                    ),
                      P(xt),
                      P(Fe),
                      Ne(
                        (It, Tt, Mt, Wt) => {
                          le(mt, It),
                            le(qt, `${Tt ?? ""} `),
                            le(Ft, `${Mt ?? ""} `),
                            gr(Ye, "data-tip", Wt);
                        },
                        [
                          () => YS(),
                          () => Mc(),
                          () => Ac().toLowerCase(),
                          () => nC(),
                        ]
                      ),
                      G(Ve, Fe);
                  },
                  Xe = (Ve) => {
                    var Ke = Jt(),
                      Fe = _t(Ke);
                    {
                      var ft = (yt) => {
                          var mt = fz(),
                            ct = M(mt),
                            qt = M(ct),
                            Ft = q(M(qt)),
                            Ye = M(Ft, !0);
                          P(Ft);
                          var at = q(Ft),
                            xt = M(at),
                            It = q(xt, 2),
                            Tt = q(It),
                            Mt = M(Tt);
                          ah(Mt, {
                            class:
                              "text-base-content/50 mb-0.5 ml-1 inline size-4",
                          }),
                            P(Tt),
                            P(at),
                            P(qt),
                            P(ct);
                          var Wt = q(ct);
                          oi(
                            Wt,
                            31,
                            () => y(K),
                            (Bt) => Bt.id,
                            (Bt, Gt, At) => {
                              const Xt = ut(
                                () =>
                                  ko(y(Gt).id) ?? {
                                    name: `Pais ID: ${y(Gt).id}`,
                                    flag: "üè≥Ô∏è",
                                    code: "XX",
                                  }
                              );
                              var Lt = pz(),
                                Nt = M(Lt),
                                jt = M(Nt, !0);
                              P(Nt);
                              var mr = q(Nt),
                                ir = M(mr),
                                vr = M(ir, !0);
                              P(ir);
                              var ar = q(ir, 2),
                                pr = M(ar, !0);
                              P(ar), P(mr);
                              var tr = q(mr),
                                Dt = M(tr, !0);
                              P(tr),
                                P(Lt),
                                Ne(
                                  (Sr, Te) => {
                                    le(jt, y(At) + 1),
                                      gr(ir, "data-tip", y(Xt).name),
                                      le(vr, y(Xt).flag),
                                      Br(ar, 1, `font-semibold ${Sr ?? ""}`),
                                      le(pr, y(Xt).name),
                                      le(Dt, Te);
                                  },
                                  [
                                    () => Ni(y(Gt).id),
                                    () =>
                                      y(Gt).pixelsPainted.toLocaleString(
                                        "en-US"
                                      ),
                                  ]
                                ),
                                _l(
                                  Lt,
                                  () => gl,
                                  () => ({ duration: 200 })
                                ),
                                G(Bt, Lt);
                            }
                          ),
                            P(Wt),
                            P(mt),
                            Ne(
                              (Bt, Gt, At, Xt) => {
                                le(Ye, Bt),
                                  le(xt, `${Gt ?? ""} `),
                                  le(It, `${At ?? ""} `),
                                  gr(Tt, "data-tip", Xt);
                              },
                              [
                                () => __(),
                                () => Mc(),
                                () => Ac().toLowerCase(),
                                () => LC(),
                              ]
                            ),
                            G(yt, mt);
                        },
                        lt = (yt) => {
                          var mt = Jt(),
                            ct = _t(mt);
                          {
                            var qt = (Ye) => {
                                const at = ut(() => y(K));
                                var xt = vz(),
                                  It = M(xt),
                                  Tt = M(It),
                                  Mt = q(M(Tt)),
                                  Wt = M(Mt, !0);
                                P(Mt);
                                var Bt = q(Mt),
                                  Gt = M(Bt),
                                  At = q(Gt, 2, !0);
                                P(Bt), P(Tt), P(It);
                                var Xt = q(It);
                                oi(
                                  Xt,
                                  31,
                                  () => y(at),
                                  (Lt) => Lt.id,
                                  (Lt, Nt, jt) => {
                                    const mr = ut(() => {
                                      var Ct;
                                      return (
                                        ((Ct = kt.data) == null
                                          ? void 0
                                          : Ct.id) === y(Nt).id
                                      );
                                    });
                                    var ir = gz();
                                    let vr;
                                    var ar = M(ir),
                                      pr = M(ar, !0);
                                    P(ar);
                                    var tr = q(ar),
                                      Dt = M(tr),
                                      Sr = M(Dt);
                                    mo(Sr, {
                                      class: "size-8 border sm:size-10",
                                      get userId() {
                                        return y(Nt).id;
                                      },
                                      get pictureUrl() {
                                        return y(Nt).picture;
                                      },
                                    });
                                    var Te = q(Sr, 2),
                                      O = M(Te),
                                      E = M(O),
                                      D = q(E),
                                      j = M(D);
                                    P(D), P(O);
                                    var H = q(O, 2);
                                    {
                                      var W = (Ct) => {
                                        const _e = ut(() =>
                                          ko(y(Nt).equippedFlag)
                                        );
                                        var Vt = Jt(),
                                          cr = _t(Vt);
                                        {
                                          var Ot = (ur) => {
                                            var Nr = mz(),
                                              Ur = M(Nr, !0);
                                            P(Nr),
                                              Ne(() => {
                                                gr(Nr, "data-tip", y(_e).name),
                                                  le(Ur, y(_e).flag);
                                              }),
                                              G(ur, Nr);
                                          };
                                          Me(cr, (ur) => {
                                            y(_e) && ur(Ot);
                                          });
                                        }
                                        G(Ct, Vt);
                                      };
                                      Me(H, (Ct) => {
                                        y(Nt).equippedFlag && Ct(W);
                                      });
                                    }
                                    var ce = q(H, 2);
                                    {
                                      var ge = (Ct) => {
                                        Hh(Ct, {
                                          get username() {
                                            return y(Nt).discord;
                                          },
                                          get id() {
                                            return y(Nt).discordId;
                                          },
                                        });
                                      };
                                      Me(ce, (Ct) => {
                                        y(Nt).discord && Ct(ge);
                                      });
                                    }
                                    var de = q(ce, 2);
                                    {
                                      var Se = (Ct) => {
                                        var _e = _z(),
                                          Vt = M(_e, !0);
                                        P(_e),
                                          Ne(
                                            (cr, Ot) => {
                                              Br(
                                                _e,
                                                1,
                                                `badge badge-sm ml-0.5 border-0 ${
                                                  cr ?? ""
                                                } ${Ot ?? ""}`
                                              ),
                                                le(Vt, y(Nt).allianceName);
                                            },
                                            [
                                              () => Wp(y(Nt).allianceId),
                                              () => Ni(y(Nt).allianceId),
                                            ]
                                          ),
                                          G(Ct, _e);
                                      };
                                      Me(de, (Ct) => {
                                        "allianceName" in y(Nt) &&
                                          y(Nt).allianceName &&
                                          Ct(Se);
                                      });
                                    }
                                    P(Te), P(Dt), P(tr);
                                    var We = q(tr),
                                      Ze = M(We, !0);
                                    P(We),
                                      P(ir),
                                      Ne(
                                        (Ct, _e) => {
                                          (vr = Br(ir, 1, "", null, vr, {
                                            "bg-base-200": y(mr),
                                          })),
                                            le(pr, y(jt) + 1),
                                            Br(
                                              O,
                                              1,
                                              `font-semibold max-sm:ml-2 ${
                                                Ct ?? ""
                                              } flex gap-1`
                                            ),
                                            le(E, `${y(Nt).name ?? ""} `),
                                            le(j, `#${y(Nt).id ?? ""}`),
                                            le(Ze, _e);
                                        },
                                        [
                                          () => Ni(y(Nt).id),
                                          () =>
                                            y(Nt).pixelsPainted.toLocaleString(
                                              "en-US"
                                            ),
                                        ]
                                      ),
                                      _l(
                                        ir,
                                        () => gl,
                                        () => ({ duration: 200 })
                                      ),
                                      G(Lt, ir);
                                  }
                                ),
                                  P(Xt),
                                  P(xt),
                                  Ne(
                                    (Lt, Nt, jt) => {
                                      le(Wt, Lt),
                                        le(Gt, `${Nt ?? ""} `),
                                        le(At, jt);
                                    },
                                    [
                                      () => d_(),
                                      () => Mc(),
                                      () => Ac().toLowerCase(),
                                    ]
                                  ),
                                  G(Ye, xt);
                              },
                              Ft = (Ye) => {
                                var at = Jt(),
                                  xt = _t(at);
                                {
                                  var It = (Tt) => {
                                    var Mt = xz(),
                                      Wt = M(Mt),
                                      Bt = M(Wt),
                                      Gt = q(M(Bt)),
                                      At = M(Gt, !0);
                                    P(Gt);
                                    var Xt = q(Gt),
                                      Lt = M(Xt),
                                      Nt = q(Lt, 2, !0);
                                    P(Xt), P(Bt), P(Wt);
                                    var jt = q(Wt);
                                    oi(
                                      jt,
                                      31,
                                      () => y(K),
                                      (mr) => mr.id,
                                      (mr, ir, vr) => {
                                        const ar = ut(() => {
                                          var H;
                                          return (
                                            ((H = kt.data) == null
                                              ? void 0
                                              : H.allianceId) === y(ir).id
                                          );
                                        });
                                        var pr = yz();
                                        let tr;
                                        var Dt = M(pr),
                                          Sr = M(Dt, !0);
                                        P(Dt);
                                        var Te = q(Dt),
                                          O = M(Te),
                                          E = M(O, !0);
                                        P(O), P(Te);
                                        var D = q(Te),
                                          j = M(D, !0);
                                        P(D),
                                          P(pr),
                                          Ne(
                                            (H, W) => {
                                              (tr = Br(pr, 1, "", null, tr, {
                                                "bg-base-200": y(ar),
                                              })),
                                                le(Sr, y(vr) + 1),
                                                Br(
                                                  O,
                                                  1,
                                                  `font-semibold ${H ?? ""}`
                                                ),
                                                le(E, y(ir).name),
                                                le(j, W);
                                            },
                                            [
                                              () => Ni(y(ir).id),
                                              () =>
                                                y(
                                                  ir
                                                ).pixelsPainted.toLocaleString(
                                                  "en-US"
                                                ),
                                            ]
                                          ),
                                          _l(
                                            pr,
                                            () => gl,
                                            () => ({ duration: 200 })
                                          ),
                                          G(mr, pr);
                                      }
                                    ),
                                      P(jt),
                                      P(Mt),
                                      Ne(
                                        (mr, ir, vr) => {
                                          le(At, mr),
                                            le(Lt, `${ir ?? ""} `),
                                            le(Nt, vr);
                                        },
                                        [
                                          () => Kp(),
                                          () => Mc(),
                                          () => Ac().toLowerCase(),
                                        ]
                                      ),
                                      G(Tt, Mt);
                                  };
                                  Me(
                                    xt,
                                    (Tt) => {
                                      y(s) === "alliances" && Tt(It);
                                    },
                                    !0
                                  );
                                }
                                G(Ye, at);
                              };
                            Me(
                              ct,
                              (Ye) => {
                                y(s) === "players" ? Ye(qt) : Ye(Ft, !1);
                              },
                              !0
                            );
                          }
                          G(yt, mt);
                        };
                      Me(
                        Fe,
                        (yt) => {
                          y(s) === "countries" ? yt(ft) : yt(lt, !1);
                        },
                        !0
                      );
                    }
                    G(Ve, Ke);
                  };
                Me(Ge, (Ve) => {
                  y(s) === "regions" ? Ve(bt) : Ve(Xe, !1);
                });
              }
              G(dt, je);
            },
            nt = (dt) => {
              var je = bz();
              G(dt, je);
            };
          Me(
            $e,
            (dt) => {
              y(K) ? dt(Le) : dt(nt, !1);
            },
            !0
          );
        }
        G(Be, ke);
      };
    Me(Ae, (Be) => {
      y(K) && y(K).length === 0 ? Be(qe) : Be(Ue, !1);
    });
  }
  Yp("innerWidth", (Be) => te(x, Be, !0)), G(_, re), Rr();
}
Bn(["click"]);
var Sz = Lr(
  '<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>'
);
function Sy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Sz();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var Cz = me(
  '<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function Pz(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const ee = (re) => {
      re.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", ee),
      () => document.removeEventListener("keydown", ee)
    );
  });
  var x = Cz(),
    A = M(x),
    L = q(M(A), 2),
    T = M(L);
  Sy(T, { class: "size-6" });
  var s = q(T, 2),
    B = M(s, !0);
  P(s), P(L);
  var N = q(L, 2),
    K = M(N);
  Tz(K, {
    get onvisitclick() {
      return o.onvisitclick;
    },
    get open() {
      return f();
    },
  }),
    P(N),
    P(A),
    yn(2),
    P(x),
    yi(x, () => (ee) => {
      $r(() => {
        f() ? ee.show() : ee.close();
      });
    }),
    Ne((ee) => le(B, ee), [() => m_()]),
    Zn("close", x, () => f(!1)),
    G(_, x),
    Rr();
}
var Iz = me("<div><!></div>"),
  Mz = me(
    '<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function Az(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  Fn(() => {
    const s = (B) => {
      B.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", s),
      () => document.removeEventListener("keydown", s)
    );
  });
  var x = Mz(),
    A = M(x),
    L = q(M(A), 2);
  {
    var T = (s) => {
      var B = Iz(),
        N = M(B);
      Ub(N, {}),
        P(B),
        oa(
          2,
          B,
          () => Ha,
          () => ({ duration: 300 })
        ),
        G(s, B);
    };
    Me(L, (s) => {
      f() && s(T);
    });
  }
  P(A),
    yn(2),
    P(x),
    yi(x, () => (s) => {
      $r(() => {
        f() ? s.show() : s.close();
      });
    }),
    Zn("close", x, () => f(!1)),
    G(_, x),
    Rr();
}
var kz = me("<p>You don't have charges to paint. <br/> </p>");
function Ez(_, o) {
  Dr(o, !1), D0();
  var f = kz(),
    x = q(M(f), 2);
  P(f),
    Ne(
      (A) => le(x, ` Next charge in ${A ?? ""}`),
      [() => Lp(kt.cooldown ?? 0)]
    ),
    G(_, f),
    Rr();
}
var zz = me(
    '<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form>'
  ),
  Lz = me(
    '<form method="dialog" class="modal-backdrop"><button> </button></form>'
  ),
  Dz = me("<dialog><div><!> <!></div> <!></dialog>");
function M_(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Et(o, "hasBackdrop", 3, !0),
    A = Et(o, "hasCloseButton", 3, !0);
  var L = Dz(),
    T = M(L),
    s = M(T);
  {
    var B = (re) => {
      var ue = zz();
      G(re, ue);
    };
    Me(s, (re) => {
      A() && re(B);
    });
  }
  var N = q(s, 2);
  si(N, () => o.children ?? sa), P(T);
  var K = q(T, 2);
  {
    var ee = (re) => {
      var ue = Lz(),
        ne = M(ue),
        Y = M(ne, !0);
      P(ne), P(ue), Ne((xe) => le(Y, xe), [() => ds()]), G(re, ue);
    };
    Me(K, (re) => {
      x() && re(ee);
    });
  }
  P(L),
    yi(L, () => (re) => {
      $r(() => {
        f() ? re.show() : re.close();
      });
    }),
    Ne(() => {
      Br(L, 1, `modal ${o.dialogClass ?? ""}`),
        Br(T, 1, `modal-box ${o.modalBoxClass ?? ""}`);
    }),
    Zn("close", L, () => f(!1)),
    G(_, L),
    Rr();
}
var Rz = me(
  '<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>'
);
function Fz(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Et(o, "buttonText", 3, "OK");
  M_(_, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return f();
    },
    set open(A) {
      f(A);
    },
    children: (A, L) => {
      var T = Rz(),
        s = M(T),
        B = M(s, !0);
      P(s);
      var N = q(s, 2),
        K = M(N);
      si(K, () => o.message), P(N);
      var ee = q(N, 2);
      ee.__click = () => {
        f(!1);
      };
      var re = M(ee, !0);
      P(ee),
        P(T),
        Ne(() => {
          le(B, o.title), le(re, x());
        }),
        G(A, T);
    },
    $$slots: { default: !0 },
  }),
    Rr();
}
Bn(["click"]);
function Bz(_) {
  const o = new Date();
  return _.getDate() === o.getDate() &&
    _.getMonth() === o.getMonth() &&
    _.getFullYear() === o.getFullYear()
    ? _.toLocaleTimeString(void 0, { timeStyle: "short" })
    : _.toLocaleDateString(void 0, { dateStyle: "medium" });
}
var Oz = me('<span class="size-2 rounded-full bg-red-400"></span>'),
  Nz = me(
    '<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>'
  );
function jz(_, o) {
  Dr(o, !0);
  let f = Et(o, "read", 15);
  var x = Nz();
  x.__click = () => {
    f(!0), o.onclick();
  };
  var A = M(x),
    L = M(A);
  si(L, () => o.icon), P(A);
  var T = q(A, 2),
    s = M(T),
    B = M(s),
    N = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee, !0);
  P(ee);
  var ue = q(ee, 2);
  {
    var ne = (Ie) => {
      var Ee = Oz();
      G(Ie, Ee);
    };
    Me(ue, (Ie) => {
      f() || Ie(ne);
    });
  }
  P(K), P(s);
  var Y = q(s, 2),
    xe = M(Y, !0);
  P(Y),
    P(T),
    P(x),
    Ne(
      (Ie) => {
        le(N, o.title), le(re, Ie), le(xe, o.message);
      },
      [() => Bz(o.createdAt)]
    ),
    G(_, x),
    Rr();
}
Bn(["click"]);
var Vz = Lr(
  '<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>'
);
function qz(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Vz();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var Uz = me('<button class="btn btn-sm btn-ghost"> </button>'),
  Zz = me('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  Gz = me("<!> <!>", 1),
  $z = me(
    '<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'
  ),
  Hz = me(
    '<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>',
    1
  ),
  Wz = me("<p> </p>"),
  Xz = me("<!> <!>", 1);
function Yz(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(!1),
    A = Je(void 0),
    L = Je(void 0),
    T = Je(!1);
  var s = Xz(),
    B = _t(s);
  M_(B, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return f();
    },
    set open(K) {
      f(K);
    },
    children: (K, ee) => {
      var re = Hz(),
        ue = _t(re),
        ne = M(ue),
        Y = M(ne, !0);
      P(ne);
      var xe = q(ne, 2);
      {
        var Ie = (Be) => {
          var ke = Uz();
          ke.__click = async () => {
            if (
              (Jr.postNotificationMarkReadAll(),
              (kt.notificiationCount = 0),
              y(A))
            )
              for (const Le of y(A)) Le.read = !0;
          };
          var $e = M(ke, !0);
          P(ke), Ne((Le) => le($e, Le), [() => jM()]), G(Be, ke);
        };
        Me(xe, (Be) => {
          kt.notificiationCount !== 0 && Be(Ie);
        });
      }
      P(ue);
      var Ee = q(ue, 2),
        De = M(Ee);
      {
        var Ae = (Be) => {
          var ke = Gz(),
            $e = _t(ke);
          oi(
            $e,
            17,
            () => y(A),
            (dt) => dt.id,
            (dt, je, Ge) => {
              var bt = Jt(),
                Xe = _t(bt);
              {
                var Ve = (Ke) => {
                  {
                    const Fe = (mt) => {
                      qz(mt, { class: "size-5" });
                    };
                    let ft = ut(() => Fv()),
                      lt = ut(() => Bv()),
                      yt = ut(() => new Date(y(je).createdAt));
                    jz(Ke, {
                      get title() {
                        return y(ft);
                      },
                      get message() {
                        return y(lt);
                      },
                      get createdAt() {
                        return y(yt);
                      },
                      onclick: () => {
                        te(T, !0);
                      },
                      get read() {
                        return y(je).read;
                      },
                      set read(mt) {
                        y(je).read = mt;
                      },
                      icon: Fe,
                      $$slots: { icon: !0 },
                    });
                  }
                };
                Me(Xe, (Ke) => {
                  y(je).type === "report_feedback" && Ke(Ve);
                });
              }
              G(dt, bt);
            }
          );
          var Le = q($e, 2);
          {
            var nt = (dt) => {
              var je = Zz(),
                Ge = M(je, !0);
              P(je), Ne((bt) => le(Ge, bt), [() => kM()]), G(dt, je);
            };
            Me(Le, (dt) => {
              y(A).length === 0 && !y(x) && dt(nt);
            });
          }
          G(Be, ke);
        };
        Me(De, (Be) => {
          y(A) && Be(Ae);
        });
      }
      var qe = q(De, 2);
      {
        var Ue = (Be) => {
          var ke = $z();
          yi(ke, () => ($e) => {
            const Le = new IntersectionObserver((nt) => {
              nt[0].isIntersecting &&
                !y(x) &&
                (te(x, !0),
                Jr.getNotificationPage(y(L))
                  .then((dt) => {
                    te(A, [...(y(A) ?? []), ...dt.notifications], !0),
                      te(L, dt.nextCursor, !0);
                    const je = dt.notifications
                      .filter((Ge) => !Ge.read)
                      .map((Ge) => Ge.id);
                    je.length > 0 &&
                      (Jr.postNotificationMarkRead(je),
                      kt.notificiationCount &&
                        (kt.notificiationCount = Math.max(
                          0,
                          je.length - je.length
                        )));
                  })
                  .catch((dt) => {
                    xr.error(dt.message);
                  })
                  .finally(() => {
                    te(x, !1);
                  }));
            });
            return (
              Le.observe($e),
              () => {
                Le.disconnect();
              }
            );
          }),
            G(Be, ke);
        };
        Me(qe, (Be) => {
          f() && (y(A) === void 0 || y(L) !== void 0) && Be(Ue);
        });
      }
      P(Ee), Ne((Be) => le(Y, Be), [() => X0()]), G(K, re);
    },
    $$slots: { default: !0 },
  });
  var N = q(B, 2);
  {
    const K = (re) => {
      var ue = Wz(),
        ne = M(ue);
      P(ue),
        Ne(
          (Y, xe) => le(ne, `${Y ?? ""} ${xe ?? ""}`),
          [() => Bv(), () => BM()]
        ),
        G(re, ue);
    };
    let ee = ut(() => Fv());
    Fz(N, {
      get title() {
        return y(ee);
      },
      get open() {
        return y(T);
      },
      set open(re) {
        te(T, re, !0);
      },
      message: K,
      $$slots: { message: !0 },
    });
  }
  G(_, s), Rr();
}
Bn(["click"]);
var Kz = me("<canvas></canvas>");
function Cy(_, o) {
  Dr(o, !0);
  let f = Et(o, "width", 15, 0),
    x = lr(o, [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "fontSize",
      "color",
      "weight",
      "mono",
      "width",
    ]),
    A = ut(() => Math.ceil(o.fontSize)),
    L = Je(null);
  const T = window.devicePixelRatio ?? 1,
    s =
      '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    B =
      '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  $r(() => {
    const K = y(L).getContext("2d");
    (K.textBaseline = "top"),
      (K.font = `${o.weight ?? "normal"} ${o.fontSize}px ${o.mono ? B : s}`),
      (K.fillStyle = o.color ?? "#394e6a"),
      K.setTransform(T, 0, 0, T, 0, 0),
      K.clearRect(0, 0, f(), y(A)),
      K.fillText(o.value, 0, 0);
    const ee = K.measureText(o.value);
    f(Math.ceil(ee.actualBoundingBoxRight)), te(A, ee.actualBoundingBoxDescent);
  });
  var N = Kz();
  dr(N, () => ({
    width: f() * T,
    height: y(A) * T,
    style: `width: ${f() ?? ""}px; height: ${y(A) ?? ""}px`,
    ...x,
  })),
    Eo(
      N,
      (K) => te(L, K),
      () => y(L)
    ),
    G(_, N),
    Rr();
}
var Jz = me('<span class="w-7 text-xs"> </span>'),
  Qz = me(
    '<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'
  ),
  eL = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  tL = me(
    '<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>'
  );
function Py(_, o) {
  Dr(o, !0);
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    x = Je(0);
  var A = tL();
  dr(A, () => ({
    ...f,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${o.class ?? ""}`,
  }));
  var L = M(A);
  Wh(L, { class: "size-6" });
  var T = q(L, 2),
    s = M(T),
    B = q(s);
  {
    var N = (re) => {
      const ue = ut(() => `${Math.floor(o.charges)}/${kt.data.charges.max}`);
      var ne = Qz(),
        Y = M(ne),
        xe = M(Y);
      {
        let De = ut(() => (o.disabled ? "#394e6a33" : "#ffffff"));
        Cy(xe, {
          weight: 600,
          fontSize: 16,
          get value() {
            return y(ue);
          },
          get color() {
            return y(De);
          },
          get width() {
            return y(x);
          },
          set width(Ae) {
            te(x, Ae, !0);
          },
        });
      }
      P(Y);
      var Ie = q(Y, 2);
      {
        var Ee = (De) => {
          var Ae = Jz(),
            qe = M(Ae);
          P(Ae),
            Ne((Ue) => le(qe, `(${Ue ?? ""})`), [() => Lp(kt.cooldown)]),
            G(De, Ae);
        };
        Me(Ie, (De) => {
          o.charges < kt.data.charges.max && kt.cooldown !== void 0 && De(Ee);
        });
      }
      P(ne),
        Ne(
          (De) => Oc(Y, `width: ${De ?? ""}px`),
          [() => (Math.floor(y(x) / 5) + 1) * 5]
        ),
        G(re, ne);
    };
    Me(B, (re) => {
      o.charges !== void 0 && kt.data && re(N);
    });
  }
  P(T);
  var K = q(T, 2);
  {
    var ee = (re) => {
      var ue = eL();
      G(re, ue);
    };
    Me(K, (re) => {
      o.loading && re(ee);
    });
  }
  P(A), Ne((re) => le(s, `${re ?? ""} `), [() => j0()]), G(_, A), Rr();
}
const rL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  nL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  iL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  aL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class oL {
  constructor(o) {
    Ir(this, "gm");
    Ir(this, "opacity", 1);
    Ir(this, "id", `paint-preview-${Math.random()}`);
    Ir(this, "tiles", new Map());
    (this.input = o), (this.gm = new ps(this.input.tileSize));
  }
  place([o, f], x) {
    const { tile: A, pixel: L } = this.gm.latLonToTileAndPixel(
        o,
        f,
        this.input.tileZoom
      ),
      T = this.getTileKey(A[0], A[1]);
    let s = this.tiles.get(T);
    if (!s) {
      const B = this.gm.tileBoundsLatLon(A[0], A[1], this.input.tileZoom),
        N = b_(B, !0),
        K = new sL({
          coordinates: N,
          id: `${this.id}-${T}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest",
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId,
        });
      K.addTo(this.input.map), this.tiles.set(T, K), (s = K);
    }
    s.place(L[0], this.input.tileSize - L[1] - 1, x);
  }
  clear() {
    const o = this.input.map;
    for (const f of this.tiles.values()) f.removeFrom(o), f.removeDOM();
    this.tiles.clear();
  }
  clearAndPlace(o, f) {
    this.clear(), this.place(o, f);
  }
  remove([o, f]) {
    const { tile: x, pixel: A } = this.gm.latLonToTileAndPixel(
        o,
        f,
        this.input.tileZoom
      ),
      L = this.getTileKey(x[0], x[1]),
      T = this.tiles.get(L);
    T && T.remove(A[0], this.input.tileSize - A[1] - 1);
  }
  setCanvasOpacity(o) {
    this.opacity = o;
    for (const f of this.tiles.values()) f.setOpacity(o);
  }
  getTileKey(o, f) {
    return `${o},${f}`;
  }
}
class sL {
  constructor(o) {
    Ir(this, "canvas");
    Ir(this, "maps", new Set());
    this.input = o;
    const f = this.input.tileSize;
    (this.canvas = document.createElement("canvas")),
      (this.canvas.width = f),
      (this.canvas.height = f);
  }
  place(o, f, x) {
    var T;
    const A = ((T = pa.colors) == null ? void 0 : T[x]) ?? pa.colors[0],
      L = this.canvas.getContext("2d");
    if (L) {
      const s = L.createImageData(1, 1),
        [B, N, K] = A.rgb,
        ee = x === 0 ? 0 : 255;
      (s.data[0] = B),
        (s.data[1] = N),
        (s.data[2] = K),
        (s.data[3] = ee),
        L.putImageData(s, o, f);
    }
  }
  remove(o, f) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(o, f, 1, 1);
  }
  addTo(o) {
    const f = this.input.id;
    o.getSource(f) ||
      o.addSource(f, {
        type: "canvas",
        canvas: this.canvas,
        coordinates: this.input.coordinates,
      }),
      o.getLayer(f) ||
        (o.addLayer({
          id: f,
          type: "raster",
          source: f,
          paint: this.input.layerPaint,
        }),
        this.input.beforeLayerId && o.moveLayer(f, this.input.beforeLayerId)),
      this.maps.add(o);
  }
  removeFrom(o) {
    const { id: f } = this.input;
    o.getLayer(f) && o.removeLayer(f),
      o.getSource(f) && o.removeSource(f),
      this.maps.delete(o);
  }
  removeDOM() {
    this.canvas.remove();
  }
  setOpacity(o) {
    for (const f of this.maps.values())
      f.setPaintProperty(this.input.id, "raster-opacity", o);
  }
}
var lL = Lr(
  '<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>'
);
function cL(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = lL();
  dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f,
  })),
    G(_, x);
}
var uL = Lr(
  '<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>'
);
function hL(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = uL();
  dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f,
  })),
    G(_, x);
}
var dL = me("<div><!></div>");
function pl(_, o) {
  Dr(o, !0);
  var f = dL(),
    x = M(f);
  si(x, () => o.children ?? sa),
    P(f),
    Ne(() =>
      Br(
        f,
        1,
        `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${
          o.class ?? ""
        }`
      )
    ),
    G(_, f),
    Rr();
}
var pL = me('<div class="confetti svelte-av71ki"></div>'),
  fL = me("<div></div>");
function A_(_, o) {
  Dr(o, !0);
  const f = Et(o, "size", 3, 10),
    x = Et(o, "x", 19, () => [-0.5, 0.5]),
    A = Et(o, "y", 19, () => [0.25, 1]),
    L = Et(o, "duration", 3, 2e3),
    T = Et(o, "infinite", 3, !1),
    s = Et(o, "delay", 19, () => [0, 50]),
    B = Et(o, "colorRange", 19, () => [0, 360]),
    N = Et(o, "colorArray", 19, () => []),
    K = Et(o, "amount", 3, 50),
    ee = Et(o, "iterationCount", 3, 1),
    re = Et(o, "fallDistance", 3, "100px"),
    ue = Et(o, "rounded", 3, !1),
    ne = Et(o, "cone", 3, !1),
    Y = Et(o, "noGravity", 3, !1),
    xe = Et(o, "xSpread", 3, 0.15),
    Ie = Et(o, "destroyOnComplete", 3, !0),
    Ee = Et(o, "disableForReducedMotion", 3, !1);
  let De = Je(!1);
  Fn(() => {
    !Ie() ||
      T() ||
      typeof ee() == "string" ||
      setTimeout(() => te(De, !0), (L() + s()[1]) * ee());
  });
  function Ae($e, Le) {
    return Math.random() * (Le - $e) + $e;
  }
  function qe() {
    return N().length
      ? N()[Math.round(Math.random() * (N().length - 1))]
      : `hsl(${Math.round(Ae(B()[0], B()[1]))}, 75%, 50%)`;
  }
  var Ue = Jt(),
    Be = _t(Ue);
  {
    var ke = ($e) => {
      var Le = fL();
      let nt;
      oi(
        Le,
        21,
        () => ({ length: K() }),
        Hp,
        (dt, je) => {
          var Ge = pL();
          Ne(
            (bt, Xe, Ve, Ke, Fe, ft, lt, yt, mt, ct, qt) =>
              Oc(
                Ge,
                `
        --color: ${bt ?? ""};
        --skew: ${Xe ?? ""}deg,${Ve ?? ""}deg;
        --rotation-xyz: ${Ke ?? ""}, ${Fe ?? ""}, ${ft ?? ""};
        --rotation-deg: ${lt ?? ""}deg;
        --translate-y-multiplier: ${yt ?? ""};
        --translate-x-multiplier: ${mt ?? ""};
        --scale: ${ct ?? ""};
        --transition-delay: ${qt ?? ""}ms;
        --transition-duration: ${
          T() ? `calc(${L()}ms * var(--scale))` : `${L()}ms`
        };`
              ),
            [
              qe,
              () => Ae(-45, 45),
              () => Ae(-45, 45),
              () => Ae(-10, 10),
              () => Ae(-10, 10),
              () => Ae(-10, 10),
              () => Ae(0, 360),
              () => Ae(A()[0], A()[1]),
              () => Ae(x()[0], x()[1]),
              () => 0.1 * Ae(2, 10),
              () => Ae(s()[0], s()[1]),
            ]
          ),
            G(dt, Ge);
        }
      ),
        P(Le),
        Ne(() => {
          (nt = Br(Le, 1, "confetti-holder svelte-av71ki", null, nt, {
            rounded: ue(),
            cone: ne(),
            "no-gravity": Y(),
            "reduced-motion": Ee(),
          })),
            Oc(
              Le,
              `
    --fall-distance: ${re() ?? ""};
    --size: ${f() ?? ""}px;
    --x-spread: ${1 - xe()};
    --transition-iteration-count: ${(T() ? "infinite" : ee()) ?? ""};`
            );
        }),
        G($e, Le);
    };
    Me(Be, ($e) => {
      y(De) || $e(ke);
    });
  }
  G(_, Ue), Rr();
}
var mL = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  _L = me('<!> <span class="text-sm">Droplets</span>', 1),
  gL = me('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  vL = me(
    '<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'
  ),
  yL = me(
    '<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function xL(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  const x = ut(() => pa.colors[o.colorIdx]),
    A = ut(() => {
      var ue;
      return ((ue = kt.data) == null ? void 0 : ue.droplets) ?? 0;
    });
  let L = Je(!1);
  const T = ut(() => (y(L), kt.hasColor(o.colorIdx)));
  Fn(() => {
    const ue = (ne) => {
      ne.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", ue),
      () => document.removeEventListener("keydown", ue)
    );
  });
  const s = 100,
    B = pa.products[s];
  var N = yL(),
    K = M(N),
    ee = q(M(K), 2);
  {
    var re = (ue) => {
      var ne = vL(),
        Y = M(ne),
        xe = M(Y),
        Ie = M(xe);
      Dp(Ie, { class: "size-6" });
      var Ee = q(Ie, 4),
        De = M(Ee);
      z0(De, {
        get value() {
          return y(A);
        },
      }),
        P(Ee),
        P(xe),
        yn(2),
        P(Y);
      var Ae = q(Y, 2),
        qe = M(Ae),
        Ue = M(qe);
      P(qe);
      var Be = q(qe, 2),
        ke = M(Be, !0);
      P(Be);
      var $e = q(Be, 2),
        Le = M($e);
      let nt;
      var dt = M(Le);
      dt.__click = async () => {
        try {
          te(L, !0),
            await Jr.purchase({ id: s, amount: 1, variant: o.colorIdx }),
            await kt.refresh(),
            Oi.notification1.play();
        } catch (Fe) {
          xr.error(Fe.message);
        } finally {
          te(L, !1);
        }
      };
      var je = M(dt);
      {
        var Ge = (Fe) => {
          var ft = mL();
          G(Fe, ft);
        };
        Me(je, (Fe) => {
          y(L) && Fe(Ge);
        });
      }
      var bt = q(je, 2);
      {
        var Xe = (Fe) => {
            var ft = _L(),
              lt = _t(ft);
            Xp(lt, { class: "size-5" });
            var yt = q(lt);
            yn(),
              Ne(
                (mt) => le(yt, ` ${mt ?? ""} `),
                [() => B.price.toLocaleString("en-US")]
              ),
              G(Fe, ft);
          },
          Ve = (Fe) => {
            var ft = gL(),
              lt = _t(ft);
            Dp(lt, { class: "size-5" });
            var yt = q(lt, 2),
              mt = M(yt);
            A_(mt, {}), P(yt), G(Fe, ft);
          };
        Me(bt, (Fe) => {
          y(T) ? Fe(Ve, !1) : Fe(Xe);
        });
      }
      P(dt), P(Le);
      var Ke = q(Le, 2);
      (Ke.__click = () => f(!1)),
        P($e),
        P(Ae),
        P(ne),
        Ne(
          (Fe) => {
            Oc(
              Ue,
              `background: rgb(${y(x).rgb[0]} ${y(x).rgb[1]} ${y(x).rgb[2]})`
            ),
              gr(Ue, "aria-label", y(x).name),
              le(ke, y(x).name),
              gr(Le, "data-tip", Fe),
              (nt = Br(Le, 1, "", null, nt, {
                tooltip: !y(T) && y(A) < B.price,
              })),
              (dt.disabled = y(A) < B.price || y(L) || y(T));
          },
          [() => Jp()]
        ),
        G(ue, ne);
    };
    Me(ee, (ue) => {
      kt.data && ue(re);
    });
  }
  P(K),
    yn(2),
    P(N),
    yi(N, () => (ue) => {
      $r(() => {
        f() ? ue.show() : ue.close();
      });
    }),
    Zn("close", N, () => f(!1)),
    G(_, N),
    Rr();
}
Bn(["click"]);
var t_ = function () {
  return (
    (t_ =
      Object.assign ||
      function (o) {
        for (var f, x = 1, A = arguments.length; x < A; x++) {
          f = arguments[x];
          for (var L in f)
            Object.prototype.hasOwnProperty.call(f, L) && (o[L] = f[L]);
        }
        return o;
      }),
    t_.apply(this, arguments)
  );
};
function zo(_, o, f, x) {
  function A(L) {
    return L instanceof f
      ? L
      : new f(function (T) {
          T(L);
        });
  }
  return new (f || (f = Promise))(function (L, T) {
    function s(K) {
      try {
        N(x.next(K));
      } catch (ee) {
        T(ee);
      }
    }
    function B(K) {
      try {
        N(x.throw(K));
      } catch (ee) {
        T(ee);
      }
    }
    function N(K) {
      K.done ? L(K.value) : A(K.value).then(s, B);
    }
    N((x = x.apply(_, o || [])).next());
  });
}
function Lo(_, o) {
  var f = {
      label: 0,
      sent: function () {
        if (L[0] & 1) throw L[1];
        return L[1];
      },
      trys: [],
      ops: [],
    },
    x,
    A,
    L,
    T = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (T.next = s(0)),
    (T.throw = s(1)),
    (T.return = s(2)),
    typeof Symbol == "function" &&
      (T[Symbol.iterator] = function () {
        return this;
      }),
    T
  );
  function s(N) {
    return function (K) {
      return B([N, K]);
    };
  }
  function B(N) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; T && ((T = 0), N[0] && (f = 0)), f; )
      try {
        if (
          ((x = 1),
          A &&
            (L =
              N[0] & 2
                ? A.return
                : N[0]
                ? A.throw || ((L = A.return) && L.call(A), 0)
                : A.next) &&
            !(L = L.call(A, N[1])).done)
        )
          return L;
        switch (((A = 0), L && (N = [N[0] & 2, L.value]), N[0])) {
          case 0:
          case 1:
            L = N;
            break;
          case 4:
            return f.label++, { value: N[1], done: !1 };
          case 5:
            f.label++, (A = N[1]), (N = [0]);
            continue;
          case 7:
            (N = f.ops.pop()), f.trys.pop();
            continue;
          default:
            if (
              ((L = f.trys),
              !(L = L.length > 0 && L[L.length - 1]) &&
                (N[0] === 6 || N[0] === 2))
            ) {
              f = 0;
              continue;
            }
            if (N[0] === 3 && (!L || (N[1] > L[0] && N[1] < L[3]))) {
              f.label = N[1];
              break;
            }
            if (N[0] === 6 && f.label < L[1]) {
              (f.label = L[1]), (L = N);
              break;
            }
            if (L && f.label < L[2]) {
              (f.label = L[2]), f.ops.push(N);
              break;
            }
            L[2] && f.ops.pop(), f.trys.pop();
            continue;
        }
        N = o.call(_, f);
      } catch (K) {
        (N = [6, K]), (A = 0);
      } finally {
        x = L = 0;
      }
    if (N[0] & 5) throw N[1];
    return { value: N[0] ? N[1] : void 0, done: !0 };
  }
}
function Iy(_, o, f) {
  if (f || arguments.length === 2)
    for (var x = 0, A = o.length, L; x < A; x++)
      (L || !(x in o)) &&
        (L || (L = Array.prototype.slice.call(o, 0, x)), (L[x] = o[x]));
  return _.concat(L || Array.prototype.slice.call(o));
}
var My = "4.6.2";
function Fp(_, o) {
  return new Promise(function (f) {
    return setTimeout(f, _, o);
  });
}
function bL() {
  return new Promise(function (_) {
    var o = new MessageChannel();
    (o.port1.onmessage = function () {
      return _();
    }),
      o.port2.postMessage(null);
  });
}
function wL(_, o) {
  o === void 0 && (o = 1 / 0);
  var f = window.requestIdleCallback;
  return f
    ? new Promise(function (x) {
        return f.call(
          window,
          function () {
            return x();
          },
          { timeout: o }
        );
      })
    : Fp(Math.min(_, o));
}
function Ay(_) {
  return !!_ && typeof _.then == "function";
}
function Jv(_, o) {
  try {
    var f = _();
    Ay(f)
      ? f.then(
          function (x) {
            return o(!0, x);
          },
          function (x) {
            return o(!1, x);
          }
        )
      : o(!0, f);
  } catch (x) {
    o(!1, x);
  }
}
function Qv(_, o, f) {
  return (
    f === void 0 && (f = 16),
    zo(this, void 0, void 0, function () {
      var x, A, L, T;
      return Lo(this, function (s) {
        switch (s.label) {
          case 0:
            (x = Array(_.length)), (A = Date.now()), (L = 0), (s.label = 1);
          case 1:
            return L < _.length
              ? ((x[L] = o(_[L], L)),
                (T = Date.now()),
                T >= A + f ? ((A = T), [4, bL()]) : [3, 3])
              : [3, 4];
          case 2:
            s.sent(), (s.label = 3);
          case 3:
            return ++L, [3, 1];
          case 4:
            return [2, x];
        }
      });
    })
  );
}
function oh(_) {
  return _.then(void 0, function () {}), _;
}
function TL(_, o) {
  for (var f = 0, x = _.length; f < x; ++f) if (_[f] === o) return !0;
  return !1;
}
function SL(_, o) {
  return !TL(_, o);
}
function k_(_) {
  return parseInt(_);
}
function po(_) {
  return parseFloat(_);
}
function os(_, o) {
  return typeof _ == "number" && isNaN(_) ? o : _;
}
function fa(_) {
  return _.reduce(function (o, f) {
    return o + (f ? 1 : 0);
  }, 0);
}
function ky(_, o) {
  if ((o === void 0 && (o = 1), Math.abs(o) >= 1)) return Math.round(_ / o) * o;
  var f = 1 / o;
  return Math.round(_ * f) / f;
}
function CL(_) {
  for (
    var o,
      f,
      x = "Unexpected syntax '".concat(_, "'"),
      A = /^\s*([a-z-]*)(.*)$/i.exec(_),
      L = A[1] || void 0,
      T = {},
      s = /([.:#][\w-]+|\[.+?\])/gi,
      B = function (re, ue) {
        (T[re] = T[re] || []), T[re].push(ue);
      };
    ;

  ) {
    var N = s.exec(A[2]);
    if (!N) break;
    var K = N[0];
    switch (K[0]) {
      case ".":
        B("class", K.slice(1));
        break;
      case "#":
        B("id", K.slice(1));
        break;
      case "[": {
        var ee = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(
          K
        );
        if (ee)
          B(
            ee[1],
            (f = (o = ee[4]) !== null && o !== void 0 ? o : ee[5]) !== null &&
              f !== void 0
              ? f
              : ""
          );
        else throw new Error(x);
        break;
      }
      default:
        throw new Error(x);
    }
  }
  return [L, T];
}
function PL(_) {
  for (var o = new Uint8Array(_.length), f = 0; f < _.length; f++) {
    var x = _.charCodeAt(f);
    if (x > 127) return new TextEncoder().encode(_);
    o[f] = x;
  }
  return o;
}
function Es(_, o) {
  var f = _[0] >>> 16,
    x = _[0] & 65535,
    A = _[1] >>> 16,
    L = _[1] & 65535,
    T = o[0] >>> 16,
    s = o[0] & 65535,
    B = o[1] >>> 16,
    N = o[1] & 65535,
    K = 0,
    ee = 0,
    re = 0,
    ue = 0;
  (ue += L + N),
    (re += ue >>> 16),
    (ue &= 65535),
    (re += A + B),
    (ee += re >>> 16),
    (re &= 65535),
    (ee += x + s),
    (K += ee >>> 16),
    (ee &= 65535),
    (K += f + T),
    (K &= 65535),
    (_[0] = (K << 16) | ee),
    (_[1] = (re << 16) | ue);
}
function Za(_, o) {
  var f = _[0] >>> 16,
    x = _[0] & 65535,
    A = _[1] >>> 16,
    L = _[1] & 65535,
    T = o[0] >>> 16,
    s = o[0] & 65535,
    B = o[1] >>> 16,
    N = o[1] & 65535,
    K = 0,
    ee = 0,
    re = 0,
    ue = 0;
  (ue += L * N),
    (re += ue >>> 16),
    (ue &= 65535),
    (re += A * N),
    (ee += re >>> 16),
    (re &= 65535),
    (re += L * B),
    (ee += re >>> 16),
    (re &= 65535),
    (ee += x * N),
    (K += ee >>> 16),
    (ee &= 65535),
    (ee += A * B),
    (K += ee >>> 16),
    (ee &= 65535),
    (ee += L * s),
    (K += ee >>> 16),
    (ee &= 65535),
    (K += f * N + x * B + A * s + L * T),
    (K &= 65535),
    (_[0] = (K << 16) | ee),
    (_[1] = (re << 16) | ue);
}
function Sc(_, o) {
  var f = _[0];
  (o %= 64),
    o === 32
      ? ((_[0] = _[1]), (_[1] = f))
      : o < 32
      ? ((_[0] = (f << o) | (_[1] >>> (32 - o))),
        (_[1] = (_[1] << o) | (f >>> (32 - o))))
      : ((o -= 32),
        (_[0] = (_[1] << o) | (f >>> (32 - o))),
        (_[1] = (f << o) | (_[1] >>> (32 - o))));
}
function Ra(_, o) {
  (o %= 64),
    o !== 0 &&
      (o < 32
        ? ((_[0] = _[1] >>> (32 - o)), (_[1] = _[1] << o))
        : ((_[0] = _[1] << (o - 32)), (_[1] = 0)));
}
function hi(_, o) {
  (_[0] ^= o[0]), (_[1] ^= o[1]);
}
var IL = [4283543511, 3981806797],
  ML = [3301882366, 444984403];
function e0(_) {
  var o = [0, _[0] >>> 1];
  hi(_, o),
    Za(_, IL),
    (o[1] = _[0] >>> 1),
    hi(_, o),
    Za(_, ML),
    (o[1] = _[0] >>> 1),
    hi(_, o);
}
var yp = [2277735313, 289559509],
  xp = [1291169091, 658871167],
  t0 = [0, 5],
  AL = [0, 1390208809],
  kL = [0, 944331445];
function EL(_, o) {
  var f = PL(_);
  o = o || 0;
  var x = [0, f.length],
    A = x[1] % 16,
    L = x[1] - A,
    T = [0, o],
    s = [0, o],
    B = [0, 0],
    N = [0, 0],
    K;
  for (K = 0; K < L; K = K + 16)
    (B[0] = f[K + 4] | (f[K + 5] << 8) | (f[K + 6] << 16) | (f[K + 7] << 24)),
      (B[1] = f[K] | (f[K + 1] << 8) | (f[K + 2] << 16) | (f[K + 3] << 24)),
      (N[0] =
        f[K + 12] | (f[K + 13] << 8) | (f[K + 14] << 16) | (f[K + 15] << 24)),
      (N[1] =
        f[K + 8] | (f[K + 9] << 8) | (f[K + 10] << 16) | (f[K + 11] << 24)),
      Za(B, yp),
      Sc(B, 31),
      Za(B, xp),
      hi(T, B),
      Sc(T, 27),
      Es(T, s),
      Za(T, t0),
      Es(T, AL),
      Za(N, xp),
      Sc(N, 33),
      Za(N, yp),
      hi(s, N),
      Sc(s, 31),
      Es(s, T),
      Za(s, t0),
      Es(s, kL);
  (B[0] = 0), (B[1] = 0), (N[0] = 0), (N[1] = 0);
  var ee = [0, 0];
  switch (A) {
    case 15:
      (ee[1] = f[K + 14]), Ra(ee, 48), hi(N, ee);
    case 14:
      (ee[1] = f[K + 13]), Ra(ee, 40), hi(N, ee);
    case 13:
      (ee[1] = f[K + 12]), Ra(ee, 32), hi(N, ee);
    case 12:
      (ee[1] = f[K + 11]), Ra(ee, 24), hi(N, ee);
    case 11:
      (ee[1] = f[K + 10]), Ra(ee, 16), hi(N, ee);
    case 10:
      (ee[1] = f[K + 9]), Ra(ee, 8), hi(N, ee);
    case 9:
      (ee[1] = f[K + 8]), hi(N, ee), Za(N, xp), Sc(N, 33), Za(N, yp), hi(s, N);
    case 8:
      (ee[1] = f[K + 7]), Ra(ee, 56), hi(B, ee);
    case 7:
      (ee[1] = f[K + 6]), Ra(ee, 48), hi(B, ee);
    case 6:
      (ee[1] = f[K + 5]), Ra(ee, 40), hi(B, ee);
    case 5:
      (ee[1] = f[K + 4]), Ra(ee, 32), hi(B, ee);
    case 4:
      (ee[1] = f[K + 3]), Ra(ee, 24), hi(B, ee);
    case 3:
      (ee[1] = f[K + 2]), Ra(ee, 16), hi(B, ee);
    case 2:
      (ee[1] = f[K + 1]), Ra(ee, 8), hi(B, ee);
    case 1:
      (ee[1] = f[K]), hi(B, ee), Za(B, yp), Sc(B, 31), Za(B, xp), hi(T, B);
  }
  return (
    hi(T, x),
    hi(s, x),
    Es(T, s),
    Es(s, T),
    e0(T),
    e0(s),
    Es(T, s),
    Es(s, T),
    ("00000000" + (T[0] >>> 0).toString(16)).slice(-8) +
      ("00000000" + (T[1] >>> 0).toString(16)).slice(-8) +
      ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) +
      ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
  );
}
function zL(_) {
  var o;
  return t_(
    {
      name: _.name,
      message: _.message,
      stack:
        (o = _.stack) === null || o === void 0
          ? void 0
          : o.split(`
`),
    },
    _
  );
}
function LL(_) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(_));
}
function DL(_) {
  return typeof _ != "function";
}
function RL(_, o) {
  var f = oh(
    new Promise(function (x) {
      var A = Date.now();
      Jv(_.bind(null, o), function () {
        for (var L = [], T = 0; T < arguments.length; T++) L[T] = arguments[T];
        var s = Date.now() - A;
        if (!L[0])
          return x(function () {
            return { error: L[1], duration: s };
          });
        var B = L[1];
        if (DL(B))
          return x(function () {
            return { value: B, duration: s };
          });
        x(function () {
          return new Promise(function (N) {
            var K = Date.now();
            Jv(B, function () {
              for (var ee = [], re = 0; re < arguments.length; re++)
                ee[re] = arguments[re];
              var ue = s + Date.now() - K;
              if (!ee[0]) return N({ error: ee[1], duration: ue });
              N({ value: ee[1], duration: ue });
            });
          });
        });
      });
    })
  );
  return function () {
    return f.then(function (A) {
      return A();
    });
  };
}
function FL(_, o, f, x) {
  var A = Object.keys(_).filter(function (T) {
      return SL(f, T);
    }),
    L = oh(
      Qv(
        A,
        function (T) {
          return RL(_[T], o);
        },
        x
      )
    );
  return function () {
    return zo(this, void 0, void 0, function () {
      var s, B, N, K, ee;
      return Lo(this, function (re) {
        switch (re.label) {
          case 0:
            return [4, L];
          case 1:
            return (
              (s = re.sent()),
              [
                4,
                Qv(
                  s,
                  function (ue) {
                    return oh(ue());
                  },
                  x
                ),
              ]
            );
          case 2:
            return (B = re.sent()), [4, Promise.all(B)];
          case 3:
            for (N = re.sent(), K = {}, ee = 0; ee < A.length; ++ee)
              K[A[ee]] = N[ee];
            return [2, K];
        }
      });
    });
  };
}
function Ey() {
  var _ = window,
    o = navigator;
  return (
    fa([
      "MSCSSMatrix" in _,
      "msSetImmediate" in _,
      "msIndexedDB" in _,
      "msMaxTouchPoints" in o,
      "msPointerEnabled" in o,
    ]) >= 4
  );
}
function BL() {
  var _ = window,
    o = navigator;
  return (
    fa([
      "msWriteProfilerMark" in _,
      "MSStream" in _,
      "msLaunchUri" in o,
      "msSaveBlob" in o,
    ]) >= 3 && !Ey()
  );
}
function Yh() {
  var _ = window,
    o = navigator;
  return (
    fa([
      "webkitPersistentStorage" in o,
      "webkitTemporaryStorage" in o,
      (o.vendor || "").indexOf("Google") === 0,
      "webkitResolveLocalFileSystemURL" in _,
      "BatteryManager" in _,
      "webkitMediaStream" in _,
      "webkitSpeechGrammar" in _,
    ]) >= 5
  );
}
function go() {
  var _ = window,
    o = navigator;
  return (
    fa([
      "ApplePayError" in _,
      "CSSPrimitiveValue" in _,
      "Counter" in _,
      o.vendor.indexOf("Apple") === 0,
      "RGBColor" in _,
      "WebKitMediaKeys" in _,
    ]) >= 4
  );
}
function E_() {
  var _ = window,
    o = _.HTMLElement,
    f = _.Document;
  return (
    fa([
      "safari" in _,
      !("ongestureend" in _),
      !("TouchEvent" in _),
      !("orientation" in _),
      o && !("autocapitalize" in o.prototype),
      f && "pointerLockElement" in f.prototype,
    ]) >= 4
  );
}
function Kh() {
  var _ = window;
  return LL(_.print) && String(_.browser) === "[object WebPageNamespace]";
}
function zy() {
  var _,
    o,
    f = window;
  return (
    fa([
      "buildID" in navigator,
      "MozAppearance" in
        ((o =
          (_ = document.documentElement) === null || _ === void 0
            ? void 0
            : _.style) !== null && o !== void 0
          ? o
          : {}),
      "onmozfullscreenchange" in f,
      "mozInnerScreenX" in f,
      "CSSMozDocumentRule" in f,
      "CanvasCaptureMediaStream" in f,
    ]) >= 4
  );
}
function OL() {
  var _ = window;
  return (
    fa([
      !("MediaSettingsRange" in _),
      "RTCEncodedAudioFrame" in _,
      "" + _.Intl == "[object Intl]",
      "" + _.Reflect == "[object Reflect]",
    ]) >= 3
  );
}
function NL() {
  var _ = window,
    o = _.URLPattern;
  return (
    fa([
      "union" in Set.prototype,
      "Iterator" in _,
      o && "hasRegExpGroups" in o.prototype,
      "RGB8" in WebGLRenderingContext.prototype,
    ]) >= 3
  );
}
function jL() {
  var _ = window;
  return (
    fa([
      "DOMRectList" in _,
      "RTCPeerConnectionIceEvent" in _,
      "SVGGeometryElement" in _,
      "ontransitioncancel" in _,
    ]) >= 3
  );
}
function Jh() {
  var _ = window,
    o = navigator,
    f = _.CSS,
    x = _.HTMLButtonElement;
  return (
    fa([
      !("getStorageUpdates" in o),
      x && "popover" in x.prototype,
      "CSSCounterStyleRule" in _,
      f.supports("font-size-adjust: ex-height 0.5"),
      f.supports("text-transform: full-width"),
    ]) >= 4
  );
}
function VL() {
  if (navigator.platform === "iPad") return !0;
  var _ = screen,
    o = _.width / _.height;
  return (
    fa([
      "MediaSource" in window,
      !!Element.prototype.webkitRequestFullscreen,
      o > 0.65 && o < 1.53,
    ]) >= 2
  );
}
function qL() {
  var _ = document;
  return (
    _.fullscreenElement ||
    _.msFullscreenElement ||
    _.mozFullScreenElement ||
    _.webkitFullscreenElement ||
    null
  );
}
function UL() {
  var _ = document;
  return (
    _.exitFullscreen ||
    _.msExitFullscreen ||
    _.mozCancelFullScreen ||
    _.webkitExitFullscreen
  ).call(_);
}
function z_() {
  var _ = Yh(),
    o = zy(),
    f = window,
    x = navigator,
    A = "connection";
  return _
    ? fa([
        !("SharedWorker" in f),
        x[A] && "ontypechange" in x[A],
        !("sinkId" in new Audio()),
      ]) >= 2
    : o
    ? fa([
        "onorientationchange" in f,
        "orientation" in f,
        /android/i.test(x.appVersion),
      ]) >= 2
    : !1;
}
function ZL() {
  var _ = navigator,
    o = window,
    f = Audio.prototype,
    x = o.visualViewport;
  return (
    fa([
      "srLatency" in f,
      "srChannelCount" in f,
      "devicePosture" in _,
      x && "segments" in x,
      "getTextInformation" in Image.prototype,
    ]) >= 3
  );
}
function GL() {
  return WL() ? -4 : $L();
}
function $L() {
  var _ = window,
    o = _.OfflineAudioContext || _.webkitOfflineAudioContext;
  if (!o) return -2;
  if (HL()) return -1;
  var f = 4500,
    x = 5e3,
    A = new o(1, x, 44100),
    L = A.createOscillator();
  (L.type = "triangle"), (L.frequency.value = 1e4);
  var T = A.createDynamicsCompressor();
  (T.threshold.value = -50),
    (T.knee.value = 40),
    (T.ratio.value = 12),
    (T.attack.value = 0),
    (T.release.value = 0.25),
    L.connect(T),
    T.connect(A.destination),
    L.start(0);
  var s = XL(A),
    B = s[0],
    N = s[1],
    K = oh(
      B.then(
        function (ee) {
          return YL(ee.getChannelData(0).subarray(f));
        },
        function (ee) {
          if (ee.name === "timeout" || ee.name === "suspended") return -3;
          throw ee;
        }
      )
    );
  return function () {
    return N(), K;
  };
}
function HL() {
  return go() && !E_() && !jL();
}
function WL() {
  return (go() && Jh() && Kh()) || (Yh() && ZL() && NL());
}
function XL(_) {
  var o = 3,
    f = 500,
    x = 500,
    A = 5e3,
    L = function () {},
    T = new Promise(function (s, B) {
      var N = !1,
        K = 0,
        ee = 0;
      _.oncomplete = function (ne) {
        return s(ne.renderedBuffer);
      };
      var re = function () {
          setTimeout(function () {
            return B(r0("timeout"));
          }, Math.min(x, ee + A - Date.now()));
        },
        ue = function () {
          try {
            var ne = _.startRendering();
            switch ((Ay(ne) && oh(ne), _.state)) {
              case "running":
                (ee = Date.now()), N && re();
                break;
              case "suspended":
                document.hidden || K++,
                  N && K >= o ? B(r0("suspended")) : setTimeout(ue, f);
                break;
            }
          } catch (Y) {
            B(Y);
          }
        };
      ue(),
        (L = function () {
          N || ((N = !0), ee > 0 && re());
        });
    });
  return [T, L];
}
function YL(_) {
  for (var o = 0, f = 0; f < _.length; ++f) o += Math.abs(_[f]);
  return o;
}
function r0(_) {
  var o = new Error(_);
  return (o.name = _), o;
}
function Ly(_, o, f) {
  var x, A, L;
  return (
    f === void 0 && (f = 50),
    zo(this, void 0, void 0, function () {
      var T, s;
      return Lo(this, function (B) {
        switch (B.label) {
          case 0:
            (T = document), (B.label = 1);
          case 1:
            return T.body ? [3, 3] : [4, Fp(f)];
          case 2:
            return B.sent(), [3, 1];
          case 3:
            (s = T.createElement("iframe")), (B.label = 4);
          case 4:
            return (
              B.trys.push([4, , 10, 11]),
              [
                4,
                new Promise(function (N, K) {
                  var ee = !1,
                    re = function () {
                      (ee = !0), N();
                    },
                    ue = function (xe) {
                      (ee = !0), K(xe);
                    };
                  (s.onload = re), (s.onerror = ue);
                  var ne = s.style;
                  ne.setProperty("display", "block", "important"),
                    (ne.position = "absolute"),
                    (ne.top = "0"),
                    (ne.left = "0"),
                    (ne.visibility = "hidden"),
                    o && "srcdoc" in s
                      ? (s.srcdoc = o)
                      : (s.src = "about:blank"),
                    T.body.appendChild(s);
                  var Y = function () {
                    var xe, Ie;
                    ee ||
                      (((Ie =
                        (xe = s.contentWindow) === null || xe === void 0
                          ? void 0
                          : xe.document) === null || Ie === void 0
                        ? void 0
                        : Ie.readyState) === "complete"
                        ? re()
                        : setTimeout(Y, 10));
                  };
                  Y();
                }),
              ]
            );
          case 5:
            B.sent(), (B.label = 6);
          case 6:
            return !(
              (A =
                (x = s.contentWindow) === null || x === void 0
                  ? void 0
                  : x.document) === null || A === void 0
            ) && A.body
              ? [3, 8]
              : [4, Fp(f)];
          case 7:
            return B.sent(), [3, 6];
          case 8:
            return [4, _(s, s.contentWindow)];
          case 9:
            return [2, B.sent()];
          case 10:
            return (
              (L = s.parentNode) === null || L === void 0 || L.removeChild(s),
              [7]
            );
          case 11:
            return [2];
        }
      });
    })
  );
}
function KL(_) {
  for (
    var o = CL(_),
      f = o[0],
      x = o[1],
      A = document.createElement(f ?? "div"),
      L = 0,
      T = Object.keys(x);
    L < T.length;
    L++
  ) {
    var s = T[L],
      B = x[s].join(" ");
    s === "style" ? JL(A.style, B) : A.setAttribute(s, B);
  }
  return A;
}
function JL(_, o) {
  for (var f = 0, x = o.split(";"); f < x.length; f++) {
    var A = x[f],
      L = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(A);
    if (L) {
      var T = L[1],
        s = L[2],
        B = L[4];
      _.setProperty(T, s, B || "");
    }
  }
}
function QL() {
  for (var _ = window; ; ) {
    var o = _.parent;
    if (!o || o === _) return !1;
    try {
      if (o.location.origin !== _.location.origin) return !0;
    } catch (f) {
      if (f instanceof Error && f.name === "SecurityError") return !0;
      throw f;
    }
    _ = o;
  }
}
var eD = "mmMwWLliI0O&1",
  tD = "48px",
  Cc = ["monospace", "sans-serif", "serif"],
  n0 = [
    "sans-serif-thin",
    "ARNO PRO",
    "Agency FB",
    "Arabic Typesetting",
    "Arial Unicode MS",
    "AvantGarde Bk BT",
    "BankGothic Md BT",
    "Batang",
    "Bitstream Vera Sans Mono",
    "Calibri",
    "Century",
    "Century Gothic",
    "Clarendon",
    "EUROSTILE",
    "Franklin Gothic",
    "Futura Bk BT",
    "Futura Md BT",
    "GOTHAM",
    "Gill Sans",
    "HELV",
    "Haettenschweiler",
    "Helvetica Neue",
    "Humanst521 BT",
    "Leelawadee",
    "Letter Gothic",
    "Levenim MT",
    "Lucida Bright",
    "Lucida Sans",
    "Menlo",
    "MS Mincho",
    "MS Outlook",
    "MS Reference Specialty",
    "MS UI Gothic",
    "MT Extra",
    "MYRIAD PRO",
    "Marlett",
    "Meiryo UI",
    "Microsoft Uighur",
    "Minion Pro",
    "Monotype Corsiva",
    "PMingLiU",
    "Pristina",
    "SCRIPTINA",
    "Segoe UI Light",
    "Serifa",
    "SimHei",
    "Small Fonts",
    "Staccato222 BT",
    "TRAJAN PRO",
    "Univers CE 55 Medium",
    "Vrinda",
    "ZWAdobeF",
  ];
function rD() {
  var _ = this;
  return Ly(function (o, f) {
    var x = f.document;
    return zo(_, void 0, void 0, function () {
      var A, L, T, s, B, N, K, ee, re, ue, ne, Y;
      return Lo(this, function (xe) {
        for (
          A = x.body,
            A.style.fontSize = tD,
            L = x.createElement("div"),
            L.style.setProperty("visibility", "hidden", "important"),
            T = {},
            s = {},
            B = function (Ie) {
              var Ee = x.createElement("span"),
                De = Ee.style;
              return (
                (De.position = "absolute"),
                (De.top = "0"),
                (De.left = "0"),
                (De.fontFamily = Ie),
                (Ee.textContent = eD),
                L.appendChild(Ee),
                Ee
              );
            },
            N = function (Ie, Ee) {
              return B("'".concat(Ie, "',").concat(Ee));
            },
            K = function () {
              return Cc.map(B);
            },
            ee = function () {
              for (
                var Ie = {},
                  Ee = function (Ue) {
                    Ie[Ue] = Cc.map(function (Be) {
                      return N(Ue, Be);
                    });
                  },
                  De = 0,
                  Ae = n0;
                De < Ae.length;
                De++
              ) {
                var qe = Ae[De];
                Ee(qe);
              }
              return Ie;
            },
            re = function (Ie) {
              return Cc.some(function (Ee, De) {
                return (
                  Ie[De].offsetWidth !== T[Ee] || Ie[De].offsetHeight !== s[Ee]
                );
              });
            },
            ue = K(),
            ne = ee(),
            A.appendChild(L),
            Y = 0;
          Y < Cc.length;
          Y++
        )
          (T[Cc[Y]] = ue[Y].offsetWidth), (s[Cc[Y]] = ue[Y].offsetHeight);
        return [
          2,
          n0.filter(function (Ie) {
            return re(ne[Ie]);
          }),
        ];
      });
    });
  });
}
function nD() {
  var _ = navigator.plugins;
  if (_) {
    for (var o = [], f = 0; f < _.length; ++f) {
      var x = _[f];
      if (x) {
        for (var A = [], L = 0; L < x.length; ++L) {
          var T = x[L];
          A.push({ type: T.type, suffixes: T.suffixes });
        }
        o.push({ name: x.name, description: x.description, mimeTypes: A });
      }
    }
    return o;
  }
}
function iD() {
  return aD(dD());
}
function aD(_) {
  var o,
    f = !1,
    x,
    A,
    L = oD(),
    T = L[0],
    s = L[1];
  return (
    sD(T, s)
      ? ((f = lD(s)),
        _ ? (x = A = "skipped") : ((o = cD(T, s)), (x = o[0]), (A = o[1])))
      : (x = A = "unsupported"),
    { winding: f, geometry: x, text: A }
  );
}
function oD() {
  var _ = document.createElement("canvas");
  return (_.width = 1), (_.height = 1), [_, _.getContext("2d")];
}
function sD(_, o) {
  return !!(o && _.toDataURL);
}
function lD(_) {
  return (
    _.rect(0, 0, 10, 10), _.rect(2, 2, 6, 6), !_.isPointInPath(5, 5, "evenodd")
  );
}
function cD(_, o) {
  uD(_, o);
  var f = mm(_),
    x = mm(_);
  if (f !== x) return ["unstable", "unstable"];
  hD(_, o);
  var A = mm(_);
  return [A, f];
}
function uD(_, o) {
  (_.width = 240),
    (_.height = 60),
    (o.textBaseline = "alphabetic"),
    (o.fillStyle = "#f60"),
    o.fillRect(100, 1, 62, 20),
    (o.fillStyle = "#069"),
    (o.font = '11pt "Times New Roman"');
  var f = "Cwm fjordbank gly ".concat("üòÉ");
  o.fillText(f, 2, 15),
    (o.fillStyle = "rgba(102, 204, 0, 0.2)"),
    (o.font = "18pt Arial"),
    o.fillText(f, 4, 45);
}
function hD(_, o) {
  (_.width = 122), (_.height = 110), (o.globalCompositeOperation = "multiply");
  for (
    var f = 0,
      x = [
        ["#f2f", 40, 40],
        ["#2ff", 80, 40],
        ["#ff2", 60, 80],
      ];
    f < x.length;
    f++
  ) {
    var A = x[f],
      L = A[0],
      T = A[1],
      s = A[2];
    (o.fillStyle = L),
      o.beginPath(),
      o.arc(T, s, 40, 0, Math.PI * 2, !0),
      o.closePath(),
      o.fill();
  }
  (o.fillStyle = "#f9c"),
    o.arc(60, 60, 60, 0, Math.PI * 2, !0),
    o.arc(60, 60, 20, 0, Math.PI * 2, !0),
    o.fill("evenodd");
}
function mm(_) {
  return _.toDataURL();
}
function dD() {
  return go() && Jh() && Kh();
}
function pD() {
  var _ = navigator,
    o = 0,
    f;
  _.maxTouchPoints !== void 0
    ? (o = k_(_.maxTouchPoints))
    : _.msMaxTouchPoints !== void 0 && (o = _.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), (f = !0);
  } catch {
    f = !1;
  }
  var x = "ontouchstart" in window;
  return { maxTouchPoints: o, touchEvent: f, touchStart: x };
}
function fD() {
  return navigator.oscpu;
}
function mD() {
  var _ = navigator,
    o = [],
    f = _.language || _.userLanguage || _.browserLanguage || _.systemLanguage;
  if ((f !== void 0 && o.push([f]), Array.isArray(_.languages)))
    (Yh() && OL()) || o.push(_.languages);
  else if (typeof _.languages == "string") {
    var x = _.languages;
    x && o.push(x.split(","));
  }
  return o;
}
function _D() {
  return window.screen.colorDepth;
}
function gD() {
  return os(po(navigator.deviceMemory), void 0);
}
function vD() {
  if (!(go() && Jh() && Kh())) return yD();
}
function yD() {
  var _ = screen,
    o = function (x) {
      return os(k_(x), null);
    },
    f = [o(_.width), o(_.height)];
  return f.sort().reverse(), f;
}
var xD = 2500,
  bD = 10,
  kp,
  _m;
function wD() {
  if (_m === void 0) {
    var _ = function () {
      var o = r_();
      n_(o) ? (_m = setTimeout(_, xD)) : ((kp = o), (_m = void 0));
    };
    _();
  }
}
function TD() {
  var _ = this;
  return (
    wD(),
    function () {
      return zo(_, void 0, void 0, function () {
        var o;
        return Lo(this, function (f) {
          switch (f.label) {
            case 0:
              return (
                (o = r_()),
                n_(o)
                  ? kp
                    ? [2, Iy([], kp, !0)]
                    : qL()
                    ? [4, UL()]
                    : [3, 2]
                  : [3, 2]
              );
            case 1:
              f.sent(), (o = r_()), (f.label = 2);
            case 2:
              return n_(o) || (kp = o), [2, o];
          }
        });
      });
    }
  );
}
function SD() {
  var _ = this;
  if (go() && Jh() && Kh())
    return function () {
      return Promise.resolve(void 0);
    };
  var o = TD();
  return function () {
    return zo(_, void 0, void 0, function () {
      var f, x;
      return Lo(this, function (A) {
        switch (A.label) {
          case 0:
            return [4, o()];
          case 1:
            return (
              (f = A.sent()),
              (x = function (L) {
                return L === null ? null : ky(L, bD);
              }),
              [2, [x(f[0]), x(f[1]), x(f[2]), x(f[3])]]
            );
        }
      });
    });
  };
}
function r_() {
  var _ = screen;
  return [
    os(po(_.availTop), null),
    os(po(_.width) - po(_.availWidth) - os(po(_.availLeft), 0), null),
    os(po(_.height) - po(_.availHeight) - os(po(_.availTop), 0), null),
    os(po(_.availLeft), null),
  ];
}
function n_(_) {
  for (var o = 0; o < 4; ++o) if (_[o]) return !1;
  return !0;
}
function CD() {
  return os(k_(navigator.hardwareConcurrency), void 0);
}
function PD() {
  var _,
    o = (_ = window.Intl) === null || _ === void 0 ? void 0 : _.DateTimeFormat;
  if (o) {
    var f = new o().resolvedOptions().timeZone;
    if (f) return f;
  }
  var x = -ID();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x);
}
function ID() {
  var _ = new Date().getFullYear();
  return Math.max(
    po(new Date(_, 0, 1).getTimezoneOffset()),
    po(new Date(_, 6, 1).getTimezoneOffset())
  );
}
function MD() {
  try {
    return !!window.sessionStorage;
  } catch {
    return !0;
  }
}
function AD() {
  try {
    return !!window.localStorage;
  } catch {
    return !0;
  }
}
function kD() {
  if (!(Ey() || BL()))
    try {
      return !!window.indexedDB;
    } catch {
      return !0;
    }
}
function ED() {
  return !!window.openDatabase;
}
function zD() {
  return navigator.cpuClass;
}
function LD() {
  var _ = navigator.platform;
  return _ === "MacIntel" && go() && !E_() ? (VL() ? "iPad" : "iPhone") : _;
}
function DD() {
  return navigator.vendor || "";
}
function RD() {
  for (
    var _ = [],
      o = 0,
      f = [
        "chrome",
        "safari",
        "__crWeb",
        "__gCrWeb",
        "yandex",
        "__yb",
        "__ybro",
        "__firefox__",
        "__edgeTrackingPreventionStatistics",
        "webkit",
        "oprt",
        "samsungAr",
        "ucweb",
        "UCShellJava",
        "puffinDevice",
      ];
    o < f.length;
    o++
  ) {
    var x = f[o],
      A = window[x];
    A && typeof A == "object" && _.push(x);
  }
  return _.sort();
}
function FD() {
  var _ = document;
  try {
    _.cookie = "cookietest=1; SameSite=Strict;";
    var o = _.cookie.indexOf("cookietest=") !== -1;
    return (
      (_.cookie =
        "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT"),
      o
    );
  } catch {
    return !1;
  }
}
function BD() {
  var _ = atob;
  return {
    abpIndo: [
      "#Iklan-Melayang",
      "#Kolom-Iklan-728",
      "#SidebarIklan-wrapper",
      '[title="ALIENBOLA" i]',
      _("I0JveC1CYW5uZXItYWRz"),
    ],
    abpvn: [
      ".quangcao",
      "#mobileCatfish",
      _("LmNsb3NlLWFkcw=="),
      '[id^="bn_bottom_fixed_"]',
      "#pmadv",
    ],
    adBlockFinland: [
      ".mainostila",
      _("LnNwb25zb3JpdA=="),
      ".ylamainos",
      _("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
      _("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd"),
    ],
    adBlockPersian: [
      "#navbar_notice_50",
      ".kadr",
      'TABLE[width="140px"]',
      "#divAgahi",
      _("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd"),
    ],
    adBlockWarningRemoval: [
      "#adblock-honeypot",
      ".adblocker-root",
      ".wp_adblock_detect",
      _("LmhlYWRlci1ibG9ja2VkLWFk"),
      _("I2FkX2Jsb2NrZXI="),
    ],
    adGuardAnnoyances: [
      ".hs-sosyal",
      "#cookieconsentdiv",
      'div[class^="app_gdpr"]',
      ".as-oil",
      '[data-cypress="soft-push-notification-modal"]',
    ],
    adGuardBase: [
      ".BetterJsPopOverlay",
      _("I2FkXzMwMFgyNTA="),
      _("I2Jhbm5lcmZsb2F0MjI="),
      _("I2NhbXBhaWduLWJhbm5lcg=="),
      _("I0FkLUNvbnRlbnQ="),
    ],
    adGuardChinese: [
      _("LlppX2FkX2FfSA=="),
      _("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
      "#widget-quan",
      _("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
      _("YVtocmVmKj0iLjE5NTZobC5jb20vIl0="),
    ],
    adGuardFrench: [
      "#pavePub",
      _("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
      ".mobile_adhesion",
      ".widgetadv",
      _("LmFkc19iYW4="),
    ],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: [
      "#kauli_yad_1",
      _("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
      _("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
      _("LmFkZ29vZ2xl"),
      _("Ll9faXNib29zdFJldHVybkFk"),
    ],
    adGuardMobile: [
      _("YW1wLWF1dG8tYWRz"),
      _("LmFtcF9hZA=="),
      'amp-embed[type="24smi"]',
      "#mgid_iframe1",
      _("I2FkX2ludmlld19hcmVh"),
    ],
    adGuardRussian: [
      _("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
      _("LnJlY2xhbWE="),
      'div[id^="smi2adblock"]',
      _("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
      "#psyduckpockeball",
    ],
    adGuardSocial: [
      _("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
      _("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
      ".etsy-tweet",
      "#inlineShare",
      ".popup-social",
    ],
    adGuardSpanishPortuguese: [
      "#barraPublicidade",
      "#Publicidade",
      "#publiEspecial",
      "#queTooltip",
      ".cnt-publi",
    ],
    adGuardTrackingProtection: [
      "#qoo-counter",
      _("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
      _("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
      _("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
      "#top100counter",
    ],
    adGuardTurkish: [
      "#backkapat",
      _("I3Jla2xhbWk="),
      _("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
      _("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
      _("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ=="),
    ],
    bulgarian: [
      _("dGQjZnJlZW5ldF90YWJsZV9hZHM="),
      "#ea_intext_div",
      ".lapni-pop-over",
      "#xenium_hot_offers",
    ],
    easyList: [
      ".yb-floorad",
      _("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
      _("LnRyYWZmaWNqdW5reS1hZA=="),
      ".textad_headline",
      _("LnNwb25zb3JlZC10ZXh0LWxpbmtz"),
    ],
    easyListChina: [
      _("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
      _("LmZyb250cGFnZUFkdk0="),
      "#taotaole",
      "#aafoot.top_box",
      ".cfa_popup",
    ],
    easyListCookie: [
      ".ezmob-footer",
      ".cc-CookieWarning",
      "[data-cookie-number]",
      _("LmF3LWNvb2tpZS1iYW5uZXI="),
      ".sygnal24-gdpr-modal-wrap",
    ],
    easyListCzechSlovak: [
      "#onlajny-stickers",
      _("I3Jla2xhbW5pLWJveA=="),
      _("LnJla2xhbWEtbWVnYWJvYXJk"),
      ".sklik",
      _("W2lkXj0ic2tsaWtSZWtsYW1hIl0="),
    ],
    easyListDutch: [
      _("I2FkdmVydGVudGll"),
      _("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
      ".adstekst",
      _("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
      "#semilo-lrectangle",
    ],
    easyListGermany: [
      "#SSpotIMPopSlider",
      _("LnNwb25zb3JsaW5rZ3J1ZW4="),
      _("I3dlcmJ1bmdza3k="),
      _("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
      _("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0="),
    ],
    easyListItaly: [
      _("LmJveF9hZHZfYW5udW5jaQ=="),
      ".sb-box-pubbliredazionale",
      _("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
      _("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
      _("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ=="),
    ],
    easyListLithuania: [
      _("LnJla2xhbW9zX3RhcnBhcw=="),
      _("LnJla2xhbW9zX251b3JvZG9z"),
      _("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
      _("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
      _("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd"),
    ],
    estonian: [_("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: [
      "#ac-lre-player",
      ".navigate-to-top",
      "#subscribe_popup",
      ".newsletter_holder",
      "#back-top",
    ],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [
      ".open.pushModal",
      "#issuem-leaky-paywall-articles-zero-remaining-nag",
      "#sovrn_container",
      'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
      ".BlockNag__Card",
    ],
    fanboySocial: [
      "#FollowUs",
      "#meteored_share",
      "#social_follow",
      ".article-sharer",
      ".community__social-desc",
    ],
    frellwitSwedish: [
      _("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
      _("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
      "article.category-samarbete",
      _("ZGl2LmhvbGlkQWRz"),
      "ul.adsmodern",
    ],
    greekAdBlock: [
      _("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
      _("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
      _("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
      "DIV.agores300",
      "TABLE.advright",
    ],
    hungarian: [
      "#cemp_doboz",
      ".optimonk-iframe-container",
      _("LmFkX19tYWlu"),
      _("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
      "#hirdetesek_box",
    ],
    iDontCareAboutCookies: [
      '.alert-info[data-block-track*="CookieNotice"]',
      ".ModuleTemplateCookieIndicator",
      ".o--cookies--container",
      "#cookies-policy-sticky",
      "#stickyCookieBar",
    ],
    icelandicAbp: [
      _("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ=="),
    ],
    latvian: [
      _(
        "YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="
      ),
      _(
        "YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ=="
      ),
    ],
    listKr: [
      _("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
      _("I2xpdmVyZUFkV3JhcHBlcg=="),
      _("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
      _("aW5zLmZhc3R2aWV3LWFk"),
      ".revenue_unit_item.dable",
    ],
    listeAr: [
      _("LmdlbWluaUxCMUFk"),
      ".right-and-left-sponsers",
      _("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
      _("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
      _("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd"),
    ],
    listeFr: [
      _("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
      _("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
      _("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
      ".site-pub-interstitiel",
      'div[id^="crt-"][data-criteo-id]',
    ],
    officialPolish: [
      "#ceneo-placeholder-ceneo-12",
      _("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
      _("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
      _("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
      _("ZGl2I3NrYXBpZWNfYWQ="),
    ],
    ro: [
      _("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
      _("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
      _(
        "YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="
      ),
      _("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
      'a[href^="/url/"]',
    ],
    ruAd: [
      _("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
      _("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
      _("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
      "#pgeldiz",
      ".yandex-rtb-block",
    ],
    thaiAds: [
      "a[href*=macau-uta-popup]",
      _("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
      _("LmFkczMwMHM="),
      ".bumq",
      ".img-kosana",
    ],
    webAnnoyancesUltralist: [
      "#mod-social-share-2",
      "#social-tools",
      _("LmN0cGwtZnVsbGJhbm5lcg=="),
      ".zergnet-recommend",
      ".yt.btn-link.btn-md.btn",
    ],
  };
}
function OD(_) {
  var o = _ === void 0 ? {} : _,
    f = o.debug;
  return zo(this, void 0, void 0, function () {
    var x, A, L, T, s, B;
    return Lo(this, function (N) {
      switch (N.label) {
        case 0:
          return ND()
            ? ((x = BD()),
              (A = Object.keys(x)),
              (L = (B = []).concat.apply(
                B,
                A.map(function (K) {
                  return x[K];
                })
              )),
              [4, jD(L)])
            : [2, void 0];
        case 1:
          return (
            (T = N.sent()),
            f && VD(x, T),
            (s = A.filter(function (K) {
              var ee = x[K],
                re = fa(
                  ee.map(function (ue) {
                    return T[ue];
                  })
                );
              return re > ee.length * 0.6;
            })),
            s.sort(),
            [2, s]
          );
      }
    });
  });
}
function ND() {
  return go() || z_();
}
function jD(_) {
  var o;
  return zo(this, void 0, void 0, function () {
    var f, x, A, L, B, T, s, B;
    return Lo(this, function (N) {
      switch (N.label) {
        case 0:
          for (
            f = document,
              x = f.createElement("div"),
              A = new Array(_.length),
              L = {},
              i0(x),
              B = 0;
            B < _.length;
            ++B
          )
            (T = KL(_[B])),
              T.tagName === "DIALOG" && T.show(),
              (s = f.createElement("div")),
              i0(s),
              s.appendChild(T),
              x.appendChild(s),
              (A[B] = T);
          N.label = 1;
        case 1:
          return f.body ? [3, 3] : [4, Fp(50)];
        case 2:
          return N.sent(), [3, 1];
        case 3:
          f.body.appendChild(x);
          try {
            for (B = 0; B < _.length; ++B) A[B].offsetParent || (L[_[B]] = !0);
          } finally {
            (o = x.parentNode) === null || o === void 0 || o.removeChild(x);
          }
          return [2, L];
      }
    });
  });
}
function i0(_) {
  _.style.setProperty("visibility", "hidden", "important"),
    _.style.setProperty("display", "block", "important");
}
function VD(_, o) {
  for (
    var f = "DOM blockers debug:\n```", x = 0, A = Object.keys(_);
    x < A.length;
    x++
  ) {
    var L = A[x];
    f += `
`.concat(L, ":");
    for (var T = 0, s = _[L]; T < s.length; T++) {
      var B = s[T];
      f += `
  `
        .concat(o[B] ? "üö´" : "‚û°Ô∏è", " ")
        .concat(B);
    }
  }
  console.log("".concat(f, "\n```"));
}
function qD() {
  for (var _ = 0, o = ["rec2020", "p3", "srgb"]; _ < o.length; _++) {
    var f = o[_];
    if (matchMedia("(color-gamut: ".concat(f, ")")).matches) return f;
  }
}
function UD() {
  if (a0("inverted")) return !0;
  if (a0("none")) return !1;
}
function a0(_) {
  return matchMedia("(inverted-colors: ".concat(_, ")")).matches;
}
function ZD() {
  if (o0("active")) return !0;
  if (o0("none")) return !1;
}
function o0(_) {
  return matchMedia("(forced-colors: ".concat(_, ")")).matches;
}
var GD = 100;
function $D() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var _ = 0; _ <= GD; ++_)
      if (matchMedia("(max-monochrome: ".concat(_, ")")).matches) return _;
    throw new Error("Too high value");
  }
}
function HD() {
  if (Pc("no-preference")) return 0;
  if (Pc("high") || Pc("more")) return 1;
  if (Pc("low") || Pc("less")) return -1;
  if (Pc("forced")) return 10;
}
function Pc(_) {
  return matchMedia("(prefers-contrast: ".concat(_, ")")).matches;
}
function WD() {
  if (s0("reduce")) return !0;
  if (s0("no-preference")) return !1;
}
function s0(_) {
  return matchMedia("(prefers-reduced-motion: ".concat(_, ")")).matches;
}
function XD() {
  if (l0("reduce")) return !0;
  if (l0("no-preference")) return !1;
}
function l0(_) {
  return matchMedia("(prefers-reduced-transparency: ".concat(_, ")")).matches;
}
function YD() {
  if (c0("high")) return !0;
  if (c0("standard")) return !1;
}
function c0(_) {
  return matchMedia("(dynamic-range: ".concat(_, ")")).matches;
}
var jn = Math,
  ha = function () {
    return 0;
  };
function KD() {
  var _ = jn.acos || ha,
    o = jn.acosh || ha,
    f = jn.asin || ha,
    x = jn.asinh || ha,
    A = jn.atanh || ha,
    L = jn.atan || ha,
    T = jn.sin || ha,
    s = jn.sinh || ha,
    B = jn.cos || ha,
    N = jn.cosh || ha,
    K = jn.tan || ha,
    ee = jn.tanh || ha,
    re = jn.exp || ha,
    ue = jn.expm1 || ha,
    ne = jn.log1p || ha,
    Y = function (ke) {
      return jn.pow(jn.PI, ke);
    },
    xe = function (ke) {
      return jn.log(ke + jn.sqrt(ke * ke - 1));
    },
    Ie = function (ke) {
      return jn.log(ke + jn.sqrt(ke * ke + 1));
    },
    Ee = function (ke) {
      return jn.log((1 + ke) / (1 - ke)) / 2;
    },
    De = function (ke) {
      return jn.exp(ke) - 1 / jn.exp(ke) / 2;
    },
    Ae = function (ke) {
      return (jn.exp(ke) + 1 / jn.exp(ke)) / 2;
    },
    qe = function (ke) {
      return jn.exp(ke) - 1;
    },
    Ue = function (ke) {
      return (jn.exp(2 * ke) - 1) / (jn.exp(2 * ke) + 1);
    },
    Be = function (ke) {
      return jn.log(1 + ke);
    };
  return {
    acos: _(0.12312423423423424),
    acosh: o(1e308),
    acoshPf: xe(1e154),
    asin: f(0.12312423423423424),
    asinh: x(1),
    asinhPf: Ie(1),
    atanh: A(0.5),
    atanhPf: Ee(0.5),
    atan: L(0.5),
    sin: T(-1e300),
    sinh: s(1),
    sinhPf: De(1),
    cos: B(10.000000000123),
    cosh: N(1),
    coshPf: Ae(1),
    tan: K(-1e300),
    tanh: ee(1),
    tanhPf: Ue(1),
    exp: re(1),
    expm1: ue(1),
    expm1Pf: qe(1),
    log1p: ne(10),
    log1pPf: Be(10),
    powPI: Y(-100),
  };
}
var JD = "mmMwWLliI0fiflO&1",
  gm = {
    default: [],
    apple: [{ font: "-apple-system-body" }],
    serif: [{ fontFamily: "serif" }],
    sans: [{ fontFamily: "sans-serif" }],
    mono: [{ fontFamily: "monospace" }],
    min: [{ fontSize: "1px" }],
    system: [{ fontFamily: "system-ui" }],
  };
function QD() {
  return eR(function (_, o) {
    for (var f = {}, x = {}, A = 0, L = Object.keys(gm); A < L.length; A++) {
      var T = L[A],
        s = gm[T],
        B = s[0],
        N = B === void 0 ? {} : B,
        K = s[1],
        ee = K === void 0 ? JD : K,
        re = _.createElement("span");
      (re.textContent = ee), (re.style.whiteSpace = "nowrap");
      for (var ue = 0, ne = Object.keys(N); ue < ne.length; ue++) {
        var Y = ne[ue],
          xe = N[Y];
        xe !== void 0 && (re.style[Y] = xe);
      }
      (f[T] = re), o.append(_.createElement("br"), re);
    }
    for (var Ie = 0, Ee = Object.keys(gm); Ie < Ee.length; Ie++) {
      var T = Ee[Ie];
      x[T] = f[T].getBoundingClientRect().width;
    }
    return x;
  });
}
function eR(_, o) {
  return (
    o === void 0 && (o = 4e3),
    Ly(function (f, x) {
      var A = x.document,
        L = A.body,
        T = L.style;
      (T.width = "".concat(o, "px")),
        (T.webkitTextSizeAdjust = T.textSizeAdjust = "none"),
        Yh()
          ? (L.style.zoom = "".concat(1 / x.devicePixelRatio))
          : go() && (L.style.zoom = "reset");
      var s = A.createElement("div");
      return (
        (s.textContent = Iy([], Array((o / 20) << 0), !0)
          .map(function () {
            return "word";
          })
          .join(" ")),
        L.appendChild(s),
        _(A, L)
      );
    }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
  );
}
function tR() {
  return navigator.pdfViewerEnabled;
}
function rR() {
  var _ = new Float32Array(1),
    o = new Uint8Array(_.buffer);
  return (_[0] = 1 / 0), (_[0] = _[0] - _[0]), o[3];
}
function nR() {
  var _ = window.ApplePaySession;
  if (typeof (_ == null ? void 0 : _.canMakePayments) != "function") return -1;
  if (iR()) return -3;
  try {
    return _.canMakePayments() ? 1 : 0;
  } catch (o) {
    return aR(o);
  }
}
var iR = QL;
function aR(_) {
  if (
    _ instanceof Error &&
    _.name === "InvalidAccessError" &&
    /\bfrom\b.*\binsecure\b/i.test(_.message)
  )
    return -2;
  throw _;
}
function oR() {
  var _,
    o = document.createElement("a"),
    f =
      (_ = o.attributionSourceId) !== null && _ !== void 0
        ? _
        : o.attributionsourceid;
  return f === void 0 ? void 0 : String(f);
}
var Dy = -1,
  Ry = -2,
  sR = new Set([
    10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961,
    2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089,
    3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939,
    32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902,
    34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816,
    34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739,
    36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937,
    7938,
  ]),
  lR = new Set([
    34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449,
  ]),
  cR = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  uR = [
    "LOW_FLOAT",
    "MEDIUM_FLOAT",
    "HIGH_FLOAT",
    "LOW_INT",
    "MEDIUM_INT",
    "HIGH_INT",
  ],
  Fy = "WEBGL_debug_renderer_info",
  hR = "WEBGL_polygon_mode";
function dR(_) {
  var o,
    f,
    x,
    A,
    L,
    T,
    s = _.cache,
    B = By(s);
  if (!B) return Dy;
  if (!Ny(B)) return Ry;
  var N = Oy() ? null : B.getExtension(Fy);
  return {
    version:
      ((o = B.getParameter(B.VERSION)) === null || o === void 0
        ? void 0
        : o.toString()) || "",
    vendor:
      ((f = B.getParameter(B.VENDOR)) === null || f === void 0
        ? void 0
        : f.toString()) || "",
    vendorUnmasked: N
      ? (x = B.getParameter(N.UNMASKED_VENDOR_WEBGL)) === null || x === void 0
        ? void 0
        : x.toString()
      : "",
    renderer:
      ((A = B.getParameter(B.RENDERER)) === null || A === void 0
        ? void 0
        : A.toString()) || "",
    rendererUnmasked: N
      ? (L = B.getParameter(N.UNMASKED_RENDERER_WEBGL)) === null || L === void 0
        ? void 0
        : L.toString()
      : "",
    shadingLanguageVersion:
      ((T = B.getParameter(B.SHADING_LANGUAGE_VERSION)) === null || T === void 0
        ? void 0
        : T.toString()) || "",
  };
}
function pR(_) {
  var o = _.cache,
    f = By(o);
  if (!f) return Dy;
  if (!Ny(f)) return Ry;
  var x = f.getSupportedExtensions(),
    A = f.getContextAttributes(),
    L = [],
    T = [],
    s = [],
    B = [],
    N = [];
  if (A)
    for (var K = 0, ee = Object.keys(A); K < ee.length; K++) {
      var re = ee[K];
      T.push("".concat(re, "=").concat(A[re]));
    }
  for (var ue = u0(f), ne = 0, Y = ue; ne < Y.length; ne++) {
    var xe = Y[ne],
      Ie = f[xe];
    s.push(
      ""
        .concat(xe, "=")
        .concat(Ie)
        .concat(sR.has(Ie) ? "=".concat(f.getParameter(Ie)) : "")
    );
  }
  if (x)
    for (var Ee = 0, De = x; Ee < De.length; Ee++) {
      var Ae = De[Ee];
      if (!((Ae === Fy && Oy()) || (Ae === hR && _R()))) {
        var qe = f.getExtension(Ae);
        if (!qe) {
          L.push(Ae);
          continue;
        }
        for (var Ue = 0, Be = u0(qe); Ue < Be.length; Ue++) {
          var xe = Be[Ue],
            Ie = qe[xe];
          B.push(
            ""
              .concat(xe, "=")
              .concat(Ie)
              .concat(lR.has(Ie) ? "=".concat(f.getParameter(Ie)) : "")
          );
        }
      }
    }
  for (var ke = 0, $e = cR; ke < $e.length; ke++)
    for (var Le = $e[ke], nt = 0, dt = uR; nt < dt.length; nt++) {
      var je = dt[nt],
        Ge = fR(f, Le, je);
      N.push("".concat(Le, ".").concat(je, "=").concat(Ge.join(",")));
    }
  return (
    B.sort(),
    s.sort(),
    {
      contextAttributes: T,
      parameters: s,
      shaderPrecisions: N,
      extensions: x,
      extensionParameters: B,
      unsupportedExtensions: L,
    }
  );
}
function By(_) {
  if (_.webgl) return _.webgl.context;
  var o = document.createElement("canvas"),
    f;
  o.addEventListener("webglCreateContextError", function () {
    return (f = void 0);
  });
  for (var x = 0, A = ["webgl", "experimental-webgl"]; x < A.length; x++) {
    var L = A[x];
    try {
      f = o.getContext(L);
    } catch {}
    if (f) break;
  }
  return (_.webgl = { context: f }), f;
}
function fR(_, o, f) {
  var x = _.getShaderPrecisionFormat(_[o], _[f]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : [];
}
function u0(_) {
  var o = Object.keys(_.__proto__);
  return o.filter(mR);
}
function mR(_) {
  return typeof _ == "string" && !_.match(/[^A-Z0-9_x]/);
}
function Oy() {
  return zy();
}
function _R() {
  return Yh() || go();
}
function Ny(_) {
  return typeof _.getParameter == "function";
}
function gR() {
  var _ = z_() || go();
  if (!_) return -2;
  if (!window.AudioContext) return -1;
  var o = new AudioContext().baseLatency;
  return o == null ? -1 : isFinite(o) ? o : -3;
}
function vR() {
  if (!window.Intl) return -1;
  var _ = window.Intl.DateTimeFormat;
  if (!_) return -2;
  var o = _().resolvedOptions().locale;
  return !o && o !== "" ? -3 : o;
}
var yR = {
  fonts: rD,
  domBlockers: OD,
  fontPreferences: QD,
  audio: GL,
  screenFrame: SD,
  canvas: iD,
  osCpu: fD,
  languages: mD,
  colorDepth: _D,
  deviceMemory: gD,
  screenResolution: vD,
  hardwareConcurrency: CD,
  timezone: PD,
  sessionStorage: MD,
  localStorage: AD,
  indexedDB: kD,
  openDatabase: ED,
  cpuClass: zD,
  platform: LD,
  plugins: nD,
  touchSupport: pD,
  vendor: DD,
  vendorFlavors: RD,
  cookiesEnabled: FD,
  colorGamut: qD,
  invertedColors: UD,
  forcedColors: ZD,
  monochrome: $D,
  contrast: HD,
  reducedMotion: WD,
  reducedTransparency: XD,
  hdr: YD,
  math: KD,
  pdfViewerEnabled: tR,
  architecture: rR,
  applePay: nR,
  privateClickMeasurement: oR,
  audioBaseLatency: gR,
  dateTimeLocale: vR,
  webGlBasics: dR,
  webGlExtensions: pR,
};
function xR(_) {
  return FL(yR, _, []);
}
var bR = "$ if upgrade to Pro: https://fpjs.dev/pro";
function wR(_) {
  var o = TR(_),
    f = SR(o);
  return { score: o, comment: bR.replace(/\$/g, "".concat(f)) };
}
function TR(_) {
  if (z_()) return 0.4;
  if (go()) return E_() && !(Jh() && Kh()) ? 0.5 : 0.3;
  var o = "value" in _.platform ? _.platform.value : "";
  return /^Win/.test(o) ? 0.6 : /^Mac/.test(o) ? 0.5 : 0.7;
}
function SR(_) {
  return ky(0.99 + 0.01 * _, 1e-4);
}
function CR(_) {
  for (var o = "", f = 0, x = Object.keys(_).sort(); f < x.length; f++) {
    var A = x[f],
      L = _[A],
      T = "error" in L ? "error" : JSON.stringify(L.value);
    o += ""
      .concat(o ? "|" : "")
      .concat(A.replace(/([:|\\])/g, "\\$1"), ":")
      .concat(T);
  }
  return o;
}
function jy(_) {
  return JSON.stringify(
    _,
    function (o, f) {
      return f instanceof Error ? zL(f) : f;
    },
    2
  );
}
function Vy(_) {
  return EL(CR(_));
}
function PR(_) {
  var o,
    f = wR(_);
  return {
    get visitorId() {
      return o === void 0 && (o = Vy(this.components)), o;
    },
    set visitorId(x) {
      o = x;
    },
    confidence: f,
    components: _,
    version: My,
  };
}
function IR(_) {
  return _ === void 0 && (_ = 50), wL(_, _ * 2);
}
function MR(_, o) {
  var f = Date.now();
  return {
    get: function (x) {
      return zo(this, void 0, void 0, function () {
        var A, L, T;
        return Lo(this, function (s) {
          switch (s.label) {
            case 0:
              return (A = Date.now()), [4, _()];
            case 1:
              return (
                (L = s.sent()),
                (T = PR(L)),
                (o || (x != null && x.debug)) &&
                  console.log(
                    "Copy the text below to get the debug data:\n\n```\nversion: "
                      .concat(
                        T.version,
                        `
userAgent: `
                      )
                      .concat(
                        navigator.userAgent,
                        `
timeBetweenLoadAndGet: `
                      )
                      .concat(
                        A - f,
                        `
visitorId: `
                      )
                      .concat(
                        T.visitorId,
                        `
components: `
                      )
                      .concat(jy(L), "\n```")
                  ),
                [2, T]
              );
          }
        });
      });
    },
  };
}
function AR() {
  if (!(window.__fpjs_d_m || Math.random() >= 0.001))
    try {
      var _ = new XMLHttpRequest();
      _.open(
        "get",
        "https://m1.openfpcdn.io/fingerprintjs/v".concat(My, "/npm-monitoring"),
        !0
      ),
        _.send();
    } catch (o) {
      console.error(o);
    }
}
function kR(_) {
  var o;
  return (
    _ === void 0 && (_ = {}),
    zo(this, void 0, void 0, function () {
      var f, x, A;
      return Lo(this, function (L) {
        switch (L.label) {
          case 0:
            return (
              (!((o = _.monitoring) !== null && o !== void 0) || o) && AR(),
              (f = _.delayFallback),
              (x = _.debug),
              [4, IR(f)]
            );
          case 1:
            return L.sent(), (A = xR({ cache: {}, debug: x })), [2, MR(A, x)];
        }
      });
    })
  );
}
var ER = { load: kR, hashComponents: Vy, componentsToDebugString: jy };
let vm = null;
async function zR() {
  return vm || (vm = ER.load()), vm;
}
async function qy() {
  return (await (await zR()).get()).visitorId;
}
var LR = Lr(
  '<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>'
);
function sh(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = LR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var DR = Lr(
  '<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>'
);
function h0(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = DR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var RR = Lr(
  '<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>'
);
function Uy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = RR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var FR = Lr(
    '<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'
  ),
  BR = Lr(
    '<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>'
  );
function Zy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        var B = FR();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      },
      T = (s) => {
        var B = BR();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      };
    Me(A, (s) => {
      o.filled ? s(L) : s(T, !1);
    });
  }
  G(_, x);
}
var OR = Lr(
  '<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>'
);
function i_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = OR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var NR = Lr(
  '<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>'
);
function Gy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = NR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var jR = Lr(
  '<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>'
);
function VR(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = jR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var qR = Lr(
  '<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>'
);
function UR(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = qR();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var ZR = me("<!> ", 1),
  GR = me("<!> ", 1),
  $R = me("<!> ", 1),
  HR = me(
    '<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ',
    1
  ),
  WR = me("<!> ", 1),
  XR = me("<!> <!>", 1),
  YR = me(
    '<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'
  ),
  KR = me(
    '<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>',
    1
  ),
  JR = me("<div><button><!></button></div>"),
  QR = me(
    '<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>',
    1
  );
function e7(_, o) {
  Dr(o, !0);
  let f = Et(o, "screenLocked", 15),
    x = Et(o, "opaquePixelArt", 15);
  const A = ut(() => new ps(o.tileSize));
  let L = Je(1),
    T = Je("pencil");
  const s = new Map(),
    B = new Map();
  let N = Je(0),
    K = Je(!1),
    ee = Je(!0),
    re = ut(() => kt.charges ?? 0),
    ue = ut(() => y(re) - y(N)),
    ne = Je(!1),
    Y = !1,
    xe = Je(!1),
    Ie = Je(Si([]));
  const Ee = ut(() => y(T) === "pencil"),
    De = ut(() => y(T) === "eraser"),
    Ae = ut(() => y(T) === "colorpicker"),
    qe = ut(() => y(T) === "cleararea"),
    Ue = ut(() => {
      var zt, Qt;
      return ba(
        (Qt = (zt = kt) == null ? void 0 : zt.data) == null ? void 0 : Qt.role,
        ["admin", "global_moderator", "moderator"]
      );
    });
  let Be = Je(!1),
    ke = Je(0),
    $e = Je(void 0),
    Le = Je(void 0);
  const nt = [
      1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42,
      12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49,
      23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52,
      61, 62, 63, 58, 59, 60, 0,
    ].map((zt) => ({ ...pa.colors[zt], idx: zt })),
    dt = [
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
      22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,
    ].map((zt) => ({ ...pa.colors[zt], idx: zt }));
  let je = Je(!1);
  const Ge = ut(() => (y(je) ? nt : dt)),
    bt = "show-all-colors";
  Fn(() => {
    te(je, localStorage.getItem(bt) === "true");
  }),
    $r(() => {
      localStorage.setItem(bt, y(je) ? "true" : "false");
    });
  const Xe = "selected-color";
  Fn(() => {
    const zt = Number(localStorage.getItem(Xe));
    !isNaN(zt) && zt < pa.colors.length && zt > 0 && te(L, zt, !0);
  }),
    $r(() => {
      localStorage.setItem(Xe, y(L).toString());
    });
  const Ve = new oL({
    map: o.map,
    tileSize: o.tileSize,
    tileZoom: o.tileZoom,
    beforeLayerId: o.hoverLayerId,
  });
  $r(() => {
    const zt = x() ? 1 : 0;
    Ve.setCanvasOpacity(zt);
  }),
    $r(() => {
      x() ? Tm() : ct([...s.values()]);
    });
  let Ke = !1;
  Fn(() => {
    as(o.map.getCenter(), o.map.getZoom());
    const zt = o.map.on("click", (fr) => {
      var nn;
      o.zoom < o.tileZoom + 2 &&
        ((nn = kt.data) == null ? void 0 : nn.role) === "user" &&
        o.map.easeTo({ center: fr.lngLat, zoom: 17 });
      const Zr = [fr.lngLat.lat, fr.lngLat.lng];
      if (y(Ee)) ft([Zr], y(L));
      else if (y(De)) lt([Zr]);
      else if (y(Ae)) yt(Zr, fr.point);
      else if (y(qe) && (y(Ie).push(Zr), ft([Zr], 0), y(Ie).length >= 2)) {
        const [Tn, gn] = y(Ie),
          [Gn, Rn] = y(A).latLonToPixelsFloor(Tn[0], Tn[1], o.tileZoom),
          [hn, Qn] = y(A).latLonToPixelsFloor(gn[0], gn[1], o.tileZoom),
          li = Math.min(Gn, hn),
          ii = Math.max(Gn, hn),
          pi = Math.min(Rn, Qn),
          Qi = Math.max(Rn, Qn),
          xi = [];
        for (let Hi = pi; Hi <= Qi; Hi++) {
          const ma = y(A).pixelsToLatLon(li + 0.5, Hi + 0.5, o.tileZoom),
            Ta = y(A).pixelsToLatLon(ii + 0.5, Hi + 0.5, o.tileZoom),
            Na = Qt(
              { lat: ma[0], lng: ma[1] },
              { lat: Ta[0], lng: Ta[1] }
            ).slice(0, y(ue) - xi.length);
          if ((xi.push(...Na), xi.length >= y(ue))) break;
        }
        ft(xi, 0), te(Ie, [], !0), te(T, "pencil");
      }
      te(ne, !0);
    });
    function Qt(fr, Zr) {
      const nn = y(A).latLonToPixels(fr.lat, fr.lng, o.tileZoom),
        Tn = Zr ? y(A).latLonToPixels(Zr.lat, Zr.lng, o.tileZoom) : nn;
      return Ob(nn, Tn).map((Gn) =>
        y(A).pixelsToLatLon(Gn[0] + 0.5, Gn[1] + 0.5, o.tileZoom)
      );
    }
    function rt(fr, Zr) {
      const nn = Qt(fr, Zr);
      y(Ee) ? ft(nn, y(L)) : y(De) && lt(nn), te(ne, !0);
    }
    let $t;
    function st(fr) {
      const Zr = o.map.unproject([fr.clientX, fr.clientY]);
      if (y(xe)) {
        const nn = Qt(Zr, $t);
        lt(nn);
      }
      (Ke || Y) && rt(Zr, $t), ($t = Zr);
    }
    window.addEventListener("mousemove", st);
    let gt = !1;
    const Ut = o.map.on("touchstart", (fr) => {
        if (fr.points.length == 2) {
          f(!1), at(), (gt = !0), setTimeout(() => (gt = !1), 150);
          return;
        }
        f() &&
          setTimeout(() => {
            !gt && rt(fr.lngLat);
          }, 150),
          ($t = fr.lngLat);
      }),
      br = o.map.on("touchmove", (fr) => {
        f() && rt(fr.lngLat, $t), ($t = fr.lngLat);
      }),
      wt = (fr) => {
        fr.code === "Space" &&
          (Ke || ($t && rt($t)), (Ke = !0), fr.preventDefault());
      };
    document.addEventListener("keydown", wt);
    const sr = (fr) => {
      fr.code === "Space" &&
        ((Ke = !1), (Fe = !1), y(N) === 0 && y(De) && te(T, "pencil"));
    };
    document.addEventListener("keyup", sr);
    function wr(fr) {
      if (fr.button === 2) {
        te(xe, !0);
        const nn = o.map.unproject([fr.clientX, fr.clientY]);
        lt([[nn.lat, nn.lng]]);
      }
    }
    document.addEventListener("mousedown", wr);
    function jr(fr) {
      fr.button === 2 && te(xe, !1);
    }
    document.addEventListener("mouseup", jr);
    const Yr = (fr) => {
      switch (fr.code) {
        case "KeyE":
          y(N) > 0 && (y(De) ? te(T, "pencil") : te(T, "eraser"));
          return;
        case "KeyI":
          te(T, "colorpicker");
          return;
        case "KeyC":
          y(Ue) && te(T, "cleararea");
          return;
      }
    };
    return (
      document.addEventListener("keypress", Yr),
      () => {
        br.unsubscribe(),
          Ut.unsubscribe(),
          zt.unsubscribe(),
          document.removeEventListener("mousemove", st),
          document.removeEventListener("keydown", wt),
          document.removeEventListener("keyup", sr),
          document.removeEventListener("keypress", Yr),
          document.removeEventListener("mousedown", wr),
          document.removeEventListener("mouseup", jr),
          qt();
      }
    );
  });
  let Fe = !1;
  function ft(zt, Qt) {
    let rt = !1;
    const $t = Qt === 0;
    for (let st of zt) {
      const [gt, Ut] = st,
        br = M0(Qt),
        { tile: wt, pixel: sr } = y(A).latLonToTileAndPixel(gt, Ut, o.tileZoom),
        wr = { color: br, tile: wt, pixel: sr, season: o.season, colorIdx: Qt },
        jr = um(wr),
        Yr = s.get(jr),
        fr = y(re) - s.size;
      if (!Yr && fr < 1) {
        if (Fe && (Ke || f())) continue;
        (Fe = !0), xr.info(NC());
        continue;
      }
      (Yr && Yr.colorIdx === Qt) ||
        (Oi.plop.play(),
        rt || o.hidePixelHover(),
        s.set(jr, wr),
        Ve.place(st, Qt),
        o.crosshair.place(st),
        (rt = !0),
        $t && B.set(jr, wr));
    }
    te(N, s.size, !0),
      rt && !x() ? ct([...s.values()]) : rt && x() && $t && ct([...B.values()]);
  }
  function lt(zt) {
    let Qt = !1,
      rt = !1;
    for (let $t of zt) {
      const [st, gt] = $t,
        { tile: Ut, pixel: br } = y(A).latLonToTileAndPixel(st, gt, o.tileZoom),
        wt = um({ tile: Ut, pixel: br, season: o.season }),
        sr = s.get(wt);
      sr &&
        (Oi.plop.play(),
        o.hidePixelHover(),
        s.delete(wt),
        B.delete(wt),
        Ve.remove([st, gt]),
        o.crosshair.remove($t),
        (Qt = !0),
        sr.colorIdx === 0 && (rt = !0)),
        s.size === 0 && !(Ke || Y || f()) && te(T, "pencil");
    }
    te(N, s.size, !0),
      Qt && !x() ? ct([...s.values()]) : Qt && x() && rt && ct([...B.values()]);
  }
  function yt(zt, Qt) {
    const { tile: rt, pixel: $t } = y(A).latLonToTileAndPixel(
        zt[0],
        zt[1],
        o.tileZoom
      ),
      st = um({ tile: rt, pixel: $t, season: o.season }),
      gt = s.get(st);
    if (gt) {
      xt(gt.colorIdx),
        requestAnimationFrame(() => {
          var sr;
          (sr = document.getElementById(`color-${gt.colorIdx}`)) == null ||
            sr.focus();
        });
      return;
    }
    const Ut = window.devicePixelRatio,
      br = Math.floor(Qt.x * Ut),
      wt = Math.floor(Qt.y * Ut);
    o.hidePixelHover(),
      ik(o.map, br, wt).then(([sr, wr, jr]) => {
        const Yr = Bb({ r: sr, g: wr, b: jr });
        xt(Yr),
          requestAnimationFrame(() => {
            var fr;
            (fr = document.getElementById(`color-${Yr}`)) == null || fr.focus();
          });
      });
  }
  Fs(
    () => y(L),
    () => {
      o.clickedLatLon &&
        !y(ne) &&
        (y(L) === void 0 && te(L, 1), ft([o.clickedLatLon], y(L)));
    }
  ),
    $r(() => {
      const zt = y(ee) ? 0.8 : 0;
      o.crosshair.setCanvasOpacity(zt);
    });
  let mt = Je(16.5);
  $r(() => {
    if (y($e) && y(Le) && o.clickedLatLon) {
      const zt = o.map.getZoom();
      if (zt < y(mt)) {
        const [Qt, rt] = o.clickedLatLon,
          $t = y(A).latLonToPixelBoundsLatLon(Qt, rt, o.tileZoom),
          st = w_($t),
          gt = y($e) - y(Le).clientHeight,
          Ut = y($e) / 2 - gt / 2;
        o.map.flyTo({
          center: { lat: st[0], lng: st[1] },
          zoom: 17.5,
          offset: zt > 11 ? [0, -Ut] : [0, 0],
        });
      }
      te(mt, o.tileZoom, !0);
    }
  }),
    Fn(() => {
      const zt = () => {
        !document.hidden &&
          (console.log("Tab visible again"),
          x() ? ct([...B.values()]) : ct([...s.values()]));
      };
      return (
        document.addEventListener("visibilitychange", zt),
        () => document.removeEventListener("visibilitychange", zt)
      );
    }),
    $r(() => {
      switch (y(T)) {
        case "pencil":
          (o.map.getCanvas().style.cursor = `url('${iL}') 8 8, default`),
            o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", 0.4);
          return;
        case "colorpicker":
          (o.map.getCanvas().style.cursor = `url('${rL}') 0 16, default`),
            o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", 0);
          return;
        case "eraser":
          (o.map.getCanvas().style.cursor = `url('${nL}') 2 14, default`),
            o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", 0.4);
          return;
      }
    }),
    $r(() => {
      f() ? Ye() : at();
    });
  async function ct(zt) {
    await bb(zt), o.refreshPixelArt();
  }
  async function qt() {
    await Tm(), Ve.clear(), o.refreshPixelArt(), o.crosshair.clear();
  }
  async function Ft() {
    await qt(),
      at(),
      (o.map.getCanvas().style.cursor = "default"),
      o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", 0.4),
      o.onclose();
  }
  function Ye() {
    o.map.dragPan.disable(),
      o.map.touchZoomRotate.disable(),
      (document.documentElement.style.overscrollBehavior = "none");
  }
  function at() {
    o.map.dragPan.enable(),
      o.map.touchZoomRotate.enable(),
      (document.documentElement.style.overscrollBehavior = "");
  }
  function xt(zt) {
    return (
      zt >= 32 && te(je, !0),
      kt.hasColor(zt)
        ? (Oi.smallDropplet.play(), te(L, zt, !0), te(T, "pencil"), !0)
        : (Oi.smallDropplet.play(), te(Be, !0), te(ke, zt, !0), !1)
    );
  }
  lb((zt) => {
    zt.type === "leave" && y(N) > 0 && zt.cancel();
  });
  const It = "show-paint-more-than-one-pixel-msg";
  let Tt = Je(!1);
  Fn(() => {
    var zt;
    te(
      Tt,
      !localStorage.getItem(It) &&
        (((zt = kt.data) == null ? void 0 : zt.pixelsPainted) ?? 0) < 100,
      !0
    );
  }),
    $r(() => {
      y(N) > 1 && (te(Tt, !1), localStorage.setItem(It, "false"));
    });
  const Mt = "lp";
  Fn(() => {
    var Qt;
    const zt = localStorage.getItem(Mt);
    if (zt)
      try {
        const rt = JSON.parse(atob(zt)),
          $t = (rt == null ? void 0 : rt.time) ?? 0,
          st = 60 * 1e3;
        (rt == null ? void 0 : rt.userId) !==
          ((Qt = kt.data) == null ? void 0 : Qt.id) &&
          Date.now() - $t < 30 * st &&
          !Jb &&
          (xr.error(qC()), Ft());
      } catch (rt) {
        console.error(rt);
      }
  });
  function Wt() {
    var Qt;
    const zt = btoa(
      JSON.stringify({
        userId: (Qt = kt.data) == null ? void 0 : Qt.id,
        time: Date.now(),
      })
    );
    localStorage.setItem(Mt, zt);
  }
  var Bt = QR(),
    Gt = _t(Bt),
    At = M(Gt);
  {
    var Xt = (zt) => {
        pl(zt, {
          children: (Qt, rt) => {
            var $t = ZR(),
              st = _t($t);
            Uy(st, { class: "inline size-5" });
            var gt = q(st);
            Ne((Ut) => le(gt, ` ${Ut ?? ""}`), [() => y3()]), G(Qt, $t);
          },
          $$slots: { default: !0 },
        });
      },
      Lt = (zt) => {
        var Qt = Jt(),
          rt = _t(Qt);
        {
          var $t = (gt) => {
              pl(gt, {
                class: "not-touchscreen:hidden",
                children: (Ut, br) => {
                  var wt = GR(),
                    sr = _t(wt);
                  Cm(sr, { class: "inline size-5" });
                  var wr = q(sr);
                  Ne((jr) => le(wr, ` ${jr ?? ""}`), [() => w3()]), G(Ut, wt);
                },
                $$slots: { default: !0 },
              });
            },
            st = (gt) => {
              var Ut = Jt(),
                br = _t(Ut);
              {
                var wt = (wr) => {
                    pl(wr, {
                      class: "not-touchscreen:hidden",
                      children: (jr, Yr) => {
                        var fr = $R(),
                          Zr = _t(fr);
                        h0(Zr, { class: "inline size-5" });
                        var nn = q(Zr, 1, !0);
                        Ne((Tn) => le(nn, Tn), [() => C3()]), G(jr, fr);
                      },
                      $$slots: { default: !0 },
                    });
                  },
                  sr = (wr) => {
                    var jr = Jt(),
                      Yr = _t(jr);
                    {
                      var fr = (nn) => {
                          pl(nn, {
                            class: "touchscreen:hidden",
                            children: (Tn, gn) => {
                              var Gn = HR(),
                                Rn = _t(Gn);
                              Gy(Rn, { class: "inline size-5" });
                              var hn = q(Rn),
                                Qn = M(hn, !0);
                              P(hn);
                              var li = q(hn, 2),
                                ii = M(li),
                                pi = q(ii),
                                Qi = M(pi, !0);
                              P(pi), P(li);
                              var xi = q(li);
                              Ne(
                                (Hi, ma, Ta, Na) => {
                                  le(Qn, Hi),
                                    le(ii, `${ma ?? ""} `),
                                    le(Qi, Ta),
                                    le(xi, ` ${Na ?? ""}`);
                                },
                                [() => M3(), () => D3(), () => E3(), () => B3()]
                              ),
                                G(Tn, Gn);
                            },
                            $$slots: { default: !0 },
                          });
                        },
                        Zr = (nn) => {
                          var Tn = Jt(),
                            gn = _t(Tn);
                          {
                            var Gn = (hn) => {
                                pl(hn, {
                                  class:
                                    "bg-warning text-warning-content animate-bounce",
                                  children: (Qn, li) => {
                                    var ii = WR(),
                                      pi = _t(ii);
                                    Wh(pi, { class: "inline size-5" });
                                    var Qi = q(pi);
                                    Ne(
                                      (xi) => le(Qi, ` ${xi ?? ""}`),
                                      [() => j3()]
                                    ),
                                      G(Qn, ii);
                                  },
                                  $$slots: { default: !0 },
                                });
                              },
                              Rn = (hn) => {
                                var Qn = Jt(),
                                  li = _t(Qn);
                                {
                                  var ii = (pi) => {
                                    pl(pi, {
                                      class:
                                        "bg-warning text-warning-content animate-bounce",
                                      children: (Qi, xi) => {
                                        var Hi = XR(),
                                          ma = _t(Hi);
                                        sh(ma, { class: "inline size-5" });
                                        var Ta = q(ma, 2);
                                        {
                                          var Na = (Sa) => {
                                              var Ca = ji();
                                              Ne(
                                                (vt) => le(Ca, vt),
                                                [() => $0()]
                                              ),
                                                G(Sa, Ca);
                                            },
                                            Do = (Sa) => {
                                              var Ca = Jt(),
                                                vt = _t(Ca);
                                              {
                                                var Kt = (qr) => {
                                                  var In = ji();
                                                  Ne(
                                                    ($n) => le(In, $n),
                                                    [() => H0()]
                                                  ),
                                                    G(qr, In);
                                                };
                                                Me(
                                                  vt,
                                                  (qr) => {
                                                    y(Ie).length === 1 &&
                                                      qr(Kt);
                                                  },
                                                  !0
                                                );
                                              }
                                              G(Sa, Ca);
                                            };
                                          Me(Ta, (Sa) => {
                                            y(Ie).length === 0
                                              ? Sa(Na)
                                              : Sa(Do, !1);
                                          });
                                        }
                                        G(Qi, Hi);
                                      },
                                      $$slots: { default: !0 },
                                    });
                                  };
                                  Me(
                                    li,
                                    (pi) => {
                                      y(qe) && pi(ii);
                                    },
                                    !0
                                  );
                                }
                                G(hn, Qn);
                              };
                            Me(
                              gn,
                              (hn) => {
                                y(Tt) ? hn(Gn) : hn(Rn, !1);
                              },
                              !0
                            );
                          }
                          G(nn, Tn);
                        };
                      Me(
                        Yr,
                        (nn) => {
                          y(Ee) && y(N) === 0 ? nn(fr) : nn(Zr, !1);
                        },
                        !0
                      );
                    }
                    G(wr, jr);
                  };
                Me(
                  br,
                  (wr) => {
                    y(Ae) ? wr(wt) : wr(sr, !1);
                  },
                  !0
                );
              }
              G(gt, Ut);
            };
          Me(
            rt,
            (gt) => {
              y(De) ? gt($t) : gt(st, !1);
            },
            !0
          );
        }
        G(zt, Qt);
      };
    Me(At, (zt) => {
      y(De) && y(N) === 0 ? zt(Xt) : zt(Lt, !1);
    });
  }
  var Nt = q(At, 2),
    jt = M(Nt);
  jt.__click = () => te(ee, !y(ee));
  var mr = M(jt);
  {
    var ir = (zt) => {
        cL(zt, { class: "size-4" });
      },
      vr = (zt) => {
        hL(zt, { class: "size-4" });
      };
    Me(mr, (zt) => {
      y(ee) ? zt(ir) : zt(vr, !1);
    });
  }
  P(jt);
  var ar = q(jt, 2),
    pr = M(ar),
    tr = M(pr),
    Dt = q(tr);
  Cy(Dt, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${y(N) ?? ""})`;
    },
    mono: !0,
  }),
    P(pr);
  var Sr = q(pr, 2),
    Te = M(Sr),
    O = M(Te);
  yn(), P(Te);
  var E = q(Te, 2);
  E.__click = () => {
    te(T, "colorpicker");
  };
  var D = M(E);
  h0(D, { class: "size-4.5" }), P(E), P(Sr);
  var j = q(Sr, 2),
    H = M(j);
  let W;
  H.__click = () => {
    x(!x());
  };
  var ce = M(H);
  {
    let zt = ut(() => !x());
    Zy(ce, {
      class: "size-4.5",
      get filled() {
        return y(zt);
      },
    });
  }
  P(H), P(j);
  var ge = q(j, 2);
  {
    var de = (zt) => {
      var Qt = YR(),
        rt = M(Qt),
        $t = M(rt);
      yn(), P(rt);
      var st = q(rt, 2);
      st.__click = () => {
        te(T, "cleararea");
      };
      var gt = M(st);
      sh(gt, { class: "size-4.5" }),
        P(st),
        P(Qt),
        Ne(
          (Ut) => {
            le($t, `${Ut ?? ""} `),
              Br(
                st,
                1,
                hs({
                  "btn btn-circle btn-sm": !0,
                  "btn-ghost": !y(qe),
                  "btn-primary": y(qe),
                })
              );
          },
          [() => VI()]
        ),
        G(zt, Qt);
    };
    Me(ge, (zt) => {
      y(Ue) && zt(de);
    });
  }
  P(ar);
  var Se = q(ar, 2);
  Se.__click = () => {
    Oi.smallPlop.play(), Ft();
  };
  var We = M(Se);
  Os(We, { class: "size-4" }), P(Se), P(Nt);
  var Ze = q(Nt, 2),
    Ct = M(Ze);
  oi(
    Ct,
    23,
    () => y(Ge),
    (zt) => zt.idx,
    (zt, Qt, rt) => {
      const $t = ut(() => {
          const [jr, Yr, fr] = y(Qt).rgb;
          return { r: jr, g: Yr, b: fr };
        }),
        st = ut(() => y(L) === y(Qt).idx && y(Ee)),
        gt = ut(() => y(Qt).idx === 0),
        Ut = ut(() => kt.hasColor(y(Qt).idx));
      var br = JR(),
        wt = M(br);
      wt.__click = () => {
        xt(y(Qt).idx);
      };
      var sr = M(wt);
      {
        var wr = (jr) => {
          var Yr = KR(),
            fr = _t(Yr);
          i_(fr, {
            class:
              "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6",
          });
          var Zr = q(fr, 2),
            nn = M(Zr);
          i_(nn, { class: "text-base-content/80 size-4" }), P(Zr), G(jr, Yr);
        };
        Me(sr, (jr) => {
          y(Ut) || jr(wr);
        });
      }
      P(wt),
        P(br),
        Ne(() => {
          Br(
            br,
            1,
            hs({
              tooltip: !0,
              "max-sm:h-6": y(je),
              "max-sm:before:translate-x-1/4":
                y(rt) % 8 === 0 && y(Qt).name.length > 7,
              "max-sm:before:-translate-x-1/4":
                (y(rt) - 7) % 8 === 0 && y(Qt).name.length > 7,
              "max-xl:before:translate-x-1/4":
                y(rt) % 16 === 0 && y(Qt).name.length > 7,
              "max-xl:before:-translate-x-1/4":
                (y(rt) - 15) % 16 === 0 && y(Qt).name.length > 7,
              "xl:before:translate-x-1/4":
                y(je) && y(rt) % 32 === 0 && y(Qt).name.length > 7,
              "xl:before:-translate-x-1/4":
                y(je) && (y(rt) - 31) % 32 === 0 && y(Qt).name.length > 7,
            })
          ),
            gr(br, "data-tip", y(Qt).name),
            Br(
              wt,
              1,
              hs({
                "btn relative aspect-square w-full rounded-xl": !0,
                "border-primary ring-primary ring-2": y(st),
                "border-base-300": !y(st) && y(gt),
                "border-base-content/20": !y(st) && !y(gt),
                "max-sm:h-6 max-sm:rounded-md": y(je),
              })
            ),
            Oc(
              wt,
              y(gt)
                ? `background-image: url(${aL}); background-size: cover; image-rendering: pixelated;`
                : `background: rgb(${y($t).r} ${y($t).g} ${y($t).b})`
            ),
            gr(wt, "aria-label", y(Qt).name),
            gr(wt, "id", `color-${y(Qt).idx ?? ""}`);
        }),
        Zn("focus", wt, () => {
          y(Ut) && (te(L, y(Qt).idx, !0), te(T, "pencil"));
        }),
        G(zt, br);
    }
  ),
    P(Ct),
    P(Ze);
  var _e = q(Ze, 2),
    Vt = M(_e);
  Vt.__click = () => {
    te(je, !y(je));
  };
  var cr = M(Vt);
  {
    var Ot = (zt) => {
        VR(zt, { class: "size-5" });
      },
      ur = (zt) => {
        UR(zt, { class: "size-5" });
      };
    Me(cr, (zt) => {
      y(je) ? zt(Ot) : zt(ur, !1);
    });
  }
  P(Vt);
  var Nr = q(Vt, 2),
    Ur = M(Nr);
  {
    let zt = ut(() => (y(N) > 100 ? "animate-pulse" : "")),
      Qt = ut(() => y(N) === 0 || y(K) || y(ue) < 0);
    Py(Ur, {
      get class() {
        return y(zt);
      },
      get charges() {
        return y(ue);
      },
      get disabled() {
        return y(Qt);
      },
      get loading() {
        return y(K);
      },
      onclick: async () => {
        Oi.droppletAndPlop.play();
        const rt = [...s.values()];
        te(K, !0);
        try {
          const $t = await qy();
          await Jr.paint(rt, $t),
            await b0(rt),
            Wt(),
            kt.refresh(),
            (Cp.shouldReload = !0),
            await Ft();
        } catch ($t) {
          xr.error(`${$t.message}`, { duration: 7e3 });
        } finally {
          te(K, !1);
        }
      },
    });
  }
  P(Nr);
  var Wr = q(Nr, 2),
    un = M(Wr),
    an = M(un),
    fn = M(an);
  yn(), P(an);
  var rn = q(an, 2);
  let pt;
  rn.__click = () => {
    te(T, y(T) === "eraser" ? "pencil" : "eraser", !0);
  };
  var on = M(rn);
  Cm(on, {
    class: "size-5",
    get filled() {
      return y(De);
    },
  }),
    P(rn),
    P(un),
    P(Wr),
    P(_e),
    P(Gt),
    Eo(
      Gt,
      (zt) => te(Le, zt),
      () => y(Le)
    );
  var Pn = q(Gt, 2);
  xL(Pn, {
    get colorIdx() {
      return y(ke);
    },
    get open() {
      return y(Be);
    },
    set open(zt) {
      te(Be, zt, !0);
    },
  }),
    Ne(
      (zt, Qt, rt, $t) => {
        le(tr, `${zt ?? ""} `),
          le(O, `${Qt ?? ""} `),
          Br(
            E,
            1,
            hs({
              "btn btn-circle btn-sm": !0,
              "btn-ghost": !y(Ae),
              "btn-primary": y(Ae),
            })
          ),
          gr(j, "data-tip", rt),
          (W = Br(
            H,
            1,
            "btn btn-sm btn-circle btn-ghost text-base-content/80",
            null,
            W,
            { "text-primary": !x() }
          )),
          Br(
            Ct,
            1,
            hs({
              "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
              "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": y(je),
              "gap-1": !y(je),
            })
          ),
          le(fn, `${$t ?? ""} `),
          (pt = Br(
            rn,
            1,
            "btn btn-lg btn-square sm:btn-xl shadow-md",
            null,
            pt,
            { "btn-primary": y(De) }
          )),
          (rn.disabled = y(N) === 0);
      },
      [() => U3(), () => $3(), () => N0(), () => Nb()]
    ),
    Yp("innerHeight", (zt) => te($e, zt, !0)),
    G(_, Bt),
    Rr();
}
Bn(["click"]);
function L_(..._) {
  return P0(Qu(_));
}
var t7 = me("<div><!></div>");
function r7(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var A = t7();
  dr(A, (T) => ({ class: T, ...x }), [() => L_("flex items-center", o.class)]);
  var L = M(A);
  si(L, () => o.children ?? sa),
    P(A),
    Eo(
      A,
      (T) => f(T),
      () => f()
    ),
    G(_, A),
    Rr();
}
var n7 = me(
    '<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'
  ),
  i7 = me(" <!>", 1);
function a7(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var A = Jt(),
    L = _t(A);
  {
    let T = ut(() =>
      L_(
        "border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        o.cell.isActive && "ring-base-content/40 z-10 ring-2",
        o.class
      )
    );
    Ti(
      L,
      () => B8,
      (s, B) => {
        B(
          s,
          Bs(
            {
              get cell() {
                return o.cell;
              },
              get class() {
                return y(T);
              },
            },
            () => x,
            {
              get ref() {
                return f();
              },
              set ref(N) {
                f(N);
              },
              children: (N, K) => {
                yn();
                var ee = i7(),
                  re = _t(ee),
                  ue = q(re);
                {
                  var ne = (Y) => {
                    var xe = n7();
                    G(Y, xe);
                  };
                  Me(ue, (Y) => {
                    o.cell.hasFakeCaret && Y(ne);
                  });
                }
                Ne(() => le(re, `${o.cell.char ?? ""} `)), G(N, ee);
              },
              $$slots: { default: !0 },
            }
          )
        );
      }
    );
  }
  G(_, A), Rr();
}
function o7(_, o) {
  Dr(o, !0);
  let f = Et(o, "ref", 15, null),
    x = Et(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var L = Jt(),
    T = _t(L);
  {
    let s = ut(() =>
      L_(
        "flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed",
        o.class
      )
    );
    Ti(
      T,
      () => R8,
      (B, N) => {
        N(
          B,
          Bs(
            {
              get class() {
                return y(s);
              },
            },
            () => A,
            {
              get ref() {
                return f();
              },
              set ref(K) {
                f(K);
              },
              get value() {
                return x();
              },
              set value(K) {
                x(K);
              },
            }
          )
        );
      }
    );
  }
  G(_, L), Rr();
}
var ym = { exports: {} },
  d0;
function s7() {
  return (
    d0 ||
      ((d0 = 1),
      (function (_) {
        (function (o) {
          _.exports ? (_.exports = o()) : (window.intlTelInput = o());
        })(() => {
          var o = (() => {
            var f = Object.defineProperty,
              x = Object.getOwnPropertyDescriptor,
              A = Object.getOwnPropertyNames,
              L = Object.prototype.hasOwnProperty,
              T = (Te, O) => {
                for (var E in O) f(Te, E, { get: O[E], enumerable: !0 });
              },
              s = (Te, O, E, D) => {
                if ((O && typeof O == "object") || typeof O == "function")
                  for (let j of A(O))
                    !L.call(Te, j) &&
                      j !== E &&
                      f(Te, j, {
                        get: () => O[j],
                        enumerable: !(D = x(O, j)) || D.enumerable,
                      });
                return Te;
              },
              B = (Te) => s(f({}, "__esModule", { value: !0 }), Te),
              N = {};
            T(N, { Iti: () => ar, default: () => Sr });
            var K = [
                ["af", "93", 0, null, "0"],
                ["ax", "358", 1, ["18", "4"], "0"],
                ["al", "355", 0, null, "0"],
                ["dz", "213", 0, null, "0"],
                ["as", "1", 5, ["684"], "1"],
                ["ad", "376"],
                ["ao", "244"],
                ["ai", "1", 6, ["264"], "1"],
                ["ag", "1", 7, ["268"], "1"],
                ["ar", "54", 0, null, "0"],
                ["am", "374", 0, null, "0"],
                ["aw", "297"],
                ["ac", "247"],
                ["au", "61", 0, ["4"], "0"],
                ["at", "43", 0, null, "0"],
                ["az", "994", 0, null, "0"],
                ["bs", "1", 8, ["242"], "1"],
                ["bh", "973"],
                ["bd", "880", 0, null, "0"],
                ["bb", "1", 9, ["246"], "1"],
                ["by", "375", 0, null, "8"],
                ["be", "32", 0, null, "0"],
                ["bz", "501"],
                ["bj", "229"],
                ["bm", "1", 10, ["441"], "1"],
                ["bt", "975"],
                ["bo", "591", 0, null, "0"],
                ["ba", "387", 0, null, "0"],
                ["bw", "267"],
                ["br", "55", 0, null, "0"],
                ["io", "246"],
                ["vg", "1", 11, ["284"], "1"],
                ["bn", "673"],
                ["bg", "359", 0, null, "0"],
                ["bf", "226"],
                ["bi", "257"],
                ["kh", "855", 0, null, "0"],
                ["cm", "237"],
                [
                  "ca",
                  "1",
                  1,
                  [
                    "204",
                    "226",
                    "236",
                    "249",
                    "250",
                    "257",
                    "263",
                    "289",
                    "306",
                    "343",
                    "354",
                    "365",
                    "367",
                    "368",
                    "382",
                    "403",
                    "416",
                    "418",
                    "428",
                    "431",
                    "437",
                    "438",
                    "450",
                    "468",
                    "474",
                    "506",
                    "514",
                    "519",
                    "548",
                    "579",
                    "581",
                    "584",
                    "587",
                    "604",
                    "613",
                    "639",
                    "647",
                    "672",
                    "683",
                    "705",
                    "709",
                    "742",
                    "753",
                    "778",
                    "780",
                    "782",
                    "807",
                    "819",
                    "825",
                    "867",
                    "873",
                    "879",
                    "902",
                    "905",
                    "942",
                  ],
                  "1",
                ],
                ["cv", "238"],
                ["bq", "599", 1, ["3", "4", "7"]],
                ["ky", "1", 12, ["345"], "1"],
                ["cf", "236"],
                ["td", "235"],
                ["cl", "56"],
                ["cn", "86", 0, null, "0"],
                ["cx", "61", 2, ["4", "89164"], "0"],
                ["cc", "61", 1, ["4", "89162"], "0"],
                ["co", "57", 0, null, "0"],
                ["km", "269"],
                ["cg", "242"],
                ["cd", "243", 0, null, "0"],
                ["ck", "682"],
                ["cr", "506"],
                ["ci", "225"],
                ["hr", "385", 0, null, "0"],
                ["cu", "53", 0, null, "0"],
                ["cw", "599", 0],
                ["cy", "357"],
                ["cz", "420"],
                ["dk", "45"],
                ["dj", "253"],
                ["dm", "1", 13, ["767"], "1"],
                ["do", "1", 2, ["809", "829", "849"], "1"],
                ["ec", "593", 0, null, "0"],
                ["eg", "20", 0, null, "0"],
                ["sv", "503"],
                ["gq", "240"],
                ["er", "291", 0, null, "0"],
                ["ee", "372"],
                ["sz", "268"],
                ["et", "251", 0, null, "0"],
                ["fk", "500"],
                ["fo", "298"],
                ["fj", "679"],
                ["fi", "358", 0, ["4"], "0"],
                ["fr", "33", 0, null, "0"],
                ["gf", "594", 0, null, "0"],
                ["pf", "689"],
                ["ga", "241"],
                ["gm", "220"],
                ["ge", "995", 0, null, "0"],
                ["de", "49", 0, null, "0"],
                ["gh", "233", 0, null, "0"],
                ["gi", "350"],
                ["gr", "30"],
                ["gl", "299"],
                ["gd", "1", 14, ["473"], "1"],
                ["gp", "590", 0, null, "0"],
                ["gu", "1", 15, ["671"], "1"],
                ["gt", "502"],
                ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
                ["gn", "224"],
                ["gw", "245"],
                ["gy", "592"],
                ["ht", "509"],
                ["hn", "504"],
                ["hk", "852"],
                ["hu", "36", 0, null, "06"],
                ["is", "354"],
                ["in", "91", 0, null, "0"],
                ["id", "62", 0, null, "0"],
                ["ir", "98", 0, null, "0"],
                ["iq", "964", 0, null, "0"],
                ["ie", "353", 0, null, "0"],
                ["im", "44", 2, ["1624", "74576", "7524", "7624", "7924"], "0"],
                ["il", "972", 0, null, "0"],
                ["it", "39", 0, ["3"]],
                ["jm", "1", 4, ["658", "876"], "1"],
                ["jp", "81", 0, null, "0"],
                [
                  "je",
                  "44",
                  3,
                  ["1534", "7509", "7700", "7797", "7829", "7937"],
                  "0",
                ],
                ["jo", "962", 0, null, "0"],
                ["kz", "7", 1, ["33", "7"], "8"],
                ["ke", "254", 0, null, "0"],
                ["ki", "686", 0, null, "0"],
                ["xk", "383", 0, null, "0"],
                ["kw", "965"],
                ["kg", "996", 0, null, "0"],
                ["la", "856", 0, null, "0"],
                ["lv", "371"],
                ["lb", "961", 0, null, "0"],
                ["ls", "266"],
                ["lr", "231", 0, null, "0"],
                ["ly", "218", 0, null, "0"],
                ["li", "423", 0, null, "0"],
                ["lt", "370", 0, null, "0"],
                ["lu", "352"],
                ["mo", "853"],
                ["mg", "261", 0, null, "0"],
                ["mw", "265", 0, null, "0"],
                ["my", "60", 0, null, "0"],
                ["mv", "960"],
                ["ml", "223"],
                ["mt", "356"],
                ["mh", "692", 0, null, "1"],
                ["mq", "596", 0, null, "0"],
                ["mr", "222"],
                ["mu", "230"],
                ["yt", "262", 1, ["269", "639"], "0"],
                ["mx", "52"],
                ["fm", "691"],
                ["md", "373", 0, null, "0"],
                ["mc", "377", 0, null, "0"],
                ["mn", "976", 0, null, "0"],
                ["me", "382", 0, null, "0"],
                ["ms", "1", 16, ["664"], "1"],
                ["ma", "212", 0, ["6", "7"], "0"],
                ["mz", "258"],
                ["mm", "95", 0, null, "0"],
                ["na", "264", 0, null, "0"],
                ["nr", "674"],
                ["np", "977", 0, null, "0"],
                ["nl", "31", 0, null, "0"],
                ["nc", "687"],
                ["nz", "64", 0, null, "0"],
                ["ni", "505"],
                ["ne", "227"],
                ["ng", "234", 0, null, "0"],
                ["nu", "683"],
                ["nf", "672"],
                ["kp", "850", 0, null, "0"],
                ["mk", "389", 0, null, "0"],
                ["mp", "1", 17, ["670"], "1"],
                ["no", "47", 0, ["4", "9"]],
                ["om", "968"],
                ["pk", "92", 0, null, "0"],
                ["pw", "680"],
                ["ps", "970", 0, null, "0"],
                ["pa", "507"],
                ["pg", "675"],
                ["py", "595", 0, null, "0"],
                ["pe", "51", 0, null, "0"],
                ["ph", "63", 0, null, "0"],
                ["pl", "48"],
                ["pt", "351"],
                ["pr", "1", 3, ["787", "939"], "1"],
                ["qa", "974"],
                ["re", "262", 0, null, "0"],
                ["ro", "40", 0, null, "0"],
                ["ru", "7", 0, ["33"], "8"],
                ["rw", "250", 0, null, "0"],
                ["ws", "685"],
                ["sm", "378"],
                ["st", "239"],
                ["sa", "966", 0, null, "0"],
                ["sn", "221"],
                ["rs", "381", 0, null, "0"],
                ["sc", "248"],
                ["sl", "232", 0, null, "0"],
                ["sg", "65"],
                ["sx", "1", 21, ["721"], "1"],
                ["sk", "421", 0, null, "0"],
                ["si", "386", 0, null, "0"],
                ["sb", "677"],
                ["so", "252", 0, null, "0"],
                ["za", "27", 0, null, "0"],
                ["kr", "82", 0, null, "0"],
                ["ss", "211", 0, null, "0"],
                ["es", "34"],
                ["lk", "94", 0, null, "0"],
                ["bl", "590", 1, null, "0"],
                ["sh", "290"],
                ["kn", "1", 18, ["869"], "1"],
                ["lc", "1", 19, ["758"], "1"],
                ["mf", "590", 2, null, "0"],
                ["pm", "508", 0, null, "0"],
                ["vc", "1", 20, ["784"], "1"],
                ["sd", "249", 0, null, "0"],
                ["sr", "597"],
                ["sj", "47", 1, ["4", "79", "9"]],
                ["se", "46", 0, null, "0"],
                ["ch", "41", 0, null, "0"],
                ["sy", "963", 0, null, "0"],
                ["tw", "886", 0, null, "0"],
                ["tj", "992"],
                ["tz", "255", 0, null, "0"],
                ["th", "66", 0, null, "0"],
                ["tl", "670"],
                ["tg", "228"],
                ["tk", "690"],
                ["to", "676"],
                ["tt", "1", 22, ["868"], "1"],
                ["tn", "216"],
                ["tr", "90", 0, null, "0"],
                ["tm", "993", 0, null, "8"],
                ["tc", "1", 23, ["649"], "1"],
                ["tv", "688"],
                ["vi", "1", 24, ["340"], "1"],
                ["ug", "256", 0, null, "0"],
                ["ua", "380", 0, null, "0"],
                ["ae", "971", 0, null, "0"],
                ["gb", "44", 0, null, "0"],
                ["us", "1", 0, null, "1"],
                ["uy", "598", 0, null, "0"],
                ["uz", "998"],
                ["vu", "678"],
                ["va", "39", 1, ["06698", "3"]],
                ["ve", "58", 0, null, "0"],
                ["vn", "84", 0, null, "0"],
                ["wf", "681"],
                ["eh", "212", 1, ["5288", "5289", "6", "7"], "0"],
                ["ye", "967", 0, null, "0"],
                ["zm", "260", 0, null, "0"],
                ["zw", "263", 0, null, "0"],
              ],
              ee = [];
            for (const Te of K)
              ee.push({
                name: "",
                iso2: Te[0],
                dialCode: Te[1],
                priority: Te[2] || 0,
                areaCodes: Te[3] || null,
                nodeById: {},
                nationalPrefix: Te[4] || null,
                normalisedName: "",
                initials: "",
                dialCodePlus: "",
              });
            var re = ee,
              ue = {
                ad: "Andorra",
                ae: "United Arab Emirates",
                af: "Afghanistan",
                ag: "Antigua & Barbuda",
                ai: "Anguilla",
                al: "Albania",
                am: "Armenia",
                ao: "Angola",
                ar: "Argentina",
                as: "American Samoa",
                at: "Austria",
                au: "Australia",
                aw: "Aruba",
                ax: "√Öland Islands",
                az: "Azerbaijan",
                ba: "Bosnia & Herzegovina",
                bb: "Barbados",
                bd: "Bangladesh",
                be: "Belgium",
                bf: "Burkina Faso",
                bg: "Bulgaria",
                bh: "Bahrain",
                bi: "Burundi",
                bj: "Benin",
                bl: "St. Barth√©lemy",
                bm: "Bermuda",
                bn: "Brunei",
                bo: "Bolivia",
                bq: "Caribbean Netherlands",
                br: "Brazil",
                bs: "Bahamas",
                bt: "Bhutan",
                bw: "Botswana",
                by: "Belarus",
                bz: "Belize",
                ca: "Canada",
                cc: "Cocos (Keeling) Islands",
                cd: "Congo - Kinshasa",
                cf: "Central African Republic",
                cg: "Congo - Brazzaville",
                ch: "Switzerland",
                ci: "C√¥te d‚ÄôIvoire",
                ck: "Cook Islands",
                cl: "Chile",
                cm: "Cameroon",
                cn: "China",
                co: "Colombia",
                cr: "Costa Rica",
                cu: "Cuba",
                cv: "Cape Verde",
                cw: "Cura√ßao",
                cx: "Christmas Island",
                cy: "Cyprus",
                cz: "Czechia",
                de: "Germany",
                dj: "Djibouti",
                dk: "Denmark",
                dm: "Dominica",
                do: "Dominican Republic",
                dz: "Algeria",
                ec: "Ecuador",
                ee: "Estonia",
                eg: "Egypt",
                eh: "Western Sahara",
                er: "Eritrea",
                es: "Spain",
                et: "Ethiopia",
                fi: "Finland",
                fj: "Fiji",
                fk: "Falkland Islands",
                fm: "Micronesia",
                fo: "Faroe Islands",
                fr: "France",
                ga: "Gabon",
                gb: "United Kingdom",
                gd: "Grenada",
                ge: "Georgia",
                gf: "French Guiana",
                gg: "Guernsey",
                gh: "Ghana",
                gi: "Gibraltar",
                gl: "Greenland",
                gm: "Gambia",
                gn: "Guinea",
                gp: "Guadeloupe",
                gq: "Equatorial Guinea",
                gr: "Greece",
                gt: "Guatemala",
                gu: "Guam",
                gw: "Guinea-Bissau",
                gy: "Guyana",
                hk: "Hong Kong SAR China",
                hn: "Honduras",
                hr: "Croatia",
                ht: "Haiti",
                hu: "Hungary",
                id: "Indonesia",
                ie: "Ireland",
                il: "Israel",
                im: "Isle of Man",
                in: "India",
                io: "British Indian Ocean Territory",
                iq: "Iraq",
                ir: "Iran",
                is: "Iceland",
                it: "Italy",
                je: "Jersey",
                jm: "Jamaica",
                jo: "Jordan",
                jp: "Japan",
                ke: "Kenya",
                kg: "Kyrgyzstan",
                kh: "Cambodia",
                ki: "Kiribati",
                km: "Comoros",
                kn: "St. Kitts & Nevis",
                kp: "North Korea",
                kr: "South Korea",
                kw: "Kuwait",
                ky: "Cayman Islands",
                kz: "Kazakhstan",
                la: "Laos",
                lb: "Lebanon",
                lc: "St. Lucia",
                li: "Liechtenstein",
                lk: "Sri Lanka",
                lr: "Liberia",
                ls: "Lesotho",
                lt: "Lithuania",
                lu: "Luxembourg",
                lv: "Latvia",
                ly: "Libya",
                ma: "Morocco",
                mc: "Monaco",
                md: "Moldova",
                me: "Montenegro",
                mf: "St. Martin",
                mg: "Madagascar",
                mh: "Marshall Islands",
                mk: "North Macedonia",
                ml: "Mali",
                mm: "Myanmar (Burma)",
                mn: "Mongolia",
                mo: "Macao SAR China",
                mp: "Northern Mariana Islands",
                mq: "Martinique",
                mr: "Mauritania",
                ms: "Montserrat",
                mt: "Malta",
                mu: "Mauritius",
                mv: "Maldives",
                mw: "Malawi",
                mx: "Mexico",
                my: "Malaysia",
                mz: "Mozambique",
                na: "Namibia",
                nc: "New Caledonia",
                ne: "Niger",
                nf: "Norfolk Island",
                ng: "Nigeria",
                ni: "Nicaragua",
                nl: "Netherlands",
                no: "Norway",
                np: "Nepal",
                nr: "Nauru",
                nu: "Niue",
                nz: "New Zealand",
                om: "Oman",
                pa: "Panama",
                pe: "Peru",
                pf: "French Polynesia",
                pg: "Papua New Guinea",
                ph: "Philippines",
                pk: "Pakistan",
                pl: "Poland",
                pm: "St. Pierre & Miquelon",
                pr: "Puerto Rico",
                ps: "Palestinian Territories",
                pt: "Portugal",
                pw: "Palau",
                py: "Paraguay",
                qa: "Qatar",
                re: "R√©union",
                ro: "Romania",
                rs: "Serbia",
                ru: "Russia",
                rw: "Rwanda",
                sa: "Saudi Arabia",
                sb: "Solomon Islands",
                sc: "Seychelles",
                sd: "Sudan",
                se: "Sweden",
                sg: "Singapore",
                sh: "St. Helena",
                si: "Slovenia",
                sj: "Svalbard & Jan Mayen",
                sk: "Slovakia",
                sl: "Sierra Leone",
                sm: "San Marino",
                sn: "Senegal",
                so: "Somalia",
                sr: "Suriname",
                ss: "South Sudan",
                st: "S√£o Tom√© & Pr√≠ncipe",
                sv: "El Salvador",
                sx: "Sint Maarten",
                sy: "Syria",
                sz: "Eswatini",
                tc: "Turks & Caicos Islands",
                td: "Chad",
                tg: "Togo",
                th: "Thailand",
                tj: "Tajikistan",
                tk: "Tokelau",
                tl: "Timor-Leste",
                tm: "Turkmenistan",
                tn: "Tunisia",
                to: "Tonga",
                tr: "Turkey",
                tt: "Trinidad & Tobago",
                tv: "Tuvalu",
                tw: "Taiwan",
                tz: "Tanzania",
                ua: "Ukraine",
                ug: "Uganda",
                us: "United States",
                uy: "Uruguay",
                uz: "Uzbekistan",
                va: "Vatican City",
                vc: "St. Vincent & Grenadines",
                ve: "Venezuela",
                vg: "British Virgin Islands",
                vi: "U.S. Virgin Islands",
                vn: "Vietnam",
                vu: "Vanuatu",
                wf: "Wallis & Futuna",
                ws: "Samoa",
                ye: "Yemen",
                yt: "Mayotte",
                za: "South Africa",
                zm: "Zambia",
                zw: "Zimbabwe",
              },
              ne = ue,
              Y = {
                selectedCountryAriaLabel:
                  "Change country, selected ${countryName} (${dialCode})",
                noCountrySelected: "Select country",
                countryListAriaLabel: "List of countries",
                searchPlaceholder: "Search",
                clearSearchAriaLabel: "Clear search",
                zeroSearchResults: "No results found",
                oneSearchResult: "1 result found",
                multipleSearchResults: "${count} results found",
                ac: "Ascension Island",
                xk: "Kosovo",
              },
              xe = Y,
              Ie = { ...ne, ...xe },
              Ee = Ie,
              De = {
                OPEN_COUNTRY_DROPDOWN: "open:countrydropdown",
                CLOSE_COUNTRY_DROPDOWN: "close:countrydropdown",
                COUNTRY_CHANGE: "countrychange",
                INPUT: "input",
              },
              Ae = {
                HIDE: "iti__hide",
                V_HIDE: "iti__v-hide",
                ARROW_UP: "iti__arrow--up",
                GLOBE: "iti__globe",
                FLAG: "iti__flag",
                COUNTRY_ITEM: "iti__country",
                HIGHLIGHT: "iti__highlight",
              },
              qe = {
                ARROW_UP: "ArrowUp",
                ARROW_DOWN: "ArrowDown",
                SPACE: " ",
                ENTER: "Enter",
                ESC: "Escape",
                TAB: "Tab",
              },
              Ue = {
                PASTE: "insertFromPaste",
                DELETE_FWD: "deleteContentForward",
              },
              Be = {
                ALPHA_UNICODE: new RegExp("\\p{L}", "u"),
                NON_PLUS_NUMERIC: /[^+0-9]/,
                NON_PLUS_NUMERIC_GLOBAL: /[^+0-9]/g,
                HIDDEN_SEARCH_CHAR: /^[a-zA-Z√Ä-√ø–∞-—è–ê-–Ø ]$/,
              },
              ke = { HIDDEN_SEARCH_RESET_MS: 1e3 },
              $e = { UNKNOWN_NUMBER_TYPE: -99, UNKNOWN_VALIDATION_ERROR: -99 },
              Le = {
                SANE_SELECTED_WITH_DIAL_WIDTH: 78,
                SANE_SELECTED_NO_DIAL_WIDTH: 42,
                INPUT_PADDING_EXTRA_LEFT: 6,
              },
              nt = { NANP: "1" },
              dt = {
                DIAL_CODE: "44",
                MOBILE_PREFIX: "7",
                MOBILE_CORE_LENGTH: 10,
              },
              je = { ISO2: "us" },
              Ge = { AGGRESSIVE: "aggressive", POLITE: "polite" },
              bt = { AUTO: "auto" },
              Xe = { COUNTRY_CODE: "countryCode", DIAL_CODE: "dialCode" },
              Ve = {
                EXPANDED: "aria-expanded",
                LABEL: "aria-label",
                SELECTED: "aria-selected",
                ACTIVE_DESCENDANT: "aria-activedescendant",
                HASPOPUP: "aria-haspopup",
                CONTROLS: "aria-controls",
                HIDDEN: "aria-hidden",
                AUTOCOMPLETE: "aria-autocomplete",
                MODAL: "aria-modal",
              },
              Ke = (Te) =>
                typeof window < "u" &&
                typeof window.matchMedia == "function" &&
                window.matchMedia(Te).matches,
              Fe = () => {
                if (typeof navigator < "u" && typeof window < "u") {
                  const Te =
                      /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                        navigator.userAgent
                      ),
                    O = Ke("(max-width: 500px)"),
                    E = Ke("(max-height: 600px)"),
                    D = Ke("(pointer: coarse)");
                  return Te || O || (D && E);
                }
                return !1;
              },
              ft = {
                allowPhonewords: !1,
                allowDropdown: !0,
                autoPlaceholder: Ge.POLITE,
                containerClass: "",
                countryOrder: null,
                countrySearch: !0,
                customPlaceholder: null,
                dropdownContainer: null,
                excludeCountries: [],
                fixDropdownWidth: !0,
                formatAsYouType: !0,
                formatOnDisplay: !0,
                geoIpLookup: null,
                hiddenInput: null,
                i18n: {},
                initialCountry: "",
                loadUtils: null,
                nationalMode: !0,
                onlyCountries: [],
                placeholderNumberType: "MOBILE",
                showFlags: !0,
                separateDialCode: !1,
                strictMode: !1,
                useFullscreenPopup: Fe(),
                validationNumberTypes: ["MOBILE"],
              },
              lt = (Te, O) => {
                Te.useFullscreenPopup && (Te.fixDropdownWidth = !1),
                  Te.onlyCountries.length === 1 &&
                    (Te.initialCountry = Te.onlyCountries[0]),
                  Te.separateDialCode && (Te.nationalMode = !1),
                  Te.allowDropdown &&
                    !Te.showFlags &&
                    !Te.separateDialCode &&
                    (Te.nationalMode = !1),
                  Te.useFullscreenPopup &&
                    !Te.dropdownContainer &&
                    (Te.dropdownContainer = document.body),
                  (Te.i18n = { ...O, ...Te.i18n });
              },
              yt = (Te) => Te.replace(/\D/g, ""),
              mt = (Te = "") =>
                Te.normalize("NFD")
                  .replace(/[\u0300-\u036f]/g, "")
                  .toLowerCase(),
              ct = (Te, O) => {
                const E = mt(O),
                  D = [],
                  j = [],
                  H = [],
                  W = [],
                  ce = [],
                  ge = [];
                for (const Se of Te)
                  Se.iso2 === E
                    ? D.push(Se)
                    : Se.normalisedName.startsWith(E)
                    ? j.push(Se)
                    : Se.normalisedName.includes(E)
                    ? H.push(Se)
                    : E === Se.dialCode || E === Se.dialCodePlus
                    ? W.push(Se)
                    : Se.dialCodePlus.includes(E)
                    ? ce.push(Se)
                    : Se.initials.includes(E) && ge.push(Se);
                const de = (Se, We) => Se.priority - We.priority;
                return [
                  ...D.sort(de),
                  ...j.sort(de),
                  ...H.sort(de),
                  ...W.sort(de),
                  ...ce.sort(de),
                  ...ge.sort(de),
                ];
              },
              qt = (Te, O) => {
                const E = O.toLowerCase();
                for (const D of Te)
                  if (D.name.toLowerCase().startsWith(E)) return D;
                return null;
              },
              Ft = (Te) =>
                Object.keys(Te)
                  .filter((O) => !!Te[O])
                  .join(" "),
              Ye = (Te, O, E) => {
                const D = document.createElement(Te);
                return (
                  O &&
                    Object.entries(O).forEach(([j, H]) => D.setAttribute(j, H)),
                  E && E.appendChild(D),
                  D
                );
              },
              at = () => `
  <svg class="iti__search-icon-svg" width="14" height="14" viewBox="0 0 24 24" focusable="false" ${Ve.HIDDEN}="true">
    <circle cx="11" cy="11" r="7" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
  </svg>`,
              xt = (Te) => {
                const O = `iti-${Te}-clear-mask`;
                return `
    <svg class="iti__search-clear-svg" width="12" height="12" viewBox="0 0 16 16" ${Ve.HIDDEN}="true" focusable="false">
      <mask id="${O}" maskUnits="userSpaceOnUse">
        <rect width="16" height="16" fill="white" />
        <path d="M5.2 5.2 L10.8 10.8 M10.8 5.2 L5.2 10.8" stroke="black" stroke-linecap="round" class="iti__search-clear-x" />
      </mask>
      <circle cx="8" cy="8" r="8" class="iti__search-clear-bg" mask="url(#${O})" />
    </svg>`;
              },
              It = class {
                constructor(Te, O, E) {
                  (this.highlightedItem = null),
                    (Te.dataset.intlTelInputId = E.toString()),
                    (this.telInput = Te),
                    (this.options = O),
                    (this.id = E),
                    (this.hadInitialPlaceholder =
                      !!Te.getAttribute("placeholder")),
                    (this.isRTL = !!this.telInput.closest("[dir=rtl]")),
                    this.options.separateDialCode &&
                      (this.originalPaddingLeft =
                        this.telInput.style.paddingLeft);
                }
                generateMarkup(Te) {
                  (this.countries = Te), this._prepareTelInput();
                  const O = this._createWrapperAndInsert();
                  this._maybeBuildCountryContainer(O),
                    O.appendChild(this.telInput),
                    this._maybeUpdateInputPaddingAndReveal(),
                    this._maybeBuildHiddenInputs(O);
                }
                _prepareTelInput() {
                  var Te;
                  this.telInput.classList.add("iti__tel-input"),
                    !this.telInput.hasAttribute("autocomplete") &&
                      !(
                        (Te = this.telInput.form) != null &&
                        Te.hasAttribute("autocomplete")
                      ) &&
                      this.telInput.setAttribute("autocomplete", "off");
                }
                _createWrapperAndInsert() {
                  const {
                      allowDropdown: Te,
                      showFlags: O,
                      containerClass: E,
                      useFullscreenPopup: D,
                    } = this.options,
                    j = Ft({
                      iti: !0,
                      "iti--allow-dropdown": Te,
                      "iti--show-flags": O,
                      "iti--inline-dropdown": !D,
                      [E]: !!E,
                    }),
                    H = Ye("div", { class: j });
                  return (
                    this.isRTL && H.setAttribute("dir", "ltr"),
                    this.telInput.before(H),
                    H
                  );
                }
                _maybeBuildCountryContainer(Te) {
                  const {
                    allowDropdown: O,
                    separateDialCode: E,
                    showFlags: D,
                  } = this.options;
                  if (O || D || E) {
                    (this.countryContainer = Ye(
                      "div",
                      { class: `iti__country-container ${Ae.V_HIDE}` },
                      Te
                    )),
                      O
                        ? ((this.selectedCountry = Ye(
                            "button",
                            {
                              type: "button",
                              class: "iti__selected-country",
                              [Ve.EXPANDED]: "false",
                              [Ve.LABEL]: this.options.i18n.noCountrySelected,
                              [Ve.HASPOPUP]: "dialog",
                              [Ve.CONTROLS]: `iti-${this.id}__dropdown-content`,
                            },
                            this.countryContainer
                          )),
                          this.telInput.disabled &&
                            this.selectedCountry.setAttribute(
                              "disabled",
                              "true"
                            ))
                        : (this.selectedCountry = Ye(
                            "div",
                            { class: "iti__selected-country" },
                            this.countryContainer
                          ));
                    const j = Ye(
                      "div",
                      { class: "iti__selected-country-primary" },
                      this.selectedCountry
                    );
                    (this.selectedCountryInner = Ye(
                      "div",
                      { class: Ae.FLAG },
                      j
                    )),
                      O &&
                        (this.dropdownArrow = Ye(
                          "div",
                          { class: "iti__arrow", [Ve.HIDDEN]: "true" },
                          j
                        )),
                      E &&
                        (this.selectedDialCode = Ye(
                          "div",
                          { class: "iti__selected-dial-code" },
                          this.selectedCountry
                        )),
                      O && this._buildDropdownContent();
                  }
                }
                _buildDropdownContent() {
                  const {
                      fixDropdownWidth: Te,
                      useFullscreenPopup: O,
                      countrySearch: E,
                      i18n: D,
                      dropdownContainer: j,
                      containerClass: H,
                    } = this.options,
                    W = Te ? "" : "iti--flexible-dropdown-width";
                  if (
                    ((this.dropdownContent = Ye("div", {
                      id: `iti-${this.id}__dropdown-content`,
                      class: `iti__dropdown-content ${Ae.HIDE} ${W}`,
                      role: "dialog",
                      [Ve.MODAL]: "true",
                    })),
                    this.isRTL &&
                      this.dropdownContent.setAttribute("dir", "rtl"),
                    E && this._buildSearchUI(),
                    (this.countryList = Ye(
                      "ul",
                      {
                        class: "iti__country-list",
                        id: `iti-${this.id}__country-listbox`,
                        role: "listbox",
                        [Ve.LABEL]: D.countryListAriaLabel,
                      },
                      this.dropdownContent
                    )),
                    this._appendListItems(),
                    E && this.updateSearchResultsA11yText(),
                    j)
                  ) {
                    const ce = Ft({
                      iti: !0,
                      "iti--container": !0,
                      "iti--fullscreen-popup": O,
                      "iti--inline-dropdown": !O,
                      [H]: !!H,
                    });
                    (this.dropdown = Ye("div", { class: ce })),
                      this.dropdown.appendChild(this.dropdownContent);
                  } else
                    this.countryContainer.appendChild(this.dropdownContent);
                }
                _buildSearchUI() {
                  const { i18n: Te } = this.options,
                    O = Ye(
                      "div",
                      { class: "iti__search-input-wrapper" },
                      this.dropdownContent
                    );
                  (this.searchIcon = Ye(
                    "span",
                    { class: "iti__search-icon", [Ve.HIDDEN]: "true" },
                    O
                  )),
                    (this.searchIcon.innerHTML = at()),
                    (this.searchInput = Ye(
                      "input",
                      {
                        id: `iti-${this.id}__search-input`,
                        type: "search",
                        class: "iti__search-input",
                        placeholder: Te.searchPlaceholder,
                        role: "combobox",
                        [Ve.EXPANDED]: "true",
                        [Ve.LABEL]: Te.searchPlaceholder,
                        [Ve.CONTROLS]: `iti-${this.id}__country-listbox`,
                        [Ve.AUTOCOMPLETE]: "list",
                        autocomplete: "off",
                      },
                      O
                    )),
                    (this.searchClearButton = Ye(
                      "button",
                      {
                        type: "button",
                        class: `iti__search-clear ${Ae.HIDE}`,
                        [Ve.LABEL]: Te.clearSearchAriaLabel,
                        tabindex: "-1",
                      },
                      O
                    )),
                    (this.searchClearButton.innerHTML = xt(this.id)),
                    (this.searchResultsA11yText = Ye(
                      "span",
                      { class: "iti__a11y-text" },
                      this.dropdownContent
                    )),
                    (this.searchNoResults = Ye(
                      "div",
                      {
                        class: `iti__no-results ${Ae.HIDE}`,
                        [Ve.HIDDEN]: "true",
                      },
                      this.dropdownContent
                    )),
                    (this.searchNoResults.textContent = Te.zeroSearchResults);
                }
                _maybeUpdateInputPaddingAndReveal() {
                  this.countryContainer &&
                    (this.updateInputPadding(),
                    this.countryContainer.classList.remove(Ae.V_HIDE));
                }
                _maybeBuildHiddenInputs(Te) {
                  var E, D;
                  const { hiddenInput: O } = this.options;
                  if (O) {
                    const j = this.telInput.getAttribute("name") || "",
                      H = O(j);
                    if (H.phone) {
                      const W =
                        (E = this.telInput.form) == null
                          ? void 0
                          : E.querySelector(`input[name="${H.phone}"]`);
                      W
                        ? (this.hiddenInput = W)
                        : ((this.hiddenInput = Ye("input", {
                            type: "hidden",
                            name: H.phone,
                          })),
                          Te.appendChild(this.hiddenInput));
                    }
                    if (H.country) {
                      const W =
                        (D = this.telInput.form) == null
                          ? void 0
                          : D.querySelector(`input[name="${H.country}"]`);
                      W
                        ? (this.hiddenInputCountry = W)
                        : ((this.hiddenInputCountry = Ye("input", {
                            type: "hidden",
                            name: H.country,
                          })),
                          Te.appendChild(this.hiddenInputCountry));
                    }
                  }
                }
                _appendListItems() {
                  const Te = document.createDocumentFragment();
                  for (let O = 0; O < this.countries.length; O++) {
                    const E = this.countries[O],
                      D = Ft({
                        [Ae.COUNTRY_ITEM]: !0,
                        [Ae.HIGHLIGHT]: O === 0,
                      }),
                      j = Ye("li", {
                        id: `iti-${this.id}__item-${E.iso2}`,
                        class: D,
                        tabindex: "-1",
                        role: "option",
                        [Ve.SELECTED]: "false",
                      });
                    (j.dataset.dialCode = E.dialCode),
                      (j.dataset.countryCode = E.iso2),
                      (E.nodeById[this.id] = j),
                      this.options.showFlags &&
                        Ye("div", { class: `${Ae.FLAG} iti__${E.iso2}` }, j);
                    const H = Ye("span", { class: "iti__country-name" }, j);
                    H.textContent = E.name;
                    const W = Ye("span", { class: "iti__dial-code" }, j);
                    this.isRTL && W.setAttribute("dir", "ltr"),
                      (W.textContent = `+${E.dialCode}`),
                      Te.appendChild(j);
                  }
                  this.countryList.appendChild(Te);
                }
                updateInputPadding() {
                  if (this.selectedCountry) {
                    const Te = this.options.separateDialCode
                        ? Le.SANE_SELECTED_WITH_DIAL_WIDTH
                        : Le.SANE_SELECTED_NO_DIAL_WIDTH,
                      E =
                        (this.selectedCountry.offsetWidth ||
                          this._getHiddenSelectedCountryWidth() ||
                          Te) + Le.INPUT_PADDING_EXTRA_LEFT;
                    this.telInput.style.paddingLeft = `${E}px`;
                  }
                }
                _getHiddenSelectedCountryWidth() {
                  if (this.telInput.parentNode) {
                    let Te;
                    try {
                      Te = window.top.document.body;
                    } catch {
                      Te = document.body;
                    }
                    const O = this.telInput.parentNode.cloneNode(!1);
                    (O.style.visibility = "hidden"), Te.appendChild(O);
                    const E = this.countryContainer.cloneNode();
                    O.appendChild(E);
                    const D = this.selectedCountry.cloneNode(!0);
                    E.appendChild(D);
                    const j = D.offsetWidth;
                    return Te.removeChild(O), j;
                  }
                  return 0;
                }
                updateSearchResultsA11yText() {
                  const { i18n: Te } = this.options,
                    O = this.countryList.childElementCount;
                  let E;
                  O === 0
                    ? (E = Te.zeroSearchResults)
                    : Te.searchResultsText
                    ? (E = Te.searchResultsText(O))
                    : O === 1
                    ? (E = Te.oneSearchResult)
                    : (E = Te.multipleSearchResults.replace(
                        "${count}",
                        O.toString()
                      )),
                    (this.searchResultsA11yText.textContent = E);
                }
                scrollTo(Te) {
                  const O = this.countryList,
                    E = document.documentElement.scrollTop,
                    D = O.offsetHeight,
                    j = O.getBoundingClientRect().top + E,
                    H = j + D,
                    W = Te.offsetHeight,
                    ce = Te.getBoundingClientRect().top + E,
                    ge = ce + W,
                    de = ce - j + O.scrollTop;
                  if (ce < j) O.scrollTop = de;
                  else if (ge > H) {
                    const Se = D - W;
                    O.scrollTop = de - Se;
                  }
                }
                highlightListItem(Te, O) {
                  const E = this.highlightedItem;
                  if (
                    (E &&
                      (E.classList.remove(Ae.HIGHLIGHT),
                      E.setAttribute(Ve.SELECTED, "false")),
                    (this.highlightedItem = Te),
                    this.highlightedItem &&
                      (this.highlightedItem.classList.add(Ae.HIGHLIGHT),
                      this.highlightedItem.setAttribute(Ve.SELECTED, "true"),
                      this.options.countrySearch))
                  ) {
                    const D = this.highlightedItem.getAttribute("id") || "";
                    this.searchInput.setAttribute(Ve.ACTIVE_DESCENDANT, D);
                  }
                  O && this.highlightedItem.focus();
                }
                filterCountries(Te) {
                  this.countryList.innerHTML = "";
                  let O = !0;
                  for (const E of Te) {
                    const D = E.nodeById[this.id];
                    D &&
                      (this.countryList.appendChild(D),
                      O && (this.highlightListItem(D, !1), (O = !1)));
                  }
                  O
                    ? (this.highlightListItem(null, !1),
                      this.searchNoResults &&
                        this.searchNoResults.classList.remove(Ae.HIDE))
                    : this.searchNoResults &&
                      this.searchNoResults.classList.add(Ae.HIDE),
                    (this.countryList.scrollTop = 0),
                    this.updateSearchResultsA11yText();
                }
                destroy() {
                  (this.telInput.iti = void 0),
                    delete this.telInput.dataset.intlTelInputId,
                    this.options.separateDialCode &&
                      (this.telInput.style.paddingLeft =
                        this.originalPaddingLeft);
                  const Te = this.telInput.parentNode;
                  Te.before(this.telInput),
                    Te.remove(),
                    (this.telInput = null),
                    (this.countryContainer = null),
                    (this.selectedCountry = null),
                    (this.selectedCountryInner = null),
                    (this.selectedDialCode = null),
                    (this.dropdownArrow = null),
                    (this.dropdownContent = null),
                    (this.searchInput = null),
                    (this.searchIcon = null),
                    (this.searchClearButton = null),
                    (this.searchNoResults = null),
                    (this.searchResultsA11yText = null),
                    (this.countryList = null),
                    (this.dropdown = null),
                    (this.hiddenInput = null),
                    (this.hiddenInputCountry = null),
                    (this.highlightedItem = null);
                  for (const O of this.countries) delete O.nodeById[this.id];
                  this.countries = null;
                }
              },
              Tt = (Te) => {
                const { onlyCountries: O, excludeCountries: E } = Te;
                if (O.length) {
                  const D = O.map((j) => j.toLowerCase());
                  return re.filter((j) => D.includes(j.iso2));
                } else if (E.length) {
                  const D = E.map((j) => j.toLowerCase());
                  return re.filter((j) => !D.includes(j.iso2));
                }
                return re;
              },
              Mt = (Te, O) => {
                for (const E of Te) {
                  const D = E.iso2.toLowerCase();
                  O.i18n[D] && (E.name = O.i18n[D]);
                }
              },
              Wt = (Te, O) => {
                const E = new Set();
                let D = 0;
                const j = {},
                  H = (W, ce, ge) => {
                    if (!W || !ce) return;
                    ce.length > D && (D = ce.length),
                      j.hasOwnProperty(ce) || (j[ce] = []);
                    const de = j[ce];
                    if (de.includes(W)) return;
                    const Se = ge !== void 0 ? ge : de.length;
                    de[Se] = W;
                  };
                for (const W of Te) {
                  E.has(W.dialCode) || E.add(W.dialCode);
                  for (let ce = 1; ce < W.dialCode.length; ce++) {
                    const ge = W.dialCode.substring(0, ce);
                    H(W.iso2, ge);
                  }
                  H(W.iso2, W.dialCode, W.priority);
                }
                (O.onlyCountries.length || O.excludeCountries.length) &&
                  E.forEach((W) => {
                    j[W] = j[W].filter(Boolean);
                  });
                for (const W of Te)
                  if (W.areaCodes) {
                    const ce = j[W.dialCode][0];
                    for (const ge of W.areaCodes) {
                      for (let de = 1; de < ge.length; de++) {
                        const Se = ge.substring(0, de),
                          We = W.dialCode + Se;
                        H(ce, We), H(W.iso2, We);
                      }
                      H(W.iso2, W.dialCode + ge);
                    }
                  }
                return {
                  dialCodes: E,
                  dialCodeMaxLen: D,
                  dialCodeToIso2Map: j,
                };
              },
              Bt = (Te, O) => {
                O.countryOrder &&
                  (O.countryOrder = O.countryOrder.map((E) => E.toLowerCase())),
                  Te.sort((E, D) => {
                    const { countryOrder: j } = O;
                    if (j) {
                      const H = j.indexOf(E.iso2),
                        W = j.indexOf(D.iso2),
                        ce = H > -1,
                        ge = W > -1;
                      if (ce || ge) return ce && ge ? H - W : ce ? -1 : 1;
                    }
                    return E.name.localeCompare(D.name);
                  });
              },
              Gt = (Te) => {
                for (const O of Te)
                  (O.normalisedName = mt(O.name)),
                    (O.initials = O.normalisedName
                      .split(/[^a-z]/)
                      .map((E) => E[0])
                      .join("")),
                    (O.dialCodePlus = `+${O.dialCode}`);
              },
              At = (Te, O, E, D) => {
                let j = Te;
                if (E && O) {
                  O = `+${D.dialCode}`;
                  const H =
                    j[O.length] === " " || j[O.length] === "-"
                      ? O.length + 1
                      : O.length;
                  j = j.substring(H);
                }
                return j;
              },
              Xt = (Te, O, E, D, j) => {
                const H = E ? E.formatNumberAsYouType(Te, D.iso2) : Te,
                  { dialCode: W } = D;
                return j && O.charAt(0) !== "+" && H.includes(`+${W}`)
                  ? (H.split(`+${W}`)[1] || "").trim()
                  : H;
              },
              Lt = (Te, O, E, D) => {
                if (E === 0 && !D) return 0;
                let j = 0;
                for (let H = 0; H < O.length; H++) {
                  if ((/[+0-9]/.test(O[H]) && j++, j === Te && !D))
                    return H + 1;
                  if (D && j === Te + 1) return H;
                }
                return O.length;
              },
              Nt = [
                "800",
                "822",
                "833",
                "844",
                "855",
                "866",
                "877",
                "880",
                "881",
                "882",
                "883",
                "884",
                "885",
                "886",
                "887",
                "888",
                "889",
              ],
              jt = (Te) => {
                const O = yt(Te);
                if (O.startsWith(nt.NANP) && O.length >= 4) {
                  const E = O.substring(1, 4);
                  return Nt.includes(E);
                }
                return !1;
              };
            for (const Te of re) Te.name = Ee[Te.iso2];
            var mr = 0,
              ir = new Set(re.map((Te) => Te.iso2)),
              vr = (Te) => ir.has(Te),
              ar = class $y {
                constructor(O, E = {}) {
                  (this.id = mr++),
                    (this.options = { ...ft, ...E }),
                    lt(this.options, Ee),
                    (this.ui = new It(O, this.options, this.id)),
                    (this.isAndroid = $y._getIsAndroid()),
                    (this.promise = this._createInitPromises()),
                    (this.countries = Tt(this.options));
                  const {
                    dialCodes: D,
                    dialCodeMaxLen: j,
                    dialCodeToIso2Map: H,
                  } = Wt(this.countries, this.options);
                  (this.dialCodes = D),
                    (this.dialCodeMaxLen = j),
                    (this.dialCodeToIso2Map = H),
                    (this.countryByIso2 = new Map(
                      this.countries.map((W) => [W.iso2, W])
                    )),
                    this._init();
                }
                static _getIsAndroid() {
                  return typeof navigator < "u"
                    ? /Android/i.test(navigator.userAgent)
                    : !1;
                }
                _createInitPromises() {
                  const O = new Promise((D, j) => {
                      (this.resolveAutoCountryPromise = D),
                        (this.rejectAutoCountryPromise = j);
                    }),
                    E = new Promise((D, j) => {
                      (this.resolveUtilsScriptPromise = D),
                        (this.rejectUtilsScriptPromise = j);
                    });
                  return Promise.all([O, E]);
                }
                _init() {
                  (this.selectedCountryData = {}),
                    (this.abortController = new AbortController()),
                    this._processCountryData(),
                    this.ui.generateMarkup(this.countries),
                    this._setInitialState(),
                    this._initListeners(),
                    this._initRequests();
                }
                _processCountryData() {
                  Mt(this.countries, this.options),
                    Bt(this.countries, this.options),
                    Gt(this.countries);
                }
                _setInitialState(O = !1) {
                  const E = this.ui.telInput.getAttribute("value"),
                    D = this.ui.telInput.value,
                    H =
                      E && E.startsWith("+") && (!D || !D.startsWith("+"))
                        ? E
                        : D,
                    W = this._getDialCode(H),
                    ce = jt(H),
                    { initialCountry: ge, geoIpLookup: de } = this.options,
                    Se = ge === bt.AUTO && de;
                  if (W && !ce) this._updateCountryFromNumber(H);
                  else if (!Se || O) {
                    const We = ge ? ge.toLowerCase() : "";
                    vr(We)
                      ? this._setCountry(We)
                      : W && ce
                      ? this._setCountry(je.ISO2)
                      : this._setCountry("");
                  }
                  H && this._updateValFromNumber(H);
                }
                _initListeners() {
                  this._initTelInputListeners(),
                    this.options.allowDropdown && this._initDropdownListeners(),
                    (this.ui.hiddenInput || this.ui.hiddenInputCountry) &&
                      this.ui.telInput.form &&
                      this._initHiddenInputListener();
                }
                _initHiddenInputListener() {
                  var E;
                  const O = () => {
                    this.ui.hiddenInput &&
                      (this.ui.hiddenInput.value = this.getNumber()),
                      this.ui.hiddenInputCountry &&
                        (this.ui.hiddenInputCountry.value =
                          this.selectedCountryData.iso2 || "");
                  };
                  (E = this.ui.telInput.form) == null ||
                    E.addEventListener("submit", O, {
                      signal: this.abortController.signal,
                    });
                }
                _initDropdownListeners() {
                  const O = this.abortController.signal,
                    E = (W) => {
                      this.ui.dropdownContent.classList.contains(Ae.HIDE)
                        ? this.ui.telInput.focus()
                        : W.preventDefault();
                    },
                    D = this.ui.telInput.closest("label");
                  D && D.addEventListener("click", E, { signal: O });
                  const j = () => {
                    this.ui.dropdownContent.classList.contains(Ae.HIDE) &&
                      !this.ui.telInput.disabled &&
                      !this.ui.telInput.readOnly &&
                      this._openDropdown();
                  };
                  this.ui.selectedCountry.addEventListener("click", j, {
                    signal: O,
                  });
                  const H = (W) => {
                    this.ui.dropdownContent.classList.contains(Ae.HIDE) &&
                      [qe.ARROW_UP, qe.ARROW_DOWN, qe.SPACE, qe.ENTER].includes(
                        W.key
                      ) &&
                      (W.preventDefault(),
                      W.stopPropagation(),
                      this._openDropdown()),
                      W.key === qe.TAB && this._closeDropdown();
                  };
                  this.ui.countryContainer.addEventListener("keydown", H, {
                    signal: O,
                  });
                }
                _initRequests() {
                  const {
                    loadUtils: O,
                    initialCountry: E,
                    geoIpLookup: D,
                  } = this.options;
                  if (O && !Dt.utils) {
                    const H = () => {
                      var W;
                      (W = Dt.attachUtils(O)) == null || W.catch(() => {});
                    };
                    if (Dt.documentReady()) H();
                    else {
                      const W = () => {
                        H();
                      };
                      window.addEventListener("load", W, {
                        signal: this.abortController.signal,
                      });
                    }
                  } else this.resolveUtilsScriptPromise();
                  E === bt.AUTO && D && !this.selectedCountryData.iso2
                    ? this._loadAutoCountry()
                    : this.resolveAutoCountryPromise();
                }
                _loadAutoCountry() {
                  Dt.autoCountry
                    ? this.handleAutoCountry()
                    : Dt.startedLoadingAutoCountry ||
                      ((Dt.startedLoadingAutoCountry = !0),
                      typeof this.options.geoIpLookup == "function" &&
                        this.options.geoIpLookup(
                          (O = "") => {
                            const E = O.toLowerCase();
                            vr(E)
                              ? ((Dt.autoCountry = E),
                                setTimeout(() => tr("handleAutoCountry")))
                              : (this._setInitialState(!0),
                                tr("rejectAutoCountryPromise"));
                          },
                          () => {
                            this._setInitialState(!0),
                              tr("rejectAutoCountryPromise");
                          }
                        ));
                }
                _openDropdownWithPlus() {
                  this._openDropdown(),
                    (this.ui.searchInput.value = "+"),
                    this._filterCountriesByQuery("");
                }
                _initTelInputListeners() {
                  this._bindInputListener(),
                    this._maybeBindKeydownListener(),
                    this._maybeBindPasteListener();
                }
                _bindInputListener() {
                  const {
                    strictMode: O,
                    formatAsYouType: E,
                    separateDialCode: D,
                    allowDropdown: j,
                    countrySearch: H,
                  } = this.options;
                  let W = !1;
                  Be.ALPHA_UNICODE.test(this.ui.telInput.value) && (W = !0);
                  const ce = (ge) => {
                    if (
                      this.isAndroid &&
                      (ge == null ? void 0 : ge.data) === "+" &&
                      D &&
                      j &&
                      H
                    ) {
                      const Ze = this.ui.telInput.selectionStart || 0,
                        Ct = this.ui.telInput.value.substring(0, Ze - 1),
                        _e = this.ui.telInput.value.substring(Ze);
                      (this.ui.telInput.value = Ct + _e),
                        this._openDropdownWithPlus();
                      return;
                    }
                    this._updateCountryFromNumber(this.ui.telInput.value) &&
                      this._triggerCountryChange();
                    const de =
                        (ge == null ? void 0 : ge.data) &&
                        Be.NON_PLUS_NUMERIC.test(ge.data),
                      Se =
                        (ge == null ? void 0 : ge.inputType) === Ue.PASTE &&
                        this.ui.telInput.value;
                    de || (Se && !O)
                      ? (W = !0)
                      : Be.NON_PLUS_NUMERIC.test(this.ui.telInput.value) ||
                        (W = !1);
                    const We =
                      (ge == null ? void 0 : ge.detail) &&
                      ge.detail.isSetNumber;
                    if (E && !W && !We) {
                      const Ze = this.ui.telInput.selectionStart || 0,
                        _e = this.ui.telInput.value
                          .substring(0, Ze)
                          .replace(Be.NON_PLUS_NUMERIC_GLOBAL, "").length,
                        Vt =
                          (ge == null ? void 0 : ge.inputType) ===
                          Ue.DELETE_FWD,
                        cr = this._getFullNumber(),
                        Ot = Xt(
                          cr,
                          this.ui.telInput.value,
                          Dt.utils,
                          this.selectedCountryData,
                          this.options.separateDialCode
                        ),
                        ur = Lt(_e, Ot, Ze, Vt);
                      (this.ui.telInput.value = Ot),
                        this.ui.telInput.setSelectionRange(ur, ur);
                    }
                  };
                  this.ui.telInput.addEventListener("input", ce, {
                    signal: this.abortController.signal,
                  });
                }
                _maybeBindKeydownListener() {
                  const {
                    strictMode: O,
                    separateDialCode: E,
                    allowDropdown: D,
                    countrySearch: j,
                  } = this.options;
                  if (O || E) {
                    const H = (W) => {
                      if (
                        W.key &&
                        W.key.length === 1 &&
                        !W.altKey &&
                        !W.ctrlKey &&
                        !W.metaKey
                      ) {
                        if (E && D && j && W.key === "+") {
                          W.preventDefault(), this._openDropdownWithPlus();
                          return;
                        }
                        if (O) {
                          const ce = this.ui.telInput.value,
                            de =
                              !ce.startsWith("+") &&
                              this.ui.telInput.selectionStart === 0 &&
                              W.key === "+",
                            Se = /^[0-9]$/.test(W.key),
                            We = E ? Se : de || Se,
                            Ze =
                              ce.slice(0, this.ui.telInput.selectionStart) +
                              W.key +
                              ce.slice(this.ui.telInput.selectionEnd),
                            Ct = this._getFullNumber(Ze),
                            _e = Dt.utils.getCoreNumber(
                              Ct,
                              this.selectedCountryData.iso2
                            ),
                            Vt =
                              this.maxCoreNumberLength &&
                              _e.length > this.maxCoreNumberLength,
                            Ot = this._getNewCountryFromNumber(Ct) !== null;
                          (!We || (Vt && !Ot && !de)) && W.preventDefault();
                        }
                      }
                    };
                    this.ui.telInput.addEventListener("keydown", H, {
                      signal: this.abortController.signal,
                    });
                  }
                }
                _maybeBindPasteListener() {
                  if (this.options.strictMode) {
                    const O = (E) => {
                      E.preventDefault();
                      const D = this.ui.telInput,
                        j = D.selectionStart,
                        H = D.selectionEnd,
                        W = D.value.slice(0, j),
                        ce = D.value.slice(H),
                        ge = this.selectedCountryData.iso2,
                        de = E.clipboardData.getData("text"),
                        Se = j === 0 && H > 0,
                        We = !D.value.startsWith("+") || Se,
                        Ze = de.replace(Be.NON_PLUS_NUMERIC_GLOBAL, ""),
                        Ct = Ze.startsWith("+"),
                        _e = Ze.replace(/\+/g, ""),
                        Vt = Ct && We ? `+${_e}` : _e;
                      let cr = W + Vt + ce,
                        Ot = Dt.utils.getCoreNumber(cr, ge);
                      for (; Ot.length === 0 && cr.length > 0; )
                        (cr = cr.slice(0, -1)),
                          (Ot = Dt.utils.getCoreNumber(cr, ge));
                      if (!Ot) return;
                      if (
                        this.maxCoreNumberLength &&
                        Ot.length > this.maxCoreNumberLength
                      )
                        if (D.selectionEnd === D.value.length) {
                          const Nr = Ot.length - this.maxCoreNumberLength;
                          cr = cr.slice(0, cr.length - Nr);
                        } else return;
                      D.value = cr;
                      const ur = j + Vt.length;
                      D.setSelectionRange(ur, ur),
                        D.dispatchEvent(
                          new InputEvent("input", { bubbles: !0 })
                        );
                    };
                    this.ui.telInput.addEventListener("paste", O, {
                      signal: this.abortController.signal,
                    });
                  }
                }
                _cap(O) {
                  const E = Number(this.ui.telInput.getAttribute("maxlength"));
                  return E && O.length > E ? O.substring(0, E) : O;
                }
                _trigger(O, E = {}) {
                  const D = new CustomEvent(O, {
                    bubbles: !0,
                    cancelable: !0,
                    detail: E,
                  });
                  this.ui.telInput.dispatchEvent(D);
                }
                _openDropdown() {
                  const { fixDropdownWidth: O, countrySearch: E } =
                    this.options;
                  if (
                    ((this.dropdownAbortController = new AbortController()),
                    O &&
                      (this.ui.dropdownContent.style.width = `${this.ui.telInput.offsetWidth}px`),
                    this.ui.dropdownContent.classList.remove(Ae.HIDE),
                    this.ui.selectedCountry.setAttribute(Ve.EXPANDED, "true"),
                    this._setDropdownPosition(),
                    E)
                  ) {
                    const D = this.ui.countryList.firstElementChild;
                    D &&
                      (this.ui.highlightListItem(D, !1),
                      (this.ui.countryList.scrollTop = 0)),
                      this.ui.searchInput.focus();
                  }
                  this._bindDropdownListeners(),
                    this.ui.dropdownArrow.classList.add(Ae.ARROW_UP),
                    this._trigger(De.OPEN_COUNTRY_DROPDOWN);
                }
                _setDropdownPosition() {
                  if (
                    (this.options.dropdownContainer &&
                      this.options.dropdownContainer.appendChild(
                        this.ui.dropdown
                      ),
                    !this.options.useFullscreenPopup)
                  ) {
                    const O = this.ui.telInput.getBoundingClientRect(),
                      E = this.ui.telInput.offsetHeight;
                    if (this.options.dropdownContainer) {
                      (this.ui.dropdown.style.top = `${O.top + E}px`),
                        (this.ui.dropdown.style.left = `${O.left}px`);
                      const D = () => this._closeDropdown();
                      window.addEventListener("scroll", D, {
                        signal: this.dropdownAbortController.signal,
                      });
                    }
                  }
                }
                _bindDropdownListeners() {
                  const O = this.dropdownAbortController.signal;
                  this._bindDropdownMouseoverListener(O),
                    this._bindDropdownCountryClickListener(O),
                    this._bindDropdownClickOffListener(O),
                    this._bindDropdownKeydownListener(O),
                    this.options.countrySearch &&
                      this._bindDropdownSearchListeners(O);
                }
                _bindDropdownMouseoverListener(O) {
                  const E = (D) => {
                    var H;
                    const j =
                      (H = D.target) == null
                        ? void 0
                        : H.closest(`.${Ae.COUNTRY_ITEM}`);
                    j && this.ui.highlightListItem(j, !1);
                  };
                  this.ui.countryList.addEventListener("mouseover", E, {
                    signal: O,
                  });
                }
                _bindDropdownCountryClickListener(O) {
                  const E = (D) => {
                    var H;
                    const j =
                      (H = D.target) == null
                        ? void 0
                        : H.closest(`.${Ae.COUNTRY_ITEM}`);
                    j && this._selectListItem(j);
                  };
                  this.ui.countryList.addEventListener("click", E, {
                    signal: O,
                  });
                }
                _bindDropdownClickOffListener(O) {
                  const E = (D) => {
                    !!D.target.closest(`#iti-${this.id}__dropdown-content`) ||
                      this._closeDropdown();
                  };
                  setTimeout(() => {
                    document.documentElement.addEventListener("click", E, {
                      signal: O,
                    });
                  }, 0);
                }
                _bindDropdownKeydownListener(O) {
                  let E = "",
                    D = null;
                  const j = (H) => {
                    [qe.ARROW_UP, qe.ARROW_DOWN, qe.ENTER, qe.ESC].includes(
                      H.key
                    ) &&
                      (H.preventDefault(),
                      H.stopPropagation(),
                      H.key === qe.ARROW_UP || H.key === qe.ARROW_DOWN
                        ? this._handleUpDownKey(H.key)
                        : H.key === qe.ENTER
                        ? this._handleEnterKey()
                        : H.key === qe.ESC && this._closeDropdown()),
                      !this.options.countrySearch &&
                        Be.HIDDEN_SEARCH_CHAR.test(H.key) &&
                        (H.stopPropagation(),
                        D && clearTimeout(D),
                        (E += H.key.toLowerCase()),
                        this._searchForCountry(E),
                        (D = setTimeout(() => {
                          E = "";
                        }, ke.HIDDEN_SEARCH_RESET_MS)));
                  };
                  document.addEventListener("keydown", j, { signal: O });
                }
                _bindDropdownSearchListeners(O) {
                  const E = () => {
                    const W = this.ui.searchInput.value.trim();
                    this._filterCountriesByQuery(W),
                      this.ui.searchInput.value
                        ? this.ui.searchClearButton.classList.remove(Ae.HIDE)
                        : this.ui.searchClearButton.classList.add(Ae.HIDE);
                  };
                  let D = null;
                  const j = () => {
                    D && clearTimeout(D),
                      (D = setTimeout(() => {
                        E(), (D = null);
                      }, 100));
                  };
                  this.ui.searchInput.addEventListener("input", j, {
                    signal: O,
                  });
                  const H = () => {
                    (this.ui.searchInput.value = ""),
                      this.ui.searchInput.focus(),
                      E();
                  };
                  this.ui.searchClearButton.addEventListener("click", H, {
                    signal: O,
                  });
                }
                _searchForCountry(O) {
                  const E = qt(this.countries, O);
                  if (E) {
                    const D = E.nodeById[this.id];
                    this.ui.highlightListItem(D, !1), this.ui.scrollTo(D);
                  }
                }
                _filterCountriesByQuery(O) {
                  let E;
                  O === "" ? (E = this.countries) : (E = ct(this.countries, O)),
                    this.ui.filterCountries(E);
                }
                _handleUpDownKey(O) {
                  var D, j;
                  let E =
                    O === qe.ARROW_UP
                      ? (D = this.ui.highlightedItem) == null
                        ? void 0
                        : D.previousElementSibling
                      : (j = this.ui.highlightedItem) == null
                      ? void 0
                      : j.nextElementSibling;
                  !E &&
                    this.ui.countryList.childElementCount > 1 &&
                    (E =
                      O === qe.ARROW_UP
                        ? this.ui.countryList.lastElementChild
                        : this.ui.countryList.firstElementChild),
                    E &&
                      (this.ui.scrollTo(E), this.ui.highlightListItem(E, !1));
                }
                _handleEnterKey() {
                  this.ui.highlightedItem &&
                    this._selectListItem(this.ui.highlightedItem);
                }
                _updateValFromNumber(O) {
                  let E = O;
                  if (
                    this.options.formatOnDisplay &&
                    Dt.utils &&
                    this.selectedCountryData
                  ) {
                    const D =
                        this.options.nationalMode ||
                        (!E.startsWith("+") && !this.options.separateDialCode),
                      { NATIONAL: j, INTERNATIONAL: H } = Dt.utils.numberFormat,
                      W = D ? j : H;
                    E = Dt.utils.formatNumber(
                      E,
                      this.selectedCountryData.iso2,
                      W
                    );
                  }
                  (E = this._beforeSetNumber(E)), (this.ui.telInput.value = E);
                }
                _updateCountryFromNumber(O) {
                  const E = this._getNewCountryFromNumber(O);
                  return E !== null ? this._setCountry(E) : !1;
                }
                _ensureHasDialCode(O) {
                  const { dialCode: E, nationalPrefix: D } =
                    this.selectedCountryData;
                  if (O.startsWith("+") || !E) return O;
                  const W =
                    D && O.startsWith(D) && !this.options.separateDialCode
                      ? O.substring(1)
                      : O;
                  return `+${E}${W}`;
                }
                _getNewCountryFromNumber(O) {
                  const E = O.indexOf("+");
                  let D = E ? O.substring(E) : O;
                  const j = this.selectedCountryData.iso2,
                    H = this.selectedCountryData.dialCode;
                  D = this._ensureHasDialCode(D);
                  const W = this._getDialCode(D, !0),
                    ce = yt(D);
                  if (W) {
                    const ge = yt(W),
                      de = this.dialCodeToIso2Map[ge];
                    if (de.length === 1) return de[0] === j ? null : de[0];
                    if (
                      !j &&
                      this.defaultCountry &&
                      de.includes(this.defaultCountry)
                    )
                      return this.defaultCountry;
                    if (H === nt.NANP && jt(ce)) return null;
                    const { areaCodes: We, priority: Ze } =
                      this.selectedCountryData;
                    if (We) {
                      const Ot = We.map((ur) => `${H}${ur}`);
                      for (const ur of Ot) if (ce.startsWith(ur)) return null;
                    }
                    const _e = We && !(Ze === 0) && ce.length > ge.length,
                      Vt = j && de.includes(j) && !_e,
                      cr = j === de[0];
                    if (!Vt && !cr) return de[0];
                  } else if (D.startsWith("+") && ce.length) {
                    const ge = this.selectedCountryData.dialCode || "";
                    return ge && ge.startsWith(ce) ? null : "";
                  } else if ((!D || D === "+") && !j)
                    return this.defaultCountry;
                  return null;
                }
                _setCountry(O) {
                  const {
                      separateDialCode: E,
                      showFlags: D,
                      i18n: j,
                    } = this.options,
                    H = this.selectedCountryData.iso2 || "";
                  if (
                    ((this.selectedCountryData = O
                      ? this.countryByIso2.get(O)
                      : {}),
                    this.selectedCountryData.iso2 &&
                      (this.defaultCountry = this.selectedCountryData.iso2),
                    this.ui.selectedCountry)
                  ) {
                    const W =
                      O && D
                        ? `${Ae.FLAG} iti__${O}`
                        : `${Ae.FLAG} ${Ae.GLOBE}`;
                    let ce, ge;
                    if (O) {
                      const { name: de, dialCode: Se } =
                        this.selectedCountryData;
                      (ge = de),
                        (ce = j.selectedCountryAriaLabel
                          .replace("${countryName}", de)
                          .replace("${dialCode}", `+${Se}`));
                    } else
                      (ge = j.noCountrySelected), (ce = j.noCountrySelected);
                    (this.ui.selectedCountryInner.className = W),
                      this.ui.selectedCountry.setAttribute("title", ge),
                      this.ui.selectedCountry.setAttribute(Ve.LABEL, ce);
                  }
                  if (E) {
                    const W = this.selectedCountryData.dialCode
                      ? `+${this.selectedCountryData.dialCode}`
                      : "";
                    (this.ui.selectedDialCode.textContent = W),
                      this.ui.updateInputPadding();
                  }
                  return (
                    this._updatePlaceholder(), this._updateMaxLength(), H !== O
                  );
                }
                _updateMaxLength() {
                  const {
                      strictMode: O,
                      placeholderNumberType: E,
                      validationNumberTypes: D,
                    } = this.options,
                    { iso2: j } = this.selectedCountryData;
                  if (O && Dt.utils)
                    if (j) {
                      const H = Dt.utils.numberType[E];
                      let W = Dt.utils.getExampleNumber(j, !1, H, !0),
                        ce = W;
                      for (; Dt.utils.isPossibleNumber(W, j, D); )
                        (ce = W), (W += "0");
                      const ge = Dt.utils.getCoreNumber(ce, j);
                      (this.maxCoreNumberLength = ge.length),
                        j === "by" &&
                          (this.maxCoreNumberLength = ge.length + 1);
                    } else this.maxCoreNumberLength = null;
                }
                _updatePlaceholder() {
                  const {
                      autoPlaceholder: O,
                      placeholderNumberType: E,
                      nationalMode: D,
                      customPlaceholder: j,
                    } = this.options,
                    H =
                      O === Ge.AGGRESSIVE ||
                      (!this.ui.hadInitialPlaceholder && O === Ge.POLITE);
                  if (Dt.utils && H) {
                    const W = Dt.utils.numberType[E];
                    let ce = this.selectedCountryData.iso2
                      ? Dt.utils.getExampleNumber(
                          this.selectedCountryData.iso2,
                          D,
                          W
                        )
                      : "";
                    (ce = this._beforeSetNumber(ce)),
                      typeof j == "function" &&
                        (ce = j(ce, this.selectedCountryData)),
                      this.ui.telInput.setAttribute("placeholder", ce);
                  }
                }
                _selectListItem(O) {
                  const E = O.dataset[Xe.COUNTRY_CODE],
                    D = this._setCountry(E);
                  this._closeDropdown();
                  const j = O.dataset[Xe.DIAL_CODE];
                  this._updateDialCode(j),
                    this.options.formatOnDisplay &&
                      this._updateValFromNumber(this.ui.telInput.value),
                    this.ui.telInput.focus(),
                    D && this._triggerCountryChange();
                }
                _closeDropdown() {
                  this.ui.dropdownContent.classList.contains(Ae.HIDE) ||
                    (this.ui.dropdownContent.classList.add(Ae.HIDE),
                    this.ui.selectedCountry.setAttribute(Ve.EXPANDED, "false"),
                    this.ui.highlightedItem &&
                      this.ui.highlightedItem.setAttribute(
                        Ve.SELECTED,
                        "false"
                      ),
                    this.options.countrySearch &&
                      this.ui.searchInput.removeAttribute(Ve.ACTIVE_DESCENDANT),
                    this.ui.dropdownArrow.classList.remove(Ae.ARROW_UP),
                    this.dropdownAbortController.abort(),
                    (this.dropdownAbortController = null),
                    this.options.dropdownContainer && this.ui.dropdown.remove(),
                    this._trigger(De.CLOSE_COUNTRY_DROPDOWN));
                }
                _updateDialCode(O) {
                  const E = this.ui.telInput.value,
                    D = `+${O}`;
                  let j;
                  if (E.startsWith("+")) {
                    const H = this._getDialCode(E);
                    H ? (j = E.replace(H, D)) : (j = D),
                      (this.ui.telInput.value = j);
                  }
                }
                _getDialCode(O, E) {
                  let D = "";
                  if (O.startsWith("+")) {
                    let j = "",
                      H = !1;
                    for (let W = 0; W < O.length; W++) {
                      const ce = O.charAt(W);
                      if (/[0-9]/.test(ce)) {
                        if (((j += ce), !!!this.dialCodeToIso2Map[j])) break;
                        if (this.dialCodes.has(j)) {
                          if (((D = O.substring(0, W + 1)), (H = !0), !E))
                            break;
                        } else E && H && (D = O.substring(0, W + 1));
                        if (j.length === this.dialCodeMaxLen) break;
                      }
                    }
                  }
                  return D;
                }
                _getFullNumber(O) {
                  const E = O || this.ui.telInput.value.trim(),
                    { dialCode: D } = this.selectedCountryData;
                  let j;
                  const H = yt(E);
                  return (
                    this.options.separateDialCode &&
                    !E.startsWith("+") &&
                    D &&
                    H
                      ? (j = `+${D}`)
                      : (j = ""),
                    j + E
                  );
                }
                _beforeSetNumber(O) {
                  const E = this._getDialCode(O),
                    D = At(
                      O,
                      E,
                      this.options.separateDialCode,
                      this.selectedCountryData
                    );
                  return this._cap(D);
                }
                _triggerCountryChange() {
                  this._trigger(De.COUNTRY_CHANGE);
                }
                handleAutoCountry() {
                  this.options.initialCountry === bt.AUTO &&
                    Dt.autoCountry &&
                    ((this.defaultCountry = Dt.autoCountry),
                    this.selectedCountryData.iso2 ||
                      this.ui.selectedCountryInner.classList.contains(
                        Ae.GLOBE
                      ) ||
                      this.setCountry(this.defaultCountry),
                    this.resolveAutoCountryPromise());
                }
                handleUtils() {
                  Dt.utils &&
                    (this.ui.telInput.value &&
                      this._updateValFromNumber(this.ui.telInput.value),
                    this.selectedCountryData.iso2 &&
                      (this._updatePlaceholder(), this._updateMaxLength())),
                    this.resolveUtilsScriptPromise();
                }
                destroy() {
                  this.ui.telInput &&
                    (this.options.allowDropdown && this._closeDropdown(),
                    this.abortController.abort(),
                    (this.abortController = null),
                    this.ui.destroy(),
                    Dt.instances instanceof Map
                      ? Dt.instances.delete(this.id)
                      : delete Dt.instances[this.id]);
                }
                getExtension() {
                  return Dt.utils
                    ? Dt.utils.getExtension(
                        this._getFullNumber(),
                        this.selectedCountryData.iso2
                      )
                    : "";
                }
                getNumber(O) {
                  if (Dt.utils) {
                    const { iso2: E } = this.selectedCountryData;
                    return Dt.utils.formatNumber(this._getFullNumber(), E, O);
                  }
                  return "";
                }
                getNumberType() {
                  return Dt.utils
                    ? Dt.utils.getNumberType(
                        this._getFullNumber(),
                        this.selectedCountryData.iso2
                      )
                    : $e.UNKNOWN_NUMBER_TYPE;
                }
                getSelectedCountryData() {
                  return this.selectedCountryData;
                }
                getValidationError() {
                  if (Dt.utils) {
                    const { iso2: O } = this.selectedCountryData;
                    return Dt.utils.getValidationError(
                      this._getFullNumber(),
                      O
                    );
                  }
                  return $e.UNKNOWN_VALIDATION_ERROR;
                }
                isValidNumber() {
                  const { dialCode: O, iso2: E } = this.selectedCountryData;
                  if (O === dt.DIAL_CODE && Dt.utils) {
                    const D = this._getFullNumber(),
                      j = Dt.utils.getCoreNumber(D, E);
                    if (
                      j[0] === dt.MOBILE_PREFIX &&
                      j.length !== dt.MOBILE_CORE_LENGTH
                    )
                      return !1;
                  }
                  return this._validateNumber(!1);
                }
                isValidNumberPrecise() {
                  return this._validateNumber(!0);
                }
                _utilsIsPossibleNumber(O) {
                  return Dt.utils
                    ? Dt.utils.isPossibleNumber(
                        O,
                        this.selectedCountryData.iso2,
                        this.options.validationNumberTypes
                      )
                    : null;
                }
                _validateNumber(O) {
                  if (!Dt.utils) return null;
                  if (!this.selectedCountryData.iso2) return !1;
                  const E = (W) =>
                      O
                        ? this._utilsIsValidNumber(W)
                        : this._utilsIsPossibleNumber(W),
                    D = this._getFullNumber(),
                    j = D.search(Be.ALPHA_UNICODE);
                  if (j > -1 && !this.options.allowPhonewords) {
                    const W = D.substring(0, j),
                      ce = E(W),
                      ge = E(D);
                    return ce && ge;
                  }
                  return E(D);
                }
                _utilsIsValidNumber(O) {
                  return Dt.utils
                    ? Dt.utils.isValidNumber(
                        O,
                        this.selectedCountryData.iso2,
                        this.options.validationNumberTypes
                      )
                    : null;
                }
                setCountry(O) {
                  const E = O == null ? void 0 : O.toLowerCase();
                  if (!vr(E)) throw new Error(`Invalid country code: '${E}'`);
                  const D = this.selectedCountryData.iso2;
                  ((O && E !== D) || (!O && D)) &&
                    (this._setCountry(E),
                    this._updateDialCode(this.selectedCountryData.dialCode),
                    this.options.formatOnDisplay &&
                      this._updateValFromNumber(this.ui.telInput.value),
                    this._triggerCountryChange());
                }
                setNumber(O) {
                  const E = this._updateCountryFromNumber(O);
                  this._updateValFromNumber(O),
                    E && this._triggerCountryChange(),
                    this._trigger(De.INPUT, { isSetNumber: !0 });
                }
                setPlaceholderNumberType(O) {
                  (this.options.placeholderNumberType = O),
                    this._updatePlaceholder();
                }
                setDisabled(O) {
                  (this.ui.telInput.disabled = O),
                    O
                      ? this.ui.selectedCountry.setAttribute("disabled", "true")
                      : this.ui.selectedCountry.removeAttribute("disabled");
                }
              },
              pr = (Te) => {
                if (!Dt.utils && !Dt.startedLoadingUtilsScript) {
                  let O;
                  if (typeof Te == "function")
                    try {
                      O = Promise.resolve(Te());
                    } catch (E) {
                      return Promise.reject(E);
                    }
                  else
                    return Promise.reject(
                      new TypeError(
                        `The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Te}`
                      )
                    );
                  return (
                    (Dt.startedLoadingUtilsScript = !0),
                    O.then((E) => {
                      const D = E == null ? void 0 : E.default;
                      if (!D || typeof D != "object")
                        throw new TypeError(
                          "The loader function passed to attachUtils did not resolve to a module object with utils as its default export."
                        );
                      return (Dt.utils = D), tr("handleUtils"), !0;
                    }).catch((E) => {
                      throw (tr("rejectUtilsScriptPromise", E), E);
                    })
                  );
                }
                return null;
              },
              tr = (Te, ...O) => {
                Object.values(Dt.instances).forEach((E) => {
                  const D = E[Te];
                  typeof D == "function" && D.apply(E, O);
                });
              },
              Dt = Object.assign(
                (Te, O) => {
                  const E = new ar(Te, O);
                  return (Dt.instances[E.id] = E), (Te.iti = E), E;
                },
                {
                  defaults: ft,
                  documentReady: () => document.readyState === "complete",
                  getCountryData: () => re,
                  getInstance: (Te) => {
                    const O = Te.dataset.intlTelInputId;
                    return O ? Dt.instances[O] : null;
                  },
                  instances: {},
                  attachUtils: pr,
                  startedLoadingUtilsScript: !1,
                  startedLoadingAutoCountry: !1,
                  version: "25.12.5",
                }
              ),
              Sr = Dt;
            return B(N);
          })();
          return o.default;
        });
      })(ym)),
    ym.exports
  );
}
var l7 = s7();
const c7 = J0(l7);
var u7 = me(
    '<div><span class="loading loading-spinner loading-xl"></span></div>'
  ),
  h7 = me('<span class="w-8"> </span>'),
  d7 = me(
    '<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>',
    1
  ),
  p7 = me('<span class="w-8"> </span>'),
  f7 = me(
    '<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>',
    1
  ),
  m7 = me(
    '<div class="flex h-full w-full flex-col items-center justify-center"><!></div>'
  );
function _7(_, o) {
  Dr(o, !0);
  let f = Je(!0),
    x = Je(""),
    A = Je(0),
    L = Je(!1);
  const T = ut(() => y(A) > 0 || y(L));
  let s = Je(!1),
    B = Je(""),
    N = Je(void 0);
  const K = ut(() => {
    var xe;
    return `phone:${(xe = kt.data) == null ? void 0 : xe.id}`;
  });
  $r(() => {
    const xe = localStorage.getItem(y(K));
    xe && te(x, xe, !0);
  }),
    Fn(() => {
      Jr.getOtpCooldown()
        .then((Ee) => {
          te(A, Ee.cooldownMs, !0);
        })
        .catch((Ee) => {
          xr.error(Ee.message);
        })
        .finally(() => {
          te(f, !1);
        });
      const xe = 1e3,
        Ie = setInterval(() => {
          te(A, Math.max(0, y(A) - xe), !0);
        }, xe);
      return () => {
        clearInterval(Ie);
      };
    });
  async function ee(xe) {
    try {
      te(L, !0);
      const Ie = await Jr.sendOtp(xe);
      xr.info(`${GC()} ${Ie.phone}`),
        te(x, Ie.phone, !0),
        te(A, Ie.cooldownMs, !0),
        localStorage.setItem(y(K), y(x));
    } catch (Ie) {
      xr.error(Ie.message);
    } finally {
      te(L, !1);
    }
  }
  $r(() => {
    y(B).length === 6 &&
      (te(s, !0),
      (async () => {
        try {
          await Jr.verifyOtp(y(B)),
            await kt.refresh(),
            xr.success(WC()),
            localStorage.removeItem(y(K)),
            o.onsuccess(y(x));
        } catch (xe) {
          xr.error(xe.message);
        } finally {
          te(B, ""), te(s, !1);
        }
      })());
  });
  var re = m7(),
    ue = M(re);
  {
    var ne = (xe) => {
        var Ie = u7();
        G(xe, Ie);
      },
      Y = (xe) => {
        var Ie = Jt(),
          Ee = _t(Ie);
        {
          var De = (qe) => {
              var Ue = d7(),
                Be = _t(Ue),
                ke = M(Be),
                $e = M(ke, !0);
              P(ke);
              var Le = q(ke, 2),
                nt = M(Le, !0);
              P(Le), P(Be);
              var dt = q(Be, 2),
                je = M(dt);
              yi(
                je,
                () => (Ke) => (
                  te(
                    N,
                    c7(Ke, {
                      strictMode: !0,
                      initialCountry: "br",
                      loadUtils: () =>
                        Zb(
                          () => import("../chunks/DfSCc6yA.js"),
                          [],
                          import.meta.url
                        ),
                      containerClass: "w-full",
                      dropdownContainer: document.body,
                    })
                  ),
                  () => {
                    var Fe;
                    (Fe = y(N)) == null || Fe.destroy();
                  }
                )
              );
              var Ge = q(je, 2),
                bt = M(Ge),
                Xe = q(bt);
              {
                var Ve = (Ke) => {
                  var Fe = h7(),
                    ft = M(Fe);
                  P(Fe),
                    Ne((lt) => le(ft, `(${lt ?? ""})`), [() => Lp(y(A))]),
                    G(Ke, Fe);
                };
                Me(Xe, (Ke) => {
                  y(A) > 0 && Ke(Ve);
                });
              }
              P(Ge),
                P(dt),
                Ne(
                  (Ke, Fe, ft) => {
                    le($e, Ke),
                      le(nt, Fe),
                      (Ge.disabled = y(T)),
                      le(bt, `${ft ?? ""} `);
                  },
                  [() => FP(), () => NP(), () => qP()]
                ),
                Zn("submit", dt, async () => {
                  var Fe;
                  if (y(T)) return;
                  if (!((Fe = y(N)) != null && Fe.isValidNumber())) {
                    xr.error(KC());
                    return;
                  }
                  const Ke = y(N).getNumber();
                  await ee(Ke);
                }),
                G(qe, Ue);
            },
            Ae = (qe) => {
              var Ue = f7(),
                Be = _t(Ue),
                ke = M(Be),
                $e = M(ke, !0);
              P(ke);
              var Le = q(ke, 2),
                nt = M(Le);
              P(Le), P(Be);
              var dt = q(Be, 2),
                je = M(dt);
              {
                const lt = (yt, mt) => {
                  let ct = () => (mt == null ? void 0 : mt().cells);
                  var qt = Jt(),
                    Ft = _t(qt);
                  Ti(
                    Ft,
                    () => r7,
                    (Ye, at) => {
                      at(Ye, {
                        class: "border-primary",
                        children: (xt, It) => {
                          var Tt = Jt(),
                            Mt = _t(Tt);
                          oi(
                            Mt,
                            16,
                            ct,
                            (Wt) => Wt,
                            (Wt, Bt) => {
                              var Gt = Jt(),
                                At = _t(Gt);
                              Ti(
                                At,
                                () => a7,
                                (Xt, Lt) => {
                                  Lt(Xt, {
                                    get cell() {
                                      return Bt;
                                    },
                                    class:
                                      "border-base-content/20 size-11 sm:size-12",
                                  });
                                }
                              ),
                                G(Wt, Gt);
                            }
                          ),
                            G(xt, Tt);
                        },
                        $$slots: { default: !0 },
                      });
                    }
                  ),
                    G(yt, qt);
                };
                Ti(
                  je,
                  () => o7,
                  (yt, mt) => {
                    mt(yt, {
                      maxlength: 6,
                      class: "mx-auto w-max",
                      get disabled() {
                        return y(s);
                      },
                      get value() {
                        return y(B);
                      },
                      set value(ct) {
                        te(B, ct, !0);
                      },
                      children: lt,
                      $$slots: { default: !0 },
                    });
                  }
                );
              }
              P(dt);
              var Ge = q(dt, 2),
                bt = M(Ge);
              bt.__click = async () => {
                await ee(y(x));
              };
              var Xe = M(bt),
                Ve = q(Xe);
              {
                var Ke = (lt) => {
                  var yt = p7(),
                    mt = M(yt);
                  P(yt),
                    Ne((ct) => le(mt, `(${ct ?? ""})`), [() => Lp(y(A))]),
                    G(lt, yt);
                };
                Me(Ve, (lt) => {
                  y(A) > 0 && lt(Ke);
                });
              }
              P(bt);
              var Fe = q(bt, 2);
              Fe.__click = () => {
                te(x, "");
              };
              var ft = M(Fe, !0);
              P(Fe),
                P(Ge),
                Ne(
                  (lt, yt, mt, ct) => {
                    le($e, lt),
                      le(nt, `${yt ?? ""} ${y(x) ?? ""}`),
                      (bt.disabled = y(T)),
                      le(Xe, `${mt ?? ""} `),
                      le(ft, ct);
                  },
                  [() => GP(), () => WP(), () => KP(), () => eI()]
                ),
                G(qe, Ue);
            };
          Me(
            Ee,
            (qe) => {
              y(x) ? qe(Ae, !1) : qe(De);
            },
            !0
          );
        }
        G(xe, Ie);
      };
    Me(ue, (xe) => {
      y(f) ? xe(ne) : xe(Y, !1);
    });
  }
  P(re), G(_, re), Rr();
}
Bn(["click"]);
var g7 = me(
  '<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div></dialog>'
);
function v7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  var x = g7(),
    A = M(x),
    L = q(M(A), 2);
  {
    var T = (s) => {
      _7(s, { onsuccess: () => f(!1) });
    };
    Me(L, (s) => {
      f() && s(T);
    });
  }
  P(A),
    P(x),
    yi(x, () => (s) => {
      $r(() => {
        f() ? s.show() : s.close();
      });
    }),
    Zn("close", x, () => f(!1)),
    G(_, x),
    Rr();
}
var y7 = me(
  '<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>'
);
function x7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(!1),
    A = Je(""),
    L = Je(0),
    T = Je(!1);
  $r(() => {
    f() &&
      (async () => {
        try {
          te(x, !0);
          const ke = await Jr.getUserLastAppeal();
          if (ke === null) {
            te(T, !1), te(L, 0);
            return;
          }
          const $e = new Date(ke),
            Le = 1440 * 60 * 1e3;
          Date.now() - $e.getTime() < 90 * Le
            ? (te(T, !0),
              te(L, Math.ceil(($e.getTime() + 90 * Le - Date.now()) / Le), !0))
            : te(L, 0);
        } catch (ke) {
          xr.error(ke.message);
        } finally {
          te(x, !1);
        }
      })();
  });
  var s = y7(),
    B = M(s),
    N = q(M(B), 2),
    K = M(N, !0);
  P(N);
  var ee = q(N, 2),
    re = M(ee),
    ue = M(re);
  Gp(ue, () => iM()), P(re);
  var ne = q(re, 2),
    Y = M(ne);
  {
    let ke = ut(() => sM()),
      $e = ut(() => uM()),
      Le = ut(() => y(x) || y(T));
    T0(Y, {
      get label() {
        return y(ke);
      },
      get placeholder() {
        return y($e);
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return y(Le);
      },
      get value() {
        return y(A);
      },
      set value(nt) {
        te(A, nt, !0);
      },
    });
  }
  P(ne);
  var xe = q(ne, 2),
    Ie = M(xe);
  Ie.__click = () => {
    f(!1);
  };
  var Ee = M(Ie, !0);
  P(Ie);
  var De = q(Ie, 2),
    Ae = M(De),
    qe = M(Ae, !0);
  P(Ae);
  var Ue = q(Ae, 2),
    Be = M(Ue, !0);
  P(Ue),
    P(De),
    P(xe),
    P(ee),
    P(B),
    P(s),
    yi(s, () => (ke) => {
      $r(() => {
        f() ? ke.show() : ke.close();
      });
    }),
    Ne(
      (ke, $e, Le, nt) => {
        le(K, ke),
          (Ie.disabled = y(x)),
          le(Ee, $e),
          le(qe, Le),
          (Ue.disabled = y(x) || y(T) || y(A).length <= 1),
          le(Be, nt);
      },
      [
        () => (o.userData.banned ? W0() : tM()),
        () => ds(),
        () => (y(T) ? wM({ days: y(L) }) : ""),
        () => pM(),
      ]
    ),
    Zn("close", s, () => f(!1)),
    Zn("submit", ee, async () => {
      try {
        te(x, !0), await Jr.submitBanAppeal(y(A)), xr.success(_M()), f(!1);
      } catch (ke) {
        xr.error(ke.message, { duration: 5e3 });
      } finally {
        te(x, !1);
      }
    }),
    G(_, s),
    Rr();
}
Bn(["click"]);
var b7 = me("<span> </span>");
function p0(_, o) {
  Dr(o, !0);
  var f = b7(),
    x = M(f, !0);
  P(f),
    Ne(() => {
      Br(
        f,
        1,
        `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${
          o.count < 10 ? "text-xs" : "text-[10px]"
        } ${o.class ?? ""}`
      ),
        le(x, o.count < 10 ? o.count : "9+");
    }),
    G(_, f),
    Rr();
}
var w7 = me('<p class="text-error mt-1 text-sm"> </p>'),
  T7 = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  S7 = me(
    '<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>'
  );
function C7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(""),
    A = Je(null),
    L = Je(!1),
    T = ut(() => {
      var Ke;
      return ((Ke = kt.data) == null ? void 0 : Ke.name) ?? "";
    });
  $r(() => {
    f() || (te(x, ""), te(A, null));
  });
  var s = S7(),
    B = M(s),
    N = q(M(B), 2),
    K = M(N);
  Sb(K, { class: "text-error size-5" });
  var ee = q(K, 2),
    re = M(ee, !0);
  P(ee), P(N);
  var ue = q(N, 2),
    ne = M(ue),
    Y = M(ne, !0);
  P(ne);
  var xe = q(ne);
  P(ue);
  var Ie = q(ue, 2),
    Ee = M(Ie);
  P(Ie);
  var De = q(Ie, 2),
    Ae = M(De, !0);
  P(De);
  var qe = q(De, 2);
  Oa(qe);
  var Ue = q(qe, 2);
  {
    var Be = (Ke) => {
      var Fe = w7(),
        ft = M(Fe, !0);
      P(Fe), Ne(() => le(ft, y(A))), G(Ke, Fe);
    };
    Me(Ue, (Ke) => {
      y(A) && Ke(Be);
    });
  }
  var ke = q(Ue, 2),
    $e = M(ke);
  $e.__click = () => {
    f(!1);
  };
  var Le = M($e, !0);
  P($e);
  var nt = q($e, 2);
  nt.__click = async () => {
    if (y(x) !== y(T)) {
      te(A, hb(), !0);
      return;
    }
    try {
      te(L, !0),
        await Jr.deleteMe(y(T)),
        xr.warning(SP()),
        await kt.logout(),
        f(!1);
    } catch (Ke) {
      xr.error(Ke.message);
    } finally {
      te(L, !1);
    }
  };
  var dt = M(nt),
    je = q(dt);
  {
    var Ge = (Ke) => {
      var Fe = T7();
      G(Ke, Fe);
    };
    Me(je, (Ke) => {
      y(L) && Ke(Ge);
    });
  }
  P(nt), P(ke), P(B);
  var bt = q(B, 2),
    Xe = M(bt),
    Ve = M(Xe, !0);
  P(Xe),
    P(bt),
    P(s),
    yi(s, () => (Ke) => {
      $r(() => {
        f() ? Ke.show() : Ke.close();
      });
    }),
    Ne(
      (Ke, Fe, ft, lt, yt, mt, ct, qt, Ft) => {
        le(re, Ke),
          le(Y, Fe),
          le(xe, ` ${ft ?? ""}`),
          le(Ee, `${lt ?? ""} ${yt ?? ""}`),
          le(Ae, y(T)),
          gr(qe, "placeholder", mt),
          le(Le, ct),
          (nt.disabled = y(L)),
          le(dt, `${qt ?? ""} `),
          le(Ve, Ft);
      },
      [
        () => Im(),
        () => s5(),
        () => u5(),
        () => x4(),
        () => T4(),
        () => P4(),
        () => Gh(),
        () => Im(),
        () => ds(),
      ]
    ),
    Zn("close", s, () => f(!1)),
    $h(
      qe,
      () => y(x),
      (Ke) => te(x, Ke)
    ),
    G(_, s),
    Rr();
}
Bn(["click"]);
var P7 = me('<p class="text-base-content/80 text-sm"> </p>'),
  I7 = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  M7 = me(
    '<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>',
    1
  );
function A7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Et(o, "type", 3, "confirmation"),
    A = Et(o, "buttonText", 19, () => R0()),
    L = Je(!1);
  M_(_, {
    dialogClass: "!bg-black/80",
    get open() {
      return f();
    },
    set open(T) {
      f(T);
    },
    children: (T, s) => {
      var B = M7(),
        N = _t(B),
        K = M(N, !0);
      P(N);
      var ee = q(N, 2),
        re = M(ee, !0);
      P(ee);
      var ue = q(ee, 2);
      {
        var ne = (ke) => {
          var $e = P7(),
            Le = M($e, !0);
          P($e), Ne(() => le(Le, o.subDescription)), G(ke, $e);
        };
        Me(ue, (ke) => {
          o.subDescription && ke(ne);
        });
      }
      var Y = q(ue, 2),
        xe = M(Y),
        Ie = M(xe),
        Ee = M(Ie, !0);
      P(Ie), P(xe);
      var De = q(xe, 2);
      let Ae;
      De.__click = async () => {
        try {
          te(L, !0), f(await o.onConfirm());
        } finally {
          te(L, !1);
        }
      };
      var qe = M(De),
        Ue = q(qe);
      {
        var Be = (ke) => {
          var $e = I7();
          G(ke, $e);
        };
        Me(Ue, (ke) => {
          y(L) && ke(Be);
        });
      }
      P(De),
        P(Y),
        Ne(
          (ke) => {
            le(K, o.title),
              le(re, o.description),
              le(Ee, ke),
              (Ae = Br(De, 1, "btn relative", null, Ae, {
                "btn-error": x() === "warning",
                "btn-primary": x() === "confirmation",
              })),
              (De.disabled = y(L)),
              le(qe, `${A() ?? ""} `);
          },
          [() => Gh()]
        ),
        G(T, B);
    },
    $$slots: { default: !0 },
  }),
    Rr();
}
Bn(["click"]);
function k7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  {
    let x = ut(() => C0()),
      A = ut(() => f4()),
      L = ut(() => A4());
    A7(_, {
      type: "warning",
      get title() {
        return y(x);
      },
      get description() {
        return y(A);
      },
      get subDescription() {
        return y(L);
      },
      onConfirm: async () => {
        try {
          return (
            await Jr.deleteSessions(), xr.success(Cb()), await kt.logout(), !0
          );
        } catch {
          return xr.error(Pb()), !1;
        }
      },
      get open() {
        return f();
      },
      set open(T) {
        f(T);
      },
    });
  }
  Rr();
}
var E7 = me(
    '<span class="center-absolute loading loading-spinner absolute"></span>'
  ),
  z7 = me(
    '<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'
  ),
  L7 = me(
    '<span class="center-absolute loading loading-spinner absolute"></span>'
  ),
  D7 = me(
    '<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'
  ),
  R7 = me(
    '<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'
  ),
  F7 = me('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  B7 = me('<button class="btn btn-error btn-soft"><!> </button>'),
  O7 = me(
    '<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="tooltip flex w-full flex-col gap-3 max-sm:overflow-x-hidden"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>',
    1
  );
function N7(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(Si(o.userData.name)),
    A = Je(Si(o.userData.discord)),
    L = Je(Si(o.userData.showLastPixel)),
    T = Je(!1),
    s = Je(void 0),
    B = Je(!1),
    N = Je(!1);
  const K = db("2025-09_discord_linking");
  let ee = Je(!!o.userData.discordId),
    re = Je(void 0),
    ue = Je(void 0);
  $r(() => {
    te(x, o.userData.name, !0), te(L, o.userData.showLastPixel, !0);
  }),
    $r(() => {
      f() &&
        !y(s) &&
        Jr.getMyProfilePictures()
          .then((jt) => {
            te(s, jt, !0);
          })
          .catch((jt) => {
            xr.error(jt.message);
          });
    });
  let ne = Je(!1);
  async function Y(jt) {
    try {
      te(ne, !0), await Jr.changeProfilePicture(jt), await kt.refresh();
    } finally {
      te(ne, !1);
    }
  }
  var xe = O7(),
    Ie = _t(xe),
    Ee = M(Ie),
    De = q(M(Ee), 2),
    Ae = M(De, !0);
  P(De);
  var qe = q(De, 2),
    Ue = M(qe),
    Be = M(Ue),
    ke = M(Be),
    $e = M(ke);
  mo($e, {
    class: "size-30",
    get userId() {
      return o.userData.id;
    },
    get pictureUrl() {
      return o.userData.picture;
    },
  });
  var Le = q($e, 2),
    nt = M(Le);
  k0(nt, { class: "size-5" }), P(Le), P(ke);
  var dt = q(ke, 2);
  {
    var je = (jt) => {
      var mr = R7(),
        ir = M(mr),
        vr = M(ir, !0);
      P(ir);
      var ar = q(ir, 2),
        pr = M(ar);
      {
        var tr = (Sr) => {
          var Te = z7();
          Te.__click = () => {
            Y();
          };
          var O = M(Te);
          mo(O, {
            class: "size-10 border",
            get userId() {
              return o.userData.id;
            },
          });
          var E = q(O, 2);
          {
            var D = (j) => {
              var H = E7();
              G(j, H);
            };
            Me(E, (j) => {
              y(ne) && j(D);
            });
          }
          P(Te), Ne(() => (Te.disabled = y(ne))), G(Sr, Te);
        };
        Me(pr, (Sr) => {
          o.userData.picture && Sr(tr);
        });
      }
      var Dt = q(pr, 2);
      oi(
        Dt,
        17,
        () => y(s),
        (Sr) => Sr.id,
        (Sr, Te) => {
          var O = Jt(),
            E = _t(O);
          {
            var D = (j) => {
              var H = D7();
              H.__click = () => {
                Y(y(Te).id);
              };
              var W = M(H);
              mo(W, {
                class: "size-10 border",
                get userId() {
                  return o.userData.id;
                },
                get pictureUrl() {
                  return y(Te).url;
                },
              });
              var ce = q(W, 2);
              {
                var ge = (de) => {
                  var Se = L7();
                  G(de, Se);
                };
                Me(ce, (de) => {
                  y(ne) && de(ge);
                });
              }
              P(H), Ne(() => (H.disabled = y(ne))), G(j, H);
            };
            Me(E, (j) => {
              o.userData.picture !== y(Te).url && j(D);
            });
          }
          G(Sr, O);
        }
      ),
        P(ar),
        P(mr),
        Ne((Sr) => le(vr, Sr), [() => Qw()]),
        G(jt, mr);
    };
    Me(dt, (jt) => {
      var mr;
      (mr = y(s)) != null && mr.length && jt(je);
    });
  }
  P(Be);
  var Ge = q(Be, 2),
    bt = M(Ge);
  {
    let jt = ut(() => Mm()),
      mr = ut(() => Mm());
    Em(bt, {
      get label() {
        return y(jt);
      },
      get placeholder() {
        return y(mr);
      },
      min: 1,
      max: 16,
      get value() {
        return y(x);
      },
      set value(ir) {
        te(x, ir, !0);
      },
      get validate() {
        return y(re);
      },
      set validate(ir) {
        te(re, ir, !0);
      },
    });
  }
  var Xe = q(bt, 2);
  {
    var Ve = (jt) => {
        var mr = Jt(),
          ir = _t(mr);
        {
          var vr = (pr) => {
              var tr = F7(),
                Dt = M(tr);
              Lm(Dt, { class: "size-4.5" });
              var Sr = q(Dt);
              P(tr),
                Ne(
                  (Te, O) => {
                    gr(tr, "href", Te), le(Sr, ` ${O ?? ""}`);
                  },
                  [() => pb("/discord/authorize"), () => vP()]
                ),
                G(pr, tr);
            },
            ar = (pr) => {
              var tr = B7();
              tr.__click = async () => {
                try {
                  te(T, !0),
                    await Jr.unlinkDiscord(),
                    kt.refresh(),
                    xr.success(mP()),
                    te(ee, !1);
                } catch (Te) {
                  xr.error(Te.message, { duration: 5e3 });
                } finally {
                  te(T, !1);
                }
              };
              var Dt = M(tr);
              Lm(Dt, { class: "size-4.5" });
              var Sr = q(Dt);
              P(tr),
                Ne(
                  (Te) => {
                    (tr.disabled = y(T)), le(Sr, ` ${Te ?? ""}`);
                  },
                  [
                    () => {
                      var Te;
                      return bP({
                        username:
                          ((Te = o.userData) == null ? void 0 : Te.discord) ??
                          "",
                      });
                    },
                  ]
                ),
                G(pr, tr);
            };
          Me(ir, (pr) => {
            y(ee) ? pr(ar, !1) : pr(vr);
          });
        }
        G(jt, mr);
      },
      Ke = (jt) => {
        {
          let mr = ut(() => eT());
          Em(jt, {
            label: "Discord",
            get placeholder() {
              return y(mr);
            },
            max: 32,
            get value() {
              return y(A);
            },
            set value(ir) {
              te(A, ir, !0);
            },
            get validate() {
              return y(ue);
            },
            set validate(ir) {
              te(ue, ir, !0);
            },
          });
        }
      };
    Me(Xe, (jt) => {
      K ? jt(Ve) : jt(Ke, !1);
    });
  }
  var Fe = q(Xe, 2),
    ft = M(Fe);
  Oa(ft);
  var lt = q(ft);
  P(Fe), P(Ge), P(Ue);
  var yt = q(Ue, 2),
    mt = M(yt),
    ct = M(mt),
    qt = M(ct, !0);
  P(ct);
  var Ft = q(ct, 2),
    Ye = M(Ft),
    at = M(Ye);
  at.__click = () => {
    te(N, !0);
  };
  var xt = M(at, !0);
  P(at), P(Ye);
  var It = q(Ye, 2),
    Tt = M(It);
  Tt.__click = () => {
    te(B, !0);
  };
  var Mt = M(Tt, !0);
  P(Tt), P(It), P(Ft), P(mt);
  var Wt = q(mt, 2),
    Bt = M(Wt);
  Bt.__click = () => {
    f(!1);
  };
  var Gt = M(Bt, !0);
  P(Bt);
  var At = q(Bt, 2),
    Xt = M(At, !0);
  P(At),
    P(Wt),
    P(yt),
    P(qe),
    P(Ee),
    P(Ie),
    yi(Ie, () => (jt) => {
      $r(() => {
        f() ? jt.show() : jt.close();
      });
    });
  var Lt = q(Ie, 2);
  C7(Lt, {
    get open() {
      return y(B);
    },
    set open(jt) {
      te(B, jt, !0);
    },
  });
  var Nt = q(Lt, 2);
  k7(Nt, {
    get open() {
      return y(N);
    },
    set open(jt) {
      te(N, jt, !0);
    },
  }),
    Ne(
      (jt, mr, ir, vr, ar, pr, tr, Dt, Sr) => {
        le(Ae, jt),
          gr(Le, "data-tip", mr),
          gr(Ge, "data-tip", ir),
          le(lt, ` ${vr ?? ""}`),
          le(qt, ar),
          le(xt, pr),
          le(Mt, tr),
          (Bt.disabled = y(T)),
          le(Gt, Dt),
          (At.disabled = y(T)),
          le(Xt, Sr);
      },
      [
        () => nI(),
        () => jb(),
        () => X4(),
        () => r5(),
        () => g4(),
        () => C0(),
        () => Im(),
        () => ds(),
        () => Fb(),
      ]
    ),
    Zn("close", Ie, () => f(!1)),
    Zn("submit", qe, async () => {
      var jt;
      try {
        if (!((jt = y(re)) != null && jt())) return;
        te(T, !0),
          await Jr.updateMe({ name: y(x), showLastPixel: y(L) }),
          kt.refresh(),
          xr.success(cP()),
          f(!1);
      } catch (mr) {
        xr.error(mr.message, { duration: 5e3 });
      } finally {
        te(T, !1);
      }
    }),
    Lb(
      ft,
      () => y(L),
      (jt) => te(L, jt)
    ),
    G(_, xe),
    Rr();
}
Bn(["click"]);
var j7 = Lr(
  '<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>'
);
function V7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = j7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var q7 = Lr(
  '<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>'
);
function U7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = q7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var Z7 = Lr(
  '<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>'
);
function G7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Z7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var $7 = Lr(
  '<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>'
);
function f0(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = $7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var H7 = Lr(
  '<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>'
);
function W7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = H7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var X7 = Lr(
  '<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>'
);
function Y7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = X7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var K7 = Lr(
  '<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>'
);
function J7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = K7();
  dr(
    x,
    () => ({
      xmlns: "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      viewBox: "0 0 216 216",
      ...f,
    }),
    void 0,
    void 0,
    void 0,
    "svelte-14mu38d"
  ),
    G(_, x);
}
var Q7 = Lr(
  '<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>'
);
function a_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Q7();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var eF = Lr(
  '<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>'
);
function xm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = eF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var tF = Lr(
  '<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>'
);
function rF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = tF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var nF = Lr(
  '<svg><path fill="#fff" d="m2200 1300-400 400h-400l-350 350v-350H600V200h1600z"></path><g fill="#9146ff"><path d="M500 0 0 500v1800h600v500l500-500h400l900-900V0H500zm1700 1300-400 400h-400l-350 350v-350H600V200h1600v1100z"></path><path d="M1700 550h200v600h-200zm-550 0h200v600h-200z"></path></g></svg>'
);
function iF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = nF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    viewBox: "0 0 2400 2800",
    ...f,
  })),
    G(_, x);
}
var aF = Lr(
  '<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>'
);
function oF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = aF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var sF = Lr(
  '<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>'
);
function Hy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = sF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var lF = Lr(
  '<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>'
);
function cF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = lF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var uF = Lr(
  '<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>'
);
function hF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = uF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var dF = me('<span class="tooltip font-flag ml-0.5"> </span>'),
  pF = me('<div class="mt-1"><!></div>'),
  fF = me('<p class="w-full"> <!></p>'),
  mF = me('<p class="w-full"><!></p>'),
  _F = me(
    '<div class=" flex items-center gap-[8px]"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'
  ),
  gF = me(
    '<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'
  ),
  vF = me("<li><button><!> </button></li>"),
  yF = me(
    '<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'
  ),
  xF = me(
    '<button class="btn btn-sm btn-circle tooltip" data-tip="Toggle pixel arts"><!></button>'
  ),
  bF = me('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  wF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  TF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  SF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  CF = me(
    '<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>',
    1
  ),
  PF = me(
    '<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="https://discord.gg/ZRC4DnP9Z2" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>',
    1
  );
function IF(_, o) {
  Dr(o, !0);
  let f = Je(!1),
    x = Je(!1),
    A = Je(!0);
  function L() {
    var ue;
    (ue = document.activeElement) == null || ue.blur();
  }
  const T = [
    { label: "üá∫üá∏ English", key: "en" },
    { label: "üáßüá∑ Portugu√™s", key: "pt" },
  ];
  let s = Je(""),
    B = Je(void 0);
  const N = ut(() => {
    var ue;
    return !!((ue = o.user.data) != null && ue.banned) || !!o.user.timeoutUntil;
  });
  var K = Jt(),
    ee = _t(K);
  {
    var re = (ue) => {
      var ne = PF(),
        Y = _t(ne),
        xe = M(Y);
      let Ie;
      var Ee = M(xe);
      L0(Ee, {
        get userId() {
          return o.user.data.id;
        },
        get level() {
          return o.user.data.level;
        },
        get pictureUrl() {
          return o.user.data.picture;
        },
      });
      var De = q(Ee, 2);
      {
        var Ae = (st) => {
          p0(st, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return o.user.notificiationCount;
            },
          });
        };
        Me(De, (st) => {
          o.user.notificiationCount && st(Ae);
        });
      }
      P(xe);
      var qe = q(xe, 2),
        Ue = M(qe);
      Ue.__click = L;
      var Be = M(Ue);
      Os(Be, { class: "size-5" }), P(Ue);
      var ke = q(Ue, 2),
        $e = M(ke),
        Le = M($e);
      mo(Le, {
        get userId() {
          return o.user.data.id;
        },
        get pictureUrl() {
          return o.user.data.picture;
        },
        get isSuspended() {
          return y(N);
        },
      });
      var nt = q(Le, 2);
      nt.__click = () => {
        te(f, !0);
      };
      var dt = M(nt);
      zm(dt, { class: "size-4" }), P(nt), P($e);
      var je = q($e, 2),
        Ge = M(je),
        bt = M(Ge),
        Xe = M(bt, !0);
      P(bt);
      var Ve = q(bt, 2),
        Ke = M(Ve);
      P(Ve);
      var Fe = q(Ve, 2);
      {
        var ft = (st) => {
          const gt = ut(() => ko(o.user.data.equippedFlag));
          var Ut = dF(),
            br = M(Ut, !0);
          P(Ut),
            Ne(() => {
              gr(Ut, "data-tip", y(gt).name), le(br, y(gt).flag);
            }),
            G(st, Ut);
        };
        Me(Fe, (st) => {
          o.user.data.equippedFlag && st(ft);
        });
      }
      var lt = q(Fe, 2);
      {
        var yt = (st) => {
          var gt = pF(),
            Ut = M(gt);
          Hh(Ut, {
            get username() {
              return o.user.data.discord;
            },
            get id() {
              return o.user.data.discordId;
            },
          }),
            P(gt),
            G(st, gt);
        };
        Me(lt, (st) => {
          o.user.data.discord && st(yt);
        });
      }
      P(Ge);
      var mt = q(Ge, 2),
        ct = M(mt);
      Wh(ct, { class: "inline size-4" });
      var qt = q(ct, 2),
        Ft = M(qt),
        Ye = q(Ft),
        at = M(Ye, !0);
      P(Ye), P(qt), P(mt);
      var xt = q(mt, 2),
        It = M(xt);
      V7(It, { class: "inline size-4" });
      var Tt = q(It, 2),
        Mt = M(Tt),
        Wt = M(Mt);
      P(Mt);
      var Bt = q(Mt),
        Gt = q(Bt),
        At = M(Gt);
      ah(At, { class: "mb-0.5 inline size-4 opacity-50" }),
        P(Gt),
        P(Tt),
        P(xt),
        P(je),
        P(ke);
      var Xt = q(ke, 2),
        Lt = M(Xt);
      {
        var Nt = (st) => {
          var gt = _F(),
            Ut = M(gt);
          a_(Ut, { class: "size-6 text-red-500" });
          var br = q(Ut, 2);
          {
            var wt = (fr) => {
                var Zr = fF(),
                  nn = M(Zr),
                  Tn = q(nn);
                {
                  var gn = (Rn) => {
                      var hn = ji();
                      Ne(
                        (Qn) => le(hn, `(${Qn ?? ""})`),
                        [() => Rv({ reason: _b() })]
                      ),
                        G(Rn, hn);
                    },
                    Gn = (Rn) => {
                      var hn = Jt(),
                        Qn = _t(hn);
                      {
                        var li = (ii) => {
                          var pi = ji();
                          Ne(
                            (Qi) => le(pi, `(${Qi ?? ""})`),
                            [() => Rv({ reason: gb() })]
                          ),
                            G(ii, pi);
                        };
                        Me(
                          Qn,
                          (ii) => {
                            o.user.data.suspensionReason ===
                              "multi-accounting" && ii(li);
                          },
                          !0
                        );
                      }
                      G(Rn, hn);
                    };
                  Me(Tn, (Rn) => {
                    o.user.data.suspensionReason === "bot"
                      ? Rn(gn)
                      : Rn(Gn, !1);
                  });
                }
                P(Zr),
                  Ne((Rn) => le(nn, `${Rn ?? ""} `), [() => fb()]),
                  G(fr, Zr);
              },
              sr = (fr) => {
                var Zr = Jt(),
                  nn = _t(Zr);
                {
                  var Tn = (gn) => {
                    var Gn = mF(),
                      Rn = M(Gn);
                    Gp(Rn, () =>
                      mb({
                        until: `<span class="text-secondary font-medium text-nowrap">${o.user.timeoutUntil.toLocaleString()}</span>`,
                      })
                    ),
                      P(Gn),
                      G(gn, Gn);
                  };
                  Me(
                    nn,
                    (gn) => {
                      o.user.timeoutUntil && gn(Tn);
                    },
                    !0
                  );
                }
                G(fr, Zr);
              };
            Me(br, (fr) => {
              var Zr;
              (Zr = o.user.data) != null && Zr.banned ? fr(wt) : fr(sr, !1);
            });
          }
          var wr = q(br, 2);
          wr.__click = (fr) => {
            var Zr;
            (Zr = o.onbanappeal) == null || Zr.call(o);
          };
          var jr = M(wr);
          a_(jr, { class: "size-5 text-red-500" });
          var Yr = q(jr, 1, !0);
          P(wr), P(gt), Ne((fr) => le(Yr, fr), [() => CM()]), G(st, gt);
        };
        Me(Lt, (st) => {
          y(N) && st(Nt);
        });
      }
      var jt = q(Lt, 2),
        mr = M(jt),
        ir = M(mr, !0);
      P(mr);
      var vr = q(mr, 2),
        ar = M(vr),
        pr = M(ar),
        tr = M(pr);
      rF(tr, { class: "size-4" }), P(pr);
      var Dt = q(pr, 2);
      oi(
        Dt,
        21,
        () => T,
        Hp,
        (st, gt) => {
          const Ut = ut(() => y(s) === y(gt).key);
          var br = vF(),
            wt = M(br);
          let sr;
          wt.__click = () => {
            localStorage.setItem(wb, y(gt).key),
              te(s, y(gt).key, !0),
              location.reload();
          };
          var wr = M(wt);
          {
            var jr = (fr) => {
              var Zr = gF();
              G(fr, Zr);
            };
            Me(wr, (fr) => {
              y(Ut) && fr(jr);
            });
          }
          var Yr = q(wr);
          P(wt),
            P(br),
            Ne(() => {
              (sr = Br(wt, 1, "font-flag relative font-medium", null, sr, {
                "bg-base-200": y(Ut),
              })),
                le(Yr, ` ${y(gt).label ?? ""}`);
            }),
            G(st, br);
        }
      ),
        P(Dt),
        P(ar);
      var Sr = q(ar, 2),
        Te = M(Sr);
      Te.__click = () => {
        da.muted = !da.muted;
      };
      var O = M(Te);
      {
        var E = (st) => {
            cF(st, { class: "size-4" });
          },
          D = (st) => {
            hF(st, { class: "size-4" });
          };
        Me(O, (st) => {
          da.muted ? st(E) : st(D, !1);
        });
      }
      P(Te), P(Sr);
      var j = q(Sr, 2);
      {
        var H = (st) => {
          var gt = yF(),
            Ut = M(gt);
          Ut.__click = () => {
            da.theme = da.theme === "dark" ? "custom-winter" : "dark";
          };
          var br = M(Ut);
          {
            var wt = (wr) => {
                G7(wr, { class: "size-4" });
              },
              sr = (wr) => {
                U7(wr, { class: "size-4" });
              };
            Me(br, (wr) => {
              da.theme === "dark" ? wr(wt) : wr(sr, !1);
            });
          }
          P(Ut),
            P(gt),
            Ne(
              (wr) => gr(gt, "data-tip", wr),
              [() => (da.theme === "dark" ? h4() : l4())]
            ),
            G(st, gt);
        };
        Me(j, (st) => {
          var gt, Ut;
          ba(
            (Ut = (gt = o.user) == null ? void 0 : gt.data) == null
              ? void 0
              : Ut.role,
            ["admin", "moderator", "global_moderator"]
          ) && st(H);
        });
      }
      var W = q(j, 2);
      {
        var ce = (st) => {
          var gt = xF();
          gt.__click = () => {
            var sr;
            te(A, !y(A)),
              (sr = o.ontogglepixelarts) == null || sr.call(o, y(A));
          };
          var Ut = M(gt);
          {
            var br = (sr) => {
                oF(sr, { class: "size-4" });
              },
              wt = (sr) => {
                Hy(sr, { class: "size-4" });
              };
            Me(Ut, (sr) => {
              y(A) ? sr(wt, !1) : sr(br);
            });
          }
          P(gt), G(st, gt);
        };
        Me(W, (st) => {
          var gt, Ut;
          ba(
            (Ut = (gt = o.user) == null ? void 0 : gt.data) == null
              ? void 0
              : Ut.role,
            ["admin"]
          ) && st(ce);
        });
      }
      var ge = q(W, 2);
      ge.__click = function (...st) {
        var gt;
        (gt = o.onnotificationclick) == null || gt.apply(this, st);
      };
      var de = M(ge);
      W7(de, { class: "size-4" });
      var Se = q(de, 2);
      {
        var We = (st) => {
          p0(st, {
            class: "absolute -right-1 -top-1",
            get count() {
              return o.user.notificiationCount;
            },
          });
        };
        Me(Se, (st) => {
          o.user.notificiationCount && st(We);
        });
      }
      P(ge), P(vr), P(jt);
      var Ze = q(jt, 2);
      {
        var Ct = (st) => {
          var gt = bF();
          gt.__click = async () => {
            var wt;
            try {
              const sr = await ((wt = y(B)) == null ? void 0 : wt.prompt());
              (sr == null ? void 0 : sr.outcome) === "accepted" &&
                te(B, void 0);
            } catch (sr) {
              xr.error(Vw({ error: sr.message }));
            }
          };
          var Ut = M(gt);
          S0(Ut, { class: "size-5" });
          var br = q(Ut);
          P(gt), Ne((wt) => le(br, ` ${wt ?? ""}`), [() => Zw()]), G(st, gt);
        };
        Me(Ze, (st) => {
          y(B) && st(Ct);
        });
      }
      var _e = q(Ze, 2);
      {
        var Vt = (st) => {
          var gt = wF(),
            Ut = M(gt);
          xm(Ut, { class: "size-5" });
          var br = q(Ut);
          P(gt),
            Ne(
              (wt) => {
                gr(gt, "href", `${di.url.origin ?? ""}/admin`),
                  le(br, ` ${wt ?? ""}`);
              },
              [() => WI()]
            ),
            G(st, gt);
        };
        Me(_e, (st) => {
          var gt, Ut;
          ba(
            (Ut = (gt = o.user) == null ? void 0 : gt.data) == null
              ? void 0
              : Ut.role,
            ["admin"]
          ) && st(Vt);
        });
      }
      var cr = q(_e, 2);
      {
        var Ot = (st) => {
          var gt = TF(),
            Ut = M(gt);
          xm(Ut, { class: "size-5" });
          var br = q(Ut);
          P(gt),
            Ne(
              (wt) => {
                gr(gt, "href", `${di.url.origin ?? ""}/moderation`),
                  le(br, ` ${wt ?? ""}`);
              },
              [() => kI()]
            ),
            G(st, gt);
        };
        Me(cr, (st) => {
          var gt;
          ba((gt = o.user.data) == null ? void 0 : gt.role, [
            "admin",
            "moderator",
            "global_moderator",
          ]) && st(Ot);
        });
      }
      var ur = q(cr, 2);
      {
        var Nr = (st) => {
          var gt = SF(),
            Ut = M(gt);
          xm(Ut, { class: "size-5" });
          var br = q(Ut);
          P(gt),
            Ne(
              (wt) => {
                gr(gt, "href", `${di.url.origin ?? ""}/appeal`),
                  le(br, ` ${wt ?? ""}`);
              },
              [() => yM()]
            ),
            G(st, gt);
        };
        Me(ur, (st) => {
          var gt, Ut;
          ba(
            (Ut = (gt = o.user) == null ? void 0 : gt.data) == null
              ? void 0
              : Ut.role,
            ["admin"]
          ) && st(Nr);
        });
      }
      var Ur = q(ur, 2),
        Wr = M(Ur);
      iF(Wr, { class: "size-5" });
      var un = q(Wr);
      P(Ur);
      var an = q(Ur, 2),
        fn = M(an);
      km(fn, { class: "size-5" }), yn(), P(an);
      var rn = q(an, 2),
        pt = M(rn);
      J7(pt, { class: "size-5" }), yn(), P(rn);
      var on = q(rn, 2);
      {
        var Pn = (st) => {
          var gt = CF(),
            Ut = _t(gt),
            br = M(Ut),
            wt = M(br);
          Y7(wt, { class: "size-5" });
          var sr = q(wt);
          P(br), P(Ut);
          var wr = q(Ut, 2),
            jr = M(wr);
          ah(jr, { class: "size-5" });
          var Yr = q(jr);
          P(wr),
            Ne(
              (fr, Zr, nn) => {
                gr(Ut, "action", `${cb}/payment/create-portal-session`),
                  le(sr, ` ${fr ?? ""}`),
                  gr(wr, "href", Zr),
                  le(Yr, ` ${nn ?? ""}`);
              },
              [() => Mb(), () => E0(di.url.origin), () => G0()]
            ),
            G(st, gt);
        };
        Me(on, (st) => {
          var gt;
          (gt = o.user.data) != null && gt.isCustomer && st(Pn);
        });
      }
      var zt = q(on, 2);
      zt.__click = async () => {
        var st;
        try {
          te(x, !0),
            await o.user.logout(),
            L(),
            xr.warning(IP(), { icon: f0 }),
            (st = o.onlogout) == null || st.call(o);
        } catch {
          xr.error(kP());
        } finally {
          te(x, !1);
        }
      };
      var Qt = M(zt);
      f0(Qt, { class: "size-5" });
      var rt = q(Qt);
      P(zt), P(Xt), P(qe), P(Y);
      var $t = q(Y, 2);
      N7($t, {
        get userData() {
          return o.user.data;
        },
        get open() {
          return y(f);
        },
        set open(st) {
          te(f, st, !0);
        },
      }),
        Ne(
          (st, gt, Ut, br, wt, sr, wr, jr, Yr, fr, Zr, nn, Tn) => {
            (Ie = Br(xe, 1, "btn relative size-12 p-0 shadow-md", null, Ie, {
              "bg-red-500": y(N),
            })),
              gr(xe, "title", st),
              gr(bt, "title", o.user.data.name),
              le(Xe, o.user.data.name),
              Br(Ve, 1, gt),
              le(Ke, `#${o.user.data.id ?? ""}`),
              le(Ft, `${Ut ?? ""}: `),
              le(at, br),
              le(Wt, `Level ${wt ?? ""}`),
              le(Bt, ` (${sr ?? ""}%) `),
              gr(Gt, "data-tip", wr),
              le(ir, jr),
              gr(pr, "data-tip", Yr),
              gr(Sr, "data-tip", fr),
              gr(ge, "data-tip", Zr),
              le(un, ` ${nn ?? ""}`),
              (zt.disabled = y(x)),
              le(rt, ` ${Tn ?? ""}`);
          },
          [
            () => Rw(),
            () => hs(Ni(o.user.data.id)),
            () => c_(),
            () => o.user.data.pixelsPainted.toLocaleString("en-US"),
            () => Math.floor(o.user.data.level),
            () => Math.floor((o.user.data.level % 1) * 100),
            () => X3(),
            () => Ow(),
            () => b6(),
            () => (da.muted ? IC() : SC()),
            () => X0(),
            () => Hw(),
            () => Ib(),
          ]
        ),
        Zn("focus", xe, () => {
          te(B, window.pwaInstallPrompt, !0);
        }),
        G(ue, ne);
    };
    Me(ee, (ue) => {
      o.user.data && o.user.charges !== void 0 && ue(re);
    });
  }
  G(_, K), Rr();
}
Bn(["click"]);
var MF = me(
    '<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'
  ),
  AF = me(
    '<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
  ),
  kF = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  EF = me("<span> </span>"),
  zF = me(
    '<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
  ),
  LF = me(
    '<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
  ),
  DF = me(
    '<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
  ),
  RF = me(
    '<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
  ),
  FF = me(
    '<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'
  ),
  BF = me(
    '<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>',
    1
  );
function OF(_, o) {
  Dr(o, !0);
  const f = [];
  let x = Je("today"),
    A = {
      players: { label: U0(), icon: ef },
      alliances: { label: Z0(), icon: tf },
    },
    L = Je("players"),
    T = Si({ players: {}, alliances: {} });
  const s = ut(() => T[y(L)][y(x)]);
  $r(() => {
    if (y(s)) return;
    const Y = y(x),
      xe = y(L);
    xe === "players"
      ? Jr.leaderboardRegionPlayers(o.regionId, Y)
          .then((Ie) => {
            T[xe][Y] = Ie;
          })
          .catch((Ie) => {
            xr.error(Ie.message);
          })
      : xe === "alliances" &&
        Jr.leaderboardRegionAlliances(o.regionId, Y)
          .then((Ie) => {
            T[xe][Y] = Ie;
          })
          .catch((Ie) => {
            xr.error(Ie.message);
          });
  });
  var B = BF(),
    N = _t(B);
  oi(
    N,
    21,
    () => Object.entries(A),
    ([Y, { label: xe, icon: Ie }]) => Y,
    (Y, xe) => {
      var Ie = ut(() => v0(y(xe), 2));
      let Ee = () => y(Ie)[0],
        De = () => y(Ie)[1].label,
        Ae = () => y(Ie)[1].icon;
      const qe = ut(Ae);
      var Ue = MF(),
        Be = M(Ue);
      Oa(Be);
      var ke,
        $e = q(Be, 2);
      Ti(
        $e,
        () => y(qe),
        (nt, dt) => {
          dt(nt, {
            get this() {
              return Ae();
            },
            class: "mr-1 size-5 max-sm:hidden",
          });
        }
      );
      var Le = q($e);
      P(Ue),
        Ne(() => {
          gr(Be, "aria-label", De()),
            ke !== (ke = Ee()) && (Be.value = (Be.__value = Ee()) ?? ""),
            le(Le, ` ${De() ?? ""}`);
        }),
        h_(
          f,
          [],
          Be,
          () => (Ee(), y(L)),
          (nt) => te(L, nt)
        ),
        G(Y, Ue);
    }
  ),
    P(N);
  var K = q(N, 2),
    ee = M(K);
  T_(ee, {
    get value() {
      return y(x);
    },
    set value(Y) {
      te(x, Y, !0);
    },
  }),
    P(K);
  var re = q(K, 2);
  {
    var ue = (Y) => {
        var xe = AF(),
          Ie = M(xe),
          Ee = q(Ie);
        {
          var De = (qe) => {
              var Ue = ji();
              Ne((Be) => le(Ue, Be), [() => Qp().toLowerCase()]), G(qe, Ue);
            },
            Ae = (qe) => {
              var Ue = Jt(),
                Be = _t(Ue);
              {
                var ke = (Le) => {
                    var nt = ji();
                    Ne((dt) => le(nt, dt), [() => y_()]), G(Le, nt);
                  },
                  $e = (Le) => {
                    var nt = Jt(),
                      dt = _t(nt);
                    {
                      var je = (Ge) => {
                        var bt = ji();
                        Ne((Xe) => le(bt, Xe), [() => x_()]), G(Ge, bt);
                      };
                      Me(
                        dt,
                        (Ge) => {
                          y(x) === "month" && Ge(je);
                        },
                        !0
                      );
                    }
                    G(Le, nt);
                  };
                Me(
                  Be,
                  (Le) => {
                    y(x) === "week" ? Le(ke) : Le($e, !1);
                  },
                  !0
                );
              }
              G(qe, Ue);
            };
          Me(Ee, (qe) => {
            y(x) === "today" ? qe(De) : qe(Ae, !1);
          });
        }
        P(xe), Ne((qe) => le(Ie, `${qe ?? ""} `), [() => v_()]), G(Y, xe);
      },
      ne = (Y) => {
        var xe = Jt(),
          Ie = _t(xe);
        {
          var Ee = (Ae) => {
              var qe = Jt(),
                Ue = _t(qe);
              {
                var Be = ($e) => {
                    const Le = ut(() => y(s));
                    var nt = LF(),
                      dt = M(nt),
                      je = M(dt),
                      Ge = q(M(je)),
                      bt = M(Ge, !0);
                    P(Ge);
                    var Xe = q(Ge),
                      Ve = M(Xe),
                      Ke = q(Ve, 2, !0);
                    P(Xe), P(je), P(dt);
                    var Fe = q(dt);
                    oi(
                      Fe,
                      31,
                      () => y(Le),
                      (ft) => ft.id,
                      (ft, lt, yt) => {
                        const mt = ut(() => {
                          var ar;
                          return (
                            ((ar = kt.data) == null ? void 0 : ar.id) ===
                            y(lt).id
                          );
                        });
                        var ct = zF();
                        let qt;
                        var Ft = M(ct),
                          Ye = M(Ft, !0);
                        P(Ft);
                        var at = q(Ft),
                          xt = M(at),
                          It = M(xt);
                        mo(It, {
                          class: "size-10 border",
                          get userId() {
                            return y(lt).id;
                          },
                          get pictureUrl() {
                            return y(lt).picture;
                          },
                        });
                        var Tt = q(It, 2),
                          Mt = M(Tt),
                          Wt = M(Mt),
                          Bt = q(Wt),
                          Gt = M(Bt);
                        P(Bt), P(Mt);
                        var At = q(Mt, 2);
                        {
                          var Xt = (ar) => {
                            const pr = ut(() => ko(y(lt).equippedFlag));
                            var tr = kF(),
                              Dt = M(tr, !0);
                            P(tr),
                              Ne(() => {
                                gr(tr, "data-tip", y(pr).name),
                                  le(Dt, y(pr).flag);
                              }),
                              G(ar, tr);
                          };
                          Me(At, (ar) => {
                            "equippedFlag" in y(lt) &&
                              y(lt).equippedFlag &&
                              ar(Xt);
                          });
                        }
                        var Lt = q(At, 2);
                        {
                          var Nt = (ar) => {
                            Hh(ar, {
                              get username() {
                                return y(lt).discord;
                              },
                              get id() {
                                return y(lt).discordId;
                              },
                            });
                          };
                          Me(Lt, (ar) => {
                            y(lt).discord && ar(Nt);
                          });
                        }
                        var jt = q(Lt, 2);
                        {
                          var mr = (ar) => {
                            var pr = EF(),
                              tr = M(pr, !0);
                            P(pr),
                              Ne(
                                (Dt, Sr) => {
                                  Br(
                                    pr,
                                    1,
                                    `badge badge-sm ml-0.5 border-0 ${
                                      Dt ?? ""
                                    } ${Sr ?? ""}`
                                  ),
                                    le(tr, y(lt).allianceName);
                                },
                                [
                                  () => Wp(y(lt).allianceId),
                                  () => Ni(y(lt).allianceId),
                                ]
                              ),
                              G(ar, pr);
                          };
                          Me(jt, (ar) => {
                            "allianceName" in y(lt) &&
                              y(lt).allianceName &&
                              ar(mr);
                          });
                        }
                        P(Tt), P(xt), P(at);
                        var ir = q(at),
                          vr = M(ir, !0);
                        P(ir),
                          P(ct),
                          Ne(
                            (ar, pr) => {
                              (qt = Br(ct, 1, "", null, qt, {
                                "bg-base-200": y(mt),
                              })),
                                le(Ye, y(yt) + 1),
                                Br(
                                  Mt,
                                  1,
                                  `font-semibold max-sm:ml-2 ${
                                    ar ?? ""
                                  } flex gap-1`
                                ),
                                le(Wt, `${y(lt).name ?? ""} `),
                                le(Gt, `#${y(lt).id ?? ""}`),
                                le(vr, pr);
                            },
                            [
                              () => Ni(y(lt).id),
                              () => y(lt).pixelsPainted.toLocaleString("en-US"),
                            ]
                          ),
                          _l(
                            ct,
                            () => gl,
                            () => ({ duration: 200 })
                          ),
                          G(ft, ct);
                      }
                    ),
                      P(Fe),
                      P(nt),
                      Ne(
                        (ft, lt, yt) => {
                          le(bt, ft), le(Ve, `${lt ?? ""} `), le(Ke, yt);
                        },
                        [() => d_(), () => Mc(), () => Ac().toLowerCase()]
                      ),
                      G($e, nt);
                  },
                  ke = ($e) => {
                    var Le = Jt(),
                      nt = _t(Le);
                    {
                      var dt = (je) => {
                        var Ge = RF(),
                          bt = M(Ge),
                          Xe = M(bt),
                          Ve = q(M(Xe)),
                          Ke = M(Ve, !0);
                        P(Ve);
                        var Fe = q(Ve),
                          ft = M(Fe),
                          lt = q(ft, 2, !0);
                        P(Fe), P(Xe), P(bt);
                        var yt = q(bt);
                        oi(
                          yt,
                          31,
                          () => y(s),
                          (mt) => mt.id,
                          (mt, ct, qt) => {
                            const Ft = ut(() => {
                              var At;
                              return (
                                ((At = kt.data) == null
                                  ? void 0
                                  : At.allianceId) === y(ct).id
                              );
                            });
                            var Ye = DF();
                            let at;
                            var xt = M(Ye),
                              It = M(xt, !0);
                            P(xt);
                            var Tt = q(xt),
                              Mt = M(Tt),
                              Wt = M(Mt, !0);
                            P(Mt), P(Tt);
                            var Bt = q(Tt),
                              Gt = M(Bt, !0);
                            P(Bt),
                              P(Ye),
                              Ne(
                                (At, Xt) => {
                                  (at = Br(Ye, 1, "", null, at, {
                                    "bg-base-200": y(Ft),
                                  })),
                                    le(It, y(qt) + 1),
                                    Br(Mt, 1, `font-semibold ${At ?? ""}`),
                                    le(Wt, y(ct).name),
                                    le(Gt, Xt);
                                },
                                [
                                  () => Ni(y(ct).id),
                                  () =>
                                    y(ct).pixelsPainted.toLocaleString("en-US"),
                                ]
                              ),
                              _l(
                                Ye,
                                () => gl,
                                () => ({ duration: 200 })
                              ),
                              G(mt, Ye);
                          }
                        ),
                          P(yt),
                          P(Ge),
                          Ne(
                            (mt, ct, qt) => {
                              le(Ke, mt), le(ft, `${ct ?? ""} `), le(lt, qt);
                            },
                            [() => Kp(), () => Mc(), () => Ac().toLowerCase()]
                          ),
                          G(je, Ge);
                      };
                      Me(
                        nt,
                        (je) => {
                          y(L) === "alliances" && je(dt);
                        },
                        !0
                      );
                    }
                    G($e, Le);
                  };
                Me(Ue, ($e) => {
                  y(L) === "players" ? $e(Be) : $e(ke, !1);
                });
              }
              G(Ae, qe);
            },
            De = (Ae) => {
              var qe = FF();
              G(Ae, qe);
            };
          Me(
            Ie,
            (Ae) => {
              y(s) ? Ae(Ee) : Ae(De, !1);
            },
            !0
          );
        }
        G(Y, xe);
      };
    Me(re, (Y) => {
      y(s) && y(s).length === 0 ? Y(ue) : Y(ne, !1);
    });
  }
  G(_, B), Rr();
}
var NF = me('<div class="mt-5"><!></div>'),
  jF = me(
    '<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function VF(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15);
  const x = ut(() => ko(o.region.countryId));
  Fn(() => {
    const Y = (xe) => {
      xe.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", Y),
      () => document.removeEventListener("keydown", Y)
    );
  });
  var A = jF(),
    L = M(A),
    T = q(M(L), 2),
    s = M(T),
    B = M(s, !0);
  P(s);
  var N = q(s, 2),
    K = M(N, !0);
  P(N);
  var ee = q(N, 2),
    re = M(ee);
  P(ee), P(T);
  var ue = q(T, 2);
  {
    var ne = (Y) => {
      var xe = NF(),
        Ie = M(xe);
      OF(Ie, {
        get regionId() {
          return o.region.id;
        },
      }),
        P(xe),
        oa(
          2,
          xe,
          () => Ha,
          () => ({ duration: 300 })
        ),
        G(Y, xe);
    };
    Me(ue, (Y) => {
      f() && Y(ne);
    });
  }
  P(L),
    yn(2),
    P(A),
    yi(A, () => (Y) => {
      $r(() => {
        f() ? Y.show() : Y.close();
      });
    }),
    Ne(
      (Y) => {
        Br(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Y ?? ""}`),
          gr(s, "data-tip", y(x).name),
          le(B, y(x).flag),
          le(K, o.region.name),
          le(re, `#${o.region.number ?? ""}`);
      },
      [() => Ni(o.region.cityId)]
    ),
    Zn("close", A, () => f(!1)),
    G(_, A),
    Rr();
}
async function qF(_) {
  const o = ze();
  let f = `/v1/autocomplete?text=${encodeURIComponent(
    _
  )}${o === "pt" ? "&lang=pt" : ""}`;
  const x = await fetch(f);
  if (!x.ok) {
    const A = await x.text();
    throw (console.error(`Geocoding API error: ${A}`), new Error(vb()));
  }
  return x.json();
}
var UF = me(
    '<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'
  ),
  ZF = me(
    '<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>'
  );
function bm(_, o) {
  Dr(o, !0);
  const f = (s, B) => {
    let N = () => (B == null ? void 0 : B().name),
      K = () => (B == null ? void 0 : B().label),
      ee = () => (B == null ? void 0 : B().onclick);
    var re = ZF(),
      ue = M(re);
    ue.__click = function (...Ue) {
      var Be;
      (Be = ee()) == null || Be.apply(this, Ue);
    };
    var ne = M(ue);
    $p(ne, { class: "text-base-content/80 mt-0.5 size-6 min-w-6" });
    var Y = q(ne, 2),
      xe = M(Y),
      Ie = M(xe, !0);
    P(xe);
    var Ee = q(xe, 2),
      De = M(Ee, !0);
    P(Ee), P(Y), P(ue);
    var Ae = q(ue, 2);
    {
      var qe = (Ue) => {
        var Be = UF(),
          ke = M(Be);
        ke.__click = function (...Le) {
          var nt;
          (nt = o.onremove) == null || nt.apply(this, Le);
        };
        var $e = M(ke);
        Os($e, { class: "size-4" }), P(ke), P(Be), G(Ue, Be);
      };
      Me(Ae, (Ue) => {
        o.onremove && Ue(qe);
      });
    }
    P(re),
      Ne(() => {
        le(Ie, N()), le(De, K());
      }),
      G(s, re);
  };
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        f(s, () => ({
          name: o.location.name,
          label: o.location.label,
          onclick: o.onclick,
        }));
      },
      T = (s) => {
        var B = Jt(),
          N = _t(B);
        {
          var K = (re) => {
              {
                let ue = ut(() => ({
                  name: o.location.name,
                  label: __(),
                  onclick: o.onclick,
                }));
                f(re, () => y(ue));
              }
            },
            ee = (re) => {
              var ue = Jt(),
                ne = _t(ue);
              {
                var Y = (xe) => {
                  {
                    let Ie = ut(() => ({
                      name: `${o.location.pos.lat.toFixed(
                        4
                      )}, ${o.location.pos.lng.toFixed(4)}`,
                      label: Y0(),
                      onclick: o.onclick,
                    }));
                    f(xe, () => y(Ie));
                  }
                };
                Me(
                  ne,
                  (xe) => {
                    o.location.type === "coordinates" && xe(Y);
                  },
                  !0
                );
              }
              G(re, ue);
            };
          Me(
            N,
            (re) => {
              o.location.type === "country" ? re(K) : re(ee, !1);
            },
            !0
          );
        }
        G(s, B);
      };
    Me(A, (s) => {
      o.location.type === "place" ? s(L) : s(T, !1);
    });
  }
  G(_, x), Rr();
}
Bn(["click"]);
var GF = Lr(
  '<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>'
);
function $F(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = GF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var HF = Lr(
  '<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>'
);
function WF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = HF();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var XF = me(
    '<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'
  ),
  YF = me('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  KF = me("<!> <!>", 1),
  JF = me('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  QF = me(
    '<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>',
    1
  ),
  e9 = me(
    '<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
  );
function t9(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(""),
    A = Je(!1),
    L = Je(!1);
  const T = new iA(() => y(x), 400);
  let s = Je(null),
    B = Je(void 0),
    N = Je([]);
  const K =
      /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    ee = ut(() => {
      const je = K.exec(y(x));
      if (je) {
        const Ge = parseFloat(je[1]),
          bt = parseFloat(je[5]);
        return {
          type: "coordinates",
          id: `coords-${Ge}-${bt}`,
          pos: { lat: Ge, lng: bt },
          zoom: o.tileZoom + 2,
        };
      }
    }),
    re = "recent-locations";
  Fn(() => {
    const je = localStorage.getItem(re);
    if (je)
      try {
        te(N, JSON.parse(je));
      } catch (Ge) {
        console.error("Failed to parse recent locations from localStorage", Ge);
      }
  }),
    $r(() => {
      T.current &&
        qF(T.current).then((je) => {
          te(
            B,
            je.features.map((Ge) => {
              if (Ge.properties.layer === "country")
                return {
                  type: "country",
                  id: Ge.properties.id,
                  name: Ge.properties.name,
                  bbox: Ge.bbox,
                };
              const bt = Ge.properties.label
                .replace(Ge.properties.name + ",", "")
                .trim();
              return {
                type: "place",
                id: Ge.properties.id,
                name: Ge.properties.name,
                label: bt,
                bbox: Ge.bbox,
              };
            })
          ),
            y(A) && y(B).length > 0 && ne(y(B)[0]);
        });
    }),
    $r(() => {
      y(x) || te(B, void 0);
    }),
    $r(() => {
      f()
        ? setTimeout(() => {
            y(s).focus();
          }, 50)
        : (te(x, ""), te(A, !1), te(B, void 0));
    });
  async function ue() {
    const { tile: je, pixel: Ge } = await Jr.getRandomTile(o.season),
      bt = new ps(o.tileSize),
      Xe = je.x * o.tileSize + Ge.x,
      Ve = je.y * o.tileSize + Ge.y,
      [Ke, Fe] = bt.pixelsToLatLon(Xe, Ve, o.tileZoom),
      ft = { lat: Ke, lng: Fe },
      lt = o.tileZoom + 2;
    o.map.flyTo({ zoom: lt, center: ft }),
      Y({ type: "coordinates", id: `coords-${Ke}-${Fe}`, pos: ft, zoom: lt });
  }
  function ne(je) {
    je.type === "coordinates"
      ? o.map.flyTo({ zoom: je.zoom, center: je.pos })
      : o.map.fitBounds(
          [
            [je.bbox[0], je.bbox[1]],
            [je.bbox[2], je.bbox[3]],
          ],
          { padding: 40, duration: 1e3 }
        ),
      f(!1),
      te(B, void 0),
      Y(je);
  }
  function Y(je) {
    te(
      N,
      y(N).filter((bt) => bt.id !== je.id)
    ),
      y(N).unshift(je);
    const Ge = 15;
    y(N).length > Ge && te(N, y(N).slice(0, Ge)),
      te(N, [...y(N)]),
      localStorage.setItem(re, JSON.stringify(y(N)));
  }
  var xe = e9(),
    Ie = M(xe),
    Ee = M(Ie),
    De = M(Ee),
    Ae = M(De);
  Oa(Ae),
    Eo(
      Ae,
      (je) => te(s, je),
      () => y(s)
    );
  var qe = q(Ae, 2);
  qe.__click = () => f(!1);
  var Ue = M(qe);
  A0(Ue, { class: "size-5" }), P(qe);
  var Be = q(qe, 2);
  {
    var ke = (je) => {
      var Ge = XF();
      Ge.__click = () => te(x, "");
      var bt = M(Ge);
      $F(bt, { class: "size-4.5" }), P(Ge), G(je, Ge);
    };
    Me(Be, (je) => {
      y(x) && je(ke);
    });
  }
  P(De), P(Ee);
  var $e = q(Ee, 2),
    Le = M($e);
  {
    var nt = (je) => {
        bm(je, {
          get location() {
            return y(ee);
          },
          onclick: () => ne(y(ee)),
        });
      },
      dt = (je) => {
        var Ge = Jt(),
          bt = _t(Ge);
        {
          var Xe = (Ke) => {
              var Fe = KF(),
                ft = _t(Fe);
              oi(
                ft,
                17,
                () => y(B),
                (mt) => mt.id,
                (mt, ct) => {
                  bm(mt, {
                    get location() {
                      return y(ct);
                    },
                    onclick: () => ne(y(ct)),
                  });
                }
              );
              var lt = q(ft, 2);
              {
                var yt = (mt) => {
                  var ct = YF(),
                    qt = M(ct, !0);
                  P(ct), Ne((Ft) => le(qt, Ft), [() => XM()]), G(mt, ct);
                };
                Me(lt, (mt) => {
                  y(B).length === 0 && mt(yt);
                });
              }
              G(Ke, Fe);
            },
            Ve = (Ke) => {
              var Fe = QF(),
                ft = _t(Fe),
                lt = M(ft),
                yt = M(lt, !0);
              P(lt);
              var mt = q(lt, 2);
              mt.__click = async () => {
                try {
                  await ue(), f(!1);
                } catch (at) {
                  xr.error(at.message);
                } finally {
                  te(L, !1);
                }
              };
              var ct = M(mt);
              WF(ct, { class: "size-5" }), P(mt), P(ft);
              var qt = q(ft, 2);
              oi(
                qt,
                17,
                () => y(N),
                (at) => at.id,
                (at, xt) => {
                  bm(at, {
                    get location() {
                      return y(xt);
                    },
                    onclick: () => {
                      ne(y(xt));
                    },
                    onremove: () => {
                      te(
                        N,
                        y(N).filter((It) => It.id !== y(xt).id)
                      ),
                        localStorage.setItem(re, JSON.stringify(y(N)));
                    },
                  });
                }
              );
              var Ft = q(qt, 2);
              {
                var Ye = (at) => {
                  var xt = JF(),
                    It = M(xt, !0);
                  P(xt), Ne((Tt) => le(It, Tt), [() => JM()]), G(at, xt);
                };
                Me(Ft, (at) => {
                  y(N).length === 0 && at(Ye);
                });
              }
              Ne(
                (at, xt) => {
                  le(yt, at), gr(mt, "data-tip", xt), (mt.disabled = y(L));
                },
                [() => UM(), () => $M()]
              ),
                G(Ke, Fe);
            };
          Me(
            bt,
            (Ke) => {
              y(B) ? Ke(Xe) : Ke(Ve, !1);
            },
            !0
          );
        }
        G(je, Ge);
      };
    Me(Le, (je) => {
      y(ee) ? je(nt) : je(dt, !1);
    });
  }
  P($e),
    P(Ie),
    yn(2),
    P(xe),
    yi(xe, () => (je) => {
      $r(() => {
        f() ? je.showModal() : je.close();
      });
    }),
    Ne((je) => gr(Ae, "placeholder", je), [() => F0()]),
    Zn("close", xe, () => f(!1)),
    Zn("submit", De, () => {
      var je;
      y(ee)
        ? ne(y(ee))
        : T.pending
        ? te(A, !0)
        : (je = y(B)) != null && je.length && ne(y(B)[0]);
    }),
    $h(
      Ae,
      () => y(x),
      (je) => te(x, je)
    ),
    G(_, xe),
    Rr();
}
Bn(["click"]);
var r9 = me("<!> <!>", 1),
  n9 = me(
    '<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'
  ),
  i9 = me(
    '<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'
  ),
  a9 = me(
    '<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'
  ),
  o9 = me(
    '<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'
  ),
  s9 = me(
    '<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'
  ),
  l9 = me(
    '<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>',
    1
  ),
  c9 = me("<span> </span>"),
  u9 = me(
    '<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'
  ),
  h9 = me('<span class="tooltip svelte-15blegn"><!></span>'),
  d9 = me('<span class="tooltip svelte-15blegn"><!></span>'),
  p9 = me(
    '<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>',
    1
  ),
  f9 = me(
    '<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> </td></tr>'
  ),
  m9 = me(
    '<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'
  ),
  _9 = me(
    '<div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex justify-between gap-1 svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div> <div class="pb-3 svelte-15blegn"><!></div></div></div>'
  );
function g9(_, o) {
  Dr(o, !0);
  let f = Si([]),
    x = Je(Si([])),
    A = Je(!1),
    L = Je(!1),
    T = Je(!1),
    s,
    B,
    N,
    K;
  const ee = 15e6,
    re = new Pm(),
    ue = ut(() =>
      re.size === 0 ? "none" : re.size === y(x).length ? "all" : "some"
    );
  Fn(() => {
    Oi.droppletAndPlop.play(), (s = Ae());
    const Xe = o.map.on("click", async (Ve) => {
      if (f.length >= 2) {
        o.onclose();
        return;
      }
      if ((f.push(Ve.lngLat), qe(), Oi.plop.play(), f.length === 2))
        try {
          te(A, !0), te(x, await Y(f[0], f[1]), !0);
        } finally {
          te(A, !1);
        }
    });
    return () => {
      Xe.unsubscribe(), o.crosshair.clear(), s == null || s(), (s = void 0);
    };
  });
  function ne() {
    y(L) || (s == null || s(), (s = void 0), o.onclose());
  }
  async function Y(Xe, Ve) {
    const Ke = new ps(o.tileSize),
      [Fe, ft] = Ke.latLonToPixelsFloor(Xe.lat, Xe.lng, o.pixelArtZoom),
      [lt, yt] = Ke.latLonToPixelsFloor(Ve.lat, Ve.lng, o.pixelArtZoom),
      [mt, ct] = [Math.min(Fe, lt), Math.min(ft, yt)],
      [qt, Ft] = [Math.max(Fe, lt), Math.max(ft, yt)],
      Ye = qt - mt,
      at = Ft - ct;
    if (Ye * at > ee)
      return (
        xr.error(
          `The selected area is too big. Please select an area smaller than ${ee.toLocaleString()} pixels.`
        ),
        []
      );
    const It = Math.floor(mt / o.tileSize),
      Tt = Math.floor(ct / o.tileSize),
      Mt = Math.floor(qt / o.tileSize),
      Wt = Math.floor(Ft / o.tileSize),
      Bt = Mt - It + 1,
      Gt = Wt - Tt + 1,
      At = new Array(Gt).fill(0).flatMap((ir, vr) =>
        new Array(Bt).fill(0).map(async (ar, pr) => {
          const tr = It + pr,
            Dt = Tt + vr;
          let Sr = 0,
            Te = 0,
            O = o.tileSize - 1,
            E = o.tileSize - 1;
          Dt === Tt && (Te = ct % o.tileSize),
            tr === It && (Sr = mt % o.tileSize),
            Dt === Wt && (E = Ft % o.tileSize),
            tr === Mt && (O = qt % o.tileSize);
          const ce = [tr, Dt],
            ge = [Sr, Te],
            de = [O, E];
          return {
            response: await Jr.getPixelAreaInfo({
              season: o.season,
              tile: ce,
              p0: ge,
              p1: de,
            }),
            tile: ce,
            p0: ge,
            p1: de,
          };
        })
      ),
      Xt = await Promise.all(At),
      Lt = new Map();
    for (const { response: ir, p0: vr, p1: ar, tile: pr } of Xt) {
      const [tr, Dt] = pr,
        [Sr, Te] = vr,
        [O, E] = ar,
        D = O - Sr + 1,
        j = E - Te + 1;
      for (let H = 0; H < j; H++)
        for (let W = 0; W < D; W++) {
          const ce = H * D + W,
            ge = ir.paintedBy[ce];
          let de = Lt.get(ge);
          de || ((de = { latitudes: [], longitudes: [] }), Lt.set(ge, de));
          const [Se, We] = Ke.pixelsToLatLon(
            tr * o.tileSize + (Sr + W + 0.5),
            Dt * o.tileSize + (Te + H + 0.5),
            o.pixelArtZoom
          );
          de.latitudes.push(Se), de.longitudes.push(We);
        }
    }
    const { users: Nt } = await Jr.getMultipleUsersInfoById([...Lt.keys()]),
      jt = yb(Nt, (ir) => ir.id),
      mr = [...Lt.entries()].map(([ir, vr]) => ({
        ...(jt[ir] ?? { id: ir, name: "Player", deleted: !0 }),
        painted: vr,
      }));
    return (
      mr.sort((ir, vr) =>
        ir.id === 0
          ? 1
          : vr.id === 0
          ? -1
          : vr.painted.latitudes.length - ir.painted.latitudes.length
      ),
      mr
    );
  }
  async function xe({ preserveSelection: Xe = !1 } = {}) {
    if (f.length < 2) return;
    const Ve = Xe ? new Set([...re.keys()]) : void 0;
    try {
      te(A, !0);
      const Ke = await Y(f[0], f[1]);
      if ((te(x, Ke, !0), re.clear(), Xe && Ve != null && Ve.size))
        for (const Fe of Ke) Ve.has(Fe.id) && re.set(Fe.id, Fe);
      if ((o.crosshair.clear(), Xe && Ve != null && Ve.size))
        for (const Fe of re.values())
          for (let ft = 0; ft < Fe.painted.latitudes.length; ft++)
            o.crosshair.place([
              Fe.painted.latitudes[ft],
              Fe.painted.longitudes[ft],
            ]);
    } finally {
      te(A, !1);
    }
  }
  function Ie(Xe) {
    for (const Ve of Xe) Ee(Ve.painted);
    Oi.plop.play();
  }
  function Ee(Xe) {
    for (let Ve = 0; Ve < Xe.latitudes.length; Ve++)
      o.crosshair.place([Xe.latitudes[Ve], Xe.longitudes[Ve]]);
  }
  function De(Xe) {
    for (let Ve = 0; Ve < Xe.latitudes.length; Ve++)
      o.crosshair.remove([Xe.latitudes[Ve], Xe.longitudes[Ve]]);
  }
  $r(() => {
    f.length, qe(), Ue();
  });
  function Ae() {
    const Xe = o.map.getContainer(),
      Ve = document.createElement("div");
    Ve.classList.add("selection-rectangle"),
      (Ve.style.position = "absolute"),
      (Ve.style.pointerEvents = "none"),
      (Ve.style.display = "none"),
      (Ve.style.zIndex = "6"),
      Xe.appendChild(Ve);
    const Ke = ke(Xe, "horizontal"),
      Fe = ke(Xe, "vertical");
    N = { horizontal: Ke, vertical: Fe };
    const ft = (mt) => {
        f.length >= 2 ? (K = void 0) : (K = { x: mt.point.x, y: mt.point.y }),
          qe(),
          Ue();
      },
      lt = () => {
        f.length < 2 && (K = void 0), qe(), Ue();
      },
      yt = () => {
        qe(), Ue();
      };
    return (
      o.map.on("mousemove", ft),
      Xe.addEventListener("mouseleave", lt),
      o.map.on("move", yt),
      o.map.on("resize", yt),
      (B = Ve),
      qe(),
      Ue(),
      () => {
        o.map.off("mousemove", ft),
          o.map.off("move", yt),
          o.map.off("resize", yt),
          Xe.removeEventListener("mouseleave", lt),
          Ve.remove(),
          (B = void 0),
          (K = void 0),
          N == null || N.horizontal.remove(),
          N == null || N.vertical.remove(),
          (N = void 0);
      }
    );
  }
  function qe() {
    const Xe = B;
    if (!Xe) return;
    const Ve = new ps(o.tileSize);
    let Ke, Fe, ft, lt;
    if (f.length >= 2) {
      const Mt = f.map((Wt) =>
        Ve.latLonToPixelsFloor(Wt.lat, Wt.lng, o.pixelArtZoom)
      );
      (Ke = Math.min(...Mt.map(([Wt]) => Wt))),
        (Fe = Math.max(...Mt.map(([Wt]) => Wt)) + 1),
        (ft = Math.min(...Mt.map(([, Wt]) => Wt))),
        (lt = Math.max(...Mt.map(([, Wt]) => Wt)) + 1);
    } else if (f.length === 1 && K) {
      const [Mt, Wt] = Ve.latLonToPixelsFloor(
          f[0].lat,
          f[0].lng,
          o.pixelArtZoom
        ),
        Bt = o.map.unproject([K.x, K.y]),
        [Gt, At] = Ve.latLonToPixelsFloor(Bt.lat, Bt.lng, o.pixelArtZoom);
      (Ke = Math.min(Mt, Gt)),
        (Fe = Math.max(Mt, Gt) + 1),
        (ft = Math.min(Wt, At)),
        (lt = Math.max(Wt, At) + 1);
    } else {
      Xe.style.display = "none";
      return;
    }
    const [yt, mt] = Ve.pixelsToLatLon(Ke, ft, o.pixelArtZoom),
      [ct, qt] = Ve.pixelsToLatLon(Fe, lt, o.pixelArtZoom),
      Ft = o.map.project([mt, yt]),
      Ye = o.map.project([qt, ct]);
    let at = Math.min(Ft.x, Ye.x),
      xt = Math.max(Ft.x, Ye.x),
      It = Math.min(Ft.y, Ye.y),
      Tt = Math.max(Ft.y, Ye.y);
    xt - at < 1 && (xt = at + 1),
      Tt - It < 1 && (Tt = It + 1),
      (Xe.style.display = "block"),
      (Xe.style.left = `${at}px`),
      (Xe.style.top = `${It}px`),
      (Xe.style.width = `${xt - at}px`),
      (Xe.style.height = `${Tt - It}px`);
  }
  function Ue() {
    const Xe = N;
    if (Xe) {
      if (!K || f.length >= 2) {
        Be();
        return;
      }
      (Xe.horizontal.style.display = "block"),
        (Xe.horizontal.style.top = `${K.y}px`),
        (Xe.horizontal.style.transform = "translateY(-0.5px)"),
        (Xe.vertical.style.display = "block"),
        (Xe.vertical.style.left = `${K.x}px`),
        (Xe.vertical.style.transform = "translateX(-0.5px)");
    }
  }
  function Be() {
    N &&
      ((N.horizontal.style.display = "none"),
      (N.vertical.style.display = "none"));
  }
  function ke(Xe, Ve) {
    const Ke = document.createElement("div");
    return (
      (Ke.style.position = "absolute"),
      (Ke.style.pointerEvents = "none"),
      (Ke.style.zIndex = "5"),
      (Ke.style.display = "none"),
      (Ke.style.mixBlendMode = "difference"),
      (Ke.style.backgroundColor = "rgba(255, 255, 255, 0.9)"),
      Ve === "horizontal"
        ? ((Ke.style.left = "0"),
          (Ke.style.right = "0"),
          (Ke.style.height = "1px"))
        : ((Ke.style.top = "0"),
          (Ke.style.bottom = "0"),
          (Ke.style.width = "1px")),
      Xe.appendChild(Ke),
      Ke
    );
  }
  async function $e() {
    if (y(T) || y(A)) return;
    const Xe = new ps(o.tileSize),
      Ve = new Map();
    for (const Ke of re.values()) {
      if (Ke.id === 0) continue;
      const { latitudes: Fe, longitudes: ft } = Ke.painted;
      for (let lt = 0; lt < Fe.length; lt++) {
        const { tile: yt, pixel: mt } = Xe.latLonToTileAndPixel(
            Fe[lt],
            ft[lt],
            o.pixelArtZoom
          ),
          ct = { tile: yt, pixel: mt, season: o.season },
          qt = `${yt[0]}:${yt[1]}:${mt[0]}:${mt[1]}`;
        Ve.set(qt, ct);
      }
    }
    if (Ve.size === 0) {
      xr.info("Select painted pixels to clear with transparent color");
      return;
    }
    te(T, !0);
    try {
      Oi.droppletAndPlop.play();
      const Ke = await qy(),
        Fe = [];
      for (const yt of Ve.values()) Fe.push({ ...yt, colorIdx: 0 });
      await Jr.paint(Fe, Ke);
      const ft = M0(0),
        lt = Fe.map(({ tile: yt, pixel: mt, season: ct }) => ({
          tile: yt,
          pixel: mt,
          season: ct,
          color: ft,
        }));
      await b0(lt),
        xr.success("Painted selected pixels with transparent color"),
        await xe();
    } catch (Ke) {
      xr.error(Ke.message);
    } finally {
      te(T, !1);
    }
  }
  const Le = (Xe) => ({
    id: Xe.id,
    name: Xe.name,
    picture: Xe.picture,
    allianceId: Xe.allianceId ?? void 0,
    allianceName: Xe.allianceName ?? void 0,
    timedOut: Xe.timedOut,
    banned: Xe.banned,
    deleted: Xe.deleted,
  });
  async function nt(Xe, Ve) {
    try {
      te(L, !0);
      const Ke = Xe.filter((Ft) => Ft.id !== 0);
      if (Ke.length === 0) {
        xr.info("Select at least one player");
        return;
      }
      const Fe = Ke.flatMap((Ft) => Ft.painted.latitudes),
        ft = Ke.flatMap((Ft) => Ft.painted.longitudes);
      if (Fe.length === 0 || ft.length === 0) {
        xr.error("No pixel data available for the selected users.");
        return;
      }
      const lt = Math.min(...Fe),
        yt = Math.max(...Fe),
        mt = Math.min(...ft),
        ct = Math.max(...ft);
      o.map.fitBounds(
        [
          { lat: lt, lng: mt },
          { lat: yt, lng: ct },
        ],
        { padding: 100, duration: 0 }
      );
      const qt = (async () =>
        await C_(o.map, {
          maxHeight: 1080,
          maxWidth: 1080,
          quality: 0.8,
          type: "image/jpeg",
        }))();
      o.onmodaction({
        action: Ve,
        targets: Ke.map(Le),
        image: qt,
        latLon: [(lt + yt) / 2, (mt + ct) / 2],
        zoom: o.map.getZoom(),
        onSuccess: async () => {
          await xe({ preserveSelection: !0 });
        },
      });
    } catch (Ke) {
      xr.error(Ke.message);
    } finally {
      te(L, !1);
    }
  }
  var dt = Jt();
  Zn("keydown", l_, (Xe) => Xe.code === "Escape" && ne());
  var je = _t(dt);
  {
    var Ge = (Xe) => {
        pl(Xe, {
          class: "bg-warning animate-bounce",
          children: (Ve, Ke) => {
            var Fe = r9(),
              ft = _t(Fe);
            sh(ft, { class: "inline size-5" });
            var lt = q(ft, 2);
            {
              var yt = (ct) => {
                  var qt = ji();
                  Ne((Ft) => le(qt, Ft), [() => $0()]), G(ct, qt);
                },
                mt = (ct) => {
                  var qt = Jt(),
                    Ft = _t(qt);
                  {
                    var Ye = (at) => {
                      var xt = ji();
                      Ne((It) => le(xt, It), [() => H0()]), G(at, xt);
                    };
                    Me(
                      Ft,
                      (at) => {
                        f.length === 1 && at(Ye);
                      },
                      !0
                    );
                  }
                  G(ct, qt);
                };
              Me(lt, (ct) => {
                f.length === 0 ? ct(yt) : ct(mt, !1);
              });
            }
            G(Ve, Fe);
          },
          $$slots: { default: !0 },
        });
      },
      bt = (Xe) => {
        var Ve = _9(),
          Ke = M(Ve),
          Fe = M(Ke),
          ft = M(Fe),
          lt = M(ft),
          yt = M(lt);
        sh(yt, { class: "size-4" }), P(lt);
        var mt = q(lt, 4),
          ct = M(mt);
        P(mt), P(ft);
        var qt = q(ft, 2);
        qt.__click = ne;
        var Ft = M(qt);
        Os(Ft, { class: "size-4" }), P(qt), P(Fe);
        var Ye = q(Fe, 2),
          at = M(Ye);
        {
          var xt = (Tt) => {
              var Mt = n9();
              G(Tt, Mt);
            },
            It = (Tt) => {
              var Mt = Jt(),
                Wt = _t(Mt);
              {
                var Bt = (At) => {
                    var Xt = i9();
                    G(At, Xt);
                  },
                  Gt = (At) => {
                    var Xt = m9(),
                      Lt = M(Xt),
                      Nt = M(Lt),
                      jt = M(Nt),
                      mr = M(jt),
                      ir = M(mr);
                    Oa(ir),
                      (ir.__click = (H) => {
                        if (y(ue) === "none") {
                          const W = [];
                          for (const ce of y(x))
                            re.has(ce.id) || (re.set(ce.id, ce), W.push(ce));
                          W.length && Ie(W);
                          return;
                        }
                        re.clear(), o.crosshair.clear();
                      }),
                      P(mr);
                    var vr = q(mr),
                      ar = q(M(vr));
                    ar.__click = () => {
                      navigator.clipboard.writeText(
                        [...re.keys()].filter((H) => H !== 0).join(", ")
                      ),
                        xr.success("Player IDs copied to clipboard");
                    };
                    var pr = M(ar);
                    p_(pr, { class: "size-3" }), P(ar);
                    var tr = q(ar, 2);
                    tr.__click = () => {
                      nt([...re.values()], "timeout");
                    };
                    var Dt = M(tr);
                    rh(Dt, { class: "size-4" }), P(tr);
                    var Sr = q(tr, 2);
                    {
                      var Te = (H) => {
                        var W = a9();
                        W.__click = () => {
                          nt([...re.values()], "ban");
                        };
                        var ce = M(W);
                        zp(ce, { class: "size-4" }),
                          P(W),
                          Ne(() => (W.disabled = y(L))),
                          G(H, W);
                      };
                      Me(Sr, (H) => {
                        var W;
                        ba((W = kt.data) == null ? void 0 : W.role, [
                          "admin",
                          "global_moderator",
                        ]) && H(Te);
                      });
                    }
                    P(vr);
                    var O = q(vr),
                      E = M(O);
                    {
                      var D = (H) => {
                        var W = s9();
                        W.__click = $e;
                        var ce = M(W);
                        {
                          var ge = (Se) => {
                              var We = o9();
                              G(Se, We);
                            },
                            de = (Se) => {
                              Cm(Se, { class: "size-4" });
                            };
                          Me(ce, (Se) => {
                            y(T) ? Se(ge) : Se(de, !1);
                          });
                        }
                        P(W),
                          Ne(
                            () => (W.disabled = y(T) || y(A) || re.size === 0)
                          ),
                          G(H, W);
                      };
                      Me(E, (H) => {
                        var W;
                        ba((W = kt.data) == null ? void 0 : W.role, [
                          "admin",
                          "global_moderator",
                        ]) && H(D);
                      });
                    }
                    yn(), P(O), P(jt), P(Nt);
                    var j = q(Nt);
                    oi(
                      j,
                      23,
                      () => y(x),
                      (H) => H.id,
                      (H, W, ce, ge) => {
                        const de = ut(() => re.has(y(W).id));
                        var Se = f9();
                        let We;
                        Se.__click = () => {
                          y(de)
                            ? (re.delete(y(W).id), De(y(W).painted))
                            : (re.set(y(W).id, y(W)),
                              Ee(y(W).painted),
                              Oi.plop.play());
                        };
                        var Ze = M(Se),
                          Ct = M(Ze);
                        Oa(Ct), P(Ze);
                        var _e = q(Ze),
                          Vt = M(_e);
                        {
                          var cr = (Ur) => {
                              var Wr = l9();
                              yn(2), G(Ur, Wr);
                            },
                            Ot = (Ur) => {
                              var Wr = p9(),
                                un = _t(Wr);
                              mo(un, {
                                class: "size-5 border-0",
                                get userId() {
                                  return y(W).id;
                                },
                                get pictureUrl() {
                                  return y(W).picture;
                                },
                              });
                              var an = q(un, 2),
                                fn = M(an),
                                rn = M(fn),
                                pt = M(rn, !0);
                              P(rn);
                              var on = q(rn, 2),
                                Pn = M(on);
                              P(on), P(fn);
                              var zt = q(fn, 2);
                              {
                                var Qt = (wt) => {
                                  var sr = c9(),
                                    wr = M(sr, !0);
                                  P(sr),
                                    Ne(
                                      (jr, Yr) => {
                                        Br(
                                          sr,
                                          1,
                                          `badge badge-sm ml-0.5 border-0 ${
                                            jr ?? ""
                                          } ${Yr ?? ""}`,
                                          "svelte-15blegn"
                                        ),
                                          le(wr, y(W).allianceName);
                                      },
                                      [
                                        () => Wp(y(W).allianceId),
                                        () => Ni(y(W).allianceId),
                                      ]
                                    ),
                                    G(wt, sr);
                                };
                                Me(zt, (wt) => {
                                  y(W).allianceId && wt(Qt);
                                });
                              }
                              var rt = q(zt, 2);
                              {
                                var $t = (wt) => {
                                  var sr = u9();
                                  G(wt, sr);
                                };
                                Me(rt, (wt) => {
                                  y(W).deleted && wt($t);
                                });
                              }
                              var st = q(rt, 2),
                                gt = M(st);
                              {
                                var Ut = (wt) => {
                                    var sr = h9(),
                                      wr = M(sr);
                                    zp(wr, { class: "text-error size-4" }),
                                      P(sr),
                                      Ne(
                                        (jr) => gr(sr, "data-tip", jr),
                                        [() => u_()]
                                      ),
                                      G(wt, sr);
                                  },
                                  br = (wt) => {
                                    var sr = Jt(),
                                      wr = _t(sr);
                                    {
                                      var jr = (Yr) => {
                                        var fr = d9(),
                                          Zr = M(fr);
                                        rh(Zr, { class: "text-error size-4" }),
                                          P(fr),
                                          Ne(
                                            (nn) => gr(fr, "data-tip", nn),
                                            [() => B0()]
                                          ),
                                          G(Yr, fr);
                                      };
                                      Me(
                                        wr,
                                        (Yr) => {
                                          y(W).timedOut && Yr(jr);
                                        },
                                        !0
                                      );
                                    }
                                    G(wt, sr);
                                  };
                                Me(gt, (wt) => {
                                  y(W).banned ? wt(Ut) : wt(br, !1);
                                });
                              }
                              P(st),
                                P(an),
                                Ne(
                                  (wt) => {
                                    Br(
                                      fn,
                                      1,
                                      `font-medium ${wt ?? ""} flex gap-1.5`,
                                      "svelte-15blegn"
                                    ),
                                      le(pt, y(W).name),
                                      le(Pn, `#${y(W).id ?? ""}`);
                                  },
                                  [() => Ni(y(W).id)]
                                ),
                                G(Ur, Wr);
                            };
                          Me(Vt, (Ur) => {
                            y(W).id === 0 ? Ur(cr) : Ur(Ot, !1);
                          });
                        }
                        P(_e);
                        var ur = q(_e),
                          Nr = M(ur, !0);
                        P(ur),
                          P(Se),
                          Ne(
                            (Ur) => {
                              (We = Br(
                                Se,
                                1,
                                "hover:bg-base-300 cursor-pointer svelte-15blegn",
                                null,
                                We,
                                { "bg-base-200": y(de) }
                              )),
                                Av(Ct, y(de)),
                                le(Nr, Ur);
                            },
                            [
                              () =>
                                y(W).painted.latitudes.length.toLocaleString(),
                            ]
                          ),
                          G(H, Se);
                      }
                    ),
                      P(j),
                      P(Lt),
                      P(Xt),
                      Ne(() => {
                        Av(ir, y(ue) !== "none"),
                          (ir.indeterminate = y(ue) === "some"),
                          (tr.disabled = y(L));
                      }),
                      G(At, Xt);
                  };
                Me(
                  Wt,
                  (At) => {
                    y(x).length === 0 ? At(Bt) : At(Gt, !1);
                  },
                  !0
                );
              }
              G(Tt, Mt);
            };
          Me(at, (Tt) => {
            y(A) ? Tt(xt) : Tt(It, !1);
          });
        }
        P(Ye),
          P(Ke),
          P(Ve),
          Ne(
            (Tt) => le(ct, `(Pixels: ${Tt ?? ""})`),
            [
              () =>
                [...re.values()].reduce(
                  (Tt, Mt) => Tt + Mt.painted.latitudes.length,
                  0
                ),
            ]
          ),
          oa(
            3,
            Ve,
            () => bp,
            () => ({ duration: 100 })
          ),
          G(Xe, Ve);
      };
    Me(je, (Xe) => {
      f.length < 2 ? Xe(Ge) : Xe(bt, !1);
    });
  }
  G(_, dt), Rr();
}
Bn(["click"]);
const v9 =
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAfCAYAAAAfrhY5AAAByUlEQVR4AeyV0VEDMQxEbQqgDEqhFrpg6IJaKIUyaODQ89wqimKf75LM5AOY20harbWyf3gqD/z7N3/I49/j2RfbHFg49t1qvjx/vRVgtocXuMW8GZtp+Xn9JFR+jmCvObeKcI9gHPvkrhklM3OGLMv7S4mwYfAW/Btpss4PkIzMOeQDEQr149sX4dZaCl4aonjL2yyLF1/PvGvKSQwYSp4BT7/H0zOeJSycvmzejE/t+2W9BbL5pts6wDWz2oWDJJr7rXm+iMHZTTqeJ0e8LuvPH83pN6yilvPDYYF6BGmIUZPnqdc1V1NxWZYCqPNgOCAeHYCbYZd5HiIj8bkWP4tD8/hUtdZSa/VZ6slUNYJaa1dLL2NojjAOpQbiZKwoHo3Q49QjbpojYEAEHJhx9NFtYWqum/WGXNvTrGhe8zDVijpEFKcIJ4hTTHxVHc3FtaiDej7VNJUf7XE2Ipv77RkMECtiCiI368W+nfNbW16yOVxbQCYQQENynuuoo8ccYPmZsdVdc3iEF0swGCAA61BS/x/fCvuhB0hXWDj/ejePirMlGBZhQl8w8uT0VljofzNznWpLWJGjUSVzqultYq/55pBrm3/X/BcAAP//XVoCOwAAAAZJREFUAwCtKAFOt0LgOAAAAABJRU5ErkJgggAA";
var y9 = Lr(
  '<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>'
);
function Wy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = y9();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var x9 = Lr(
  '<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>'
);
function b9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = x9();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var w9 = Lr(
    '<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'
  ),
  T9 = Lr(
    '<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>'
  );
function S9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        var B = w9();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      },
      T = (s) => {
        var B = T9();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      };
    Me(A, (s) => {
      o.filled ? s(L) : s(T, !1);
    });
  }
  G(_, x);
}
var C9 = me(
    '<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'
  ),
  P9 = me('<div class="skeleton h-5 w-16"></div>'),
  I9 = me('<div class="skeleton mt-1 h-5 w-32"></div>'),
  M9 = me(
    '<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"><img alt="Pumpkin" class="size-5"/></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span> </span> <span> </span></span></div></div>'
  ),
  A9 = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  k9 = me(
    '<span class="badge badge-dash badge-sm bg-primary/20 text-primary tooltip ml-0.5 gap-1 border-0"><!> </span>'
  ),
  E9 = me("<button><!></button>"),
  z9 = me("<span> </span> <!>", 1),
  L9 = me('<span class="tooltip"><!></span>'),
  D9 = me('<span class="tooltip"><!></span>'),
  R9 = me("<li><button><!> </button></li>"),
  F9 = me("<li><button><!> </button></li>"),
  B9 = me("<li><button><!> </button></li>"),
  O9 = me('<li><button class="text-error font-medium"><!> </button></li>'),
  N9 = me(
    '<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'
  ),
  j9 = me(
    '<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'
  ),
  V9 = me('<button class="btn btn-primary"><!> </button>'),
  q9 = me("<!> ", 1),
  U9 = me("<!> ", 1),
  Z9 = me('<button class="btn btn-primary"><!></button>'),
  G9 = me("<button><!> </button>"),
  $9 = me(
    '<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>'
  );
function H9(_, o) {
  Dr(o, !0);
  let f = Je(void 0);
  const x = ut(() => new ps(o.tileSize));
  let A = Je(void 0),
    L = Je(void 0),
    T = Je(!1),
    s = Je(!1);
  const B = ut(() => {
      var Ye, at, xt;
      return (
        !!(
          (at = (Ye = y(f)) == null ? void 0 : Ye.paintedBy) != null && at.id
        ) && ((xt = kt.data) == null ? void 0 : xt.id) === y(f).paintedBy.id
      );
    }),
    N = ut(() => {
      const [Ye, at] = o.latLon ?? [0, 0],
        xt = y(x).latLonToPixelBoundsLatLon(Ye, at, o.pixelArtZoom),
        It = w_(xt),
        { tile: Tt, pixel: Mt } = y(x).latLonToTileAndPixel(
          Ye,
          at,
          o.pixelArtZoom
        ),
        Wt = y(x).latLonToRegionAndPixel(Ye, at, o.pixelArtZoom);
      return {
        bounds: xt,
        center: It,
        tile: Tt,
        pixel: Mt,
        regionPixel: Wt.pixel,
      };
    });
  $r(() => {
    Oi.plop.play(), o.crosshair.clearAndPlace(o.latLon);
  });
  let K = 0;
  const ee = ({ pixel: Ye, tile: at, season: xt }) =>
    `s${xt}:p(${Ye[0]},${Ye[1]}):t(${at[0]},${at[1]})`;
  let re;
  Fs(
    () => [y(N), o.season],
    () => {
      const Ye = { ...y(N), season: o.season },
        at = ee(Ye);
      if ((te(f, o.pixelInfoCache.get(at), !0), y(f) !== void 0)) return;
      o.pixelInfoCache.size === 0 && (K = 0),
        K++,
        K > 6
          ? (clearTimeout(re), (re = setTimeout(async () => ue(Ye), 500)))
          : ue(Ye);
    }
  );
  async function ue(Ye) {
    var It;
    const at = await Jr.getPixelInfo({
      ...Ye,
      isModerator: ba((It = kt.data) == null ? void 0 : It.role, [
        "admin",
        "global_moderator",
        "moderator",
      ]),
    });
    if (at.paintedBy !== void 0) {
      const Tt = ee(Ye);
      o.pixelInfoCache.set(Tt, at);
    }
    const xt = ee({ ...y(N), season: o.season });
    return te(f, o.pixelInfoCache.get(xt), !0), at;
  }
  Fn(() => () => {
    o.crosshair.clear(), Oi.smallPlop.play();
  });
  const ne = ut(() => {
    var It, Tt, Mt, Wt, Bt;
    const Ye = [],
      at =
        (Tt = (It = kt) == null ? void 0 : It.data) == null ? void 0 : Tt.role;
    ba(at, ["admin", "global_moderator"]) && !y(B) && Ye.push("ban-user"),
      ba(at, ["admin", "global_moderator", "moderator"]) &&
        !y(B) &&
        Ye.push("timeout-user"),
      !y(B) && kt.data && Ye.push("report-user");
    const xt = (Mt = y(f)) == null ? void 0 : Mt.paintedBy;
    return (
      (xt == null ? void 0 : xt.allianceId) ===
        ((Wt = kt.data) == null ? void 0 : Wt.allianceId) &&
        ((Bt = kt.data) == null ? void 0 : Bt.allianceRole) === "admin" &&
        kt.data.id !== (xt == null ? void 0 : xt.id) &&
        !y(B) &&
        Ye.push("ban-alliance"),
      Ye
    );
  });
  function Y(Ye) {
    const at = (async () =>
      await C_(o.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: 0.8,
        type: "image/jpeg",
      }))();
    o.onclickmodaction(y(f), at, o.latLon, Ye);
  }
  async function xe() {
    try {
      await Jr.claimEventPixel({ ...y(N), season: o.season }),
        xr.success(d6({ droplets: (2e3).toLocaleString() })),
        await ue({ ...y(N), season: o.season }),
        await kt.refresh();
    } catch (Ye) {
      xr.error(Ye.message);
    }
  }
  var Ie = $9();
  Zn("keypress", l_, (Ye) => {
    Ye.key === "Escape" && o.onclose();
  });
  var Ee = M(Ie),
    De = M(Ee),
    Ae = M(De);
  Ae.__click = () => {
    if (y(A) && y(L)) {
      const Ye = y(A) - y(L).clientHeight,
        at = y(A) / 2 - Ye / 2;
      o.map.flyTo({
        center: { lat: y(N).center[0], lng: y(N).center[1] },
        zoom: 17.5,
        offset: [0, -at],
      });
    }
  };
  var qe = M(Ae);
  $p(qe, { class: "fill-primary size-5" }), P(Ae);
  var Ue = q(Ae, 2),
    Be = M(Ue),
    ke = M(Be);
  P(Be);
  var $e = q(Be, 2);
  {
    var Le = (Ye) => {
        const at = ut(() => y(f).region),
          xt = ut(() => ko(y(at).countryId));
        var It = C9();
        It.__click = () => o.onclickregion(y(at));
        var Tt = M(It),
          Mt = M(Tt, !0);
        P(Tt);
        var Wt = q(Tt, 2),
          Bt = M(Wt, !0);
        P(Wt);
        var Gt = q(Wt, 2),
          At = M(Gt);
        P(Gt),
          P(It),
          Ne(
            (Xt) => {
              Br(
                It,
                1,
                `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${Xt ?? ""}`
              ),
                gr(Tt, "data-tip", y(xt).name),
                le(Mt, y(xt).flag),
                le(Bt, y(at).name),
                le(At, `#${y(at).number ?? ""}`);
            },
            [() => Ni(y(at).cityId)]
          ),
          G(Ye, It);
      },
      nt = (Ye) => {
        var at = P9();
        G(Ye, at);
      };
    Me($e, (Ye) => {
      var at;
      (at = y(f)) != null && at.region ? Ye(Le) : Ye(nt, !1);
    });
  }
  P(Ue), P(De);
  var dt = q(De, 2);
  dt.__click = function (...Ye) {
    var at;
    (at = o.onclose) == null || at.apply(this, Ye);
  };
  var je = M(dt);
  Os(je, { class: "size-4" }), P(dt), P(Ee);
  var Ge = q(Ee, 2),
    bt = M(Ge);
  {
    var Xe = (Ye) => {
        var at = I9();
        G(Ye, at);
      },
      Ve = (Ye) => {
        var at = Jt(),
          xt = _t(at);
        {
          var It = (Mt) => {
              var Wt = ji();
              Ne((Bt) => le(Wt, Bt), [() => oC()]), G(Mt, Wt);
            },
            Tt = (Mt) => {
              var Wt = Jt(),
                Bt = _t(Wt);
              {
                var Gt = (Xt) => {
                    var Lt = M9(),
                      Nt = M(Lt),
                      jt = M(Nt);
                    P(Nt);
                    var mr = q(Nt, 2),
                      ir = M(mr),
                      vr = M(ir);
                    P(ir), P(mr);
                    var ar = q(mr, 2),
                      pr = M(ar),
                      tr = M(pr),
                      Dt = M(tr, !0);
                    P(tr);
                    var Sr = q(tr, 2),
                      Te = M(Sr);
                    P(Sr),
                      P(pr),
                      P(ar),
                      P(Lt),
                      Ne(
                        (O, E) => {
                          le(jt, `${O ?? ""}:`),
                            gr(vr, "src", v9),
                            le(Dt, E),
                            le(Te, `#${y(f).paintedBy.eventClaimNumber ?? ""}`);
                        },
                        [() => m6(), () => n6()]
                      ),
                      G(Xt, Lt);
                  },
                  At = (Xt) => {
                    const Lt = ut(() => y(f).paintedBy);
                    var Nt = j9(),
                      jt = M(Nt),
                      mr = M(jt);
                    P(jt);
                    var ir = q(jt, 2),
                      vr = M(ir);
                    mo(vr, {
                      class: "size-5 border-0",
                      get userId() {
                        return y(Lt).id;
                      },
                      get pictureUrl() {
                        return y(Lt).picture;
                      },
                    }),
                      P(ir);
                    var ar = q(ir, 2),
                      pr = M(ar),
                      tr = M(pr),
                      Dt = M(tr, !0);
                    P(tr);
                    var Sr = q(tr, 2),
                      Te = M(Sr);
                    P(Sr), P(pr);
                    var O = q(pr, 2);
                    {
                      var E = (_e) => {
                        const Vt = ut(() => ko(y(Lt).equippedFlag));
                        var cr = A9(),
                          Ot = M(cr, !0);
                        P(cr),
                          Ne(() => {
                            gr(cr, "data-tip", y(Vt).name), le(Ot, y(Vt).flag);
                          }),
                          G(_e, cr);
                      };
                      Me(O, (_e) => {
                        y(Lt).equippedFlag && _e(E);
                      });
                    }
                    var D = q(O, 2);
                    {
                      var j = (_e) => {
                        Hh(_e, {
                          get username() {
                            return y(Lt).discord;
                          },
                          get id() {
                            return y(Lt).discordId;
                          },
                        });
                      };
                      Me(D, (_e) => {
                        y(Lt).discord && _e(j);
                      });
                    }
                    var H = q(D, 2);
                    {
                      var W = (_e) => {
                        var Vt = k9(),
                          cr = M(Vt);
                        f_(cr, { size: "none" });
                        var Ot = q(cr);
                        P(Vt),
                          Ne(() => {
                            gr(Vt, "data-tip", y(Lt).role),
                              le(Ot, ` ${w0[y(Lt).role] ?? ""}`);
                          }),
                          G(_e, Vt);
                      };
                      Me(H, (_e) => {
                        y(Lt).role && y(Lt).role !== "user" && _e(W);
                      });
                    }
                    var ce = q(H, 2);
                    {
                      var ge = (_e) => {
                        var Vt = z9(),
                          cr = _t(Vt),
                          Ot = M(cr, !0);
                        P(cr);
                        var ur = q(cr, 2);
                        {
                          var Nr = (Ur) => {
                            var Wr = E9();
                            Wr.__click = () => {
                              navigator.clipboard.writeText(
                                y(Lt).allianceId.toString()
                              ),
                                xr.success(g_());
                            };
                            var un = M(Wr);
                            p_(un, { class: "size-3" }),
                              P(Wr),
                              Ne(
                                (an, fn) => {
                                  Br(Wr, 1, an), gr(Wr, "title", fn);
                                },
                                [
                                  () => hs(Ni(y(Lt).allianceId)),
                                  () => qb({ allianceId: y(Lt).allianceId }),
                                ]
                              ),
                              G(Ur, Wr);
                          };
                          Me(ur, (Ur) => {
                            var Wr, un, an;
                            (((Wr = kt.data) == null ? void 0 : Wr.role) ===
                              "admin" ||
                              ((un = kt.data) == null ? void 0 : un.role) ===
                                "moderator" ||
                              ((an = kt.data) == null ? void 0 : an.role) ===
                                "global_moderator") &&
                              Ur(Nr);
                          });
                        }
                        Ne(
                          (Ur, Wr) => {
                            Br(
                              cr,
                              1,
                              `badge badge-sm ml-0.5 border-0 ${Ur ?? ""} ${
                                Wr ?? ""
                              }`
                            ),
                              le(Ot, y(Lt).allianceName);
                          },
                          [
                            () => Wp(y(Lt).allianceId),
                            () => Ni(y(Lt).allianceId),
                          ]
                        ),
                          G(_e, Vt);
                      };
                      Me(ce, (_e) => {
                        y(Lt).allianceId && _e(ge);
                      });
                    }
                    var de = q(ce, 2);
                    {
                      var Se = (_e) => {
                          var Vt = L9(),
                            cr = M(Vt);
                          zp(cr, { class: "text-error size-4" }),
                            P(Vt),
                            Ne((Ot) => gr(Vt, "data-tip", Ot), [() => u_()]),
                            G(_e, Vt);
                        },
                        We = (_e) => {
                          var Vt = Jt(),
                            cr = _t(Vt);
                          {
                            var Ot = (ur) => {
                              var Nr = D9(),
                                Ur = M(Nr);
                              rh(Ur, { class: "text-error size-4" }),
                                P(Nr),
                                Ne(
                                  (Wr) => gr(Nr, "data-tip", Wr),
                                  [() => B0()]
                                ),
                                G(ur, Nr);
                            };
                            Me(
                              cr,
                              (ur) => {
                                y(f).paintedBy.timedOut && ur(Ot);
                              },
                              !0
                            );
                          }
                          G(_e, Vt);
                        };
                      Me(de, (_e) => {
                        y(f).paintedBy.banned ? _e(Se) : _e(We, !1);
                      });
                    }
                    P(ar);
                    var Ze = q(ar, 2);
                    {
                      var Ct = (_e) => {
                        var Vt = N9(),
                          cr = M(Vt),
                          Ot = M(cr);
                        S_(Ot, { class: "size-4" }), P(cr);
                        var ur = q(cr, 2);
                        oi(
                          ur,
                          21,
                          () => y(ne),
                          Hp,
                          (Nr, Ur) => {
                            var Wr = Jt(),
                              un = _t(Wr);
                            {
                              var an = (rn) => {
                                  var pt = R9(),
                                    on = M(pt);
                                  let Pn;
                                  on.__click = () => {
                                    Y("report-user");
                                  };
                                  var zt = M(on);
                                  a_(zt, { class: "size-5" });
                                  var Qt = q(zt);
                                  P(on),
                                    P(pt),
                                    Ne(
                                      (rt) => {
                                        (Pn = Br(
                                          on,
                                          1,
                                          "text-error py-2 font-medium",
                                          null,
                                          Pn,
                                          { "cursor-not-allowed": y(B) }
                                        )),
                                          le(Qt, ` ${rt ?? ""}`);
                                      },
                                      [() => Ab()]
                                    ),
                                    G(rn, pt);
                                },
                                fn = (rn) => {
                                  var pt = Jt(),
                                    on = _t(pt);
                                  {
                                    var Pn = (Qt) => {
                                        var rt = F9(),
                                          $t = M(rt);
                                        let st;
                                        $t.__click = () => {
                                          Y("timeout");
                                        };
                                        var gt = M($t);
                                        rh(gt, { class: "size-5" });
                                        var Ut = q(gt);
                                        P($t),
                                          P(rt),
                                          Ne(
                                            (br) => {
                                              (st = Br(
                                                $t,
                                                1,
                                                "text-error font-medium",
                                                null,
                                                st,
                                                { "cursor-not-allowed": y(B) }
                                              )),
                                                le(Ut, ` ${br ?? ""}`);
                                            },
                                            [() => kb()]
                                          ),
                                          G(Qt, rt);
                                      },
                                      zt = (Qt) => {
                                        var rt = Jt(),
                                          $t = _t(rt);
                                        {
                                          var st = (Ut) => {
                                              var br = B9(),
                                                wt = M(br);
                                              let sr;
                                              wt.__click = () => {
                                                Y("ban");
                                              };
                                              var wr = M(wt);
                                              zp(wr, { class: "size-5" });
                                              var jr = q(wr);
                                              P(wt),
                                                P(br),
                                                Ne(
                                                  (Yr) => {
                                                    (sr = Br(
                                                      wt,
                                                      1,
                                                      "text-error font-medium",
                                                      null,
                                                      sr,
                                                      {
                                                        "cursor-not-allowed":
                                                          y(B),
                                                      }
                                                    )),
                                                      le(jr, ` ${Yr ?? ""}`);
                                                  },
                                                  [() => Eb()]
                                                ),
                                                G(Ut, br);
                                            },
                                            gt = (Ut) => {
                                              var br = Jt(),
                                                wt = _t(br);
                                              {
                                                var sr = (wr) => {
                                                  var jr = O9(),
                                                    Yr = M(jr);
                                                  Yr.__click = async () => {
                                                    te(s, !0);
                                                    try {
                                                      await Jr.banAllianceUser(
                                                        y(Lt).id
                                                      ),
                                                        await ue({
                                                          ...y(N),
                                                          season: o.season,
                                                        });
                                                    } catch (nn) {
                                                      xr.error(nn.message);
                                                    } finally {
                                                      te(s, !1);
                                                    }
                                                  };
                                                  var fr = M(Yr);
                                                  b9(fr, { class: "size-5" });
                                                  var Zr = q(fr);
                                                  P(Yr),
                                                    P(jr),
                                                    Ne(
                                                      (nn) =>
                                                        le(Zr, ` ${nn ?? ""}`),
                                                      [() => q0()]
                                                    ),
                                                    G(wr, jr);
                                                };
                                                Me(
                                                  wt,
                                                  (wr) => {
                                                    y(Ur) === "ban-alliance" &&
                                                      wr(sr);
                                                  },
                                                  !0
                                                );
                                              }
                                              G(Ut, br);
                                            };
                                          Me(
                                            $t,
                                            (Ut) => {
                                              y(Ur) === "ban-user"
                                                ? Ut(st)
                                                : Ut(gt, !1);
                                            },
                                            !0
                                          );
                                        }
                                        G(Qt, rt);
                                      };
                                    Me(
                                      on,
                                      (Qt) => {
                                        y(Ur) === "timeout-user"
                                          ? Qt(Pn)
                                          : Qt(zt, !1);
                                      },
                                      !0
                                    );
                                  }
                                  G(rn, pt);
                                };
                              Me(un, (rn) => {
                                y(Ur) === "report-user" ? rn(an) : rn(fn, !1);
                              });
                            }
                            G(Nr, Wr);
                          }
                        ),
                          P(ur),
                          P(Vt),
                          G(_e, Vt);
                      };
                      Me(Ze, (_e) => {
                        y(ne).length > 0 && _e(Ct);
                      });
                    }
                    P(Nt),
                      Ne(
                        (_e, Vt) => {
                          var cr;
                          le(mr, `${_e ?? ""}:`),
                            Br(pr, 1, `font-medium ${Vt ?? ""} flex gap-1.5`),
                            le(
                              Dt,
                              ((cr = kt.data) == null ? void 0 : cr.id) ===
                                y(Lt).id
                                ? kt.data.name
                                : y(Lt).name
                            ),
                            le(Te, `#${y(Lt).id ?? ""}`);
                        },
                        [() => cC(), () => Ni(y(Lt).id)]
                      ),
                      G(Xt, Nt);
                  };
                Me(
                  Bt,
                  (Xt) => {
                    y(f).paintedBy.event ? Xt(Gt) : Xt(At, !1);
                  },
                  !0
                );
              }
              G(Mt, Wt);
            };
          Me(
            xt,
            (Mt) => {
              y(f).paintedBy.id === 0 ? Mt(It) : Mt(Tt, !1);
            },
            !0
          );
        }
        G(Ye, at);
      };
    Me(bt, (Ye) => {
      y(f) === void 0 ? Ye(Xe) : Ye(Ve, !1);
    });
  }
  P(Ge);
  var Ke = q(Ge, 2),
    Fe = M(Ke);
  {
    var ft = (Ye) => {
        var at = V9();
        at.__click = () => o.onclickpaint(o.latLon);
        var xt = M(at);
        Wh(xt, { class: "size-4.5" });
        var It = q(xt);
        P(at),
          Ne(
            (Tt) => {
              (at.disabled = kt.loading), le(It, ` ${Tt ?? ""}`);
            },
            [() => j0()]
          ),
          G(Ye, at);
      },
      lt = (Ye) => {
        var at = Jt(),
          xt = _t(at);
        {
          var It = (Tt) => {
            var Mt = Z9();
            Mt.__click = () => xe();
            var Wt = M(Mt);
            {
              var Bt = (At) => {
                  var Xt = q9(),
                    Lt = _t(Xt);
                  Gb(Lt, { class: "size-4.5" });
                  var Nt = q(Lt);
                  Ne((jt) => le(Nt, ` ${jt ?? ""}`), [() => c6()]), G(At, Xt);
                },
                Gt = (At) => {
                  var Xt = U9(),
                    Lt = _t(Xt);
                  Wy(Lt, { class: "size-4.5" });
                  var Nt = q(Lt);
                  Ne((jt) => le(Nt, ` ${jt ?? ""}`), [() => o6()]), G(At, Xt);
                };
              Me(Wt, (At) => {
                y(f).paintedBy.claimed ? At(Bt) : At(Gt, !1);
              });
            }
            P(Mt),
              Ne(() => (Mt.disabled = kt.loading || y(f).paintedBy.claimed)),
              G(Tt, Mt);
          };
          Me(
            xt,
            (Tt) => {
              kt.data && Tt(It);
            },
            !0
          );
        }
        G(Ye, at);
      };
    Me(Fe, (Ye) => {
      var at;
      (at = y(f)) != null && at.paintedBy.event ? Ye(lt, !1) : Ye(ft);
    });
  }
  var yt = q(Fe, 2);
  {
    var mt = (Ye) => {
      const at = ut(() =>
          kt.data.favoriteLocations.find(
            (Bt) =>
              Math.abs(Bt.latitude - y(N).center[0]) < 5e-5 &&
              Math.abs(Bt.longitude - y(N).center[1]) < 5e-5
          )
        ),
        xt = ut(
          () =>
            !y(at) &&
            kt.data.favoriteLocations.length >= kt.data.maxFavoriteLocations
        );
      var It = G9();
      let Tt;
      It.__click = async () => {
        try {
          te(T, !0),
            y(at)
              ? (await Jr.deleteFavoriteLocation(y(at).id), xr.warning(eP()))
              : (await Jr.favoriteLocation(y(N).center), xr.success(nP())),
            Oi.smallPlop.play(),
            kt.refresh();
        } catch (Bt) {
          xr.error(Bt.message);
        } finally {
          te(T, !1);
        }
      };
      var Mt = M(It);
      {
        let Bt = ut(() => !!y(at));
        S9(Mt, {
          class: "size-4.5",
          get filled() {
            return y(Bt);
          },
        });
      }
      var Wt = q(Mt);
      P(It),
        Ne(
          (Bt) => {
            (Tt = Br(It, 1, "btn btn-primary btn-soft", null, Tt, {
              "text-yellow-400": !!y(at),
            })),
              (It.disabled = y(T) || y(xt)),
              le(Wt, ` ${Bt ?? ""}`);
          },
          [() => (y(xt) ? dC() : mC())]
        ),
        G(Ye, It);
    };
    Me(yt, (Ye) => {
      kt.data && Ye(mt);
    });
  }
  var ct = q(yt, 2);
  ct.__click = () =>
    o.onclickshare(
      F6(di.url, {
        pos: { lat: y(N).center[0], lng: y(N).center[1] },
        zoom: o.zoom,
      })
    );
  var qt = M(ct);
  ry(qt, { class: "size-4.5" });
  var Ft = q(qt);
  P(ct),
    P(Ke),
    P(Ie),
    Eo(
      Ie,
      (Ye) => te(L, Ye),
      () => y(L)
    ),
    Ne(
      (Ye) => {
        le(
          ke,
          `Pixel: ${y(N).regionPixel[0] ?? ""}, ${y(N).regionPixel[1] ?? ""}`
        ),
          le(Ft, ` ${Ye ?? ""}`);
      },
      [() => vC()]
    ),
    Yp("innerHeight", (Ye) => te(A, Ye, !0)),
    G(_, Ie),
    Rr();
}
Bn(["click"]);
function W9(_) {
  var x;
  const o = document.createElement("div");
  (x = _.parentElement) == null || x.insertBefore(o, _.nextSibling);
  const f = new IntersectionObserver(
    (A) => {
      A[0].isIntersecting
        ? _.classList.remove("stuck")
        : _.classList.add("stuck");
    },
    { threshold: 0, rootMargin: "0px" }
  );
  return (
    f.observe(o),
    () => {
      o.remove(), f.disconnect();
    }
  );
}
var o_;
((_) => {
  function o() {
    let f, x;
    return {
      promise: new Promise((L, T) => {
        (f = L), (x = T);
      }),
      resolve: f,
      reject: x,
    };
  }
  _.withResolvers = o;
})(o_ || (o_ = {}));
var X9 = Lr(
    '<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'
  ),
  Y9 = Lr(
    '<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>'
  );
function K9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = _t(x);
  {
    var L = (s) => {
        var B = X9();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      },
      T = (s) => {
        var B = Y9();
        dr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f,
        })),
          G(s, B);
      };
    Me(A, (s) => {
      o.filled ? s(L) : s(T, !1);
    });
  }
  G(_, x);
}
var J9 = me("<p><!></p>"),
  Q9 = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  eB = me(
    '<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'
  ),
  tB = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  rB = me('<!> <span class="text-sm"> </span>', 1),
  nB = me('<span class="text-sm"> </span>'),
  iB = me(
    '<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'
  ),
  aB = me(
    '<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'
  ),
  oB = me(
    '<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>'
  );
function sB(_, o) {
  Dr(o, !0);
  const f = (Ae, qe = sa, Ue = sa) => {
      const Be = ut(() => {
          var ct;
          return (
            (((ct = kt.data) == null ? void 0 : ct.droplets) ?? 0) >= s.price
          );
        }),
        ke = ut(() => y(N) === qe().id),
        $e = ut(() => x.has(qe().id));
      var Le = aB(),
        nt = M(Le),
        dt = M(nt, !0);
      P(nt);
      var je = q(nt, 2),
        Ge = M(je),
        bt = q(Ge);
      {
        var Xe = (ct) => {
          var qt = J9(),
            Ft = M(qt);
          ah(Ft, { class: "text-base-content/60 size-4.5 inline pb-0.5" }),
            P(qt),
            Ne(
              (Ye) => {
                Br(
                  qt,
                  1,
                  hs({
                    "tooltip inline": !0,
                    "lg:before:-translate-x-1/3": (Ue() + 1) % 4 === 0,
                    "lg:before:translate-x-1/3": Ue() % 4 === 0,
                    "before:-translate-x-1/3": (Ue() + 1) % 2 === 0,
                    "before:translate-x-1/3": Ue() % 2 === 0,
                  })
                ),
                  gr(qt, "data-tip", Ye);
              },
              [() => QI()]
            ),
            G(ct, qt);
        };
        Me(bt, (ct) => {
          y($e) && ct(Xe);
        });
      }
      P(je);
      var Ve = q(je, 2);
      {
        var Ke = (ct) => {
          A_(ct, {});
        };
        Me(Ve, (ct) => {
          qe().id === y(K) && ct(Ke);
        });
      }
      var Fe = q(Ve, 2);
      let ft;
      var lt = M(Fe);
      {
        var yt = (ct) => {
            var qt = eB();
            qt.__click = async () => {
              if (!(y($e) && !(await o.promptUserConfirmation(qe().name))))
                try {
                  const It = qe().id;
                  te(N, It, !0),
                    await Jr.purchase({ id: T, amount: 1, variant: It }),
                    kt.refresh(),
                    Oi.notification1.play();
                  const Tt = L.find((Mt) => Mt.id === It);
                  Tt && (Tt.owned = !0), te(K, It, !0);
                } catch (It) {
                  xr.error(It.message);
                } finally {
                  te(N, void 0);
                }
            };
            var Ft = M(qt);
            {
              var Ye = (It) => {
                var Tt = Q9();
                G(It, Tt);
              };
              Me(Ft, (It) => {
                y(ke) && It(Ye);
              });
            }
            var at = q(Ft, 2);
            Xp(at, { class: "size-4" });
            var xt = q(at);
            yn(),
              P(qt),
              Ne(
                (It) => {
                  (qt.disabled = !y(Be) || y(ke)), le(xt, ` ${It ?? ""} `);
                },
                [() => s.price.toLocaleString("en-US")]
              ),
              G(ct, qt);
          },
          mt = (ct) => {
            const qt = ut(() => {
              var Gt;
              return (
                ((Gt = kt.data) == null ? void 0 : Gt.equippedFlag) === qe().id
              );
            });
            var Ft = iB();
            let Ye;
            Ft.__click = async () => {
              try {
                te(N, qe().id, !0);
                const Gt = y(qt) ? 0 : qe().id;
                await Jr.equipFlag(Gt),
                  kt.data && (kt.data.equippedFlag = Gt),
                  kt.refresh();
              } catch (Gt) {
                xr.error(Gt.message);
              } finally {
                te(N, void 0);
              }
            };
            var at = M(Ft),
              xt = M(at, !0);
            P(at);
            var It = q(at, 2);
            {
              var Tt = (Gt) => {
                var At = tB();
                G(Gt, At);
              };
              Me(It, (Gt) => {
                y(ke) && Gt(Tt);
              });
            }
            var Mt = q(It, 2);
            {
              var Wt = (Gt) => {
                  var At = rB(),
                    Xt = _t(At);
                  Os(Xt, { class: "size-4" });
                  var Lt = q(Xt, 2),
                    Nt = M(Lt, !0);
                  P(Lt), Ne((jt) => le(Nt, jt), [() => w5()]), G(Gt, At);
                },
                Bt = (Gt) => {
                  var At = nB(),
                    Xt = M(At, !0);
                  P(At), Ne((Lt) => le(Xt, Lt), [() => C5()]), G(Gt, At);
                };
              Me(Mt, (Gt) => {
                y(qt) ? Gt(Wt) : Gt(Bt, !1);
              });
            }
            P(Ft),
              Ne(
                (Gt) => {
                  (Ye = Br(
                    Ft,
                    1,
                    "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10",
                    null,
                    Ye,
                    { "btn-warning": y(qt) }
                  )),
                    (Ft.disabled = y(ke)),
                    le(xt, Gt);
                },
                [() => y5()]
              ),
              G(ct, Ft);
          };
        Me(lt, (ct) => {
          qe().owned ? ct(mt, !1) : ct(yt);
        });
      }
      P(Fe),
        P(Le),
        Ne(
          (ct) => {
            le(dt, qe().flag),
              le(Ge, `${qe().name ?? ""} `),
              (ft = Br(Fe, 1, "mt-3", null, ft, { tooltip: !y(Be) })),
              gr(Fe, "data-tip", ct);
          },
          [() => Jp()]
        ),
        G(Ae, Le);
    },
    x = new Set([
      8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251,
    ]),
    A = pa.countries.map((Ae) => ({ ...Ae, owned: kt.flagsBitmap.get(Ae.id) }));
  A.sort((Ae, qe) => Number(qe.owned) - Number(Ae.owned));
  const L = Si(A),
    T = 110,
    s = pa.products[T];
  let B = Je(!1),
    N = Je(void 0),
    K = Je(void 0);
  var ee = oB(),
    re = M(ee),
    ue = M(re);
  K9(ue, { class: "size-5.5", filled: !0 }), yn(2), P(re);
  var ne = q(re, 2),
    Y = M(ne, !0);
  P(ne);
  var xe = q(ne, 2);
  oi(
    xe,
    23,
    () => L,
    (Ae) => Ae.id,
    (Ae, qe, Ue) => {
      var Be = Jt(),
        ke = _t(Be);
      {
        var $e = (Le) => {
          f(
            Le,
            () => y(qe),
            () => y(Ue)
          );
        };
        Me(ke, (Le) => {
          (y(Ue) < 8 || y(B)) && Le($e);
        });
      }
      G(Ae, Be);
    }
  ),
    P(xe);
  var Ie = q(xe, 2),
    Ee = M(Ie);
  Ee.__click = () => {
    te(B, !y(B));
  };
  var De = M(Ee, !0);
  P(Ee),
    P(Ie),
    P(ee),
    Ne(
      (Ae) => {
        le(Y, Ae), le(De, y(B) ? "Show less" : "Show more");
      },
      [() => _5()]
    ),
    G(_, ee),
    Rr();
}
Bn(["click"]);
var lB = me('<p class="mt-1 text-center text-sm"> </p>'),
  cB = me(
    '<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'
  ),
  uB = me(
    '<span class="loading loading-spinner center-absolute absolute"></span>'
  ),
  hB = me(
    '<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>'
  );
function m0(_, o) {
  Dr(o, !0);
  let f = Et(o, "amount", 15, 1);
  const x = ut(() => f() * o.unitPrice),
    A = ut(() => Math.floor(o.userDroplets / o.unitPrice));
  let L = Je(!1);
  $r(() => {
    f() < 0 && f(0);
  });
  var T = hB(),
    s = M(T),
    B = M(s);
  si(B, () => o.icon ?? sa), P(s);
  var N = q(s, 2),
    K = M(N, !0);
  P(N);
  var ee = q(N, 2);
  {
    var re = (Le) => {
      var nt = lB(),
        dt = M(nt, !0);
      P(nt), Ne(() => le(dt, o.subtitle)), G(Le, nt);
    };
    Me(ee, (Le) => {
      o.subtitle && Le(re);
    });
  }
  var ue = q(ee, 2),
    ne = M(ue);
  ne.__click = () => {
    Ev(f, -1);
  };
  var Y = q(ne, 2);
  Oa(Y);
  var xe = q(Y, 2);
  xe.__click = () => {
    Ev(f);
  };
  var Ie = q(xe, 2);
  {
    var Ee = (Le) => {
      var nt = cB();
      (nt.__click = () => {
        f(y(A));
      }),
        G(Le, nt);
    };
    Me(Ie, (Le) => {
      f() < y(A) && Le(Ee);
    });
  }
  P(ue);
  var De = q(ue, 2);
  let Ae;
  var qe = M(De);
  qe.__click = async () => {
    try {
      te(L, !0),
        await Jr.purchase({ id: o.productId, amount: f() }),
        Oi.notification1.play(),
        o.onpurchasecompleted(f());
    } catch (Le) {
      xr.error(Le.message);
    } finally {
      te(L, !1);
    }
  };
  var Ue = M(qe);
  {
    var Be = (Le) => {
      var nt = uB();
      G(Le, nt);
    };
    Me(Ue, (Le) => {
      y(L) && Le(Be);
    });
  }
  var ke = q(Ue, 2);
  Xp(ke, { class: "size-4" });
  var $e = q(ke);
  yn(),
    P(qe),
    P(De),
    P(T),
    Ne(
      (Le, nt, dt) => {
        le(K, Le),
          (xe.disabled = f() >= y(A)),
          gr(De, "data-tip", nt),
          (Ae = Br(De, 1, "", null, Ae, { tooltip: o.userDroplets < y(x) })),
          (qe.disabled = o.userDroplets < y(x) || y(L) || !f()),
          le($e, ` ${dt ?? ""} `);
      },
      [() => o.title(f()), () => Jp(), () => y(x).toLocaleString("en-US")]
    ),
    $h(Y, f),
    G(_, T),
    Rr();
}
Bn(["click"]);
var dB = Lr(
  '<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>'
);
function pB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = dB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var fB = Lr(
  '<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>'
);
function Xy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = fB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var mB = Lr(
  '<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>'
);
function _B(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = mB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var gB = Lr(
  '<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>'
);
function vB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = gB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var yB = me(
    '<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">‚úï</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'
  ),
  xB = me('<span class="center-absolute absolute"><!></span>'),
  bB = me(
    '<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>',
    1
  );
function wB(_, o) {
  Dr(o, !0);
  let f = Et(o, "open", 15),
    x = Je(null),
    A = Je(Si({ name: Dv(), prev: 1e3, new: 1e5 }));
  Fn(() => {
    const Nt = (jt) => {
      jt.key === "Escape" && f(!1);
    };
    return (
      document.addEventListener("keydown", Nt),
      () => document.removeEventListener("keydown", Nt)
    );
  });
  const L = { id: 70, product: pa.products[70] },
    T = { id: 80, product: pa.products[80] },
    s = { product: pa.products[120] };
  let B = Je(null),
    N = Je(null),
    K = Je("");
  async function ee(Nt) {
    return (
      y(B).showModal(),
      te(N, o_.withResolvers(), !0),
      te(K, Nt, !0),
      y(N).promise
    );
  }
  var re = bB(),
    ue = _t(re),
    ne = M(ue),
    Y = M(ne);
  {
    var xe = (Nt) => {
      var jt = yB(),
        mr = M(jt),
        ir = M(mr),
        vr = M(ir);
      Xy(vr, { class: "size-8" });
      var ar = q(vr, 2),
        pr = M(ar, !0);
      P(ar);
      var tr = q(ar, 2),
        Dt = M(tr);
      {
        let st = ut(() => {
          var gt;
          return ((gt = kt.data) == null ? void 0 : gt.droplets) ?? 0;
        });
        z0(Dt, {
          get value() {
            return y(st);
          },
        });
      }
      P(tr), yn(2), P(ir), P(mr), yi(mr, () => W9);
      var Sr = q(mr, 2),
        Te = M(Sr),
        O = M(Te),
        E = M(O);
      pB(E, { class: "size-5.5", filled: !0 });
      var D = q(E, 2),
        j = M(D, !0);
      P(D), P(O);
      var H = q(O, 2),
        W = M(H, !0);
      P(H);
      var ce = q(H, 2),
        ge = M(ce);
      {
        const st = (Ut) => {
          vB(Ut, { class: "text-primary size-26" });
        };
        let gt = ut(() => Sw());
        m0(ge, {
          get productId() {
            return L.id;
          },
          title: (Ut) => bw({ amount: L.product.items[0].amount * Ut }),
          get subtitle() {
            return y(gt);
          },
          get unitPrice() {
            return L.product.price;
          },
          get userDroplets() {
            return kt.data.droplets;
          },
          onpurchasecompleted: async (Ut) => {
            var sr, wr, jr, Yr;
            const br =
              (wr = (sr = kt.data) == null ? void 0 : sr.charges) == null
                ? void 0
                : wr.max;
            await kt.refresh();
            const wt =
              (Yr = (jr = kt.data) == null ? void 0 : jr.charges) == null
                ? void 0
                : Yr.max;
            br !== void 0 &&
              wt !== void 0 &&
              (te(A, { name: Dv(), prev: br, new: wt }, !0), y(x).show());
          },
          icon: st,
          $$slots: { icon: !0 },
        });
      }
      var de = q(ge, 2);
      {
        const st = (Ut) => {
          Uy(Ut, { class: "text-primary my-3 size-20" });
        };
        let gt = ut(() => dw());
        m0(de, {
          get productId() {
            return T.id;
          },
          title: (Ut) => lT({ amount: T.product.items[0].amount * Ut }),
          get subtitle() {
            return y(gt);
          },
          get unitPrice() {
            return T.product.price;
          },
          get userDroplets() {
            return kt.data.droplets;
          },
          onpurchasecompleted: async (Ut) => {
            var wt, sr, wr;
            const br =
              (sr = (wt = kt.data) == null ? void 0 : wt.charges) == null
                ? void 0
                : sr.count;
            await kt.refresh(),
              br !== void 0 &&
                (te(
                  A,
                  {
                    name: aT(),
                    prev: Math.floor(br),
                    new: Math.floor(br + T.product.items[0].amount * Ut),
                  },
                  !0
                ),
                (wr = y(x)) == null || wr.show());
          },
          icon: st,
          $$slots: { icon: !0 },
        });
      }
      P(ce), P(Te);
      var Se = q(Te, 2),
        We = M(Se),
        Ze = M(We);
      ef(Ze, { class: "size-5.5", filled: !0 });
      var Ct = q(Ze, 2),
        _e = M(Ct, !0);
      P(Ct), P(We);
      var Vt = q(We, 2),
        cr = M(Vt),
        Ot = M(cr),
        ur = M(Ot),
        Nr = M(ur),
        Ur = M(Nr);
      L0(Ur, {
        get userId() {
          return kt.data.id;
        },
        get level() {
          return kt.data.level;
        },
        get pictureUrl() {
          return kt.data.picture;
        },
      }),
        P(Nr),
        P(ur),
        P(Ot);
      var Wr = q(Ot, 2),
        un = M(Wr, !0);
      P(Wr);
      var an = q(Wr, 2),
        fn = M(an, !0);
      P(an);
      var rn = q(an, 2);
      let pt;
      var on = M(rn),
        Pn = M(on),
        zt = M(Pn);
      Xp(zt, { class: "size-4" });
      var Qt = q(zt);
      yn(), P(Pn), P(on), P(rn), P(cr), P(Vt), P(Se);
      var rt = q(Se, 2),
        $t = M(rt);
      sB($t, { promptUserConfirmation: ee }),
        P(rt),
        P(Sr),
        P(jt),
        Ne(
          (st, gt, Ut, br, wt, sr, wr, jr) => {
            le(pr, st),
              le(j, gt),
              le(W, Ut),
              le(_e, br),
              le(un, wt),
              le(fn, sr),
              gr(rn, "data-tip", wr),
              (pt = Br(rn, 1, "", null, pt, {
                tooltip: kt.data.droplets < s.product.price,
              })),
              (Pn.disabled = kt.data.droplets < s.product.price),
              le(Qt, ` ${jr ?? ""} `);
          },
          [
            () => O0(),
            () => mw(),
            () => vw(),
            () => p5(),
            () => Iw(),
            () => kw(),
            () => Jp(),
            () => s.product.price.toLocaleString("en-US"),
          ]
        ),
        oa(2, jt, () => Ha),
        G(Nt, jt);
    };
    Me(Y, (Nt) => {
      kt.data && f() && Nt(xe);
    });
  }
  P(ne);
  var Ie = q(ne, 2),
    Ee = M(Ie),
    De = M(Ee, !0);
  P(Ee),
    P(Ie),
    P(ue),
    yi(ue, () => (Nt) => {
      $r(() => {
        f() ? Nt.show() : Nt.close();
      });
    });
  var Ae = q(ue, 2),
    qe = M(Ae),
    Ue = M(qe),
    Be = M(Ue),
    ke = M(Be, !0);
  P(Be);
  var $e = q(Be, 2),
    Le = M($e),
    nt = M(Le),
    dt = q(nt),
    je = M(dt);
  P(dt), P(Le);
  var Ge = q(Le, 2),
    bt = M(Ge);
  _B(bt, { class: "size-5" }), P(Ge);
  var Xe = q(Ge, 2),
    Ve = M(Xe, !0);
  P(Xe), P($e);
  var Ke = q($e, 2),
    Fe = M(Ke),
    ft = M(Fe),
    lt = q(ft);
  th(
    lt,
    () => y(A).new,
    (Nt) => {
      var jt = xB(),
        mr = M(jt);
      A_(mr, {}), P(jt), G(Nt, jt);
    }
  ),
    P(Fe),
    P(Ke),
    P(Ue),
    P(qe);
  var yt = q(qe, 2),
    mt = M(yt),
    ct = M(mt, !0);
  P(mt),
    P(yt),
    P(Ae),
    Eo(
      Ae,
      (Nt) => te(x, Nt),
      () => y(x)
    );
  var qt = q(Ae, 2),
    Ft = M(qt),
    Ye = M(Ft),
    at = M(Ye, !0);
  P(Ye);
  var xt = q(Ye, 2),
    It = M(xt);
  Gp(It, () => a4({ country: y(K) })), P(xt);
  var Tt = q(xt, 2),
    Mt = M(Tt);
  Mt.__click = () => {
    var Nt;
    (Nt = y(N)) == null || Nt.resolve(!1), y(B).close();
  };
  var Wt = M(Mt, !0);
  P(Mt);
  var Bt = q(Mt, 2);
  Bt.__click = () => {
    var Nt;
    (Nt = y(N)) == null || Nt.resolve(!0), y(B).close();
  };
  var Gt = M(Bt, !0);
  P(Bt), P(Tt), P(Ft);
  var At = q(Ft, 2),
    Xt = M(At),
    Lt = M(Xt, !0);
  P(Xt),
    P(At),
    P(qt),
    Eo(
      qt,
      (Nt) => te(B, Nt),
      () => y(B)
    ),
    Ne(
      (Nt, jt, mr, ir, vr, ar, pr) => {
        le(De, Nt),
          le(ke, y(A).name),
          le(nt, `${y(A).prev ?? ""} `),
          le(je, `(+${y(A).new - y(A).prev})`),
          le(Ve, y(A).new),
          le(ft, `${jt ?? ""} `),
          le(ct, mr),
          le(at, ir),
          le(Wt, vr),
          le(Gt, ar),
          le(Lt, pr);
      },
      [
        () => ds(),
        () => ds(),
        () => ds(),
        () => r4(),
        () => Gh(),
        () => R0(),
        () => ds(),
      ]
    ),
    Zn("close", ue, () => f(!1)),
    G(_, re),
    Rr();
}
Bn(["click"]);
var TB = Lr(
  '<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>'
);
function SB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = TB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var CB = Lr(
  '<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>'
);
function PB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = CB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var IB = Lr(
  '<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>'
);
function MB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = IB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var AB = Lr(
  '<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>'
);
function kB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = AB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
var EB = Lr(
  '<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>'
);
function zB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = EB();
  dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f,
  })),
    G(_, x);
}
function wm(_) {
  const o = document.createElement("img");
  return (
    (o.src = _),
    new Promise((f, x) => {
      o.addEventListener("load", () => {
        f(o);
      }),
        o.addEventListener("error", (A) => {
          x(A);
        });
    })
  );
}
function LB(_) {
  const o = document.createElement("canvas");
  (o.width = _.naturalWidth), (o.height = _.naturalHeight);
  const f = o.getContext("2d");
  return f == null || f.drawImage(_, 0, 0), o;
}
function DB(_, o, f) {
  return _ < o ? o : _ > f ? f : _;
}
function RB(_, o) {
  const f = 10 ** o;
  return Math.round(_ * f) / f;
}
var FB = me(
    '<meta property="og:title" content="openplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="openplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>',
    1
  ),
  BB = me("<button><!></button>"),
  OB = me(
    '<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'
  ),
  NB = me(
    '<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'
  ),
  jB = me('<button class="btn btn-primary shadow-xl"> </button>'),
  VB = me(
    '<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"> </a>'
  ),
  qB = me(
    '<span class="tooltip badge badge-secondary tooltip-left absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold">CL</span>'
  ),
  UB = me('<div class="relative"><!> <!></div>'),
  ZB = me('<button class="btn btn-square shadow-md"><!></button>'),
  GB = me('<button class="btn btn-square relative shadow-md"><!></button>'),
  $B = me(
    '<div class="flex flex-col items-center gap-3"><!> <!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button></div>'
  ),
  HB = me('<div class="flex flex-col gap-3"><button><!></button></div>'),
  WB = me('<button class="btn btn-sm btn-circle"><!></button>'),
  XB = me(
    '<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'
  ),
  YB = me('<button class="btn btn-sm btn-circle"><!></button>'),
  KB = me('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  JB = me(
    '<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'
  ),
  QB = me(
    '<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'
  ),
  eO = me("<span></span>"),
  tO = me(
    '<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'
  ),
  rO = me(
    '<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'
  ),
  nO = me(
    '<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'
  ),
  iO = me(
    '<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'
  ),
  aO = me(
    '<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-1uha8ag"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>',
    1
  );
function QO(_, o) {
  Dr(o, !0);
  const f = cm,
    x = xb,
    A = new ps(x),
    L = f - 0.4,
    T = R6(di.url),
    s = T.season ?? kv,
    B = new Map();
  let N = Je(void 0),
    K = Je(14.5),
    ee = Je(!1);
  const re = ut(() => {
    var vt;
    return ((vt = kt.data) == null ? void 0 : vt.id) === 401;
  });
  let ue = Je(!1),
    ne = Je(
      Si(
        T.select && T.pos
          ? { name: "pixelSelected", latLon: [T.pos.lat, T.pos.lng] }
          : { name: "mainMenu" }
      )
    );
  Fn(() => {
    Ee().then((qr) => te(N, qr));
    let vt = [0, 0];
    function Kt(qr) {
      var In;
      if (y(N) && y(K) > f + 1) {
        const { lat: $n, lng: Ci } = y(N).unproject([qr.clientX, qr.clientY]),
          Xn = A.latLonToPixels($n, Ci, f),
          Mn = Math.floor(Xn[0]),
          Vi = Math.floor(Xn[1]);
        if (vt[0] !== Mn || vt[1] !== Vi) {
          const Mr = A.latLonToPixelBoundsLatLon($n, Ci, f),
            _r = b_(Mr, !0);
          (In = y(N).getSource(qe)) == null || In.setCoordinates(_r),
            (vt = [Mn, Vi]);
        }
      }
    }
    return (
      window.addEventListener("mousemove", Kt),
      () => {
        var qr;
        (qr = y(N)) == null || qr.remove(),
          window.removeEventListener("mousemove", Kt),
          Ie && clearInterval(Ie),
          Tm();
      }
    );
  }),
    Fs(
      () => [da.theme],
      () => {
        if (y(N)) {
          xe = !1;
          const vt = Y(da.theme);
          y(N).setStyle(vt);
        }
      }
    );
  function Y(vt) {
    return `/maps/styles/${
      vt === "custom-winter" ? "liberty" : "fiord"
    }`;
  }
  let xe = !1,
    Ie;
  async function Ee() {
    const vt = T.pos ? { ...T.pos, zoom: y(K) } : await S6();
    T.zoom !== void 0 && (vt.zoom = T.zoom);
    const Kt = await new Promise((Xn) => {
        const Mn = new _p.Map({
          style: Y(da.theme),
          center: vt,
          zoom: vt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1,
        });
        Mn.touchZoomRotate.disableRotation(),
          Mn.on("styledata", (Vi) => {
            xe ||
              (da.theme === "custom-winter" &&
                (Mn.setLayoutProperty("poi_transit", "visibility", "none"),
                Mn.setLayoutProperty("poi_r20", "visibility", "none"),
                Mn.setLayoutProperty("poi_r7", "visibility", "none"),
                Mn.setLayoutProperty("poi_r1", "visibility", "none"),
                Mn.setLayoutProperty("building", "visibility", "none"),
                Mn.setLayoutProperty("building-3d", "visibility", "none"),
                Mn.setLayoutProperty("landuse_pitch", "visibility", "none"),
                Mn.setLayoutProperty("landuse_hospital", "visibility", "none"),
                Mn.setLayoutProperty("landuse_school", "visibility", "none"),
                Mn.setLayoutProperty(
                  "landuse_residential",
                  "visibility",
                  "none"
                ),
                Mn.setLayoutProperty("waterway_tunnel", "visibility", "none"),
                Mn.setFilter("water", [
                  "all",
                  ["!=", "brunnel", "tunnel"],
                  ["!=", "class", "swimming_pool"],
                ])),
              Ae(Mn),
              $e(),
              (xe = !0));
          }),
          Mn.on("style.load", () => {
            Xn(Mn);
          });
      }),
      qr = pa.refreshIntervalMs;
    function In() {
      let Xn = y(K) > f + 1.5 ? qr : 2.5 * qr;
      try {
        document.visibilityState === "visible" && Ae(Kt);
      } finally {
        setTimeout(In, Xn);
      }
    }
    (Ie = setTimeout(In, qr)),
      Kt.on("load", () => {
        T.discordLinked &&
          (xr.success(dP()),
          di.url.searchParams.delete("discord-linked"),
          Ep(di.url.toString())),
          T.twitchMigration &&
            (xr.success(J4()),
            di.url.searchParams.delete("twitch-migration"),
            Ep(di.url.toString()));
      });
    let $n = y(K);
    Kt.on("zoom", () => {
      te(K, Kt.getZoom(), !0);
      const Xn = RB(y(K), 1);
      Xn != $n && (y(Ve) && y(Ve).setOpacity(Ke($n)), ($n = Xn));
    });
    let Ci = "default";
    return (
      Kt.on("dragstart", () => {
        const Xn = Kt.getCanvas();
        (Ci = Xn.style.cursor), (Xn.style.cursor = "move");
      }),
      Kt.on("dragend", () => {
        Kt.getCanvas().style.cursor = Ci;
      }),
      Kt.on("mouseout", () => {
        Le();
      }),
      Kt.on("click", async (Xn) => {
        var dn;
        const Mn = Xn.lngLat.lat,
          Vi = Xn.lngLat.lng,
          Mr = [Mn, Vi];
        if (y(ne).name === "paintingPixel" || y(ne).name === "selectArea")
          return;
        if (y(ne).name === "selectHq") {
          (y(ne).hq = Mr), (dn = y(Fe)) == null || dn.clearAndPlace(Mr);
          return;
        }
        const _r = Kt.getZoom();
        if (_r < L) {
          xr.info(LP());
          return;
        }
        as({ lat: Mn, lng: Vi }, _r),
          te(ne, { name: "pixelSelected", latLon: Mr }, !0);
      }),
      Kt
    );
  }
  const De = "pixel-art-layer";
  function Ae(vt) {
    const Kt = window.innerWidth,
      qr = `${ub}/s${kv}/tiles/{x}/{y}.png`;
    if ((B.clear(), !vt.style)) return;
    vt.getSource(De)
      ? vt.refreshTiles(De)
      : vt.addSource(De, {
          type: "raster",
          tiles: [qr],
          minzoom: f,
          maxzoom: f,
          tileSize: Kt > 640 ? 550 : 400,
        }),
      vt.getLayer(De) ||
        vt.addLayer({
          id: De,
          type: "raster",
          source: De,
          paint: { "raster-resampling": "nearest", "raster-opacity": y(je) },
        });
  }
  const qe = "pixel-hover",
    Ue = 1e-5,
    Be = [
      [0, 0],
      [Ue, 0],
      [Ue, -Ue],
      [0, -Ue],
    ],
    ke = 0.4;
  async function $e() {
    var vt, Kt, qr, In;
    if (!((vt = y(N)) != null && vt.getSource(qe))) {
      const $n = LB(await wm(w6));
      (Kt = y(N)) == null ||
        Kt.addSource(qe, { type: "canvas", canvas: $n, coordinates: Be });
    }
    ((qr = y(N)) != null && qr.getLayer(qe)) ||
      (In = y(N)) == null ||
      In.addLayer({
        id: qe,
        type: "raster",
        source: qe,
        paint: { "raster-resampling": "nearest", "raster-opacity": ke },
      });
  }
  function Le() {
    var vt, Kt;
    (Kt = (vt = y(N)) == null ? void 0 : vt.getSource(qe)) == null ||
      Kt.setCoordinates(Be);
  }
  let nt = Je(Si(T.opaque ?? !0)),
    dt = Je(!0),
    je = ut(() => (y(dt) ? (y(nt) ? 1 : 0.2) : 0));
  $r(() => {
    var vt;
    (vt = y(N)) != null &&
      vt.getLayer(De) &&
      y(N).setPaintProperty(De, "raster-opacity", y(je));
  });
  let Ge = Je(void 0),
    bt = Je(void 0),
    Xe = Je(void 0);
  Fn(
    () => (
      navigator.permissions.query({ name: "geolocation" }).then((vt) => {
        vt.state === "granted" &&
          te(
            Xe,
            navigator.geolocation.watchPosition(
              (Kt) => {
                te(Ge, Kt);
              },
              (Kt) => {
                te(bt, Kt);
              },
              { enableHighAccuracy: !1, maximumAge: 1e3, timeout: 6e3 }
            ),
            !0
          );
      }),
      () => {
        y(Xe) && navigator.geolocation.clearWatch(y(Xe));
      }
    )
  );
  let Ve = Je(void 0);
  Fs(
    () => [y(Ge), y(N)],
    () => {
      var vt, Kt;
      if (y(Ge) && y(N)) {
        const qr = { lat: y(Ge).coords.latitude, lng: y(Ge).coords.longitude },
          In = Ke(y(K));
        if (!y(Ve)) {
          const $n = document.createElement("div");
          $n.classList.add("maplibregl-user-location-dot"),
            $n.classList.add("cursor-auto"),
            te(
              Ve,
              new _p.Marker({ element: $n, opacity: In })
                .setLngLat(qr)
                .addTo(y(N))
            );
        }
        (Kt = (vt = y(Ve)) == null ? void 0 : vt.setLngLat(qr)) == null ||
          Kt.setOpacity(In);
      }
    }
  );
  function Ke(vt) {
    return vt < f ? "1.0" : DB((vt - f) * 0.2, 0.5, 1).toFixed(2);
  }
  let Fe = Je(void 0);
  $r(() => {
    var vt;
    y(N) &&
      ((vt = yl(() => y(Fe))) == null || vt.clear(),
      wm(Ov).then((Kt) => {
        te(
          Fe,
          new jv({
            id: "select-crosshair",
            map: y(N),
            tileSize: x,
            zoom: f,
            img: Kt,
            markerFn: () => {
              const qr = new _p.Marker({ color: "#0069ff" });
              return qr.addClassName("z-20"), qr;
            },
          })
        );
      }));
  });
  let ft = Je(void 0);
  $r(() => {
    var vt;
    y(N) &&
      ((vt = yl(() => y(Fe))) == null || vt.clear(),
      wm(Ov).then((Kt) => {
        te(
          ft,
          new jv({
            id: "paint-crosshair",
            map: y(N),
            tileSize: x,
            zoom: f,
            img: Kt,
          })
        );
      }));
  });
  let lt = Je(!1),
    yt = Je(Si(di.url)),
    mt = Je(Si({ cityId: 0, countryId: 1, id: 0, name: "None", number: 1 })),
    ct = Je(!1);
  const qt = "view-rules";
  let Ft = !1;
  $r(() => {
    kt.data &&
      (!Ft &&
        kt.data.pixelsPainted > 1 &&
        (localStorage.getItem(qt) ||
          (te(ct, !0), localStorage.setItem(qt, "true"))),
      (Ft = !0));
  });
  let Ye = Je(!1);
  $r(() => {
    var vt;
    te(Ye, !!((vt = kt.data) != null && vt.needsPhoneVerification));
  });
  let at = Je([]),
    xt = ut(() => (y(K) < L ? "1.0" : y(K) < L + 2 ? "0.5" : "0.3"));
  $r(() => {
    var Kt;
    const vt = (Kt = kt.data) == null ? void 0 : Kt.favoriteLocations;
    if (vt && y(N)) {
      for (const qr of yl(() => y(at))) qr.remove();
      te(
        at,
        vt.map((qr) => {
          const In = document.createElement("div");
          In.classList.add("text-yellow-400"),
            In.classList.add("cursor-pointer"),
            In.classList.add("z-10"),
            (In.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`);
          const $n = { lat: qr.latitude, lng: qr.longitude };
          return (
            In.addEventListener("click", (Xn) => {
              Xn.stopPropagation(), It([qr.latitude, qr.longitude]);
            }),
            new _p.Marker({ element: In, opacity: y(xt) })
              .setLngLat($n)
              .addTo(y(N))
          );
        })
      );
    }
  });
  function It(vt) {
    var qr;
    const Kt = { lat: vt[0], lng: vt[1] };
    (qr = y(N)) == null || qr.flyTo({ center: Kt, zoom: Math.max(y(K), 15) }),
      as(Kt, y(K)),
      te(ne, { name: "pixelSelected", latLon: [Kt.lat, Kt.lng] }, !0);
  }
  $r(() => {
    if (y(ne).name === "paintingPixel")
      for (const vt of y(at)) vt.addClassName("hidden");
    else
      for (const vt of y(at))
        vt.removeClassName("hidden"), vt.setOpacity(y(xt));
  });
  let Tt = Number.MAX_VALUE;
  $r(() => {
    if (kt.charges !== void 0 && kt.data) {
      const vt = kt.data.charges.max,
        Kt = kt.charges;
      Tt < vt && Kt >= vt && Oi.notification1.play(), (Tt = kt.charges);
    }
  });
  let Mt = Je(!1),
    Wt = Date.now();
  Fn(() => {
    const vt = D6(),
      Kt = () => {
        var In;
        if (!document.hidden && Date.now() - Wt > 30 * Ic.min) {
          if (vt) {
            const Ci = (In = y(N)) == null ? void 0 : In.getCenter();
            Ci && as(Ci, y(K)), window.location.replace(di.url.origin);
          } else kt.refresh();
          Wt = Date.now();
        }
      };
    return (
      document.addEventListener("visibilitychange", Kt),
      () => document.removeEventListener("visibilitychange", Kt)
    );
  }),
    Fn(() => {
      function vt() {
        Jr.online = !0;
      }
      window.addEventListener("online", vt);
      function Kt() {
        Jr.online = !1;
      }
      return (
        window.addEventListener("offline", Kt),
        () => {
          window.removeEventListener("online", vt),
            window.removeEventListener("offline", Kt);
        }
      );
    }),
    $r(() => {
      if (!Jr.online) {
        const vt = setInterval(() => {
          Jr.health().then(() => {
            (Jr.online = !0), !kt.data && !kt.loading && kt.refresh();
          });
        }, 5e3);
        return () => {
          clearInterval(vt);
        };
      }
    }),
    Fn(() => {
      if (!navigator.serviceWorker) {
        setTimeout(() => {
          console.log(
            "Setting up service worker message listener",
            navigator.serviceWorker
          ),
            xr.warning(v6(), { duration: 5e3 });
        });
        return;
      }
      function vt(Kt) {
        Kt.data.type && y(N) && Ae(y(N));
      }
      return (
        navigator.serviceWorker.addEventListener("message", vt),
        () => {
          navigator.serviceWorker.removeEventListener("message", vt);
        }
      );
    });
  let Bt = Je(!1),
    Gt = Je("report-user"),
    At = Je(void 0),
    Xt = Je(void 0),
    Lt = Je(void 0),
    Nt = Je(0),
    jt = Je(void 0);
  $r(() => {
    y(Bt) || (te(jt, void 0), te(Xt, void 0), te(At, void 0), te(Lt, void 0));
  });
  const mr = ut(() => {
    var vt;
    return ba((vt = kt.data) == null ? void 0 : vt.role, [
      "admin",
      "global_moderator",
      "moderator",
    ]);
  });
  let ir = !1,
    vr = Je(!1),
    ar = Je(!1),
    pr = Je(!1),
    tr = Je(!1),
    Dt = Je(!1),
    Sr = Je(!1),
    Te = Je(!!T.newUser),
    O = Je(!1),
    E = Je(!!T.alliance),
    D = Je(!1);
  const j = ut(
    () =>
      y(vr) ||
      y(ar) ||
      y(pr) ||
      y(tr) ||
      y(Dt) ||
      y(Sr) ||
      y(Te) ||
      y(O) ||
      y(E) ||
      y(D)
  );
  var H = aO();
  Zn("keypress", l_, (vt) => {
    if (!y(j))
      switch (vt.code) {
        case "KeyC":
          if (!y(mr) || y(ne).name === "paintingPixel") return;
          te(ne, { name: "selectArea" }, !0);
          break;
      }
  }),
    sb("1uha8ag", (vt) => {
      var Kt = FB();
      yn(6),
        ab(() => {
          ob.title = "openplace - Paint the world";
        }),
        G(vt, Kt);
    });
  var W = _t(H);
  {
    const vt = (Mr) => {
        var _r = BB();
        _r.__click = () => {
          te(nt, !y(nt));
        };
        var dn = M(_r);
        {
          let wn = ut(() => !y(nt));
          Zy(dn, {
            class: "size-5",
            get filled() {
              return y(wn);
            },
          });
        }
        P(_r),
          Ne(
            (wn) => {
              gr(_r, "title", wn),
                Br(
                  _r,
                  1,
                  hs({
                    "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
                    "text-base-content/80": y(nt),
                    "btn-primary btn-soft": !y(nt),
                  })
                );
            },
            [() => N0()]
          ),
          G(Mr, _r);
      },
      Kt = (Mr) => {
        var _r = NB();
        _r.__click = async () => {
          var Pr;
          y(Ge) ||
            te(
              Ge,
              await new Promise((Cn, Vn) => {
                navigator.geolocation.getCurrentPosition(
                  (kn) => {
                    Cn(kn);
                  },
                  (kn) => {
                    Vn(kn);
                  }
                );
              })
            ),
            y(Ge) &&
              (as(
                { lat: y(Ge).coords.latitude, lng: y(Ge).coords.longitude },
                y(K)
              ),
              (Pr = y(N)) == null ||
                Pr.flyTo({
                  center: {
                    lat: y(Ge).coords.latitude,
                    lng: y(Ge).coords.longitude,
                  },
                  zoom: 16.5,
                }));
        };
        var dn = M(_r);
        {
          var wn = (Pr) => {
              MB(Pr, { class: "size-5.5 fill-blue-800" });
            },
            Cr = (Pr) => {
              var Cn = OB(),
                Vn = M(Cn);
              PB(Vn, { class: "size-5.5 fill-red-400" }),
                yn(2),
                P(Cn),
                G(Pr, Cn);
            };
          Me(dn, (Pr) => {
            y(Ge) ? Pr(wn) : Pr(Cr, !1);
          });
        }
        P(_r), Ne((Pr) => gr(_r, "title", Pr), [() => L2()]), G(Mr, _r);
      };
    var ce = q(M(W), 2);
    let qr;
    var ge = M(ce);
    let In;
    var de = M(ge);
    {
      var Se = (Mr) => {
          var _r = jB();
          _r.__click = () => {
            var wn;
            te(tr, !0),
              y(N) && as((wn = y(N)) == null ? void 0 : wn.getCenter(), y(K));
          };
          var dn = M(_r, !0);
          P(_r), Ne((wn) => le(dn, wn), [() => t2()]), G(Mr, _r);
        },
        We = (Mr) => {
          var _r = Jt(),
            dn = _t(_r);
          {
            var wn = (Cr) => {
              var Pr = UB(),
                Cn = M(Pr);
              {
                var Vn = (Qr) => {
                    var Ar = VB(),
                      sn = M(Ar, !0);
                    P(Ar),
                      Ne(
                        (qn) => {
                          var pn;
                          gr(
                            Ar,
                            "href",
                            ((pn = kt.data) == null ? void 0 : pn.role) ===
                              "admin"
                              ? `${di.url.origin}/admin`
                              : `${di.url.origin}/moderation`
                          ),
                            le(sn, qn);
                        },
                        [
                          () => {
                            var qn;
                            return w0[
                              ((qn = kt.data) == null ? void 0 : qn.role) ??
                                "moderator"
                            ].toUpperCase();
                          },
                        ]
                      ),
                      G(Qr, Ar);
                  },
                  kn = (Qr) => {
                    var Ar = Jt(),
                      sn = _t(Ar);
                    {
                      var qn = (pn) => {
                        var En = qB();
                        Ne((Yn) => gr(En, "data-tip", Yn), [() => $4()]),
                          G(pn, En);
                      };
                      Me(
                        sn,
                        (pn) => {
                          var En;
                          ba((En = kt.data) == null ? void 0 : En.role, [
                            "community_leader",
                          ]) && pn(qn);
                        },
                        !0
                      );
                    }
                    G(Qr, Ar);
                  };
                Me(Cn, (Qr) => {
                  var Ar;
                  ba((Ar = kt.data) == null ? void 0 : Ar.role, [
                    "admin",
                    "moderator",
                    "global_moderator",
                  ])
                    ? Qr(Vn)
                    : Qr(kn, !1);
                });
              }
              var Sn = q(Cn, 2);
              IF(Sn, {
                get user() {
                  return kt;
                },
                onlogout: () => {
                  te(ne, { name: "mainMenu" }, !0);
                },
                onbanappeal: () => {
                  te(vr, !0);
                },
                onnotificationclick: () => {
                  te(ar, !0);
                },
                ontogglepixelarts: (Qr) => {
                  te(dt, Qr, !0);
                },
              }),
                P(Pr),
                oa(
                  3,
                  Pr,
                  () => Ha,
                  () => ({ duration: 150 })
                ),
                G(Cr, Pr);
            };
            Me(
              dn,
              (Cr) => {
                kt.data && y(N) && y(ne).name !== "paintingPixel" && Cr(wn);
              },
              !0
            );
          }
          G(Mr, _r);
        };
      Me(de, (Mr) => {
        !kt.loading && !kt.data ? Mr(Se) : Mr(We, !1);
      });
    }
    var Ze = q(de, 2);
    {
      var Ct = (Mr) => {
          var _r = $B(),
            dn = M(_r);
          {
            var wn = (Qr) => {
              var Ar = ZB();
              Ar.__click = () => {
                var pn;
                te(Dt, !0);
                const qn = (pn = y(N)) == null ? void 0 : pn.getCenter();
                qn && as(qn, y(K));
              };
              var sn = M(Ar);
              Xy(sn, { class: "size-5" }),
                P(Ar),
                Ne((qn) => gr(Ar, "title", qn), [() => O0()]),
                G(Qr, Ar);
            };
            Me(dn, (Qr) => {
              kt.data && Qr(wn);
            });
          }
          var Cr = q(dn, 2);
          {
            var Pr = (Qr) => {
              var Ar = GB();
              Ar.__click = () => {
                te(E, !0);
              };
              var sn = M(Ar);
              tf(sn, { class: "size-5" }),
                P(Ar),
                Ne((qn) => gr(Ar, "title", qn), [() => Kp()]),
                G(Qr, Ar);
            };
            Me(Cr, (Qr) => {
              kt.data && Qr(Pr);
            });
          }
          var Cn = q(Cr, 2);
          Cn.__click = () => {
            te(Sr, !0);
          };
          var Vn = M(Cn);
          Sy(Vn, { class: "size-5" }), P(Cn);
          var kn = q(Cn, 2);
          kn.__click = () => {
            te(pr, !0);
          };
          var Sn = M(kn);
          zB(Sn, { class: "size-5" }),
            P(kn),
            P(_r),
            Ne(
              (Qr, Ar) => {
                gr(Cn, "title", Qr), gr(kn, "title", Ar);
              },
              [() => m_(), () => F0()]
            ),
            oa(
              3,
              _r,
              () => Ha,
              () => ({ duration: 150 })
            ),
            G(Mr, _r);
        },
        _e = (Mr) => {
          var _r = Jt(),
            dn = _t(_r);
          {
            var wn = (Cr) => {
              var Pr = HB(),
                Cn = M(Pr);
              let Vn;
              Cn.__click = () => {
                te(ee, !y(ee));
              };
              var kn = M(Cn);
              {
                var Sn = (Ar) => {
                    i_(Ar, { class: "size-5" });
                  },
                  Qr = (Ar) => {
                    Dp(Ar, { class: "size-5" });
                  };
                Me(kn, (Ar) => {
                  y(ee) ? Ar(Sn) : Ar(Qr, !1);
                });
              }
              P(Cn),
                P(Pr),
                Ne(
                  (Ar) => {
                    gr(Cn, "title", Ar),
                      (Vn = Br(
                        Cn,
                        1,
                        "btn btn-square not-touchscreen:hidden shadow-md",
                        null,
                        Vn,
                        { "btn-primary": y(ee) }
                      ));
                  },
                  [() => (y(ee) ? u2() : p2())]
                ),
                oa(
                  1,
                  Pr,
                  () => Ha,
                  () => ({ delay: 150, duration: 150 })
                ),
                G(Cr, Pr);
            };
            Me(
              dn,
              (Cr) => {
                y(N) && y(ne).name === "paintingPixel" && Cr(wn);
              },
              !0
            );
          }
          G(Mr, _r);
        };
      Me(Ze, (Mr) => {
        y(N) && y(ne).name !== "paintingPixel" ? Mr(Ct) : Mr(_e, !1);
      });
    }
    P(ge), P(ce);
    var Vt = q(ce, 2);
    let $n;
    var cr = M(Vt);
    {
      var Ot = (Mr) => {
        var _r = WB();
        _r.__click = () => {
          te(O, !0);
        };
        var dn = M(_r);
        SB(dn, { class: "size-3.5" }),
          P(_r),
          Ne((wn) => gr(_r, "title", wn), [() => _2()]),
          G(Mr, _r);
      };
      Me(cr, (Mr) => {
        y(ne).name !== "paintingPixel" && Mr(Ot);
      });
    }
    var ur = q(cr, 2),
      Nr = M(ur);
    Nr.__click = () => {
      var Mr;
      (Mr = y(N)) == null || Mr.zoomIn();
    };
    var Ur = q(Nr, 2);
    (Ur.__click = () => {
      var Mr;
      (Mr = y(N)) == null || Mr.zoomOut();
    }),
      P(ur);
    var Wr = q(ur, 2);
    {
      var un = (Mr) => {
        var _r = XB(),
          dn = q(M(_r), 2);
        dn.__click = () => {
          te(ne, { name: "selectArea" }, !0);
        };
        var wn = M(dn);
        sh(wn, { class: "size-4" }), P(dn), P(_r), G(Mr, _r);
      };
      Me(Wr, (Mr) => {
        y(ne).name !== "paintingPixel" && y(mr) && Mr(un);
      });
    }
    var an = q(Wr, 2);
    {
      var fn = (Mr) => {
        var _r = YB(),
          dn = M(_r);
        Hy(dn, {
          class: "size-4",
          onclick: () => {
            te(ue, !y(ue));
          },
        }),
          P(_r),
          Ne((wn) => gr(_r, "title", wn), [() => Yw()]),
          G(Mr, _r);
      };
      Me(an, (Mr) => {
        y(re) && Mr(fn);
      });
    }
    var rn = q(an, 2);
    {
      var pt = (Mr) => {
        var _r = KB();
        _r.__click = () => {
          window.location.replace(di.url.origin);
        };
        var dn = M(_r);
        $b(dn, { class: "size-3" }),
          P(_r),
          Ne((wn) => gr(_r, "title", wn), [() => Wb()]),
          G(Mr, _r);
      };
      Me(rn, (Mr) => {
        y(ne).name !== "paintingPixel" && Mr(pt);
      });
    }
    P(Vt);
    var on = q(Vt, 2);
    let Ci;
    var Pn = M(on);
    {
      var zt = (Mr) => {
        var _r = JB(),
          dn = M(_r);
        Hb(dn, { class: "size-5" });
        var wn = q(dn);
        P(_r),
          Ne((Cr) => le(wn, ` ${Cr ?? ""}`), [() => C2()]),
          oa(
            1,
            _r,
            () => Ha,
            () => ({ duration: 1e3 })
          ),
          oa(2, _r, () => Ha),
          G(Mr, _r);
      };
      Me(Pn, (Mr) => {
        Jr.online || Mr(zt);
      });
    }
    var Qt = q(Pn, 2);
    {
      var rt = (Mr) => {
        var _r = QB();
        _r.__click = () => {
          var Cr;
          (Cr = y(N)) == null ||
            Cr.flyTo({ center: y(N).getCenter(), zoom: f });
        };
        var dn = M(_r);
        kB(dn, { class: "size-5" });
        var wn = q(dn);
        P(_r),
          Ne((Cr) => le(wn, ` ${Cr ?? ""}`), [() => M2()]),
          oa(
            3,
            _r,
            () => Ha,
            () => ({ duration: 300 })
          ),
          G(Mr, _r);
      };
      Me(Qt, (Mr) => {
        y(K) < L && Mr(rt);
      });
    }
    P(on);
    var $t = q(on, 2);
    let Xn;
    var st = M($t);
    vt(st), P($t);
    var gt = q($t, 2);
    let Mn;
    var Ut = M(gt);
    {
      var br = (Mr) => {
          Py(Mr, {
            class: "z-30",
            onclick: () => {
              var _r;
              (_r = kt.data) != null && _r.needsPhoneVerification
                ? (te(Ye, !0), xr.warning(Lv()))
                : kt.charges !== void 0 && kt.charges < 1
                ? xr.warning(Ez, { icon: rh })
                : y(N) && kt.data
                ? (Oi.smallDropplet.play(),
                  te(ne, { name: "paintingPixel" }, !0))
                : (te(tr, !0), y(N) && as(y(N).getCenter(), y(K)));
            },
            get disabled() {
              return kt.loading;
            },
            get loading() {
              return kt.loading;
            },
            get charges() {
              return kt.charges;
            },
          });
        },
        wt = (Mr) => {
          var _r = eO();
          G(Mr, _r);
        };
      Me(Ut, (Mr) => {
        y(ne).name === "mainMenu" ? Mr(br) : Mr(wt, !1);
      });
    }
    P(gt);
    var sr = q(gt, 2);
    let Vi;
    var wr = M(sr);
    Kt(wr), P(sr);
    var jr = q(sr, 2);
    {
      var Yr = (Mr) => {
        var _r = Jt(),
          dn = _t(_r);
        {
          var wn = (Pr) => {
              var Cn = tO(),
                Vn = M(Cn),
                kn = M(Vn);
              H9(kn, {
                get latLon() {
                  return y(ne).latLon;
                },
                get map() {
                  return y(N);
                },
                get crosshair() {
                  return y(Fe);
                },
                get pixelInfoCache() {
                  return B;
                },
                get season() {
                  return s;
                },
                get tileSize() {
                  return x;
                },
                get pixelArtZoom() {
                  return f;
                },
                get zoom() {
                  return y(K);
                },
                get opaquePixelArt() {
                  return y(nt);
                },
                onclose: () => te(ne, { name: "mainMenu" }, !0),
                onclickshare: (Sn) => {
                  te(yt, Sn, !0), te(lt, !0);
                },
                onclickpaint: ([Sn, Qr]) => {
                  var sn, qn, pn;
                  if (!kt.data) {
                    te(tr, !0);
                    return;
                  }
                  if ((sn = kt.data) != null && sn.needsPhoneVerification) {
                    te(Ye, !0), xr.warning(Lv());
                    return;
                  }
                  if (kt.charges !== void 0 && kt.charges < 1) {
                    xr.warning(F2());
                    return;
                  }
                  const Ar = w_(A.latLonToPixelBoundsLatLon(Sn, Qr, f));
                  (qn = y(N)) == null ||
                    qn.flyTo({ center: { lat: Ar[0], lon: Ar[1] } }),
                    te(
                      ne,
                      { name: "paintingPixel", clickedLatLon: [Sn, Qr] },
                      !0
                    ),
                    (pn = y(Fe)) == null || pn.clear();
                },
                onclickregion: (Sn) => {
                  te(mt, Sn, !0), te(D, !0);
                },
                onclickmodaction: (Sn, Qr, Ar, sn) => {
                  var En, Yn, _a;
                  (En = y(N)) == null || En.setZoom(Math.max(y(K), f + 3.5));
                  const qn = A.latLonToPixelBoundsLatLon(Ar[0], Ar[1], f);
                  if (
                    ((Yn = y(N)) == null ||
                      Yn.setCenter({
                        lat: qn.min[0],
                        lng: (qn.max[1] + qn.min[1]) / 2,
                      }),
                    !(Sn != null && Sn.paintedBy))
                  ) {
                    xr.error(zv());
                    return;
                  }
                  const pn = Sn.paintedBy;
                  te(At, Qr, !0),
                    te(
                      Xt,
                      [
                        {
                          id: pn.id,
                          name: pn.name,
                          picture: pn.picture,
                          allianceId: pn.allianceId ?? void 0,
                          allianceName: pn.allianceName ?? void 0,
                          timedOut: pn.timedOut,
                          banned: pn.banned,
                        },
                      ],
                      !0
                    ),
                    te(Lt, Ar, !0),
                    te(
                      Nt,
                      ((_a = y(N)) == null ? void 0 : _a.getZoom()) ?? 0,
                      !0
                    ),
                    te(Gt, sn, !0),
                    te(jt, void 0),
                    te(Bt, !0);
                },
              }),
                P(Vn),
                P(Cn),
                oa(
                  3,
                  Vn,
                  () => bp,
                  () => ({ duration: 100 })
                ),
                G(Pr, Cn);
            },
            Cr = (Pr) => {
              var Cn = Jt(),
                Vn = _t(Cn);
              {
                var kn = (Qr) => {
                    var Ar = rO(),
                      sn = M(Ar),
                      qn = M(sn);
                    e7(qn, {
                      get map() {
                        return y(N);
                      },
                      get clickedLatLon() {
                        return y(ne).clickedLatLon;
                      },
                      get tileSize() {
                        return x;
                      },
                      get tileZoom() {
                        return f;
                      },
                      get season() {
                        return s;
                      },
                      get zoom() {
                        return y(K);
                      },
                      get crosshair() {
                        return y(ft);
                      },
                      refreshPixelArt: () => y(N) && Ae(y(N)),
                      hidePixelHover: Le,
                      hoverLayerId: qe,
                      onclose: () => {
                        te(ne, { name: "mainMenu" }, !0), Le();
                      },
                      get screenLocked() {
                        return y(ee);
                      },
                      set screenLocked(pn) {
                        te(ee, pn, !0);
                      },
                      get opaquePixelArt() {
                        return y(nt);
                      },
                      set opaquePixelArt(pn) {
                        te(nt, pn, !0);
                      },
                    }),
                      P(sn),
                      P(Ar),
                      oa(
                        3,
                        sn,
                        () => bp,
                        () => ({ duration: 100 })
                      ),
                      G(Qr, Ar);
                  },
                  Sn = (Qr) => {
                    var Ar = Jt(),
                      sn = _t(Ar);
                    {
                      var qn = (En) => {
                          var Yn = nO(),
                            _a = M(Yn);
                          g9(_a, {
                            get map() {
                              return y(N);
                            },
                            get tileSize() {
                              return x;
                            },
                            get pixelArtZoom() {
                              return cm;
                            },
                            get season() {
                              return s;
                            },
                            get crosshair() {
                              return y(ft);
                            },
                            onmodaction: (ea) => {
                              var en;
                              const {
                                targets: Dn,
                                image: ga,
                                latLon: ta,
                                zoom: va,
                                action: _n,
                                onSuccess: ja,
                              } = ea;
                              if (!Dn || Dn.length === 0) {
                                xr.error(zv());
                                return;
                              }
                              te(At, ga, !0),
                                te(Xt, Dn, !0),
                                te(Lt, ta, !0),
                                te(
                                  Nt,
                                  va ??
                                    ((en = y(N)) == null
                                      ? void 0
                                      : en.getZoom()) ??
                                    0,
                                  !0
                                ),
                                te(Gt, _n, !0),
                                te(jt, { onSuccess: ja }, !0),
                                te(Bt, !0);
                            },
                            onclose: () => {
                              te(ne, { name: "mainMenu" }, !0), Le();
                            },
                          }),
                            P(Yn),
                            G(En, Yn);
                        },
                        pn = (En) => {
                          var Yn = Jt(),
                            _a = _t(Yn);
                          {
                            var ea = (Dn) => {
                              var ga = iO(),
                                ta = M(ga),
                                va = M(ta),
                                _n = M(va),
                                ja = M(_n),
                                en = M(ja);
                              Gy(en, { class: "inline size-4" });
                              var ln = q(en);
                              P(ja);
                              var vo = q(ja, 2);
                              vo.__click = () => {
                                te(ne, { name: "mainMenu" }, !0);
                              };
                              var xn = M(vo);
                              Os(xn, { class: "size-4" }), P(vo), P(_n);
                              var Ya = q(_n, 2),
                                Di = M(Ya);
                              Di.__click = async () => {
                                var Pa;
                                if (y(ne).name === "selectHq") {
                                  const Ka = y(ne).hq;
                                  if (Ka)
                                    try {
                                      te(Mt, !0),
                                        await Jr.updateAllianceHeadquarters(
                                          Ka[0],
                                          Ka[1]
                                        ),
                                        (Pa = y(Fe)) == null || Pa.clear(),
                                        te(E, !0),
                                        te(ne, { name: "mainMenu" }, !0);
                                    } catch (Fo) {
                                      xr.error(Fo.message);
                                    } finally {
                                      te(Mt, !1);
                                    }
                                }
                              };
                              var Ro = M(Di);
                              Wy(Ro, { class: "size-6" }),
                                P(Di),
                                P(Ya),
                                P(va),
                                P(ta),
                                P(ga),
                                Ne(
                                  (Pa) => {
                                    le(ln, ` ${Pa ?? ""}`),
                                      (Di.disabled =
                                        y(ne).hq === void 0 || y(Mt));
                                  },
                                  [() => kC()]
                                ),
                                oa(
                                  3,
                                  ta,
                                  () => bp,
                                  () => ({ duration: 100 })
                                ),
                                G(Dn, ga);
                            };
                            Me(
                              _a,
                              (Dn) => {
                                y(ne).name === "selectHq" && Dn(ea);
                              },
                              !0
                            );
                          }
                          G(En, Yn);
                        };
                      Me(
                        sn,
                        (En) => {
                          y(ne).name === "selectArea" ? En(qn) : En(pn, !1);
                        },
                        !0
                      );
                    }
                    G(Qr, Ar);
                  };
                Me(
                  Vn,
                  (Qr) => {
                    y(ne).name === "paintingPixel" && y(ft)
                      ? Qr(kn)
                      : Qr(Sn, !1);
                  },
                  !0
                );
              }
              G(Pr, Cn);
            };
          Me(dn, (Pr) => {
            y(ne).name === "pixelSelected" && y(Fe) ? Pr(wn) : Pr(Cr, !1);
          });
        }
        G(Mr, _r);
      };
      Me(jr, (Mr) => {
        y(N) && Mr(Yr);
      });
    }
    P(W),
      Ne(
        (Mr, _r) => {
          (qr = Br(ce, 1, "absolute right-2 top-2 z-30", null, qr, {
            hidden: y(ue),
          })),
            (In = Br(ge, 1, "flex flex-col gap-4", null, In, {
              "items-end": !kt.data,
              "items-center": kt.data,
            })),
            ($n = Br(
              Vt,
              1,
              "absolute left-2 top-2 z-30 flex flex-col gap-3",
              null,
              $n,
              { hidden: y(ue) }
            )),
            gr(Nr, "title", Mr),
            gr(Ur, "title", _r),
            (Ci = Br(
              on,
              1,
              "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2",
              null,
              Ci,
              { hidden: y(ue) }
            )),
            (Xn = Br($t, 1, "absolute bottom-3 left-3 z-30", null, Xn, {
              hidden: y(ue),
            })),
            (Mn = Br(
              gt,
              1,
              "absolute bottom-3 left-1/2 z-30 -translate-x-1/2",
              null,
              Mn,
              { hidden: y(ue) }
            )),
            (Vi = Br(sr, 1, "absolute bottom-3 right-3 z-30", null, Vi, {
              hidden: y(ue),
            }));
        },
        [() => y2(), () => w2()]
      );
  }
  var fr = q(W, 2);
  Az(fr, {
    get open() {
      return y(tr);
    },
    set open(vt) {
      te(tr, vt, !0);
    },
  });
  var Zr = q(fr, 2);
  wB(Zr, {
    get open() {
      return y(Dt);
    },
    set open(vt) {
      te(Dt, vt, !0);
    },
  });
  var nn = q(Zr, 2);
  wk(nn, {
    get open() {
      return y(Te);
    },
    set open(vt) {
      te(Te, vt, !0);
    },
  });
  var Tn = q(nn, 2);
  jk(Tn, {
    get open() {
      return y(O);
    },
    set open(vt) {
      te(O, vt, !0);
    },
  });
  var gn = q(Tn, 2);
  xk(gn, {
    get open() {
      return y(ct);
    },
    set open(vt) {
      te(ct, vt, !0);
    },
  });
  var Gn = q(gn, 2);
  Pz(Gn, {
    onvisitclick: (vt) => {
      var Kt;
      (Kt = y(N)) == null || Kt.flyTo({ center: vt, zoom: cm + 1 }),
        as(vt, y(K)),
        A6.push({ pos: vt, zoom: y(K) }),
        te(Sr, !1);
    },
    get open() {
      return y(Sr);
    },
    set open(vt) {
      te(Sr, vt, !0);
    },
  });
  var Rn = q(Gn, 2);
  VF(Rn, {
    get region() {
      return y(mt);
    },
    get open() {
      return y(D);
    },
    set open(vt) {
      te(D, vt, !0);
    },
  });
  var hn = q(Rn, 2);
  Vb(hn, {
    get open() {
      return da.dropletsDialogOpen;
    },
    set open(vt) {
      da.dropletsDialogOpen = vt;
    },
  });
  var Qn = q(hn, 2);
  {
    var li = (vt) => {
      nk(vt, {
        onhqchange: () => {
          te(ne, { name: "selectHq" }, !0), te(E, !1);
        },
        onhqclick: (Kt) => {
          var qr;
          (qr = y(N)) == null ||
            qr.flyTo({ center: Kt, zoom: Math.max(y(K), 15) }),
            te(ne, { name: "pixelSelected", latLon: [Kt.lat, Kt.lng] }, !0),
            te(E, !1);
        },
        onlastpixelclick: (Kt) => {
          var qr;
          (qr = y(N)) == null ||
            qr.flyTo({ center: Kt, zoom: Math.max(y(K), 15) }),
            te(ne, { name: "pixelSelected", latLon: [Kt.lat, Kt.lng] }, !0),
            te(E, !1);
        },
        get open() {
          return y(E);
        },
        set open(Kt) {
          te(E, Kt, !0);
        },
      });
    };
    Me(Qn, (vt) => {
      y(N) && vt(li);
    });
  }
  var ii = q(Qn, 2);
  v7(ii, {
    get open() {
      return y(Ye);
    },
    set open(vt) {
      te(Ye, vt, !0);
    },
  });
  var pi = q(ii, 2);
  {
    var Qi = (vt) => {
      fk(vt, {
        get url() {
          return y(yt);
        },
        get map() {
          return y(N);
        },
        hideHover: () => {
          var Kt, qr;
          (Kt = y(N)) == null || Kt.setPaintProperty(qe, "raster-opacity", 0),
            (qr = y(Fe)) == null || qr.setCanvasOpacity(0);
        },
        showHover: () => {
          var Kt, qr;
          (Kt = y(N)) == null || Kt.setPaintProperty(qe, "raster-opacity", ke),
            (qr = y(Fe)) == null || qr.setCanvasOpacity(1);
        },
        get open() {
          return y(lt);
        },
        set open(Kt) {
          te(lt, Kt, !0);
        },
      });
    };
    Me(pi, (vt) => {
      y(N) && vt(Qi);
    });
  }
  var xi = q(pi, 2);
  {
    var Hi = (vt) => {
      zb(vt, {
        get image() {
          return y(At);
        },
        get targets() {
          return y(Xt);
        },
        get latLon() {
          return y(Lt);
        },
        get zoom() {
          return y(Nt);
        },
        get action() {
          return y(Gt);
        },
        onsuccess: () => {
          var Kt, qr;
          (qr = (Kt = y(jt)) == null ? void 0 : Kt.onSuccess) == null ||
            qr.call(Kt);
        },
        get open() {
          return y(Bt);
        },
        set open(Kt) {
          te(Bt, Kt, !0);
        },
      });
    };
    Me(xi, (vt) => {
      y(Xt) && y(Xt).length > 0 && y(At) && y(Lt) && vt(Hi);
    });
  }
  var ma = q(xi, 2);
  {
    var Ta = (vt) => {
      x7(vt, {
        get userData() {
          return kt.data;
        },
        get open() {
          return y(vr);
        },
        set open(Kt) {
          te(vr, Kt, !0);
        },
      });
    };
    Me(ma, (vt) => {
      kt.data && vt(Ta);
    });
  }
  var Na = q(ma, 2);
  Yz(Na, {
    get open() {
      return y(ar);
    },
    set open(vt) {
      te(ar, vt, !0);
    },
  });
  var Do = q(Na, 2);
  {
    var Sa = (vt) => {
      t9(vt, {
        get map() {
          return y(N);
        },
        get tileSize() {
          return x;
        },
        get season() {
          return s;
        },
        get tileZoom() {
          return f;
        },
        get open() {
          return y(pr);
        },
        set open(Kt) {
          te(pr, Kt, !0);
        },
      });
    };
    Me(Do, (vt) => {
      y(N) && vt(Sa);
    });
  }
  var Ca = q(Do, 2);
  Me(Ca, (vt) => {
    y(N);
  }),
    G(_, H),
    Rr();
}
Bn(["click"]);
export { QO as component };
