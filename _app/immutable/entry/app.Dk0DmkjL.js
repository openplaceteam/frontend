const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      "../nodes/0.pLr2ZkeK.js",
      "../chunks/ClL9a_Zs.js",
      "../chunks/Ba2x20r8.js",
      "../chunks/iK5FT0Sa.js",
      "../chunks/BHnQYZx5.js",
      "../chunks/IsOmSjXL.js",
      "../chunks/B3m8Ax5i.js",
      "../chunks/BcevhAVP.js",
      "../chunks/DQcFTXWv.js",
      "../chunks/CAgnzvmt.js",
      "../chunks/BJyid7P1.js",
      "../chunks/6Mc7KQD2.js",
      "../chunks/DcUGKLlr.js",
      "../chunks/Cw1VVyw7.js",
      "../chunks/DnZ5W6UV.js",
      "../chunks/ClBgBzqC.js",
      "../chunks/CZQHObn-.js",
      "../chunks/CqEpAPi0.js",
      "../assets/0.JufZK6Yz.css",
      "../nodes/1.DQH1g9br.js",
      "../chunks/AXHr-fF2.js",
      "../chunks/D_G6cexA.js",
      "../chunks/BvzQyf_g.js",
      "../chunks/E8vEVpET.js",
      "../nodes/2.pstZBWzB.js",
      "../chunks/COcZhybn.js",
      "../chunks/DDOVU0Bm.js",
      "../chunks/D4MEaonn.js",
      "../chunks/qHbcPXTE.js",
      "../chunks/DG5z7AC6.js",
      "../nodes/3.DsVmlgHZ.js",
      "../nodes/4.C7N6qwFu.js",
      "../chunks/D1YbojwT.js",
      "../chunks/D_F-xNOc.js",
      "../chunks/6G5adFH1.js",
      "../chunks/yt7z1efG.js",
      "../chunks/BRvsRNeX.js",
      "../chunks/CbE2L3A6.js",
      "../chunks/DKIm2qqY.js",
      "../chunks/DUpX1e05.js",
      "../chunks/DnpWy_rL.js",
      "../chunks/BQsyJ3Sw.js",
      "../chunks/YoKKrauw.js",
      "../chunks/UjG3PxiF.js",
      "../chunks/DsSnzxUe.js",
      "../chunks/DpS0PshJ.js",
      "../chunks/BptsAMEP.js",
      "../assets/ProfileAvatarWithLevel.C1r4yqVt.css",
      "../chunks/2xVnDudW.js",
      "../chunks/CgP_-eBe.js",
      "../assets/LoginForm.DGOu-WIi.css",
      "../chunks/CD6G4wKE.js",
      "../chunks/y2OiVH5z.js",
      "../chunks/D-ki6Nha.js",
      "../chunks/DIrPyiFz.js",
      "../chunks/CnpP4qa_.js",
      "../chunks/C4amkYCn.js",
      "../assets/4.CZIVbXbQ.css",
      "../nodes/5.CvWw6Hog.js",
      "../nodes/6.DYe1Nhol.js",
      "../nodes/7.vXfYB5CG.js",
      "../chunks/Bv_KMhOk.js",
      "../chunks/D28eA48x.js",
      "../chunks/CGiPcZge.js",
      "../chunks/BpqyV1PE.js",
      "../nodes/8.D41too8x.js",
      "../nodes/9.gHzqB_fO.js",
      "../chunks/ignmDRGI.js",
      "../chunks/CtNRy5kr.js",
      "../chunks/C5dbJ4r_.js",
      "../nodes/10.qYJ5TBMT.js",
      "../chunks/VeD2qHkI.js",
      "../nodes/11.s_c5d7Pu.js",
      "../nodes/12.DaqvA-lP.js",
      "../chunks/B2X4S6Gs.js",
      "../nodes/13.D1SKYXg_.js",
      "../nodes/14.CItkIPxr.js",
      "../chunks/x172pvsV.js",
      "../chunks/D6qiv33a.js",
      "../chunks/BGlGAxl5.js",
      "../nodes/15.DFAdMRVC.js",
      "../chunks/Xu0Wy4QE.js",
      "../nodes/16.Bq0OAVIQ.js",
      "../chunks/DzqH8Dp0.js",
      "../nodes/17.DIqvAhdu.js",
      "../nodes/18.Bgc5wtfX.js",
      "../nodes/19.ofgcIKR2.js",
      "../nodes/20.DlIAN3i2.js",
      "../nodes/21.DvhKcBis.js",
      "../nodes/22.BykEdy1m.js",
      "../assets/22.AmQai5Pb.css",
      "../nodes/23.BjtvDQqY.js",
      "../nodes/24.HgwoLwLZ.js",
      "../nodes/25.CcvpK7hL.js",
      "../nodes/26.Pg0i9C45.js",
    ])
) => i.map((i) => d[i]);
var Jn = (t) => {
  throw TypeError(t);
};
var Kn = (t, e, n) => e.has(t) || Jn("Cannot " + n);
var j = (t, e, n) => (
    Kn(t, e, "read from private field"), n ? n.call(t) : e.get(t)
  ),
  Zt = (t, e, n) =>
    e.has(t)
      ? Jn("Cannot add the same private member more than once")
      : e instanceof WeakSet
      ? e.add(t)
      : e.set(t, n),
  Qt = (t, e, n, r) => (
    Kn(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n
  );
import { _ as w } from "../chunks/CD6G4wKE.js";
import {
  D as _,
  d as g,
  g as Te,
  G as x,
  a as J,
  b as X,
  S as qe,
  i as en,
  c as Mt,
  e as et,
  T as Vr,
  n as ma,
  f as ga,
  h as ze,
  j as Ce,
  k as A,
  l as pn,
  m as qt,
  o as dt,
  p as ft,
  t as q,
  q as be,
  r as O,
  u as _a,
  v as tt,
  w as ne,
  x as ha,
  y as Ea,
  z as Ye,
  A as Ln,
  B as k,
  C as Zn,
  E as L,
  F as Rt,
  H as Qn,
  I as Sa,
  J as Wr,
  K as pe,
  L as Cn,
  M as jt,
  N as Gr,
  O as zr,
  _ as Vt,
  P as ya,
  Q as wt,
  R as Wt,
  U as Yr,
  V as Ta,
  W as Xr,
  X as at,
  Y as ba,
  Z as Jr,
  $ as Gt,
  a0 as va,
  a1 as At,
  a2 as er,
  a3 as je,
  a4 as tr,
  a5 as Ia,
  a6 as Ra,
  a7 as wa,
  a8 as Kr,
  a9 as Zr,
  aa as Qr,
  ab as Aa,
  ac as mn,
  ad as zt,
  ae as On,
  af as nr,
  ag as Pa,
  ah as ka,
  ai as Na,
  aj as La,
  ak as Ca,
  al as Oa,
  am as Ma,
  an as Mn,
  ao as Ne,
  ap as ye,
  aq as Dt,
  ar as Da,
  as as Y,
  at as rr,
  au as sr,
  av as es,
  aw as ts,
  ax as xa,
  ay as ns,
  az as ot,
  aA as lt,
  aB as Fa,
  aC as gn,
  aD as it,
  aE as rs,
  aF as ss,
  aG as ar,
  aH as Ha,
  aI as Dn,
  aJ as Ba,
  aK as $a,
  aL as K,
  aM as fe,
  aN as as,
  aO as nt,
  aP as Ua,
  aQ as Ve,
  aR as or,
  aS as ir,
  aT as cr,
  aU as os,
  aV as qa,
  aW as ja,
  aX as Va,
  aY as Wa,
} from "../chunks/CAgnzvmt.js";
import { s as Ga } from "../chunks/E8vEVpET.js";
import {
  o as Pt,
  aR as za,
  g as z,
  aB as Ya,
  bA as Xa,
  a9 as Ja,
  p as Ka,
  C as Za,
  D as Qa,
  l as tn,
  M as eo,
  f as is,
  a as le,
  s as to,
  b as Q,
  c as no,
  w as Ee,
  d as ro,
  r as so,
  u as Ae,
  q as ao,
  t as oo,
} from "../chunks/iK5FT0Sa.js";
import { h as io, m as co, u as uo, s as fo } from "../chunks/BHnQYZx5.js";
import "../chunks/ClL9a_Zs.js";
import { o as lo } from "../chunks/Ba2x20r8.js";
import { i as Ze } from "../chunks/6Mc7KQD2.js";
import { c as Pe } from "../chunks/CZQHObn-.js";
import { b as ke } from "../chunks/DnZ5W6UV.js";
import { p as Qe } from "../chunks/ClBgBzqC.js";
(function () {
  try {
    var t =
      typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : typeof globalThis < "u"
        ? globalThis
        : typeof self < "u"
        ? self
        : {};
    t.SENTRY_RELEASE = { id: "0fdca126ca32380ac4e95a0011d2b66881dfb9e6" };
  } catch {}
})();
try {
  (function () {
    var t =
        typeof window < "u"
          ? window
          : typeof global < "u"
          ? global
          : typeof globalThis < "u"
          ? globalThis
          : typeof self < "u"
          ? self
          : {},
      e = new t.Error().stack;
    e &&
      ((t._sentryDebugIds = t._sentryDebugIds || {}),
      (t._sentryDebugIds[e] = "e6abc3dd-a395-4411-926f-4f73576c9d0c"),
      (t._sentryDebugIdIdentifier =
        "sentry-dbid-e6abc3dd-a395-4411-926f-4f73576c9d0c"));
  })();
} catch {}
function po(t) {
  return class extends mo {
    constructor(e) {
      super({ component: t, ...e });
    }
  };
}
var Se, te;
class mo {
  constructor(e) {
    Zt(this, Se);
    Zt(this, te);
    var a;
    var n = new Map(),
      r = (o, c) => {
        var i = Ja(c, !1, !1);
        return n.set(o, i), i;
      };
    const s = new Proxy(
      { ...(e.props || {}), $$events: {} },
      {
        get(o, c) {
          return z(n.get(c) ?? r(c, Reflect.get(o, c)));
        },
        has(o, c) {
          return c === za
            ? !0
            : (z(n.get(c) ?? r(c, Reflect.get(o, c))), Reflect.has(o, c));
        },
        set(o, c, i) {
          return Pt(n.get(c) ?? r(c, i), i), Reflect.set(o, c, i);
        },
      }
    );
    Qt(
      this,
      te,
      (e.hydrate ? io : co)(e.component, {
        target: e.target,
        anchor: e.anchor,
        props: s,
        context: e.context,
        intro: e.intro ?? !1,
        recover: e.recover,
      })
    ),
      (!((a = e == null ? void 0 : e.props) != null && a.$$host) ||
        e.sync === !1) &&
        Ya(),
      Qt(this, Se, s.$$events);
    for (const o of Object.keys(j(this, te)))
      o === "$set" ||
        o === "$destroy" ||
        o === "$on" ||
        Xa(this, o, {
          get() {
            return j(this, te)[o];
          },
          set(c) {
            j(this, te)[o] = c;
          },
          enumerable: !0,
        });
    (j(this, te).$set = (o) => {
      Object.assign(s, o);
    }),
      (j(this, te).$destroy = () => {
        uo(j(this, te));
      });
  }
  $set(e) {
    j(this, te).$set(e);
  }
  $on(e, n) {
    j(this, Se)[e] = j(this, Se)[e] || [];
    const r = (...s) => n.call(this, ...s);
    return (
      j(this, Se)[e].push(r),
      () => {
        j(this, Se)[e] = j(this, Se)[e].filter((s) => s !== r);
      }
    );
  }
  $destroy() {
    j(this, te).$destroy();
  }
}
(Se = new WeakMap()), (te = new WeakMap());
const kt = {},
  ur = {};
function Re(t, e) {
  (kt[t] = kt[t] || []), kt[t].push(e);
}
function we(t, e) {
  if (!ur[t]) {
    ur[t] = !0;
    try {
      e();
    } catch (n) {
      _ && g.error(`Error while instrumenting ${t}`, n);
    }
  }
}
function re(t, e) {
  const n = t && kt[t];
  if (n)
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        _ &&
          g.error(
            `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Te(r)}
Error:`,
            s
          );
      }
}
let nn = null;
function cs(t) {
  const e = "error";
  Re(e, t), we(e, go);
}
function go() {
  (nn = x.onerror),
    (x.onerror = function (t, e, n, r, s) {
      return (
        re("error", { column: r, error: s, line: n, msg: t, url: e }),
        nn ? nn.apply(this, arguments) : !1
      );
    }),
    (x.onerror.__SENTRY_INSTRUMENTED__ = !0);
}
let rn = null;
function us(t) {
  const e = "unhandledrejection";
  Re(e, t), we(e, _o);
}
function _o() {
  (rn = x.onunhandledrejection),
    (x.onunhandledrejection = function (t) {
      return re("unhandledrejection", t), rn ? rn.apply(this, arguments) : !0;
    }),
    (x.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0);
}
let dr = !1;
function ho() {
  if (dr) return;
  function t() {
    const e = J(),
      n = e && X(e);
    if (n) {
      const r = "internal_error";
      _ && g.log(`[Tracing] Root span: ${r} -> Global error occurred`),
        n.setStatus({ code: qe, message: r });
    }
  }
  (t.tag = "sentry_tracingErrorCallback"), (dr = !0), cs(t), us(t);
}
function fr(t) {
  g.log(
    `Ignoring span ${t.op} - ${t.description} because it matches \`ignoreSpans\`.`
  );
}
function xt(t, e) {
  if (!(e != null && e.length) || !t.description) return !1;
  for (const n of e) {
    if (So(n)) {
      if (en(t.description, n)) return _ && fr(t), !0;
      continue;
    }
    if (!n.name && !n.op) continue;
    const r = n.name ? en(t.description, n.name) : !0,
      s = n.op ? t.op && en(t.op, n.op) : !0;
    if (r && s) return _ && fr(t), !0;
  }
  return !1;
}
function Eo(t, e) {
  const n = e.parent_span_id,
    r = e.span_id;
  if (n) for (const s of t) s.parent_span_id === r && (s.parent_span_id = n);
}
function So(t) {
  return typeof t == "string" || t instanceof RegExp;
}
class ve {
  constructor(e = {}) {
    (this._traceId = e.traceId || Mt()), (this._spanId = e.spanId || et());
  }
  spanContext() {
    return { spanId: this._spanId, traceId: this._traceId, traceFlags: Vr };
  }
  end(e) {}
  setAttribute(e, n) {
    return this;
  }
  setAttributes(e) {
    return this;
  }
  setStatus(e) {
    return this;
  }
  updateName(e) {
    return this;
  }
  isRecording() {
    return !1;
  }
  addEvent(e, n, r) {
    return this;
  }
  addLink(e) {
    return this;
  }
  addLinks(e) {
    return this;
  }
  recordException(e, n) {}
}
function Me(t, e = []) {
  return [t, e];
}
function yo(t, e) {
  const [n, r] = t;
  return [n, [...r, e]];
}
function lr(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s)) return !0;
  }
  return !1;
}
function _n(t) {
  const e = ga(x);
  return e.encodePolyfill ? e.encodePolyfill(t) : new TextEncoder().encode(t);
}
function To(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);
  function s(a) {
    typeof r == "string"
      ? (r = typeof a == "string" ? r + a : [_n(r), a])
      : r.push(typeof a == "string" ? _n(a) : a);
  }
  for (const a of n) {
    const [o, c] = a;
    if (
      (s(`
${JSON.stringify(o)}
`),
      typeof c == "string" || c instanceof Uint8Array)
    )
      s(c);
    else {
      let i;
      try {
        i = JSON.stringify(c);
      } catch {
        i = JSON.stringify(ma(c));
      }
      s(i);
    }
  }
  return typeof r == "string" ? r : bo(r);
}
function bo(t) {
  const e = t.reduce((s, a) => s + a.length, 0),
    n = new Uint8Array(e);
  let r = 0;
  for (const s of t) n.set(s, r), (r += s.length);
  return n;
}
function vo(t) {
  return [{ type: "span" }, t];
}
function Io(t) {
  const e = typeof t.data == "string" ? _n(t.data) : t.data;
  return [
    {
      type: "attachment",
      length: e.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType,
    },
    e,
  ];
}
const Ro = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item",
  metric: "metric",
  trace_metric: "metric",
};
function pr(t) {
  return Ro[t];
}
function ds(t) {
  if (!(t != null && t.sdk)) return;
  const { name: e, version: n } = t.sdk;
  return { name: e, version: n };
}
function wo(t, e, n, r) {
  var a;
  const s =
    (a = t.sdkProcessingMetadata) == null ? void 0 : a.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...(e && { sdk: e }),
    ...(!!n && r && { dsn: ze(r) }),
    ...(s && { trace: s }),
  };
}
function Ao(t, e) {
  var r, s, a, o;
  if (!e) return t;
  const n = t.sdk || {};
  return (
    (t.sdk = {
      ...n,
      name: n.name || e.name,
      version: n.version || e.version,
      integrations: [
        ...(((r = t.sdk) == null ? void 0 : r.integrations) || []),
        ...(e.integrations || []),
      ],
      packages: [
        ...(((s = t.sdk) == null ? void 0 : s.packages) || []),
        ...(e.packages || []),
      ],
      settings:
        ((a = t.sdk) != null && a.settings) || e.settings
          ? { ...((o = t.sdk) == null ? void 0 : o.settings), ...e.settings }
          : void 0,
    }),
    t
  );
}
function Po(t, e, n, r) {
  const s = ds(n),
    a = {
      sent_at: new Date().toISOString(),
      ...(s && { sdk: s }),
      ...(!!r && e && { dsn: ze(e) }),
    },
    o =
      "aggregates" in t
        ? [{ type: "sessions" }, t]
        : [{ type: "session" }, t.toJSON()];
  return Me(a, [o]);
}
function ko(t, e, n, r) {
  const s = ds(n),
    a = t.type && t.type !== "replay_event" ? t.type : "event";
  Ao(t, n == null ? void 0 : n.sdk);
  const o = wo(t, s, r, e);
  return delete t.sdkProcessingMetadata, Me(o, [[{ type: a }, t]]);
}
function No(t, e) {
  function n(p) {
    return !!p.trace_id && !!p.public_key;
  }
  const r = Ce(t[0]),
    s = e == null ? void 0 : e.getDsn(),
    a = e == null ? void 0 : e.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...(n(r) && { trace: r }),
      ...(!!a && s && { dsn: ze(s) }),
    },
    { beforeSendSpan: c, ignoreSpans: i } =
      (e == null ? void 0 : e.getOptions()) || {},
    u = i != null && i.length ? t.filter((p) => !xt(A(p), i)) : t,
    f = t.length - u.length;
  f && (e == null || e.recordDroppedEvent("before_send", "span", f));
  const d = c
      ? (p) => {
          const m = A(p),
            E = c(m);
          return E || (pn(), m);
        }
      : A,
    l = [];
  for (const p of u) {
    const m = d(p);
    m && l.push(vo(m));
  }
  return Me(o, l);
}
function Lo(t) {
  if (!_) return;
  const {
      description: e = "< unknown name >",
      op: n = "< unknown op >",
      parent_span_id: r,
    } = A(t),
    { spanId: s } = t.spanContext(),
    a = qt(t),
    o = X(t),
    c = o === t,
    i = `[Tracing] Starting ${a ? "sampled" : "unsampled"} ${
      c ? "root " : ""
    }span`,
    u = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if ((r && u.push(`parent ID: ${r}`), !c)) {
    const { op: f, description: d } = A(o);
    u.push(`root ID: ${o.spanContext().spanId}`),
      f && u.push(`root op: ${f}`),
      d && u.push(`root description: ${d}`);
  }
  g.log(`${i}
  ${u.join(`
  `)}`);
}
function Co(t) {
  if (!_) return;
  const { description: e = "< unknown name >", op: n = "< unknown op >" } =
      A(t),
    { spanId: r } = t.spanContext(),
    a = X(t) === t,
    o = `[Tracing] Finishing "${n}" ${
      a ? "root " : ""
    }span "${e}" with ID ${r}`;
  g.log(o);
}
function Oo(t, e, n, r = J()) {
  const s = r && X(r);
  s &&
    (_ &&
      g.log(`[Measurement] Setting measurement on root span: ${t} = ${e} ${n}`),
    s.addEvent(t, { [ft]: e, [dt]: n }));
}
function mr(t) {
  if (!t || t.length === 0) return;
  const e = {};
  return (
    t.forEach((n) => {
      const r = n.attributes || {},
        s = r[dt],
        a = r[ft];
      typeof s == "string" &&
        typeof a == "number" &&
        (e[n.name] = { value: a, unit: s });
    }),
    e
  );
}
const gr = 1e3;
class Yt {
  constructor(e = {}) {
    (this._traceId = e.traceId || Mt()),
      (this._spanId = e.spanId || et()),
      (this._startTime = e.startTimestamp || q()),
      (this._links = e.links),
      (this._attributes = {}),
      this.setAttributes({ [O]: "manual", [be]: e.op, ...e.attributes }),
      (this._name = e.name),
      e.parentSpanId && (this._parentSpanId = e.parentSpanId),
      "sampled" in e && (this._sampled = e.sampled),
      e.endTimestamp && (this._endTime = e.endTimestamp),
      (this._events = []),
      (this._isStandaloneSpan = e.isStandalone),
      this._endTime && this._onSpanEnded();
  }
  addLink(e) {
    return this._links ? this._links.push(e) : (this._links = [e]), this;
  }
  addLinks(e) {
    return this._links ? this._links.push(...e) : (this._links = e), this;
  }
  recordException(e, n) {}
  spanContext() {
    const { _spanId: e, _traceId: n, _sampled: r } = this;
    return { spanId: e, traceId: n, traceFlags: r ? _a : Vr };
  }
  setAttribute(e, n) {
    return (
      n === void 0 ? delete this._attributes[e] : (this._attributes[e] = n),
      this
    );
  }
  setAttributes(e) {
    return Object.keys(e).forEach((n) => this.setAttribute(n, e[n])), this;
  }
  updateStartTime(e) {
    this._startTime = tt(e);
  }
  setStatus(e) {
    return (this._status = e), this;
  }
  updateName(e) {
    return (this._name = e), this.setAttribute(ne, "custom"), this;
  }
  end(e) {
    this._endTime || ((this._endTime = tt(e)), Co(this), this._onSpanEnded());
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[be],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: Ea(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[O],
      profile_id: this._attributes[Ln],
      exclusive_time: this._attributes[Ye],
      measurements: mr(this._events),
      is_segment: (this._isStandaloneSpan && X(this) === this) || void 0,
      segment_id: this._isStandaloneSpan
        ? X(this).spanContext().spanId
        : void 0,
      links: ha(this._links),
    };
  }
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  addEvent(e, n, r) {
    _ && g.log("[Tracing] Adding an event to span:", e);
    const s = _r(n) ? n : r || q(),
      a = _r(n) ? {} : n || {},
      o = { name: e, time: tt(s), attributes: a };
    return this._events.push(o), this;
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  _onSpanEnded() {
    const e = k();
    if (
      (e && e.emit("spanEnd", this),
      !(this._isStandaloneSpan || this === X(this)))
    )
      return;
    if (this._isStandaloneSpan) {
      this._sampled
        ? Do(No([this], e))
        : (_ &&
            g.log(
              "[Tracing] Discarding standalone span because its trace was not chosen to be sampled."
            ),
          e && e.recordDroppedEvent("sample_rate", "span"));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && (Zn(this).scope || L()).captureEvent(r);
  }
  _convertSpanToTransaction() {
    var f;
    if (!hr(A(this))) return;
    this._name ||
      (_ &&
        g.warn(
          "Transaction has no name, falling back to `<unlabeled transaction>`."
        ),
      (this._name = "<unlabeled transaction>"));
    const { scope: e, isolationScope: n } = Zn(this),
      r =
        (f = e == null ? void 0 : e.getScopeData().sdkProcessingMetadata) ==
        null
          ? void 0
          : f.normalizedRequest;
    if (this._sampled !== !0) return;
    const a = Rt(this)
        .filter((d) => d !== this && !Mo(d))
        .map((d) => A(d))
        .filter(hr),
      o = this._attributes[ne];
    delete this._attributes[Qn],
      a.forEach((d) => {
        delete d.data[Qn];
      });
    const c = {
        contexts: { trace: Sa(this) },
        spans:
          a.length > gr
            ? a
                .sort((d, l) => d.start_timestamp - l.start_timestamp)
                .slice(0, gr)
            : a,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: e,
          capturedSpanIsolationScope: n,
          dynamicSamplingContext: Ce(this),
        },
        request: r,
        ...(o && { transaction_info: { source: o } }),
      },
      i = mr(this._events);
    return (
      i &&
        Object.keys(i).length &&
        (_ &&
          g.log(
            "[Measurements] Adding measurements to transaction event",
            JSON.stringify(i, void 0, 2)
          ),
        (c.measurements = i)),
      c
    );
  }
}
function _r(t) {
  return (t && typeof t == "number") || t instanceof Date || Array.isArray(t);
}
function hr(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id;
}
function Mo(t) {
  return t instanceof Yt && t.isStandaloneSpan();
}
function Do(t) {
  const e = k();
  if (!e) return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return;
  }
  e.sendEnvelope(t);
}
function xo(t, e, n = () => {}, r = () => {}) {
  let s;
  try {
    s = t();
  } catch (a) {
    throw (e(a), n(), a);
  }
  return Fo(s, e, n, r);
}
function Fo(t, e, n, r) {
  return Wr(t)
    ? t.then(
        (s) => (n(), r(s), s),
        (s) => {
          throw (e(s), n(), s);
        }
      )
    : (n(), r(t), t);
}
function Ho(t, e, n) {
  if (!pe(t)) return [!1];
  let r, s;
  typeof t.tracesSampler == "function"
    ? ((s = t.tracesSampler({
        ...e,
        inheritOrSampleWith: (c) =>
          typeof e.parentSampleRate == "number"
            ? e.parentSampleRate
            : typeof e.parentSampled == "boolean"
            ? Number(e.parentSampled)
            : c,
      })),
      (r = !0))
    : e.parentSampled !== void 0
    ? (s = e.parentSampled)
    : typeof t.tracesSampleRate < "u" && ((s = t.tracesSampleRate), (r = !0));
  const a = Cn(s);
  if (a === void 0)
    return (
      _ &&
        g.warn(
          `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
            s
          )} of type ${JSON.stringify(typeof s)}.`
        ),
      [!1]
    );
  if (!a)
    return (
      _ &&
        g.log(
          `[Tracing] Discarding transaction because ${
            typeof t.tracesSampler == "function"
              ? "tracesSampler returned 0 or false"
              : "a negative sampling decision was inherited or tracesSampleRate is set to 0"
          }`
        ),
      [!1, a, r]
    );
  const o = n < a;
  return (
    o ||
      (_ &&
        g.log(
          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
            s
          )})`
        )),
    [o, a, r]
  );
}
const fs = "__SENTRY_SUPPRESS_TRACING__";
function Bo(t, e) {
  const n = Fn();
  if (n.startSpan) return n.startSpan(t, e);
  const r = ps(t),
    { forceTransaction: s, parentSpan: a, scope: o } = t,
    c = o == null ? void 0 : o.clone();
  return jt(c, () =>
    Uo(a)(() => {
      const u = L(),
        f = ms(u, a),
        l =
          t.onlyIfParent && !f
            ? new ve()
            : ls({
                parentSpan: f,
                spanArguments: r,
                forceTransaction: s,
                scope: u,
              });
      return (
        Vt(u, l),
        xo(
          () => e(l),
          () => {
            const { status: p } = A(l);
            l.isRecording() &&
              (!p || p === "ok") &&
              l.setStatus({ code: qe, message: "internal_error" });
          },
          () => {
            l.end();
          }
        )
      );
    })
  );
}
function De(t) {
  const e = Fn();
  if (e.startInactiveSpan) return e.startInactiveSpan(t);
  const n = ps(t),
    { forceTransaction: r, parentSpan: s } = t;
  return (
    t.scope
      ? (o) => jt(t.scope, o)
      : s !== void 0
      ? (o) => xn(s, o)
      : (o) => o()
  )(() => {
    const o = L(),
      c = ms(o, s);
    return t.onlyIfParent && !c
      ? new ve()
      : ls({ parentSpan: c, spanArguments: n, forceTransaction: r, scope: o });
  });
}
function xn(t, e) {
  const n = Fn();
  return n.withActiveSpan
    ? n.withActiveSpan(t, e)
    : jt((r) => (Vt(r, t || void 0), e(r)));
}
function ls({
  parentSpan: t,
  spanArguments: e,
  forceTransaction: n,
  scope: r,
}) {
  if (!pe()) {
    const o = new ve();
    if (n || !t) {
      const c = {
        sampled: "false",
        sample_rate: "0",
        transaction: e.name,
        ...Ce(o),
      };
      wt(o, c);
    }
    return o;
  }
  const s = Wt();
  let a;
  if (t && !n) (a = $o(t, r, e)), Yr(t, a);
  else if (t) {
    const o = Ce(t),
      { traceId: c, spanId: i } = t.spanContext(),
      u = qt(t);
    (a = Er({ traceId: c, parentSpanId: i, ...e }, r, u)), wt(a, o);
  } else {
    const {
      traceId: o,
      dsc: c,
      parentSpanId: i,
      sampled: u,
    } = { ...s.getPropagationContext(), ...r.getPropagationContext() };
    (a = Er({ traceId: o, parentSpanId: i, ...e }, r, u)), c && wt(a, c);
  }
  return Lo(a), Ta(a, r, s), a;
}
function ps(t) {
  const n = { isStandalone: (t.experimental || {}).standalone, ...t };
  if (t.startTime) {
    const r = { ...n };
    return (r.startTimestamp = tt(t.startTime)), delete r.startTime, r;
  }
  return n;
}
function Fn() {
  const t = Gr();
  return zr(t);
}
function Er(t, e, n) {
  var m;
  const r = k(),
    s = (r == null ? void 0 : r.getOptions()) || {},
    { name: a = "" } = t,
    o = { spanAttributes: { ...t.attributes }, spanName: a, parentSampled: n };
  r == null || r.emit("beforeSampling", o, { decision: !1 });
  const c = o.parentSampled ?? n,
    i = o.spanAttributes,
    u = e.getPropagationContext(),
    [f, d, l] = e.getScopeData().sdkProcessingMetadata[fs]
      ? [!1]
      : Ho(
          s,
          {
            name: a,
            parentSampled: c,
            attributes: i,
            parentSampleRate: Cn((m = u.dsc) == null ? void 0 : m.sample_rate),
          },
          u.sampleRand
        ),
    p = new Yt({
      ...t,
      attributes: {
        [ne]: "custom",
        [Xr]: d !== void 0 && l ? d : void 0,
        ...i,
      },
      sampled: f,
    });
  return (
    !f &&
      r &&
      (_ &&
        g.log(
          "[Tracing] Discarding root span because its trace was not chosen to be sampled."
        ),
      r.recordDroppedEvent("sample_rate", "transaction")),
    r && r.emit("spanStart", p),
    p
  );
}
function $o(t, e, n) {
  const { spanId: r, traceId: s } = t.spanContext(),
    a = e.getScopeData().sdkProcessingMetadata[fs] ? !1 : qt(t),
    o = a
      ? new Yt({ ...n, parentSpanId: r, traceId: s, sampled: a })
      : new ve({ traceId: s });
  Yr(t, o);
  const c = k();
  return (
    c && (c.emit("spanStart", o), n.endTimestamp && c.emit("spanEnd", o)), o
  );
}
function ms(t, e) {
  if (e) return e;
  if (e === null) return;
  const n = ya(t);
  if (!n) return;
  const r = k();
  return (r ? r.getOptions() : {}).parentSpanIsAlwaysRootSpan ? X(n) : n;
}
function Uo(t) {
  return t !== void 0 ? (e) => xn(t, e) : (e) => e();
}
const Nt = { idleTimeout: 1e3, finalTimeout: 3e4, childSpanTimeout: 15e3 },
  qo = "heartbeatFailed",
  jo = "idleTimeout",
  Vo = "finalTimeout",
  Wo = "externalFinish";
function gs(t, e = {}) {
  const n = new Map();
  let r = !1,
    s,
    a = Wo,
    o = !e.disableAutoFinish;
  const c = [],
    {
      idleTimeout: i = Nt.idleTimeout,
      finalTimeout: u = Nt.finalTimeout,
      childSpanTimeout: f = Nt.childSpanTimeout,
      beforeSpanEnd: d,
      trimIdleSpanEndTimestamp: l = !0,
    } = e,
    p = k();
  if (!p || !pe()) {
    const y = new ve(),
      M = { sample_rate: "0", sampled: "false", ...Ce(y) };
    return wt(y, M), y;
  }
  const m = L(),
    E = J(),
    S = Go(t);
  S.end = new Proxy(S.end, {
    apply(y, M, ge) {
      if ((d && d(S), M instanceof ve)) return;
      const [xe, ...ie] = ge,
        _e = xe || q(),
        P = tt(_e),
        $ = Rt(S).filter((b) => b !== S),
        W = A(S);
      if (!$.length || !l) return oe(P), Reflect.apply(y, M, [P, ...ie]);
      const U = p.getOptions().ignoreSpans,
        Z =
          $ == null
            ? void 0
            : $.reduce((b, D) => {
                const F = A(D);
                return !F.timestamp || (U && xt(F, U))
                  ? b
                  : b
                  ? Math.max(b, F.timestamp)
                  : F.timestamp;
              }, void 0),
        v = W.start_timestamp,
        I = Math.min(
          v ? v + u / 1e3 : 1 / 0,
          Math.max(v || -1 / 0, Math.min(P, Z || 1 / 0))
        );
      return oe(I), Reflect.apply(y, M, [I, ...ie]);
    },
  });
  function R() {
    s && (clearTimeout(s), (s = void 0));
  }
  function N(y) {
    R(),
      (s = setTimeout(() => {
        !r && n.size === 0 && o && ((a = jo), S.end(y));
      }, i));
  }
  function B(y) {
    s = setTimeout(() => {
      !r && o && ((a = qo), S.end(y));
    }, f);
  }
  function me(y) {
    R(), n.set(y, !0);
    const M = q();
    B(M + f / 1e3);
  }
  function ae(y) {
    if ((n.has(y) && n.delete(y), n.size === 0)) {
      const M = q();
      N(M + i / 1e3);
    }
  }
  function oe(y) {
    (r = !0), n.clear(), c.forEach((P) => P()), Vt(m, E);
    const M = A(S),
      { start_timestamp: ge } = M;
    if (!ge) return;
    M.data[at] || S.setAttribute(at, a),
      g.log(`[Tracing] Idle span "${M.op}" finished`);
    const ie = Rt(S).filter((P) => P !== S);
    let _e = 0;
    ie.forEach((P) => {
      P.isRecording() &&
        (P.setStatus({ code: qe, message: "cancelled" }),
        P.end(y),
        _ &&
          g.log(
            "[Tracing] Cancelling span since span ended early",
            JSON.stringify(P, void 0, 2)
          ));
      const $ = A(P),
        { timestamp: W = 0, start_timestamp: U = 0 } = $,
        Z = U <= y,
        v = (u + i) / 1e3,
        I = W - U <= v;
      if (_) {
        const b = JSON.stringify(P, void 0, 2);
        Z
          ? I ||
            g.log(
              "[Tracing] Discarding span since it finished after idle span final timeout",
              b
            )
          : g.log(
              "[Tracing] Discarding span since it happened after idle span was finished",
              b
            );
      }
      (!I || !Z) && (ba(S, P), _e++);
    }),
      _e > 0 && S.setAttribute("sentry.idle_span_discarded_spans", _e);
  }
  return (
    c.push(
      p.on("spanStart", (y) => {
        if (
          r ||
          y === S ||
          A(y).timestamp ||
          (y instanceof Yt && y.isStandaloneSpan())
        )
          return;
        Rt(S).includes(y) && me(y.spanContext().spanId);
      })
    ),
    c.push(
      p.on("spanEnd", (y) => {
        r || ae(y.spanContext().spanId);
      })
    ),
    c.push(
      p.on("idleSpanEnableAutoFinish", (y) => {
        y === S && ((o = !0), N(), n.size && B());
      })
    ),
    e.disableAutoFinish || N(),
    setTimeout(() => {
      r ||
        (S.setStatus({ code: qe, message: "deadline_exceeded" }),
        (a = Vo),
        S.end());
    }, u),
    S
  );
}
function Go(t) {
  const e = De(t);
  return Vt(L(), e), _ && g.log("[Tracing] Started span is an idle span"), e;
}
const zo = "7";
function Yo(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`;
}
function Xo(t) {
  return `${Yo(t)}${t.projectId}/envelope/`;
}
function Jo(t, e) {
  const n = { sentry_version: zo };
  return (
    t.publicKey && (n.sentry_key = t.publicKey),
    e && (n.sentry_client = `${e.name}/${e.version}`),
    new URLSearchParams(n).toString()
  );
}
function Ko(t, e, n) {
  return e || `${Xo(t)}?${Jo(t, n)}`;
}
const Sr = [];
function Zo(t) {
  const e = {};
  return (
    t.forEach((n) => {
      const { name: r } = n,
        s = e[r];
      (s && !s.isDefaultInstance && n.isDefaultInstance) || (e[r] = n);
    }),
    Object.values(e)
  );
}
function Qo(t) {
  const e = t.defaultIntegrations || [],
    n = t.integrations;
  e.forEach((s) => {
    s.isDefaultInstance = !0;
  });
  let r;
  if (Array.isArray(n)) r = [...e, ...n];
  else if (typeof n == "function") {
    const s = n(e);
    r = Array.isArray(s) ? s : [s];
  } else r = e;
  return Zo(r);
}
function ei(t, e) {
  const n = {};
  return (
    e.forEach((r) => {
      r && _s(t, r, n);
    }),
    n
  );
}
function yr(t, e) {
  for (const n of e) n != null && n.afterAllSetup && n.afterAllSetup(t);
}
function _s(t, e, n) {
  if (n[e.name]) {
    _ &&
      g.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (
    ((n[e.name] = e),
    Sr.indexOf(e.name) === -1 &&
      typeof e.setupOnce == "function" &&
      (e.setupOnce(), Sr.push(e.name)),
    e.setup && typeof e.setup == "function" && e.setup(t),
    typeof e.preprocessEvent == "function")
  ) {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, a) => r(s, a, t));
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e),
      s = Object.assign((a, o) => r(a, o, t), { id: e.name });
    t.addEventProcessor(s);
  }
  _ && g.log(`Integration installed: ${e.name}`);
}
function ti(t) {
  return [
    {
      type: "log",
      item_count: t.length,
      content_type: "application/vnd.sentry.items.log+json",
    },
    { items: t },
  ];
}
function ni(t, e, n, r) {
  const s = {};
  return (
    e != null &&
      e.sdk &&
      (s.sdk = { name: e.sdk.name, version: e.sdk.version }),
    n && r && (s.dsn = ze(r)),
    Me(s, [ti(t)])
  );
}
function hs(t, e) {
  const n = e ?? ri(t) ?? [];
  if (n.length === 0) return;
  const r = t.getOptions(),
    s = ni(n, r._metadata, r.tunnel, t.getDsn());
  Es().set(t, []), t.emit("flushLogs"), t.sendEnvelope(s);
}
function ri(t) {
  return Es().get(t);
}
function Es() {
  return Jr("clientToLogBufferMap", () => new WeakMap());
}
function si(t) {
  return [
    {
      type: "trace_metric",
      item_count: t.length,
      content_type: "application/vnd.sentry.items.trace-metric+json",
    },
    { items: t },
  ];
}
function ai(t, e, n, r) {
  const s = {};
  return (
    e != null &&
      e.sdk &&
      (s.sdk = { name: e.sdk.name, version: e.sdk.version }),
    n && r && (s.dsn = ze(r)),
    Me(s, [si(t)])
  );
}
function Ss(t, e) {
  const n = e ?? oi(t) ?? [];
  if (n.length === 0) return;
  const r = t.getOptions(),
    s = ai(n, r._metadata, r.tunnel, t.getDsn());
  ys().set(t, []), t.emit("flushMetrics"), t.sendEnvelope(s);
}
function oi(t) {
  return ys().get(t);
}
function ys() {
  return Jr("clientToMetricBufferMap", () => new WeakMap());
}
function ii(t, e, n) {
  const r = [
    { type: "client_report" },
    { timestamp: Gt(), discarded_events: t },
  ];
  return Me(e ? { dsn: e } : {}, [r]);
}
function Ts(t) {
  const e = [];
  t.message && e.push(t.message);
  try {
    const n = t.exception.values[t.exception.values.length - 1];
    n != null &&
      n.value &&
      (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`));
  } catch {}
  return e;
}
function ci(t) {
  var i;
  const {
    trace_id: e,
    parent_span_id: n,
    span_id: r,
    status: s,
    origin: a,
    data: o,
    op: c,
  } = ((i = t.contexts) == null ? void 0 : i.trace) ?? {};
  return {
    data: o ?? {},
    description: t.transaction,
    op: c,
    parent_span_id: n,
    span_id: r ?? "",
    start_timestamp: t.start_timestamp ?? 0,
    status: s,
    timestamp: t.timestamp,
    trace_id: e ?? "",
    origin: a,
    profile_id: o == null ? void 0 : o[Ln],
    exclusive_time: o == null ? void 0 : o[Ye],
    measurements: t.measurements,
    is_segment: !0,
  };
}
function ui(t) {
  return {
    type: "transaction",
    timestamp: t.timestamp,
    start_timestamp: t.start_timestamp,
    transaction: t.description,
    contexts: {
      trace: {
        trace_id: t.trace_id,
        span_id: t.span_id,
        parent_span_id: t.parent_span_id,
        op: t.op,
        status: t.status,
        origin: t.origin,
        data: {
          ...t.data,
          ...(t.profile_id && { [Ln]: t.profile_id }),
          ...(t.exclusive_time && { [Ye]: t.exclusive_time }),
        },
      },
    },
    measurements: t.measurements,
  };
}
const Tr = "Not capturing exception because it's already been captured.",
  br = "Discarded session because of missing or non-string release",
  bs = Symbol.for("SentryInternalError"),
  vs = Symbol.for("SentryDoNotSendEventError"),
  di = 5e3;
function Lt(t) {
  return { message: t, [bs]: !0 };
}
function sn(t) {
  return { message: t, [vs]: !0 };
}
function vr(t) {
  return !!t && typeof t == "object" && bs in t;
}
function Ir(t) {
  return !!t && typeof t == "object" && vs in t;
}
function Rr(t, e, n, r, s) {
  let a = 0,
    o;
  t.on(n, () => {
    (a = 0), clearTimeout(o);
  }),
    t.on(e, (c) => {
      (a += r(c)),
        a >= 8e5
          ? s(t)
          : (clearTimeout(o),
            (o = setTimeout(() => {
              s(t);
            }, di)));
    }),
    t.on("flush", () => {
      s(t);
    });
}
class fi {
  constructor(e) {
    var r;
    if (
      ((this._options = e),
      (this._integrations = {}),
      (this._numProcessing = 0),
      (this._outcomes = {}),
      (this._hooks = {}),
      (this._eventProcessors = []),
      e.dsn
        ? (this._dsn = va(e.dsn))
        : _ && g.warn("No DSN provided, client will not send events."),
      this._dsn)
    ) {
      const s = Ko(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: s,
      });
    }
    this._options.enableLogs &&
      Rr(this, "afterCaptureLog", "flushLogs", gi, hs),
      (this._options.enableMetrics ??
        ((r = this._options._experiments) == null ? void 0 : r.enableMetrics) ??
        !0) &&
        Rr(this, "afterCaptureMetric", "flushMetrics", mi, Ss);
  }
  captureException(e, n, r) {
    const s = At();
    if (er(e)) return _ && g.log(Tr), s;
    const a = { event_id: s, ...n };
    return (
      this._process(
        this.eventFromException(e, a).then((o) => this._captureEvent(o, a, r))
      ),
      a.event_id
    );
  }
  captureMessage(e, n, r, s) {
    const a = { event_id: At(), ...r },
      o = Qr(e) ? e : String(e),
      c = je(e)
        ? this.eventFromMessage(o, n, a)
        : this.eventFromException(e, a);
    return (
      this._process(c.then((i) => this._captureEvent(i, a, s))), a.event_id
    );
  }
  captureEvent(e, n, r) {
    const s = At();
    if (n != null && n.originalException && er(n.originalException))
      return _ && g.log(Tr), s;
    const a = { event_id: s, ...n },
      o = e.sdkProcessingMetadata || {},
      c = o.capturedSpanScope,
      i = o.capturedSpanIsolationScope;
    return this._process(this._captureEvent(e, a, c || r, i)), a.event_id;
  }
  captureSession(e) {
    this.sendSession(e), tr(e, { init: !1 });
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  async flush(e) {
    const n = this._transport;
    if (!n) return !0;
    this.emit("flush");
    const r = await this._isClientDoneProcessing(e),
      s = await n.flush(e);
    return r && s;
  }
  async close(e) {
    const n = await this.flush(e);
    return (this.getOptions().enabled = !1), this.emit("close"), n;
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  init() {
    (this._isEnabled() ||
      this._options.integrations.some(({ name: e }) =>
        e.startsWith("Spotlight")
      )) &&
      this._setupIntegrations();
  }
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  addIntegration(e) {
    const n = this._integrations[e.name];
    _s(this, e, this._integrations), n || yr(this, [e]);
  }
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = ko(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const s of n.attachments || []) r = yo(r, Io(s));
    this.sendEnvelope(r).then((s) => this.emit("afterSendEvent", e, s));
  }
  sendSession(e) {
    const { release: n, environment: r = Ia } = this._options;
    if ("aggregates" in e) {
      const a = e.attrs || {};
      if (!a.release && !n) {
        _ && g.warn(br);
        return;
      }
      (a.release = a.release || n),
        (a.environment = a.environment || r),
        (e.attrs = a);
    } else {
      if (!e.release && !n) {
        _ && g.warn(br);
        return;
      }
      (e.release = e.release || n), (e.environment = e.environment || r);
    }
    this.emit("beforeSendSession", e);
    const s = Po(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(s);
  }
  recordDroppedEvent(e, n, r = 1) {
    if (this._options.sendClientReports) {
      const s = `${e}:${n}`;
      _ && g.log(`Recording outcome: "${s}"${r > 1 ? ` (${r} times)` : ""}`),
        (this._outcomes[s] = (this._outcomes[s] || 0) + r);
    }
  }
  on(e, n) {
    const r = (this._hooks[e] = this._hooks[e] || new Set()),
      s = (...a) => n(...a);
    return (
      r.add(s),
      () => {
        r.delete(s);
      }
    );
  }
  emit(e, ...n) {
    const r = this._hooks[e];
    r && r.forEach((s) => s(...n));
  }
  async sendEnvelope(e) {
    if ((this.emit("beforeEnvelope", e), this._isEnabled() && this._transport))
      try {
        return await this._transport.send(e);
      } catch (n) {
        return _ && g.error("Error while sending envelope:", n), {};
      }
    return _ && g.error("Transport disabled"), {};
  }
  _setupIntegrations() {
    const { integrations: e } = this._options;
    (this._integrations = ei(this, e)), yr(this, e);
  }
  _updateSessionFromEvent(e, n) {
    var i, u;
    let r = n.level === "fatal",
      s = !1;
    const a = (i = n.exception) == null ? void 0 : i.values;
    if (a) {
      (s = !0), (r = !1);
      for (const f of a)
        if (((u = f.mechanism) == null ? void 0 : u.handled) === !1) {
          r = !0;
          break;
        }
    }
    const o = e.status === "ok";
    ((o && e.errors === 0) || (o && r)) &&
      (tr(e, {
        ...(r && { status: "crashed" }),
        errors: e.errors || Number(s || r),
      }),
      this.captureSession(e));
  }
  async _isClientDoneProcessing(e) {
    let n = 0;
    for (; !e || n < e; ) {
      if ((await new Promise((r) => setTimeout(r, 1)), !this._numProcessing))
        return !0;
      n++;
    }
    return !1;
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  _prepareEvent(e, n, r, s) {
    const a = this.getOptions(),
      o = Object.keys(this._integrations);
    return (
      !n.integrations && o != null && o.length && (n.integrations = o),
      this.emit("preprocessEvent", e, n),
      e.type || s.setLastEventId(e.event_id || n.event_id),
      Ra(a, e, n, r, this, s).then((c) => {
        if (c === null) return c;
        this.emit("postprocessEvent", c, n),
          (c.contexts = { trace: wa(r), ...c.contexts });
        const i = Kr(this, r);
        return (
          (c.sdkProcessingMetadata = {
            dynamicSamplingContext: i,
            ...c.sdkProcessingMetadata,
          }),
          c
        );
      })
    );
  }
  _captureEvent(e, n = {}, r = L(), s = Wt()) {
    return (
      _ &&
        hn(e) &&
        g.log(`Captured error event \`${Ts(e)[0] || "<unknown>"}\``),
      this._processEvent(e, n, r, s).then(
        (a) => a.event_id,
        (a) => {
          _ &&
            (Ir(a) ? g.log(a.message) : vr(a) ? g.warn(a.message) : g.warn(a));
        }
      )
    );
  }
  _processEvent(e, n, r, s) {
    const a = this.getOptions(),
      { sampleRate: o } = a,
      c = Is(e),
      i = hn(e),
      u = e.type || "error",
      f = `before send for type \`${u}\``,
      d = typeof o > "u" ? void 0 : Cn(o);
    if (i && typeof d == "number" && Math.random() > d)
      return (
        this.recordDroppedEvent("sample_rate", "error"),
        Zr(
          sn(
            `Discarding event because it's not included in the random sample (sampling rate = ${o})`
          )
        )
      );
    const l = u === "replay_event" ? "replay" : u;
    return this._prepareEvent(e, n, r, s)
      .then((p) => {
        if (p === null)
          throw (
            (this.recordDroppedEvent("event_processor", l),
            sn("An event processor returned `null`, will not send event."))
          );
        if (n.data && n.data.__sentry__ === !0) return p;
        const E = pi(this, a, p, n);
        return li(E, f);
      })
      .then((p) => {
        var S;
        if (p === null) {
          if ((this.recordDroppedEvent("before_send", l), c)) {
            const N = 1 + (e.spans || []).length;
            this.recordDroppedEvent("before_send", "span", N);
          }
          throw sn(`${f} returned \`null\`, will not send event.`);
        }
        const m = r.getSession() || s.getSession();
        if ((i && m && this._updateSessionFromEvent(m, p), c)) {
          const R =
              ((S = p.sdkProcessingMetadata) == null
                ? void 0
                : S.spanCountBeforeProcessing) || 0,
            N = p.spans ? p.spans.length : 0,
            B = R - N;
          B > 0 && this.recordDroppedEvent("before_send", "span", B);
        }
        const E = p.transaction_info;
        if (c && E && p.transaction !== e.transaction) {
          const R = "custom";
          p.transaction_info = { ...E, source: R };
        }
        return this.sendEvent(p, n), p;
      })
      .then(null, (p) => {
        throw Ir(p) || vr(p)
          ? p
          : (this.captureException(p, {
              mechanism: { handled: !1, type: "internal" },
              data: { __sentry__: !0 },
              originalException: p,
            }),
            Lt(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`));
      });
  }
  _process(e) {
    this._numProcessing++,
      e.then(
        (n) => (this._numProcessing--, n),
        (n) => (this._numProcessing--, n)
      );
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return (
      (this._outcomes = {}),
      Object.entries(e).map(([n, r]) => {
        const [s, a] = n.split(":");
        return { reason: s, category: a, quantity: r };
      })
    );
  }
  _flushOutcomes() {
    _ && g.log("Flushing outcomes...");
    const e = this._clearOutcomes();
    if (e.length === 0) {
      _ && g.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      _ && g.log("No dsn provided, will not send outcomes");
      return;
    }
    _ && g.log("Sending outcomes:", e);
    const n = ii(e, this._options.tunnel && ze(this._dsn));
    this.sendEnvelope(n);
  }
}
function li(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (Wr(t))
    return t.then(
      (r) => {
        if (!mn(r) && r !== null) throw Lt(n);
        return r;
      },
      (r) => {
        throw Lt(`${e} rejected with ${r}`);
      }
    );
  if (!mn(t) && t !== null) throw Lt(n);
  return t;
}
function pi(t, e, n, r) {
  const {
    beforeSend: s,
    beforeSendTransaction: a,
    beforeSendSpan: o,
    ignoreSpans: c,
  } = e;
  let i = n;
  if (hn(i) && s) return s(i, r);
  if (Is(i)) {
    if (o || c) {
      const u = ci(i);
      if (c != null && c.length && xt(u, c)) return null;
      if (o) {
        const f = o(u);
        f ? (i = Aa(n, ui(f))) : pn();
      }
      if (i.spans) {
        const f = [],
          d = i.spans;
        for (const p of d) {
          if (c != null && c.length && xt(p, c)) {
            Eo(d, p);
            continue;
          }
          if (o) {
            const m = o(p);
            m ? f.push(m) : (pn(), f.push(p));
          } else f.push(p);
        }
        const l = i.spans.length - f.length;
        l && t.recordDroppedEvent("before_send", "span", l), (i.spans = f);
      }
    }
    if (a) {
      if (i.spans) {
        const u = i.spans.length;
        i.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: u,
        };
      }
      return a(i, r);
    }
  }
  return i;
}
function hn(t) {
  return t.type === void 0;
}
function Is(t) {
  return t.type === "transaction";
}
function mi(t) {
  let e = 0;
  return t.name && (e += t.name.length * 2), (e += 8), e + Rs(t.attributes);
}
function gi(t) {
  let e = 0;
  return t.message && (e += t.message.length * 2), e + Rs(t.attributes);
}
function Rs(t) {
  if (!t) return 0;
  let e = 0;
  return (
    Object.values(t).forEach((n) => {
      Array.isArray(n)
        ? (e += n.length * wr(n[0]))
        : je(n)
        ? (e += wr(n))
        : (e += 100);
    }),
    e
  );
}
function wr(t) {
  return typeof t == "string"
    ? t.length * 2
    : typeof t == "number"
    ? 8
    : typeof t == "boolean"
    ? 4
    : 0;
}
function _i(t, e) {
  e.debug === !0 &&
    (_
      ? g.enable()
      : zt(() => {
          console.warn(
            "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."
          );
        })),
    L().update(e.initialScope);
  const r = new t(e);
  return hi(r), r.init(), r;
}
function hi(t) {
  L().setClient(t);
}
const ws = Symbol.for("SentryBufferFullError");
function As(t = 100) {
  const e = new Set();
  function n() {
    return e.size < t;
  }
  function r(o) {
    e.delete(o);
  }
  function s(o) {
    if (!n()) return Zr(ws);
    const c = o();
    return (
      e.add(c),
      c.then(
        () => r(c),
        () => r(c)
      ),
      c
    );
  }
  function a(o) {
    if (!e.size) return On(!0);
    const c = Promise.allSettled(Array.from(e)).then(() => !0);
    if (!o) return c;
    const i = [c, new Promise((u) => setTimeout(() => u(!1), o))];
    return Promise.race(i);
  }
  return {
    get $() {
      return Array.from(e);
    },
    add: s,
    drain: a,
  };
}
const Ei = 60 * 1e3;
function Si(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? Ei : r - e;
}
function yi(t, e) {
  return t[e] || t.all || 0;
}
function Ti(t, e, n = Date.now()) {
  return yi(t, e) > n;
}
function bi(t, { statusCode: e, headers: n }, r = Date.now()) {
  const s = { ...t },
    a = n == null ? void 0 : n["x-sentry-rate-limits"],
    o = n == null ? void 0 : n["retry-after"];
  if (a)
    for (const c of a.trim().split(",")) {
      const [i, u, , , f] = c.split(":", 5),
        d = parseInt(i, 10),
        l = (isNaN(d) ? 60 : d) * 1e3;
      if (!u) s.all = r + l;
      else
        for (const p of u.split(";"))
          p === "metric_bucket"
            ? (!f || f.split(";").includes("custom")) && (s[p] = r + l)
            : (s[p] = r + l);
    }
  else o ? (s.all = r + Si(o, r)) : e === 429 && (s.all = r + 60 * 1e3);
  return s;
}
const vi = 64;
function Ii(t, e, n = As(t.bufferSize || vi)) {
  let r = {};
  const s = (o) => n.drain(o);
  function a(o) {
    const c = [];
    if (
      (lr(o, (d, l) => {
        const p = pr(l);
        Ti(r, p) ? t.recordDroppedEvent("ratelimit_backoff", p) : c.push(d);
      }),
      c.length === 0)
    )
      return Promise.resolve({});
    const i = Me(o[0], c),
      u = (d) => {
        lr(i, (l, p) => {
          t.recordDroppedEvent(d, pr(p));
        });
      },
      f = () =>
        e({ body: To(i) }).then(
          (d) => (
            d.statusCode !== void 0 &&
              (d.statusCode < 200 || d.statusCode >= 300) &&
              _ &&
              g.warn(
                `Sentry responded with status code ${d.statusCode} to sent event.`
              ),
            (r = bi(r, d)),
            d
          ),
          (d) => {
            throw (
              (u("network_error"),
              _ && g.error("Encountered error running transport request:", d),
              d)
            );
          }
        );
    return n.add(f).then(
      (d) => d,
      (d) => {
        if (d === ws)
          return (
            _ && g.error("Skipped sending event because buffer is full."),
            u("queue_overflow"),
            Promise.resolve({})
          );
        throw d;
      }
    );
  }
  return { send: a, flush: s };
}
const Ri = "thismessage:/";
function Ps(t) {
  return "isRelative" in t;
}
function ks(t, e) {
  const n = t.indexOf("://") <= 0 && t.indexOf("//") !== 0,
    r = n ? Ri : void 0;
  try {
    if ("canParse" in URL && !URL.canParse(t, r)) return;
    const s = new URL(t, r);
    return n
      ? { isRelative: n, pathname: s.pathname, search: s.search, hash: s.hash }
      : s;
  } catch {}
}
function wi(t) {
  if (Ps(t)) return t.pathname;
  const e = new URL(t);
  return (
    (e.search = ""),
    (e.hash = ""),
    ["80", "443"].includes(e.port) && (e.port = ""),
    e.password && (e.password = "%filtered%"),
    e.username && (e.username = "%filtered%"),
    e.toString()
  );
}
function Le(t) {
  if (!t) return {};
  const e = t.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
  );
  if (!e) return {};
  const n = e[6] || "",
    r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r,
  };
}
function Ai(t) {
  return t.split(/[?#]/, 1)[0];
}
function Pi(t) {
  var e;
  "aggregates" in t
    ? ((e = t.attrs) == null ? void 0 : e.ip_address) === void 0 &&
      (t.attrs = { ...t.attrs, ip_address: "{{auto}}" })
    : t.ipAddress === void 0 && (t.ipAddress = "{{auto}}");
}
function Hn(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk ||
    (s.sdk = {
      name: `sentry.javascript.${e}`,
      packages: n.map((a) => ({ name: `${r}:@sentry/${a}`, version: nr })),
      version: nr,
    }),
    (t._metadata = s);
}
function Ns(t = {}) {
  const e = t.client || k();
  if (!Pa() || !e) return {};
  const n = Gr(),
    r = zr(n);
  if (r.getTraceData) return r.getTraceData(t);
  const s = t.scope || L(),
    a = t.span || J(),
    o = a ? ka(a) : ki(s),
    c = a ? Ce(a) : Kr(e, s),
    i = Na(c);
  if (!La.test(o))
    return g.warn("Invalid sentry-trace data. Cannot generate trace data"), {};
  const f = { "sentry-trace": o, baggage: i };
  if (t.propagateTraceparent) {
    const d = a ? Ca(a) : Ni(s);
    d && (f.traceparent = d);
  }
  return f;
}
function ki(t) {
  const {
    traceId: e,
    sampled: n,
    propagationSpanId: r,
  } = t.getPropagationContext();
  return Oa(e, r, n);
}
function Ni(t) {
  const {
    traceId: e,
    sampled: n,
    propagationSpanId: r,
  } = t.getPropagationContext();
  return Ma(e, r, n);
}
const Li = 100;
function Oe(t, e) {
  const n = k(),
    r = Wt();
  if (!n) return;
  const { beforeBreadcrumb: s = null, maxBreadcrumbs: a = Li } = n.getOptions();
  if (a <= 0) return;
  const c = { timestamp: Gt(), ...t },
    i = s ? zt(() => s(c, e)) : c;
  i !== null &&
    (n.emit && n.emit("beforeAddBreadcrumb", i, e), r.addBreadcrumb(i, a));
}
let Ar;
const Ci = "FunctionToString",
  Pr = new WeakMap(),
  Oi = () => ({
    name: Ci,
    setupOnce() {
      Ar = Function.prototype.toString;
      try {
        Function.prototype.toString = function (...t) {
          const e = Mn(this),
            n = Pr.has(k()) && e !== void 0 ? e : this;
          return Ar.apply(n, t);
        };
      } catch {}
    },
    setup(t) {
      Pr.set(t, !0);
    },
  }),
  Mi = Oi,
  Di = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    /^Can't find variable: gmo$/,
    /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
    /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
    /^Java exception was raised during method invocation$/,
  ],
  xi = "EventFilters",
  Fi = (t = {}) => {
    let e;
    return {
      name: xi,
      setup(n) {
        const r = n.getOptions();
        e = kr(t, r);
      },
      processEvent(n, r, s) {
        if (!e) {
          const a = s.getOptions();
          e = kr(t, a);
        }
        return Bi(n, e) ? null : n;
      },
    };
  },
  Hi = (t = {}) => ({ ...Fi(t), name: "InboundFilters" });
function kr(t = {}, e = {}) {
  return {
    allowUrls: [...(t.allowUrls || []), ...(e.allowUrls || [])],
    denyUrls: [...(t.denyUrls || []), ...(e.denyUrls || [])],
    ignoreErrors: [
      ...(t.ignoreErrors || []),
      ...(e.ignoreErrors || []),
      ...(t.disableErrorDefaults ? [] : Di),
    ],
    ignoreTransactions: [
      ...(t.ignoreTransactions || []),
      ...(e.ignoreTransactions || []),
    ],
  };
}
function Bi(t, e) {
  if (t.type) {
    if (t.type === "transaction" && Ui(t, e.ignoreTransactions))
      return (
        _ &&
          g.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ne(t)}`),
        !0
      );
  } else {
    if ($i(t, e.ignoreErrors))
      return (
        _ &&
          g.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ne(t)}`),
        !0
      );
    if (Wi(t))
      return (
        _ &&
          g.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Ne(t)}`),
        !0
      );
    if (qi(t, e.denyUrls))
      return (
        _ &&
          g.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ne(t)}.
Url: ${Ft(t)}`),
        !0
      );
    if (!ji(t, e.allowUrls))
      return (
        _ &&
          g.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ne(t)}.
Url: ${Ft(t)}`),
        !0
      );
  }
  return !1;
}
function $i(t, e) {
  return e != null && e.length ? Ts(t).some((n) => ye(n, e)) : !1;
}
function Ui(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = t.transaction;
  return n ? ye(n, e) : !1;
}
function qi(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = Ft(t);
  return n ? ye(n, e) : !1;
}
function ji(t, e) {
  if (!(e != null && e.length)) return !0;
  const n = Ft(t);
  return n ? ye(n, e) : !0;
}
function Vi(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function Ft(t) {
  var e, n;
  try {
    const r = [...(((e = t.exception) == null ? void 0 : e.values) ?? [])]
        .reverse()
        .find((a) => {
          var o, c, i;
          return (
            ((o = a.mechanism) == null ? void 0 : o.parent_id) === void 0 &&
            ((i = (c = a.stacktrace) == null ? void 0 : c.frames) == null
              ? void 0
              : i.length)
          );
        }),
      s = (n = r == null ? void 0 : r.stacktrace) == null ? void 0 : n.frames;
    return s ? Vi(s) : null;
  } catch {
    return _ && g.error(`Cannot extract url for event ${Ne(t)}`), null;
  }
}
function Wi(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) != null && n.length
    ? !t.message &&
        !t.exception.values.some(
          (r) => r.stacktrace || (r.type && r.type !== "Error") || r.value
        )
    : !1;
}
function Gi(t, e, n, r, s, a) {
  var c;
  if (
    !((c = s.exception) != null && c.values) ||
    !a ||
    !Dt(a.originalException, Error)
  )
    return;
  const o =
    s.exception.values.length > 0
      ? s.exception.values[s.exception.values.length - 1]
      : void 0;
  o &&
    (s.exception.values = En(
      t,
      e,
      r,
      a.originalException,
      n,
      s.exception.values,
      o,
      0
    ));
}
function En(t, e, n, r, s, a, o, c) {
  if (a.length >= n + 1) return a;
  let i = [...a];
  if (Dt(r[s], Error)) {
    Nr(o, c);
    const u = t(e, r[s]),
      f = i.length;
    Lr(u, s, f, c), (i = En(t, e, n, r[s], s, [u, ...i], u, f));
  }
  return (
    Array.isArray(r.errors) &&
      r.errors.forEach((u, f) => {
        if (Dt(u, Error)) {
          Nr(o, c);
          const d = t(e, u),
            l = i.length;
          Lr(d, `errors[${f}]`, l, c), (i = En(t, e, n, u, s, [d, ...i], d, l));
        }
      }),
    i
  );
}
function Nr(t, e) {
  t.mechanism = {
    handled: !0,
    type: "auto.core.linked_errors",
    ...t.mechanism,
    ...(t.type === "AggregateError" && { is_exception_group: !0 }),
    exception_id: e,
  };
}
function Lr(t, e, n, r) {
  t.mechanism = {
    handled: !0,
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r,
  };
}
function zi(t) {
  const e = "console";
  Re(e, t), we(e, Yi);
}
function Yi() {
  "console" in x &&
    Da.forEach(function (t) {
      t in x.console &&
        Y(x.console, t, function (e) {
          return (
            (rr[t] = e),
            function (...n) {
              re("console", { args: n, level: t });
              const s = rr[t];
              s == null || s.apply(x.console, n);
            }
          );
        });
    });
}
function Xi(t) {
  return t === "warn"
    ? "warning"
    : ["fatal", "error", "warning", "log", "info", "debug"].includes(t)
    ? t
    : "log";
}
const Ji = "Dedupe",
  Ki = () => {
    let t;
    return {
      name: Ji,
      processEvent(e) {
        if (e.type) return e;
        try {
          if (Qi(e, t))
            return (
              _ &&
                g.warn(
                  "Event dropped due to being a duplicate of previously captured event."
                ),
              null
            );
        } catch {}
        return (t = e);
      },
    };
  },
  Zi = Ki;
function Qi(t, e) {
  return e ? !!(ec(t, e) || tc(t, e)) : !1;
}
function ec(t, e) {
  const n = t.message,
    r = e.message;
  return !(
    (!n && !r) ||
    (n && !r) ||
    (!n && r) ||
    n !== r ||
    !Cs(t, e) ||
    !Ls(t, e)
  );
}
function tc(t, e) {
  const n = Cr(e),
    r = Cr(t);
  return !(
    !n ||
    !r ||
    n.type !== r.type ||
    n.value !== r.value ||
    !Cs(t, e) ||
    !Ls(t, e)
  );
}
function Ls(t, e) {
  let n = sr(t),
    r = sr(e);
  if (!n && !r) return !0;
  if ((n && !r) || (!n && r) || ((n = n), (r = r), r.length !== n.length))
    return !1;
  for (let s = 0; s < r.length; s++) {
    const a = r[s],
      o = n[s];
    if (
      a.filename !== o.filename ||
      a.lineno !== o.lineno ||
      a.colno !== o.colno ||
      a.function !== o.function
    )
      return !1;
  }
  return !0;
}
function Cs(t, e) {
  let n = t.fingerprint,
    r = e.fingerprint;
  if (!n && !r) return !0;
  if ((n && !r) || (!n && r)) return !1;
  (n = n), (r = r);
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function Cr(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) == null
    ? void 0
    : n[0];
}
function nc(t, e, n, r, s) {
  if (!t.fetchData) return;
  const { method: a, url: o } = t.fetchData,
    c = pe() && e(o);
  if (t.endTimestamp && c) {
    const p = t.fetchData.__span;
    if (!p) return;
    const m = r[p];
    m && (ac(m, t), rc(m, t, s), delete r[p]);
    return;
  }
  const { spanOrigin: i = "auto.http.browser", propagateTraceparent: u = !1 } =
      typeof s == "object" ? s : { spanOrigin: s },
    f = !!J(),
    d = c && f ? De(ic(o, a, i)) : new ve();
  if (
    ((t.fetchData.__span = d.spanContext().spanId),
    (r[d.spanContext().spanId] = d),
    n(t.fetchData.url))
  ) {
    const p = t.args[0],
      m = t.args[1] || {},
      E = sc(p, m, pe() && f ? d : void 0, u);
    E && ((t.args[1] = m), (m.headers = E));
  }
  const l = k();
  if (l) {
    const p = {
      input: t.args,
      response: t.response,
      startTimestamp: t.startTimestamp,
      endTimestamp: t.endTimestamp,
    };
    l.emit("beforeOutgoingRequestSpan", d, p);
  }
  return d;
}
function rc(t, e, n) {
  var s;
  const r = typeof n == "object" && n !== null ? n.onRequestSpanEnd : void 0;
  r == null ||
    r(t, {
      headers: (s = e.response) == null ? void 0 : s.headers,
      error: e.error,
    });
}
function sc(t, e, n, r) {
  const s = Ns({ span: n, propagateTraceparent: r }),
    a = s["sentry-trace"],
    o = s.baggage,
    c = s.traceparent;
  if (!a) return;
  const i = e.headers || (ts(t) ? t.headers : void 0);
  if (i)
    if (oc(i)) {
      const u = new Headers(i);
      if (
        (u.get("sentry-trace") || u.set("sentry-trace", a),
        r && c && !u.get("traceparent") && u.set("traceparent", c),
        o)
      ) {
        const f = u.get("baggage");
        f ? yt(f) || u.set("baggage", `${f},${o}`) : u.set("baggage", o);
      }
      return u;
    } else if (Array.isArray(i)) {
      const u = [...i];
      i.find((d) => d[0] === "sentry-trace") || u.push(["sentry-trace", a]),
        r &&
          c &&
          !i.find((d) => d[0] === "traceparent") &&
          u.push(["traceparent", c]);
      const f = i.find((d) => d[0] === "baggage" && yt(d[1]));
      return o && !f && u.push(["baggage", o]), u;
    } else {
      const u = "sentry-trace" in i ? i["sentry-trace"] : void 0,
        f = "traceparent" in i ? i.traceparent : void 0,
        d = "baggage" in i ? i.baggage : void 0,
        l = d ? (Array.isArray(d) ? [...d] : [d]) : [],
        p = d && (Array.isArray(d) ? d.find((E) => yt(E)) : yt(d));
      o && !p && l.push(o);
      const m = {
        ...i,
        "sentry-trace": u ?? a,
        baggage: l.length > 0 ? l.join(",") : void 0,
      };
      return r && c && !f && (m.traceparent = c), m;
    }
  else return { ...s };
}
function ac(t, e) {
  var n, r;
  if (e.response) {
    es(t, e.response.status);
    const s =
      (r = (n = e.response) == null ? void 0 : n.headers) == null
        ? void 0
        : r.get("content-length");
    if (s) {
      const a = parseInt(s);
      a > 0 && t.setAttribute("http.response_content_length", a);
    }
  } else e.error && t.setStatus({ code: qe, message: "internal_error" });
  t.end();
}
function yt(t) {
  return t.split(",").some((e) => e.trim().startsWith(xa));
}
function oc(t) {
  return typeof Headers < "u" && Dt(t, Headers);
}
function ic(t, e, n) {
  const r = ks(t);
  return { name: r ? `${e} ${wi(r)}` : e, attributes: cc(t, r, e, n) };
}
function cc(t, e, n, r) {
  const s = {
    url: t,
    type: "fetch",
    "http.method": n,
    [O]: r,
    [be]: "http.client",
  };
  return (
    e &&
      (Ps(e) || ((s["http.url"] = e.href), (s["server.address"] = e.host)),
      e.search && (s["http.query"] = e.search),
      e.hash && (s["http.fragment"] = e.hash)),
    s
  );
}
function Os(t) {
  if (t !== void 0)
    return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0;
}
const ct = x;
function uc() {
  return "history" in ct && !!ct.history;
}
function dc() {
  if (!("fetch" in ct)) return !1;
  try {
    return (
      new Headers(), new Request("http://www.example.com"), new Response(), !0
    );
  } catch {
    return !1;
  }
}
function Sn(t) {
  return (
    t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
  );
}
function fc() {
  var n;
  if (typeof EdgeRuntime == "string") return !0;
  if (!dc()) return !1;
  if (Sn(ct.fetch)) return !0;
  let t = !1;
  const e = ct.document;
  if (e && typeof e.createElement == "function")
    try {
      const r = e.createElement("iframe");
      (r.hidden = !0),
        e.head.appendChild(r),
        (n = r.contentWindow) != null &&
          n.fetch &&
          (t = Sn(r.contentWindow.fetch)),
        e.head.removeChild(r);
    } catch (r) {
      _ &&
        g.warn(
          "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
          r
        );
    }
  return t;
}
function Ms(t, e) {
  const n = "fetch";
  Re(n, t), we(n, () => Ds(void 0, e));
}
function lc(t) {
  const e = "fetch-body-resolved";
  Re(e, t), we(e, () => Ds(mc));
}
function Ds(t, e = !1) {
  (e && !fc()) ||
    Y(x, "fetch", function (n) {
      return function (...r) {
        const s = new Error(),
          { method: a, url: o } = gc(r),
          c = {
            args: r,
            fetchData: { method: a, url: o },
            startTimestamp: q() * 1e3,
            virtualError: s,
            headers: _c(r),
          };
        return (
          t || re("fetch", { ...c }),
          n.apply(x, r).then(
            async (i) => (
              t
                ? t(i)
                : re("fetch", { ...c, endTimestamp: q() * 1e3, response: i }),
              i
            ),
            (i) => {
              if (
                (re("fetch", { ...c, endTimestamp: q() * 1e3, error: i }),
                ns(i) &&
                  i.stack === void 0 &&
                  ((i.stack = s.stack), ot(i, "framesToPop", 1)),
                i instanceof TypeError &&
                  (i.message === "Failed to fetch" ||
                    i.message === "Load failed" ||
                    i.message ===
                      "NetworkError when attempting to fetch resource."))
              )
                try {
                  const u = new URL(c.fetchData.url);
                  i.message = `${i.message} (${u.host})`;
                } catch {}
              throw i;
            }
          )
        );
      };
    });
}
async function pc(t, e) {
  if (t != null && t.body) {
    const n = t.body,
      r = n.getReader(),
      s = setTimeout(() => {
        n.cancel().then(null, () => {});
      }, 90 * 1e3);
    let a = !0;
    for (; a; ) {
      let o;
      try {
        o = setTimeout(() => {
          n.cancel().then(null, () => {});
        }, 5e3);
        const { done: c } = await r.read();
        clearTimeout(o), c && (e(), (a = !1));
      } catch {
        a = !1;
      } finally {
        clearTimeout(o);
      }
    }
    clearTimeout(s), r.releaseLock(), n.cancel().then(null, () => {});
  }
}
function mc(t) {
  let e;
  try {
    e = t.clone();
  } catch {
    return;
  }
  pc(e, () => {
    re("fetch-body-resolved", { endTimestamp: q() * 1e3, response: t });
  });
}
function yn(t, e) {
  return !!t && typeof t == "object" && !!t[e];
}
function Or(t) {
  return typeof t == "string"
    ? t
    : t
    ? yn(t, "url")
      ? t.url
      : t.toString
      ? t.toString()
      : ""
    : "";
}
function gc(t) {
  if (t.length === 0) return { method: "GET", url: "" };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: Or(n),
      method: yn(r, "method") ? String(r.method).toUpperCase() : "GET",
    };
  }
  const e = t[0];
  return {
    url: Or(e),
    method: yn(e, "method") ? String(e.method).toUpperCase() : "GET",
  };
}
function _c(t) {
  const [e, n] = t;
  try {
    if (typeof n == "object" && n !== null && "headers" in n && n.headers)
      return new Headers(n.headers);
    if (ts(e)) return new Headers(e.headers);
  } catch {}
}
function hc() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function Ec() {
  return "npm";
}
function Sc() {
  return (
    !hc() &&
    Object.prototype.toString.call(typeof process < "u" ? process : 0) ===
      "[object process]"
  );
}
function yc() {
  return typeof window < "u" && (!Sc() || Tc());
}
function Tc() {
  const t = x.process;
  return (t == null ? void 0 : t.type) === "renderer";
}
const T = x;
let Tn = 0;
function xs() {
  return Tn > 0;
}
function bc() {
  Tn++,
    setTimeout(() => {
      Tn--;
    });
}
function We(t, e = {}) {
  function n(s) {
    return typeof s == "function";
  }
  if (!n(t)) return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s) return typeof s == "function" ? s : t;
    if (Mn(t)) return t;
  } catch {
    return t;
  }
  const r = function (...s) {
    try {
      const a = s.map((o) => We(o, e));
      return t.apply(this, a);
    } catch (a) {
      throw (
        (bc(),
        jt((o) => {
          o.addEventProcessor(
            (c) => (
              e.mechanism && (gn(c, void 0), it(c, e.mechanism)),
              (c.extra = { ...c.extra, arguments: s }),
              c
            )
          ),
            rs(a);
        }),
        a)
      );
    }
  };
  try {
    for (const s in t)
      Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s]);
  } catch {}
  Fa(r, t), ot(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable &&
      Object.defineProperty(r, "name", {
        get() {
          return t.name;
        },
      });
  } catch {}
  return r;
}
function Bn() {
  const t = lt(),
    { referrer: e } = T.document || {},
    { userAgent: n } = T.navigator || {},
    r = { ...(e && { Referer: e }), ...(n && { "User-Agent": n }) };
  return { url: t, headers: r };
}
function $n(t, e) {
  const n = Un(t, e),
    r = { type: Ac(e), value: Pc(e) };
  return (
    n.length && (r.stacktrace = { frames: n }),
    r.type === void 0 &&
      r.value === "" &&
      (r.value = "Unrecoverable error caught"),
    r
  );
}
function vc(t, e, n, r) {
  const s = k(),
    a = s == null ? void 0 : s.getOptions().normalizeDepth,
    o = Oc(e),
    c = { __serialized__: Ba(e, a) };
  if (o) return { exception: { values: [$n(t, o)] }, extra: c };
  const i = {
    exception: {
      values: [
        {
          type: Dn(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
          value: Lc(e, { isUnhandledRejection: r }),
        },
      ],
    },
    extra: c,
  };
  if (n) {
    const u = Un(t, n);
    u.length && (i.exception.values[0].stacktrace = { frames: u });
  }
  return i;
}
function an(t, e) {
  return { exception: { values: [$n(t, e)] } };
}
function Un(t, e) {
  const n = e.stacktrace || e.stack || "",
    r = Rc(e),
    s = wc(e);
  try {
    return t(n, r, s);
  } catch {}
  return [];
}
const Ic = /Minified React error #\d+;/i;
function Rc(t) {
  return t && Ic.test(t.message) ? 1 : 0;
}
function wc(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0;
}
function Fs(t) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u"
    ? t instanceof WebAssembly.Exception
    : !1;
}
function Ac(t) {
  const e = t == null ? void 0 : t.name;
  return !e && Fs(t)
    ? t.message && Array.isArray(t.message) && t.message.length == 2
      ? t.message[0]
      : "WebAssembly.Exception"
    : e;
}
function Pc(t) {
  const e = t == null ? void 0 : t.message;
  return Fs(t)
    ? Array.isArray(t.message) && t.message.length == 2
      ? t.message[1]
      : "wasm exception"
    : e
    ? e.error && typeof e.error.message == "string"
      ? e.error.message
      : e
    : "No error message";
}
function kc(t, e, n, r) {
  const s = (n == null ? void 0 : n.syntheticException) || void 0,
    a = qn(t, e, s, r);
  return (
    it(a),
    (a.level = "error"),
    n != null && n.event_id && (a.event_id = n.event_id),
    On(a)
  );
}
function Nc(t, e, n = "info", r, s) {
  const a = (r == null ? void 0 : r.syntheticException) || void 0,
    o = bn(t, e, a, s);
  return (
    (o.level = n), r != null && r.event_id && (o.event_id = r.event_id), On(o)
  );
}
function qn(t, e, n, r, s) {
  let a;
  if (ss(e) && e.error) return an(t, e.error);
  if (ar(e) || Ha(e)) {
    const o = e;
    if ("stack" in e) a = an(t, e);
    else {
      const c = o.name || (ar(o) ? "DOMError" : "DOMException"),
        i = o.message ? `${c}: ${o.message}` : c;
      (a = bn(t, i, n, r)), gn(a, i);
    }
    return (
      "code" in o && (a.tags = { ...a.tags, "DOMException.code": `${o.code}` }),
      a
    );
  }
  return ns(e)
    ? an(t, e)
    : mn(e) || Dn(e)
    ? ((a = vc(t, e, n, s)), it(a, { synthetic: !0 }), a)
    : ((a = bn(t, e, n, r)), gn(a, `${e}`), it(a, { synthetic: !0 }), a);
}
function bn(t, e, n, r) {
  const s = {};
  if (r && n) {
    const a = Un(t, n);
    a.length &&
      (s.exception = { values: [{ value: e, stacktrace: { frames: a } }] }),
      it(s, { synthetic: !0 });
  }
  if (Qr(e)) {
    const { __sentry_template_string__: a, __sentry_template_values__: o } = e;
    return (s.logentry = { message: a, params: o }), s;
  }
  return (s.message = e), s;
}
function Lc(t, { isUnhandledRejection: e }) {
  const n = $a(t),
    r = e ? "promise rejection" : "exception";
  return ss(t)
    ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\``
    : Dn(t)
    ? `Event \`${Cc(t)}\` (type=${t.type}) captured as ${r}`
    : `Object captured as ${r} with keys: ${n}`;
}
function Cc(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0;
  } catch {}
}
function Oc(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error) return n;
    }
}
class Mc extends fi {
  constructor(e) {
    var f;
    const n = Dc(e),
      r = T.SENTRY_SDK_SOURCE || Ec();
    Hn(n, "browser", ["browser"], r),
      (f = n._metadata) != null &&
        f.sdk &&
        (n._metadata.sdk.settings = {
          infer_ip: n.sendDefaultPii ? "auto" : "never",
          ...n._metadata.sdk.settings,
        }),
      super(n);
    const {
        sendDefaultPii: s,
        sendClientReports: a,
        enableLogs: o,
        _experiments: c,
        enableMetrics: i,
      } = this._options,
      u = i ?? (c == null ? void 0 : c.enableMetrics) ?? !0;
    T.document &&
      (a || o || u) &&
      T.document.addEventListener("visibilitychange", () => {
        T.document.visibilityState === "hidden" &&
          (a && this._flushOutcomes(), o && hs(this), u && Ss(this));
      }),
      s && this.on("beforeSendSession", Pi);
  }
  eventFromException(e, n) {
    return kc(this._options.stackParser, e, n, this._options.attachStacktrace);
  }
  eventFromMessage(e, n = "info", r) {
    return Nc(
      this._options.stackParser,
      e,
      n,
      r,
      this._options.attachStacktrace
    );
  }
  _prepareEvent(e, n, r, s) {
    return (
      (e.platform = e.platform || "javascript"), super._prepareEvent(e, n, r, s)
    );
  }
}
function Dc(t) {
  var e;
  return {
    release:
      typeof __SENTRY_RELEASE__ == "string"
        ? __SENTRY_RELEASE__
        : (e = T.SENTRY_RELEASE) == null
        ? void 0
        : e.id,
    sendClientReports: !0,
    parentSpanIsAlwaysRootSpan: !0,
    ...t,
  };
}
const pt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  h = x,
  xc = (t, e) => (t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good"),
  mt = (t, e, n, r) => {
    let s, a;
    return (o) => {
      e.value >= 0 &&
        (o || r) &&
        ((a = e.value - (s ?? 0)),
        (a || s === void 0) &&
          ((s = e.value), (e.delta = a), (e.rating = xc(e.value, n)), t(e)));
    };
  },
  Fc = () =>
    `v5-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`,
  gt = (t = !0) => {
    var n, r;
    const e =
      (r = (n = h.performance) == null ? void 0 : n.getEntriesByType) == null
        ? void 0
        : r.call(n, "navigation")[0];
    if (!t || (e && e.responseStart > 0 && e.responseStart < performance.now()))
      return e;
  },
  Xe = () => {
    const t = gt();
    return (t == null ? void 0 : t.activationStart) ?? 0;
  },
  _t = (t, e = -1) => {
    var a, o;
    const n = gt();
    let r = "navigate";
    return (
      n &&
        (((a = h.document) != null && a.prerendering) || Xe() > 0
          ? (r = "prerender")
          : (o = h.document) != null && o.wasDiscarded
          ? (r = "restore")
          : n.type && (r = n.type.replace(/_/g, "-"))),
      {
        name: t,
        value: e,
        rating: "good",
        delta: 0,
        entries: [],
        id: Fc(),
        navigationType: r,
      }
    );
  },
  on = new WeakMap();
function jn(t, e) {
  return on.get(t) || on.set(t, new e()), on.get(t);
}
class Ht {
  constructor() {
    Ht.prototype.__init.call(this), Ht.prototype.__init2.call(this);
  }
  __init() {
    this._sessionValue = 0;
  }
  __init2() {
    this._sessionEntries = [];
  }
  _processEntry(e) {
    var s;
    if (e.hadRecentInput) return;
    const n = this._sessionEntries[0],
      r = this._sessionEntries[this._sessionEntries.length - 1];
    this._sessionValue &&
    n &&
    r &&
    e.startTime - r.startTime < 1e3 &&
    e.startTime - n.startTime < 5e3
      ? ((this._sessionValue += e.value), this._sessionEntries.push(e))
      : ((this._sessionValue = e.value), (this._sessionEntries = [e])),
      (s = this._onAfterProcessingUnexpectedShift) == null || s.call(this, e);
  }
}
const Je = (t, e, n = {}) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const r = new PerformanceObserver((s) => {
          Promise.resolve().then(() => {
            e(s.getEntries());
          });
        });
        return r.observe({ type: t, buffered: !0, ...n }), r;
      }
    } catch {}
  },
  Vn = (t) => {
    let e = !1;
    return () => {
      e || (t(), (e = !0));
    };
  };
let rt = -1;
const Hc = () => {
    var t, e;
    return ((t = h.document) == null ? void 0 : t.visibilityState) ===
      "hidden" && !((e = h.document) != null && e.prerendering)
      ? 0
      : 1 / 0;
  },
  Bt = (t) => {
    h.document.visibilityState === "hidden" &&
      rt > -1 &&
      ((rt = t.type === "visibilitychange" ? t.timeStamp : 0), $c());
  },
  Bc = () => {
    addEventListener("visibilitychange", Bt, !0),
      addEventListener("prerenderingchange", Bt, !0);
  },
  $c = () => {
    removeEventListener("visibilitychange", Bt, !0),
      removeEventListener("prerenderingchange", Bt, !0);
  },
  Wn = () => {
    var t;
    if (h.document && rt < 0) {
      const e = Xe();
      (rt =
        (h.document.prerendering ||
        (t = globalThis.performance
          .getEntriesByType("visibility-state")
          .filter((r) => r.name === "hidden" && r.startTime > e)[0]) == null
          ? void 0
          : t.startTime) ?? Hc()),
        Bc();
    }
    return {
      get firstHiddenTime() {
        return rt;
      },
    };
  },
  Xt = (t) => {
    var e;
    (e = h.document) != null && e.prerendering
      ? addEventListener("prerenderingchange", () => t(), !0)
      : t();
  },
  Uc = [1800, 3e3],
  qc = (t, e = {}) => {
    Xt(() => {
      const n = Wn(),
        r = _t("FCP");
      let s;
      const o = Je("paint", (c) => {
        for (const i of c)
          i.name === "first-contentful-paint" &&
            (o.disconnect(),
            i.startTime < n.firstHiddenTime &&
              ((r.value = Math.max(i.startTime - Xe(), 0)),
              r.entries.push(i),
              s(!0)));
      });
      o && (s = mt(t, r, Uc, e.reportAllChanges));
    });
  },
  jc = [0.1, 0.25],
  Vc = (t, e = {}) => {
    qc(
      Vn(() => {
        var c, i;
        const n = _t("CLS", 0);
        let r;
        const s = jn(e, Ht),
          a = (u) => {
            for (const f of u) s._processEntry(f);
            s._sessionValue > n.value &&
              ((n.value = s._sessionValue),
              (n.entries = s._sessionEntries),
              r());
          },
          o = Je("layout-shift", a);
        o &&
          ((r = mt(t, n, jc, e.reportAllChanges)),
          (c = h.document) == null ||
            c.addEventListener("visibilitychange", () => {
              var u;
              ((u = h.document) == null ? void 0 : u.visibilityState) ===
                "hidden" && (a(o.takeRecords()), r(!0));
            }),
          (i = h == null ? void 0 : h.setTimeout) == null || i.call(h, r));
      })
    );
  };
let Hs = 0,
  cn = 1 / 0,
  Tt = 0;
const Wc = (t) => {
  t.forEach((e) => {
    e.interactionId &&
      ((cn = Math.min(cn, e.interactionId)),
      (Tt = Math.max(Tt, e.interactionId)),
      (Hs = Tt ? (Tt - cn) / 7 + 1 : 0));
  });
};
let vn;
const Bs = () => (vn ? Hs : performance.interactionCount || 0),
  Gc = () => {
    "interactionCount" in performance ||
      vn ||
      (vn = Je("event", Wc, {
        type: "event",
        buffered: !0,
        durationThreshold: 0,
      }));
  },
  un = 10;
let $s = 0;
const zc = () => Bs() - $s;
class $t {
  constructor() {
    $t.prototype.__init.call(this), $t.prototype.__init2.call(this);
  }
  __init() {
    this._longestInteractionList = [];
  }
  __init2() {
    this._longestInteractionMap = new Map();
  }
  _resetInteractions() {
    ($s = Bs()),
      (this._longestInteractionList.length = 0),
      this._longestInteractionMap.clear();
  }
  _estimateP98LongestInteraction() {
    const e = Math.min(
      this._longestInteractionList.length - 1,
      Math.floor(zc() / 50)
    );
    return this._longestInteractionList[e];
  }
  _processEntry(e) {
    var s, a;
    if (
      ((s = this._onBeforeProcessingEntry) == null || s.call(this, e),
      !(e.interactionId || e.entryType === "first-input"))
    )
      return;
    const n = this._longestInteractionList.at(-1);
    let r = this._longestInteractionMap.get(e.interactionId);
    if (
      r ||
      this._longestInteractionList.length < un ||
      e.duration > n._latency
    ) {
      if (
        (r
          ? e.duration > r._latency
            ? ((r.entries = [e]), (r._latency = e.duration))
            : e.duration === r._latency &&
              e.startTime === r.entries[0].startTime &&
              r.entries.push(e)
          : ((r = { id: e.interactionId, entries: [e], _latency: e.duration }),
            this._longestInteractionMap.set(r.id, r),
            this._longestInteractionList.push(r)),
        this._longestInteractionList.sort((o, c) => c._latency - o._latency),
        this._longestInteractionList.length > un)
      ) {
        const o = this._longestInteractionList.splice(un);
        for (const c of o) this._longestInteractionMap.delete(c.id);
      }
      (a = this._onAfterProcessingINPCandidate) == null || a.call(this, r);
    }
  }
}
const Gn = (t) => {
    const e = (n) => {
      var r;
      (n.type === "pagehide" ||
        ((r = h.document) == null ? void 0 : r.visibilityState) === "hidden") &&
        t(n);
    };
    h.document &&
      (addEventListener("visibilitychange", e, !0),
      addEventListener("pagehide", e, !0));
  },
  Us = (t) => {
    var n;
    const e = h.requestIdleCallback || h.setTimeout;
    ((n = h.document) == null ? void 0 : n.visibilityState) === "hidden"
      ? t()
      : ((t = Vn(t)), e(t), Gn(t));
  },
  Yc = [200, 500],
  Xc = 40,
  Jc = (t, e = {}) => {
    globalThis.PerformanceEventTiming &&
      "interactionId" in PerformanceEventTiming.prototype &&
      Xt(() => {
        Gc();
        const n = _t("INP");
        let r;
        const s = jn(e, $t),
          a = (c) => {
            Us(() => {
              for (const u of c) s._processEntry(u);
              const i = s._estimateP98LongestInteraction();
              i &&
                i._latency !== n.value &&
                ((n.value = i._latency), (n.entries = i.entries), r());
            });
          },
          o = Je("event", a, { durationThreshold: e.durationThreshold ?? Xc });
        (r = mt(t, n, Yc, e.reportAllChanges)),
          o &&
            (o.observe({ type: "first-input", buffered: !0 }),
            Gn(() => {
              a(o.takeRecords()), r(!0);
            }));
      });
  };
class Kc {
  _processEntry(e) {
    var n;
    (n = this._onBeforeProcessingEntry) == null || n.call(this, e);
  }
}
const Zc = [2500, 4e3],
  Qc = (t, e = {}) => {
    Xt(() => {
      const n = Wn(),
        r = _t("LCP");
      let s;
      const a = jn(e, Kc),
        o = (i) => {
          e.reportAllChanges || (i = i.slice(-1));
          for (const u of i)
            a._processEntry(u),
              u.startTime < n.firstHiddenTime &&
                ((r.value = Math.max(u.startTime - Xe(), 0)),
                (r.entries = [u]),
                s());
        },
        c = Je("largest-contentful-paint", o);
      if (c) {
        s = mt(t, r, Zc, e.reportAllChanges);
        const i = Vn(() => {
          o(c.takeRecords()), c.disconnect(), s(!0);
        });
        for (const u of ["keydown", "click", "visibilitychange"])
          h.document &&
            addEventListener(u, () => Us(i), { capture: !0, once: !0 });
      }
    });
  },
  eu = [800, 1800],
  In = (t) => {
    var e, n;
    (e = h.document) != null && e.prerendering
      ? Xt(() => In(t))
      : ((n = h.document) == null ? void 0 : n.readyState) !== "complete"
      ? addEventListener("load", () => In(t), !0)
      : setTimeout(t);
  },
  tu = (t, e = {}) => {
    const n = _t("TTFB"),
      r = mt(t, n, eu, e.reportAllChanges);
    In(() => {
      const s = gt();
      s &&
        ((n.value = Math.max(s.responseStart - Xe(), 0)),
        (n.entries = [s]),
        r(!0));
    });
  },
  st = {},
  Ut = {};
let qs, js, Vs, Ws;
function Gs(t, e = !1) {
  return Jt("cls", t, su, qs, e);
}
function zs(t, e = !1) {
  return Jt("lcp", t, au, js, e);
}
function nu(t) {
  return Jt("ttfb", t, ou, Vs);
}
function ru(t) {
  return Jt("inp", t, iu, Ws);
}
function Ge(t, e) {
  return Ys(t, e), Ut[t] || (cu(t), (Ut[t] = !0)), Xs(t, e);
}
function ht(t, e) {
  const n = st[t];
  if (n != null && n.length)
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        pt &&
          g.error(
            `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Te(r)}
Error:`,
            s
          );
      }
}
function su() {
  return Vc(
    (t) => {
      ht("cls", { metric: t }), (qs = t);
    },
    { reportAllChanges: !0 }
  );
}
function au() {
  return Qc(
    (t) => {
      ht("lcp", { metric: t }), (js = t);
    },
    { reportAllChanges: !0 }
  );
}
function ou() {
  return tu((t) => {
    ht("ttfb", { metric: t }), (Vs = t);
  });
}
function iu() {
  return Jc((t) => {
    ht("inp", { metric: t }), (Ws = t);
  });
}
function Jt(t, e, n, r, s = !1) {
  Ys(t, e);
  let a;
  return (
    Ut[t] || ((a = n()), (Ut[t] = !0)),
    r && e({ metric: r }),
    Xs(t, e, s ? a : void 0)
  );
}
function cu(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0),
    Je(
      t,
      (n) => {
        ht(t, { entries: n });
      },
      e
    );
}
function Ys(t, e) {
  (st[t] = st[t] || []), st[t].push(e);
}
function Xs(t, e, n) {
  return () => {
    n && n();
    const r = st[t];
    if (!r) return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1);
  };
}
function uu(t) {
  return "duration" in t;
}
function dn(t) {
  return typeof t == "number" && isFinite(t);
}
function Ie(t, e, n, { ...r }) {
  const s = A(t).start_timestamp;
  return (
    s &&
      s > e &&
      typeof t.updateStartTime == "function" &&
      t.updateStartTime(e),
    xn(t, () => {
      const a = De({ startTime: e, ...r });
      return a && a.end(n), a;
    })
  );
}
function zn(t) {
  var S;
  const e = k();
  if (!e) return;
  const { name: n, transaction: r, attributes: s, startTime: a } = t,
    { release: o, environment: c, sendDefaultPii: i } = e.getOptions(),
    u = e.getIntegrationByName("Replay"),
    f = u == null ? void 0 : u.getReplayId(),
    d = L(),
    l = d.getUser(),
    p = l !== void 0 ? l.email || l.id || l.ip_address : void 0;
  let m;
  try {
    m = d.getScopeData().contexts.profile.profile_id;
  } catch {}
  const E = {
    release: o,
    environment: c,
    user: p || void 0,
    profile_id: m || void 0,
    replay_id: f || void 0,
    transaction: r,
    "user_agent.original": (S = h.navigator) == null ? void 0 : S.userAgent,
    "client.address": i ? "{{auto}}" : void 0,
    ...s,
  };
  return De({
    name: n,
    attributes: E,
    startTime: a,
    experimental: { standalone: !0 },
  });
}
function Et() {
  return h.addEventListener && h.performance;
}
function C(t) {
  return t / 1e3;
}
function du(t) {
  let e = "unknown",
    n = "unknown",
    r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break;
    }
    if (!isNaN(Number(s))) {
      (e = r === "h" ? "http" : r), (n = t.split(r)[1]);
      break;
    }
    r += s;
  }
  return r === t && (e = r), { name: e, version: n };
}
function Js(t) {
  try {
    return PerformanceObserver.supportedEntryTypes.includes(t);
  } catch {
    return !1;
  }
}
function Ks(t, e) {
  let n,
    r = !1;
  function s(c) {
    !r && n && e(c, n), (r = !0);
  }
  Gn(() => {
    s("pagehide");
  });
  const a = t.on("beforeStartNavigationSpan", (c, i) => {
      (i != null && i.isRedirect) || (s("navigation"), a(), o());
    }),
    o = t.on("afterStartPageLoadSpan", (c) => {
      (n = c.spanContext().spanId), o();
    });
}
function fu(t) {
  let e = 0,
    n;
  if (!Js("layout-shift")) return;
  const r = Gs(({ metric: s }) => {
    const a = s.entries[s.entries.length - 1];
    a && ((e = s.value), (n = a));
  }, !0);
  Ks(t, (s, a) => {
    lu(e, n, a, s), r();
  });
}
function lu(t, e, n, r) {
  var u;
  pt && g.log(`Sending CLS span (${t})`);
  const s = e ? C((K() || 0) + e.startTime) : q(),
    a = L().getScopeData().transactionName,
    o = e ? fe((u = e.sources[0]) == null ? void 0 : u.node) : "Layout shift",
    c = {
      [O]: "auto.http.browser.cls",
      [be]: "ui.webvital.cls",
      [Ye]: 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r,
    };
  e != null &&
    e.sources &&
    e.sources.forEach((f, d) => {
      c[`cls.source.${d + 1}`] = fe(f.node);
    });
  const i = zn({ name: o, transaction: a, attributes: c, startTime: s });
  i && (i.addEvent("cls", { [dt]: "", [ft]: t }), i.end(s));
}
function pu(t) {
  let e = 0,
    n;
  if (!Js("largest-contentful-paint")) return;
  const r = zs(({ metric: s }) => {
    const a = s.entries[s.entries.length - 1];
    a && ((e = s.value), (n = a));
  }, !0);
  Ks(t, (s, a) => {
    mu(e, n, a, s), r();
  });
}
function mu(t, e, n, r) {
  pt && g.log(`Sending LCP span (${t})`);
  const s = C((K() || 0) + ((e == null ? void 0 : e.startTime) || 0)),
    a = L().getScopeData().transactionName,
    o = e ? fe(e.element) : "Largest contentful paint",
    c = {
      [O]: "auto.http.browser.lcp",
      [be]: "ui.webvital.lcp",
      [Ye]: 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r,
    };
  e &&
    (e.element && (c["lcp.element"] = fe(e.element)),
    e.id && (c["lcp.id"] = e.id),
    e.url && (c["lcp.url"] = e.url),
    e.loadTime != null && (c["lcp.loadTime"] = e.loadTime),
    e.renderTime != null && (c["lcp.renderTime"] = e.renderTime),
    e.size != null && (c["lcp.size"] = e.size));
  const i = zn({ name: o, transaction: a, attributes: c, startTime: s });
  i && (i.addEvent("lcp", { [dt]: "millisecond", [ft]: t }), i.end(s));
}
function ee(t) {
  return t && ((K() || performance.timeOrigin) + t) / 1e3;
}
function Zs(t) {
  var n;
  const e = {};
  if (t.nextHopProtocol != null) {
    const { name: r, version: s } = du(t.nextHopProtocol);
    (e["network.protocol.version"] = s), (e["network.protocol.name"] = r);
  }
  return K() || ((n = Et()) != null && n.timeOrigin)
    ? gu({
        ...e,
        "http.request.redirect_start": ee(t.redirectStart),
        "http.request.redirect_end": ee(t.redirectEnd),
        "http.request.worker_start": ee(t.workerStart),
        "http.request.fetch_start": ee(t.fetchStart),
        "http.request.domain_lookup_start": ee(t.domainLookupStart),
        "http.request.domain_lookup_end": ee(t.domainLookupEnd),
        "http.request.connect_start": ee(t.connectStart),
        "http.request.secure_connection_start": ee(t.secureConnectionStart),
        "http.request.connection_end": ee(t.connectEnd),
        "http.request.request_start": ee(t.requestStart),
        "http.request.response_start": ee(t.responseStart),
        "http.request.response_end": ee(t.responseEnd),
        "http.request.time_to_first_byte":
          t.responseStart != null ? t.responseStart / 1e3 : void 0,
      })
    : e;
}
function gu(t) {
  return Object.fromEntries(Object.entries(t).filter(([, e]) => e != null));
}
const _u = 2147483647;
let Mr = 0,
  de = {},
  V,
  $e;
function hu({
  recordClsStandaloneSpans: t,
  recordLcpStandaloneSpans: e,
  client: n,
}) {
  const r = Et();
  if (r && K()) {
    r.mark && h.performance.mark("sentry-tracing-init");
    const s = e ? pu(n) : bu(),
      a = vu(),
      o = t ? fu(n) : Tu();
    return () => {
      s == null || s(), a(), o == null || o();
    };
  }
  return () => {};
}
function Eu() {
  Ge("longtask", ({ entries: t }) => {
    const e = J();
    if (!e) return;
    const { op: n, start_timestamp: r } = A(e);
    for (const s of t) {
      const a = C(K() + s.startTime),
        o = C(s.duration);
      (n === "navigation" && r && a < r) ||
        Ie(e, a, a + o, {
          name: "Main UI thread blocked",
          op: "ui.long-task",
          attributes: { [O]: "auto.ui.browser.metrics" },
        });
    }
  });
}
function Su() {
  new PerformanceObserver((e) => {
    const n = J();
    if (n)
      for (const r of e.getEntries()) {
        if (!r.scripts[0]) continue;
        const s = C(K() + r.startTime),
          { start_timestamp: a, op: o } = A(n);
        if (o === "navigation" && a && s < a) continue;
        const c = C(r.duration),
          i = { [O]: "auto.ui.browser.metrics" },
          u = r.scripts[0],
          {
            invoker: f,
            invokerType: d,
            sourceURL: l,
            sourceFunctionName: p,
            sourceCharPosition: m,
          } = u;
        (i["browser.script.invoker"] = f),
          (i["browser.script.invoker_type"] = d),
          l && (i["code.filepath"] = l),
          p && (i["code.function"] = p),
          m !== -1 && (i["browser.script.source_char_position"] = m),
          Ie(n, s, s + c, {
            name: "Main UI thread blocked",
            op: "ui.long-animation-frame",
            attributes: i,
          });
      }
  }).observe({ type: "long-animation-frame", buffered: !0 });
}
function yu() {
  Ge("event", ({ entries: t }) => {
    const e = J();
    if (e) {
      for (const n of t)
        if (n.name === "click") {
          const r = C(K() + n.startTime),
            s = C(n.duration),
            a = {
              name: fe(n.target),
              op: `ui.interaction.${n.name}`,
              startTime: r,
              attributes: { [O]: "auto.ui.browser.metrics" },
            },
            o = as(n.target);
          o && (a.attributes["ui.component_name"] = o), Ie(e, r, r + s, a);
        }
    }
  });
}
function Tu() {
  return Gs(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && ((de.cls = { value: t.value, unit: "" }), ($e = e));
  }, !0);
}
function bu() {
  return zs(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && ((de.lcp = { value: t.value, unit: "millisecond" }), (V = e));
  }, !0);
}
function vu() {
  return nu(({ metric: t }) => {
    t.entries[t.entries.length - 1] &&
      (de.ttfb = { value: t.value, unit: "millisecond" });
  });
}
function Iu(t, e) {
  const n = Et(),
    r = K();
  if (!(n != null && n.getEntries) || !r) return;
  const s = C(r),
    a = n.getEntries(),
    { op: o, start_timestamp: c } = A(t);
  a.slice(Mr).forEach((i) => {
    const u = C(i.startTime),
      f = C(Math.max(0, i.duration));
    if (!(o === "navigation" && c && s + u < c))
      switch (i.entryType) {
        case "navigation": {
          Pu(t, i, s);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          wu(t, i, u, f, s, e.ignorePerformanceApiSpans);
          const d = Wn(),
            l = i.startTime < d.firstHiddenTime;
          i.name === "first-paint" &&
            l &&
            (de.fp = { value: i.startTime, unit: "millisecond" }),
            i.name === "first-contentful-paint" &&
              l &&
              (de.fcp = { value: i.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          Lu(t, i, i.name, u, f, s, e.ignoreResourceSpans);
          break;
        }
      }
  }),
    (Mr = Math.max(a.length - 1, 0)),
    Cu(t),
    o === "pageload" &&
      (Du(de),
      e.recordClsOnPageloadSpan || delete de.cls,
      e.recordLcpOnPageloadSpan || delete de.lcp,
      Object.entries(de).forEach(([i, u]) => {
        Oo(i, u.value, u.unit);
      }),
      t.setAttribute("performance.timeOrigin", s),
      t.setAttribute("performance.activationStart", Xe()),
      Ou(t, e)),
    (V = void 0),
    ($e = void 0),
    (de = {});
}
function Ru(t) {
  if ((t == null ? void 0 : t.entryType) === "measure")
    try {
      return t.detail.devtools.track === "Components ";
    } catch {
      return;
    }
}
function wu(t, e, n, r, s, a) {
  if (Ru(e) || (["mark", "measure"].includes(e.entryType) && ye(e.name, a)))
    return;
  const o = gt(!1),
    c = C(o ? o.requestStart : 0),
    i = s + Math.max(n, c),
    u = s + n,
    f = u + r,
    d = { [O]: "auto.resource.browser.metrics" };
  i !== u &&
    ((d["sentry.browser.measure_happened_before_request"] = !0),
    (d["sentry.browser.measure_start_time"] = i)),
    Au(d, e),
    i <= f && Ie(t, i, f, { name: e.name, op: e.entryType, attributes: d });
}
function Au(t, e) {
  try {
    const n = e.detail;
    if (!n) return;
    if (typeof n == "object") {
      for (const [r, s] of Object.entries(n))
        if (s && je(s)) t[`sentry.browser.measure.detail.${r}`] = s;
        else if (s !== void 0)
          try {
            t[`sentry.browser.measure.detail.${r}`] = JSON.stringify(s);
          } catch {}
      return;
    }
    if (je(n)) {
      t["sentry.browser.measure.detail"] = n;
      return;
    }
    try {
      t["sentry.browser.measure.detail"] = JSON.stringify(n);
    } catch {}
  } catch {}
}
function Pu(t, e, n) {
  [
    "unloadEvent",
    "redirect",
    "domContentLoadedEvent",
    "loadEvent",
    "connect",
  ].forEach((r) => {
    bt(t, e, r, n);
  }),
    bt(t, e, "secureConnection", n, "TLS/SSL"),
    bt(t, e, "fetch", n, "cache"),
    bt(t, e, "domainLookup", n, "DNS"),
    Nu(t, e, n);
}
function bt(t, e, n, r, s = n) {
  const a = ku(n),
    o = e[a],
    c = e[`${n}Start`];
  !c ||
    !o ||
    Ie(t, r + C(c), r + C(o), {
      op: `browser.${s}`,
      name: e.name,
      attributes: {
        [O]: "auto.ui.browser.metrics",
        ...(n === "redirect" && e.redirectCount != null
          ? { "http.redirect_count": e.redirectCount }
          : {}),
      },
    });
}
function ku(t) {
  return t === "secureConnection"
    ? "connectEnd"
    : t === "fetch"
    ? "domainLookupStart"
    : `${t}End`;
}
function Nu(t, e, n) {
  const r = n + C(e.requestStart),
    s = n + C(e.responseEnd),
    a = n + C(e.responseStart);
  e.responseEnd &&
    (Ie(t, r, s, {
      op: "browser.request",
      name: e.name,
      attributes: { [O]: "auto.ui.browser.metrics" },
    }),
    Ie(t, a, s, {
      op: "browser.response",
      name: e.name,
      attributes: { [O]: "auto.ui.browser.metrics" },
    }));
}
function Lu(t, e, n, r, s, a, o) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const c = e.initiatorType ? `resource.${e.initiatorType}` : "resource.other";
  if (o != null && o.includes(c)) return;
  const i = { [O]: "auto.resource.browser.metrics" },
    u = Le(n);
  u.protocol && (i["url.scheme"] = u.protocol.split(":").pop()),
    u.host && (i["server.address"] = u.host),
    (i["url.same_origin"] = n.includes(h.location.origin)),
    Mu(e, i, [
      ["responseStatus", "http.response.status_code"],
      ["transferSize", "http.response_transfer_size"],
      ["encodedBodySize", "http.response_content_length"],
      ["decodedBodySize", "http.decoded_response_content_length"],
      ["renderBlockingStatus", "resource.render_blocking_status"],
      ["deliveryType", "http.response_delivery_type"],
    ]);
  const f = { ...i, ...Zs(e) },
    d = a + r,
    l = d + s;
  Ie(t, d, l, { name: n.replace(h.location.origin, ""), op: c, attributes: f });
}
function Cu(t) {
  const e = h.navigator;
  if (!e) return;
  const n = e.connection;
  n &&
    (n.effectiveType &&
      t.setAttribute("effectiveConnectionType", n.effectiveType),
    n.type && t.setAttribute("connectionType", n.type),
    dn(n.rtt) &&
      (de["connection.rtt"] = { value: n.rtt, unit: "millisecond" })),
    dn(e.deviceMemory) &&
      t.setAttribute("deviceMemory", `${e.deviceMemory} GB`),
    dn(e.hardwareConcurrency) &&
      t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency));
}
function Ou(t, e) {
  V &&
    e.recordLcpOnPageloadSpan &&
    (V.element && t.setAttribute("lcp.element", fe(V.element)),
    V.id && t.setAttribute("lcp.id", V.id),
    V.url && t.setAttribute("lcp.url", V.url.trim().slice(0, 200)),
    V.loadTime != null && t.setAttribute("lcp.loadTime", V.loadTime),
    V.renderTime != null && t.setAttribute("lcp.renderTime", V.renderTime),
    t.setAttribute("lcp.size", V.size)),
    $e != null &&
      $e.sources &&
      e.recordClsOnPageloadSpan &&
      $e.sources.forEach((n, r) =>
        t.setAttribute(`cls.source.${r + 1}`, fe(n.node))
      );
}
function Mu(t, e, n) {
  n.forEach(([r, s]) => {
    const a = t[r];
    a != null &&
      ((typeof a == "number" && a < _u) || typeof a == "string") &&
      (e[s] = a);
  });
}
function Du(t) {
  const e = gt(!1);
  if (!e) return;
  const { responseStart: n, requestStart: r } = e;
  r <= n && (t["ttfb.requestTime"] = { value: n - r, unit: "millisecond" });
}
function xu() {
  return Et() && K() ? Ge("element", Fu) : () => {};
}
const Fu = ({ entries: t }) => {
    const e = J(),
      n = e ? X(e) : void 0,
      r = n ? A(n).description : L().getScopeData().transactionName;
    t.forEach((s) => {
      var p, m;
      const a = s;
      if (!a.identifier) return;
      const o = a.name,
        c = a.renderTime,
        i = a.loadTime,
        [u, f] = i
          ? [C(i), "load-time"]
          : c
          ? [C(c), "render-time"]
          : [q(), "entry-emission"],
        d = o === "image-paint" ? C(Math.max(0, (c ?? 0) - (i ?? 0))) : 0,
        l = {
          [O]: "auto.ui.browser.elementtiming",
          [be]: "ui.elementtiming",
          [ne]: "component",
          "sentry.span_start_time_source": f,
          "sentry.transaction_name": r,
          "element.id": a.id,
          "element.type":
            ((m = (p = a.element) == null ? void 0 : p.tagName) == null
              ? void 0
              : m.toLowerCase()) || "unknown",
          "element.size":
            a.naturalWidth && a.naturalHeight
              ? `${a.naturalWidth}x${a.naturalHeight}`
              : void 0,
          "element.render_time": c,
          "element.load_time": i,
          "element.url": a.url || void 0,
          "element.identifier": a.identifier,
          "element.paint_type": o,
        };
      Bo(
        {
          name: `element[${a.identifier}]`,
          attributes: l,
          startTime: u,
          onlyIfParent: !0,
        },
        (E) => {
          E.end(u + d);
        }
      );
    });
  },
  Hu = 1e3;
let Dr, Rn, wn;
function Bu(t) {
  Re("dom", t), we("dom", $u);
}
function $u() {
  if (!h.document) return;
  const t = re.bind(null, "dom"),
    e = xr(t, !0);
  h.document.addEventListener("click", e, !1),
    h.document.addEventListener("keypress", e, !1),
    ["EventTarget", "Node"].forEach((n) => {
      var a, o;
      const s = (a = h[n]) == null ? void 0 : a.prototype;
      (o = s == null ? void 0 : s.hasOwnProperty) != null &&
        o.call(s, "addEventListener") &&
        (Y(s, "addEventListener", function (c) {
          return function (i, u, f) {
            if (i === "click" || i == "keypress")
              try {
                const d = (this.__sentry_instrumentation_handlers__ =
                    this.__sentry_instrumentation_handlers__ || {}),
                  l = (d[i] = d[i] || { refCount: 0 });
                if (!l.handler) {
                  const p = xr(t);
                  (l.handler = p), c.call(this, i, p, f);
                }
                l.refCount++;
              } catch {}
            return c.call(this, i, u, f);
          };
        }),
        Y(s, "removeEventListener", function (c) {
          return function (i, u, f) {
            if (i === "click" || i == "keypress")
              try {
                const d = this.__sentry_instrumentation_handlers__ || {},
                  l = d[i];
                l &&
                  (l.refCount--,
                  l.refCount <= 0 &&
                    (c.call(this, i, l.handler, f),
                    (l.handler = void 0),
                    delete d[i]),
                  Object.keys(d).length === 0 &&
                    delete this.__sentry_instrumentation_handlers__);
              } catch {}
            return c.call(this, i, u, f);
          };
        }));
    });
}
function Uu(t) {
  if (t.type !== Rn) return !1;
  try {
    if (!t.target || t.target._sentryId !== wn) return !1;
  } catch {}
  return !0;
}
function qu(t, e) {
  return t !== "keypress"
    ? !1
    : e != null && e.tagName
    ? !(
        e.tagName === "INPUT" ||
        e.tagName === "TEXTAREA" ||
        e.isContentEditable
      )
    : !0;
}
function xr(t, e = !1) {
  return (n) => {
    if (!n || n._sentryCaptured) return;
    const r = ju(n);
    if (qu(n.type, r)) return;
    ot(n, "_sentryCaptured", !0), r && !r._sentryId && ot(r, "_sentryId", At());
    const s = n.type === "keypress" ? "input" : n.type;
    Uu(n) ||
      (t({ event: n, name: s, global: e }),
      (Rn = n.type),
      (wn = r ? r._sentryId : void 0)),
      clearTimeout(Dr),
      (Dr = h.setTimeout(() => {
        (wn = void 0), (Rn = void 0);
      }, Hu));
  };
}
function ju(t) {
  try {
    return t.target;
  } catch {
    return null;
  }
}
let vt;
function Yn(t) {
  const e = "history";
  Re(e, t), we(e, Vu);
}
function Vu() {
  if (
    (h.addEventListener("popstate", () => {
      const e = h.location.href,
        n = vt;
      if (((vt = e), n === e)) return;
      re("history", { from: n, to: e });
    }),
    !uc())
  )
    return;
  function t(e) {
    return function (...n) {
      const r = n.length > 2 ? n[2] : void 0;
      if (r) {
        const s = vt,
          a = Wu(String(r));
        if (((vt = a), s === a)) return e.apply(this, n);
        re("history", { from: s, to: a });
      }
      return e.apply(this, n);
    };
  }
  Y(h.history, "pushState", t), Y(h.history, "replaceState", t);
}
function Wu(t) {
  try {
    return new URL(t, h.location.origin).toString();
  } catch {
    return t;
  }
}
const Ct = {};
function Gu(t) {
  const e = Ct[t];
  if (e) return e;
  let n = h[t];
  if (Sn(n)) return (Ct[t] = n.bind(h));
  const r = h.document;
  if (r && typeof r.createElement == "function")
    try {
      const s = r.createElement("iframe");
      (s.hidden = !0), r.head.appendChild(s);
      const a = s.contentWindow;
      a != null && a[t] && (n = a[t]), r.head.removeChild(s);
    } catch (s) {
      pt &&
        g.warn(
          `Could not create sandbox iframe for ${t} check, bailing to window.${t}: `,
          s
        );
    }
  return n && (Ct[t] = n.bind(h));
}
function zu(t) {
  Ct[t] = void 0;
}
const Ue = "__sentry_xhr_v3__";
function Qs(t) {
  Re("xhr", t), we("xhr", Yu);
}
function Yu() {
  if (!h.XMLHttpRequest) return;
  const t = XMLHttpRequest.prototype;
  (t.open = new Proxy(t.open, {
    apply(e, n, r) {
      const s = new Error(),
        a = q() * 1e3,
        o = nt(r[0]) ? r[0].toUpperCase() : void 0,
        c = Xu(r[1]);
      if (!o || !c) return e.apply(n, r);
      (n[Ue] = { method: o, url: c, request_headers: {} }),
        o === "POST" &&
          c.match(/sentry_key/) &&
          (n.__sentry_own_request__ = !0);
      const i = () => {
        const u = n[Ue];
        if (u && n.readyState === 4) {
          try {
            u.status_code = n.status;
          } catch {}
          const f = {
            endTimestamp: q() * 1e3,
            startTimestamp: a,
            xhr: n,
            virtualError: s,
          };
          re("xhr", f);
        }
      };
      return (
        "onreadystatechange" in n && typeof n.onreadystatechange == "function"
          ? (n.onreadystatechange = new Proxy(n.onreadystatechange, {
              apply(u, f, d) {
                return i(), u.apply(f, d);
              },
            }))
          : n.addEventListener("readystatechange", i),
        (n.setRequestHeader = new Proxy(n.setRequestHeader, {
          apply(u, f, d) {
            const [l, p] = d,
              m = f[Ue];
            return (
              m && nt(l) && nt(p) && (m.request_headers[l.toLowerCase()] = p),
              u.apply(f, d)
            );
          },
        })),
        e.apply(n, r)
      );
    },
  })),
    (t.send = new Proxy(t.send, {
      apply(e, n, r) {
        const s = n[Ue];
        if (!s) return e.apply(n, r);
        r[0] !== void 0 && (s.body = r[0]);
        const a = { startTimestamp: q() * 1e3, xhr: n };
        return re("xhr", a), e.apply(n, r);
      },
    }));
}
function Xu(t) {
  if (nt(t)) return t;
  try {
    return t.toString();
  } catch {}
}
function Ju(t) {
  let e;
  try {
    e = t.getAllResponseHeaders();
  } catch (n) {
    return pt && g.error(n, "Failed to get xhr response headers", t), {};
  }
  return e
    ? e
        .split(
          `\r
`
        )
        .reduce((n, r) => {
          const [s, a] = r.split(": ");
          return a && (n[s.toLowerCase()] = a), n;
        }, {})
    : {};
}
const fn = [],
  Ot = new Map(),
  Be = new Map(),
  Ku = 60;
function Zu() {
  if (Et() && K()) {
    const e = Qu();
    return () => {
      e();
    };
  }
  return () => {};
}
const An = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press",
};
function Qu() {
  return ru(ed);
}
const ed = ({ metric: t }) => {
  if (t.value == null) return;
  const e = C(t.value);
  if (e > Ku) return;
  const n = t.entries.find((m) => m.duration === t.value && An[m.name]);
  if (!n) return;
  const { interactionId: r } = n,
    s = An[n.name],
    a = C(K() + n.startTime),
    o = J(),
    c = o ? X(o) : void 0,
    i = r != null ? Ot.get(r) : void 0,
    u = (i == null ? void 0 : i.span) || c,
    f = u ? A(u).description : L().getScopeData().transactionName,
    d = (i == null ? void 0 : i.elementName) || fe(n.target),
    l = {
      [O]: "auto.http.browser.inp",
      [be]: `ui.interaction.${s}`,
      [Ye]: n.duration,
    },
    p = zn({ name: d, transaction: f, attributes: l, startTime: a });
  p &&
    (p.addEvent("inp", { [dt]: "millisecond", [ft]: t.value }), p.end(a + e));
};
function td() {
  const t = Object.keys(An);
  yc() &&
    t.forEach((s) => {
      h.addEventListener(s, e, { capture: !0, passive: !0 });
    });
  function e(s) {
    const a = s.target;
    if (!a) return;
    const o = fe(a),
      c = Math.round(s.timeStamp);
    if ((Be.set(c, o), Be.size > 50)) {
      const i = Be.keys().next().value;
      i !== void 0 && Be.delete(i);
    }
  }
  function n(s) {
    const a = Math.round(s.startTime);
    let o = Be.get(a);
    if (!o)
      for (let c = -5; c <= 5; c++) {
        const i = Be.get(a + c);
        if (i) {
          o = i;
          break;
        }
      }
    return o || "<unknown>";
  }
  const r = ({ entries: s }) => {
    const a = J(),
      o = a && X(a);
    s.forEach((c) => {
      if (!uu(c)) return;
      const i = c.interactionId;
      if (i == null || Ot.has(i)) return;
      const u = c.target ? fe(c.target) : n(c);
      if (fn.length > 10) {
        const f = fn.shift();
        Ot.delete(f);
      }
      fn.push(i), Ot.set(i, { span: o, elementName: u });
    });
  };
  Ge("event", r), Ge("first-input", r);
}
const nd = 40;
function rd(t, e = Gu("fetch")) {
  let n = 0,
    r = 0;
  async function s(a) {
    const o = a.body.length;
    (n += o), r++;
    const c = {
      body: a.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: t.headers,
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions,
    };
    try {
      const i = await e(t.url, c);
      return {
        statusCode: i.status,
        headers: {
          "x-sentry-rate-limits": i.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": i.headers.get("Retry-After"),
        },
      };
    } catch (i) {
      throw (zu("fetch"), i);
    } finally {
      (n -= o), r--;
    }
  }
  return Ii(t, s, As(t.bufferSize || nd));
}
const sd = 30,
  ad = 50;
function Pn(t, e, n, r) {
  const s = { filename: t, function: e === "<anonymous>" ? Ve : e, in_app: !0 };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s;
}
const od = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  id =
    /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  cd = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  ud = /at (.+?) ?\(data:(.+?),/,
  dd = (t) => {
    const e = t.match(ud);
    if (e) return { filename: `<data:${e[2]}>`, function: e[1] };
    const n = od.exec(t);
    if (n) {
      const [, s, a, o] = n;
      return Pn(s, Ve, +a, +o);
    }
    const r = id.exec(t);
    if (r) {
      if (r[2] && r[2].indexOf("eval") === 0) {
        const c = cd.exec(r[2]);
        c && ((r[2] = c[1]), (r[3] = c[2]), (r[4] = c[3]));
      }
      const [a, o] = ea(r[1] || Ve, r[2]);
      return Pn(o, a, r[3] ? +r[3] : void 0, r[4] ? +r[4] : void 0);
    }
  },
  fd = [sd, dd],
  ld =
    /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  pd = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  md = (t) => {
    const e = ld.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const a = pd.exec(e[3]);
        a &&
          ((e[1] = e[1] || "eval"), (e[3] = a[1]), (e[4] = a[2]), (e[5] = ""));
      }
      let r = e[3],
        s = e[1] || Ve;
      return (
        ([s, r] = ea(s, r)),
        Pn(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
      );
    }
  },
  gd = [ad, md],
  _d = [fd, gd],
  hd = Ua(..._d),
  ea = (t, e) => {
    const n = t.indexOf("safari-extension") !== -1,
      r = t.indexOf("safari-web-extension") !== -1;
    return n || r
      ? [
          t.indexOf("@") !== -1 ? t.split("@")[0] : Ve,
          n ? `safari-extension:${e}` : `safari-web-extension:${e}`,
        ]
      : [t, e];
  },
  se = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  It = 1024,
  Ed = "Breadcrumbs",
  Sd = (t = {}) => {
    const e = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...t,
    };
    return {
      name: Ed,
      setup(n) {
        e.console && zi(vd(n)),
          e.dom && Bu(bd(n, e.dom)),
          e.xhr && Qs(Id(n)),
          e.fetch && Ms(Rd(n)),
          e.history && Yn(wd(n)),
          e.sentry && n.on("beforeSendEvent", Td(n));
      },
    };
  },
  yd = Sd;
function Td(t) {
  return function (n) {
    k() === t &&
      Oe(
        {
          category: `sentry.${
            n.type === "transaction" ? "transaction" : "event"
          }`,
          event_id: n.event_id,
          level: n.level,
          message: Ne(n),
        },
        { event: n }
      );
  };
}
function bd(t, e) {
  return function (r) {
    if (k() !== t) return;
    let s,
      a,
      o = typeof e == "object" ? e.serializeAttribute : void 0,
      c =
        typeof e == "object" && typeof e.maxStringLength == "number"
          ? e.maxStringLength
          : void 0;
    c &&
      c > It &&
      (se &&
        g.warn(
          `\`dom.maxStringLength\` cannot exceed ${It}, but a value of ${c} was configured. Sentry will use ${It} instead.`
        ),
      (c = It)),
      typeof o == "string" && (o = [o]);
    try {
      const u = r.event,
        f = Ad(u) ? u.target : u;
      (s = fe(f, { keyAttrs: o, maxStringLength: c })), (a = as(f));
    } catch {
      s = "<unknown>";
    }
    if (s.length === 0) return;
    const i = { category: `ui.${r.name}`, message: s };
    a && (i.data = { "ui.component_name": a }),
      Oe(i, { event: r.event, name: r.name, global: r.global });
  };
}
function vd(t) {
  return function (n) {
    if (k() !== t) return;
    const r = {
      category: "console",
      data: { arguments: n.args, logger: "console" },
      level: Xi(n.level),
      message: or(n.args, " "),
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        (r.message = `Assertion failed: ${
          or(n.args.slice(1), " ") || "console.assert"
        }`),
          (r.data.arguments = n.args.slice(1));
      else return;
    Oe(r, { input: n.args, level: n.level });
  };
}
function Id(t) {
  return function (n) {
    if (k() !== t) return;
    const { startTimestamp: r, endTimestamp: s } = n,
      a = n.xhr[Ue];
    if (!r || !s || !a) return;
    const { method: o, url: c, status_code: i, body: u } = a,
      f = { method: o, url: c, status_code: i },
      d = { xhr: n.xhr, input: u, startTimestamp: r, endTimestamp: s },
      l = { category: "xhr", data: f, type: "http", level: Os(i) };
    t.emit("beforeOutgoingRequestBreadcrumb", l, d), Oe(l, d);
  };
}
function Rd(t) {
  return function (n) {
    if (k() !== t) return;
    const { startTimestamp: r, endTimestamp: s } = n;
    if (
      s &&
      !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST")
    )
      if ((n.fetchData.method, n.fetchData.url, n.error)) {
        const a = n.fetchData,
          o = {
            data: n.error,
            input: n.args,
            startTimestamp: r,
            endTimestamp: s,
          },
          c = { category: "fetch", data: a, level: "error", type: "http" };
        t.emit("beforeOutgoingRequestBreadcrumb", c, o), Oe(c, o);
      } else {
        const a = n.response,
          o = { ...n.fetchData, status_code: a == null ? void 0 : a.status };
        n.fetchData.request_body_size,
          n.fetchData.response_body_size,
          a == null || a.status;
        const c = {
            input: n.args,
            response: a,
            startTimestamp: r,
            endTimestamp: s,
          },
          i = {
            category: "fetch",
            data: o,
            type: "http",
            level: Os(o.status_code),
          };
        t.emit("beforeOutgoingRequestBreadcrumb", i, c), Oe(i, c);
      }
  };
}
function wd(t) {
  return function (n) {
    if (k() !== t) return;
    let r = n.from,
      s = n.to;
    const a = Le(T.location.href);
    let o = r ? Le(r) : void 0;
    const c = Le(s);
    (o != null && o.path) || (o = a),
      a.protocol === c.protocol && a.host === c.host && (s = c.relative),
      a.protocol === o.protocol && a.host === o.host && (r = o.relative),
      Oe({ category: "navigation", data: { from: r, to: s } });
  };
}
function Ad(t) {
  return !!t && !!t.target;
}
const Pd = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload",
  ],
  kd = "BrowserApiErrors",
  Nd = (t = {}) => {
    const e = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      unregisterOriginalCallbacks: !1,
      ...t,
    };
    return {
      name: kd,
      setupOnce() {
        e.setTimeout && Y(T, "setTimeout", Fr),
          e.setInterval && Y(T, "setInterval", Fr),
          e.requestAnimationFrame && Y(T, "requestAnimationFrame", Cd),
          e.XMLHttpRequest &&
            "XMLHttpRequest" in T &&
            Y(XMLHttpRequest.prototype, "send", Od);
        const n = e.eventTarget;
        n && (Array.isArray(n) ? n : Pd).forEach((s) => Md(s, e));
      },
    };
  },
  Ld = Nd;
function Fr(t) {
  return function (...e) {
    const n = e[0];
    return (
      (e[0] = We(n, {
        mechanism: {
          handled: !1,
          type: `auto.browser.browserapierrors.${Te(t)}`,
        },
      })),
      t.apply(this, e)
    );
  };
}
function Cd(t) {
  return function (e) {
    return t.apply(this, [
      We(e, {
        mechanism: {
          data: { handler: Te(t) },
          handled: !1,
          type: "auto.browser.browserapierrors.requestAnimationFrame",
        },
      }),
    ]);
  };
}
function Od(t) {
  return function (...e) {
    const n = this;
    return (
      ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((s) => {
        s in n &&
          typeof n[s] == "function" &&
          Y(n, s, function (a) {
            const o = {
                mechanism: {
                  data: { handler: Te(a) },
                  handled: !1,
                  type: `auto.browser.browserapierrors.xhr.${s}`,
                },
              },
              c = Mn(a);
            return c && (o.mechanism.data.handler = Te(c)), We(a, o);
          });
      }),
      t.apply(this, e)
    );
  };
}
function Md(t, e) {
  var s, a;
  const r = (s = T[t]) == null ? void 0 : s.prototype;
  (a = r == null ? void 0 : r.hasOwnProperty) != null &&
    a.call(r, "addEventListener") &&
    (Y(r, "addEventListener", function (o) {
      return function (c, i, u) {
        try {
          Dd(i) &&
            (i.handleEvent = We(i.handleEvent, {
              mechanism: {
                data: { handler: Te(i), target: t },
                handled: !1,
                type: "auto.browser.browserapierrors.handleEvent",
              },
            }));
        } catch {}
        return (
          e.unregisterOriginalCallbacks && xd(this, c, i),
          o.apply(this, [
            c,
            We(i, {
              mechanism: {
                data: { handler: Te(i), target: t },
                handled: !1,
                type: "auto.browser.browserapierrors.addEventListener",
              },
            }),
            u,
          ])
        );
      };
    }),
    Y(r, "removeEventListener", function (o) {
      return function (c, i, u) {
        try {
          const f = i.__sentry_wrapped__;
          f && o.call(this, c, f, u);
        } catch {}
        return o.call(this, c, i, u);
      };
    }));
}
function Dd(t) {
  return typeof t.handleEvent == "function";
}
function xd(t, e, n) {
  t &&
    typeof t == "object" &&
    "removeEventListener" in t &&
    typeof t.removeEventListener == "function" &&
    t.removeEventListener(e, n);
}
const Fd = () => ({
    name: "BrowserSession",
    setupOnce() {
      if (typeof T.document > "u") {
        se &&
          g.warn(
            "Using the `browserSessionIntegration` in non-browser environments is not supported."
          );
        return;
      }
      ir({ ignoreDuration: !0 }),
        cr(),
        Yn(({ from: t, to: e }) => {
          t !== void 0 && t !== e && (ir({ ignoreDuration: !0 }), cr());
        });
    },
  }),
  Hd = "GlobalHandlers",
  Bd = (t = {}) => {
    const e = { onerror: !0, onunhandledrejection: !0, ...t };
    return {
      name: Hd,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(n) {
        e.onerror && (Ud(n), Hr("onerror")),
          e.onunhandledrejection && (qd(n), Hr("onunhandledrejection"));
      },
    };
  },
  $d = Bd;
function Ud(t) {
  cs((e) => {
    const { stackParser: n, attachStacktrace: r } = ta();
    if (k() !== t || xs()) return;
    const { msg: s, url: a, line: o, column: c, error: i } = e,
      u = Wd(qn(n, i || s, void 0, r, !1), a, o, c);
    (u.level = "error"),
      os(u, {
        originalException: i,
        mechanism: {
          handled: !1,
          type: "auto.browser.global_handlers.onerror",
        },
      });
  });
}
function qd(t) {
  us((e) => {
    const { stackParser: n, attachStacktrace: r } = ta();
    if (k() !== t || xs()) return;
    const s = jd(e),
      a = je(s) ? Vd(s) : qn(n, s, void 0, r, !0);
    (a.level = "error"),
      os(a, {
        originalException: s,
        mechanism: {
          handled: !1,
          type: "auto.browser.global_handlers.onunhandledrejection",
        },
      });
  });
}
function jd(t) {
  if (je(t)) return t;
  try {
    if ("reason" in t) return t.reason;
    if ("detail" in t && "reason" in t.detail) return t.detail.reason;
  } catch {}
  return t;
}
function Vd(t) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          value: `Non-Error promise rejection captured with value: ${String(
            t
          )}`,
        },
      ],
    },
  };
}
function Wd(t, e, n, r) {
  const s = (t.exception = t.exception || {}),
    a = (s.values = s.values || []),
    o = (a[0] = a[0] || {}),
    c = (o.stacktrace = o.stacktrace || {}),
    i = (c.frames = c.frames || []),
    u = r,
    f = n,
    d = Gd(e) ?? lt();
  return (
    i.length === 0 &&
      i.push({ colno: u, filename: d, function: Ve, in_app: !0, lineno: f }),
    t
  );
}
function Hr(t) {
  se && g.log(`Global Handler attached: ${t}`);
}
function ta() {
  const t = k();
  return (
    (t == null ? void 0 : t.getOptions()) || {
      stackParser: () => [],
      attachStacktrace: !1,
    }
  );
}
function Gd(t) {
  if (!(!nt(t) || t.length === 0)) {
    if (t.startsWith("data:")) {
      const e = t.match(/^data:([^;]+)/),
        n = e ? e[1] : "text/javascript",
        r = t.includes("base64,");
      return `<data:${n}${r ? ",base64" : ""}>`;
    }
    return t;
  }
}
const zd = () => ({
    name: "HttpContext",
    preprocessEvent(t) {
      var r;
      if (!T.navigator && !T.location && !T.document) return;
      const e = Bn(),
        n = { ...e.headers, ...((r = t.request) == null ? void 0 : r.headers) };
      t.request = { ...e, ...t.request, headers: n };
    },
  }),
  Yd = "cause",
  Xd = 5,
  Jd = "LinkedErrors",
  Kd = (t = {}) => {
    const e = t.limit || Xd,
      n = t.key || Yd;
    return {
      name: Jd,
      preprocessEvent(r, s, a) {
        const o = a.getOptions();
        Gi($n, o.stackParser, n, e, r, s);
      },
    };
  },
  Zd = Kd;
function Qd() {
  return ef()
    ? (se &&
        zt(() => {
          console.error(
            "[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
          );
        }),
      !0)
    : !1;
}
function ef() {
  var a;
  if (typeof T.window > "u") return !1;
  const t = T;
  if (t.nw) return !1;
  const e = t.chrome || t.browser;
  if (!((a = e == null ? void 0 : e.runtime) != null && a.id)) return !1;
  const n = lt(),
    r = [
      "chrome-extension",
      "moz-extension",
      "ms-browser-extension",
      "safari-web-extension",
    ];
  return !(T === T.top && r.some((o) => n.startsWith(`${o}://`)));
}
function kn(t) {
  return [Hi(), Mi(), Ld(), yd(), $d(), Zd(), Zi(), zd(), Fd()];
}
function tf(t = {}) {
  const e = !t.skipBrowserExtensionCheck && Qd();
  let n = t.defaultIntegrations == null ? kn() : t.defaultIntegrations;
  const r = {
    ...t,
    enabled: e ? !1 : t.enabled,
    stackParser: qa(t.stackParser || hd),
    integrations: Qo({ integrations: t.integrations, defaultIntegrations: n }),
    transport: t.transport || rd,
  };
  return _i(Mc, r);
}
function nf(t) {
  return t.split(",").some((e) => e.trim().startsWith("sentry-"));
}
function na(t) {
  try {
    return new URL(t, T.location.origin).href;
  } catch {
    return;
  }
}
function rf(t) {
  return (
    t.entryType === "resource" &&
    "initiatorType" in t &&
    typeof t.nextHopProtocol == "string" &&
    (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest")
  );
}
function ra(t) {
  try {
    return new Headers(t);
  } catch {
    return;
  }
}
const Br = new WeakMap(),
  ln = new Map(),
  sa = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    trackFetchStreamPerformance: !1,
  };
function sf(t, e) {
  const {
      traceFetch: n,
      traceXHR: r,
      trackFetchStreamPerformance: s,
      shouldCreateSpanForRequest: a,
      enableHTTPTimings: o,
      tracePropagationTargets: c,
      onRequestSpanStart: i,
      onRequestSpanEnd: u,
    } = { ...sa, ...e },
    f = typeof a == "function" ? a : (m) => !0,
    d = (m) => af(m, c),
    l = {},
    p = t.getOptions().propagateTraceparent;
  n &&
    (t.addEventProcessor(
      (m) => (
        m.type === "transaction" &&
          m.spans &&
          m.spans.forEach((E) => {
            if (E.op === "http.client") {
              const S = ln.get(E.span_id);
              S && ((E.timestamp = S / 1e3), ln.delete(E.span_id));
            }
          }),
        m
      )
    ),
    s &&
      lc((m) => {
        if (m.response) {
          const E = Br.get(m.response);
          E && m.endTimestamp && ln.set(E, m.endTimestamp);
        }
      }),
    Ms((m) => {
      const E = nc(m, f, d, l, {
        propagateTraceparent: p,
        onRequestSpanEnd: u,
      });
      if (
        (m.response &&
          m.fetchData.__span &&
          Br.set(m.response, m.fetchData.__span),
        E)
      ) {
        const S = na(m.fetchData.url),
          R = S ? Le(S).host : void 0;
        E.setAttributes({ "http.url": S, "server.address": R }),
          o && $r(E),
          i == null || i(E, { headers: m.headers });
      }
    })),
    r &&
      Qs((m) => {
        var S;
        const E = of(m, f, d, l, p, u);
        E &&
          (o && $r(E),
          i == null ||
            i(E, {
              headers: ra(
                (S = m.xhr.__sentry_xhr_v3__) == null
                  ? void 0
                  : S.request_headers
              ),
            }));
      });
}
function $r(t) {
  const { url: e } = A(t).data;
  if (!e || typeof e != "string") return;
  const n = Ge("resource", ({ entries: r }) => {
    r.forEach((s) => {
      rf(s) && s.name.endsWith(e) && (t.setAttributes(Zs(s)), setTimeout(n));
    });
  });
}
function af(t, e) {
  const n = lt();
  if (n) {
    let r, s;
    try {
      (r = new URL(t, n)), (s = new URL(n).origin);
    } catch {
      return !1;
    }
    const a = r.origin === s;
    return e ? ye(r.toString(), e) || (a && ye(r.pathname, e)) : a;
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? ye(t, e) : r;
  }
}
function of(t, e, n, r, s, a) {
  const o = t.xhr,
    c = o == null ? void 0 : o[Ue];
  if (!o || o.__sentry_own_request__ || !c) return;
  const { url: i, method: u } = c,
    f = pe() && e(i);
  if (t.endTimestamp && f) {
    const R = o.__sentry_xhr_span_id__;
    if (!R) return;
    const N = r[R];
    N &&
      c.status_code !== void 0 &&
      (es(N, c.status_code),
      N.end(),
      a == null || a(N, { headers: ra(Ju(o)), error: t.error }),
      delete r[R]);
    return;
  }
  const d = na(i),
    l = Le(d || i),
    p = Ai(i),
    m = !!J(),
    E =
      f && m
        ? De({
            name: `${u} ${p}`,
            attributes: {
              url: i,
              type: "xhr",
              "http.method": u,
              "http.url": d,
              "server.address": l == null ? void 0 : l.host,
              [O]: "auto.http.browser",
              [be]: "http.client",
              ...((l == null ? void 0 : l.search) && {
                "http.query": l == null ? void 0 : l.search,
              }),
              ...((l == null ? void 0 : l.hash) && {
                "http.fragment": l == null ? void 0 : l.hash,
              }),
            },
          })
        : new ve();
  (o.__sentry_xhr_span_id__ = E.spanContext().spanId),
    (r[o.__sentry_xhr_span_id__] = E),
    n(i) && cf(o, pe() && m ? E : void 0, s);
  const S = k();
  return S && S.emit("beforeOutgoingRequestSpan", E, t), E;
}
function cf(t, e, n) {
  const {
    "sentry-trace": r,
    baggage: s,
    traceparent: a,
  } = Ns({ span: e, propagateTraceparent: n });
  r && uf(t, r, s, a);
}
function uf(t, e, n, r) {
  var a;
  const s = (a = t.__sentry_xhr_v3__) == null ? void 0 : a.request_headers;
  if (!((s != null && s["sentry-trace"]) || !t.setRequestHeader))
    try {
      if (
        (t.setRequestHeader("sentry-trace", e),
        r &&
          !(s != null && s.traceparent) &&
          t.setRequestHeader("traceparent", r),
        n)
      ) {
        const o = s == null ? void 0 : s.baggage;
        (!o || !nf(o)) && t.setRequestHeader("baggage", n);
      }
    } catch {}
}
function df() {
  T.document
    ? T.document.addEventListener("visibilitychange", () => {
        const t = J();
        if (!t) return;
        const e = X(t);
        if (T.document.hidden && e) {
          const n = "cancelled",
            { op: r, status: s } = A(e);
          se &&
            g.log(
              `[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`
            ),
            s || e.setStatus({ code: qe, message: n }),
            e.setAttribute("sentry.cancellation_reason", "document.hidden"),
            e.end();
        }
      })
    : se &&
      g.warn(
        "[Tracing] Could not set up background tab detection due to lack of global document"
      );
}
const ff = 3600,
  aa = "sentry_previous_trace",
  lf = "sentry.previous_trace";
function pf(t, { linkPreviousTrace: e, consistentTraceSampling: n }) {
  const r = e === "session-storage";
  let s = r ? _f() : void 0;
  t.on("spanStart", (o) => {
    if (X(o) !== o) return;
    const c = L().getPropagationContext();
    (s = mf(s, o, c)), r && gf(s);
  });
  let a = !0;
  n &&
    t.on("beforeSampling", (o) => {
      if (!s) return;
      const c = L(),
        i = c.getPropagationContext();
      if (a && i.parentSpanId) {
        a = !1;
        return;
      }
      c.setPropagationContext({
        ...i,
        dsc: {
          ...i.dsc,
          sample_rate: String(s.sampleRate),
          sampled: String(Nn(s.spanContext)),
        },
        sampleRand: s.sampleRand,
      }),
        (o.parentSampled = Nn(s.spanContext)),
        (o.parentSampleRate = s.sampleRate),
        (o.spanAttributes = { ...o.spanAttributes, [ja]: s.sampleRate });
    });
}
function mf(t, e, n) {
  const r = A(e);
  function s() {
    var c, i;
    try {
      return (
        Number((c = n.dsc) == null ? void 0 : c.sample_rate) ??
        Number((i = r.data) == null ? void 0 : i[Xr])
      );
    } catch {
      return 0;
    }
  }
  const a = {
    spanContext: e.spanContext(),
    startTimestamp: r.start_timestamp,
    sampleRate: s(),
    sampleRand: n.sampleRand,
  };
  if (!t) return a;
  const o = t.spanContext;
  return o.traceId === r.trace_id
    ? t
    : (Date.now() / 1e3 - t.startTimestamp <= ff &&
        (se &&
          g.log(
            `Adding previous_trace ${o} link to span ${{
              op: r.op,
              ...e.spanContext(),
            }}`
          ),
        e.addLink({ context: o, attributes: { [Va]: "previous_trace" } }),
        e.setAttribute(lf, `${o.traceId}-${o.spanId}-${Nn(o) ? 1 : 0}`)),
      a);
}
function gf(t) {
  try {
    T.sessionStorage.setItem(aa, JSON.stringify(t));
  } catch (e) {
    se && g.warn("Could not store previous trace in sessionStorage", e);
  }
}
function _f() {
  var t;
  try {
    const e = (t = T.sessionStorage) == null ? void 0 : t.getItem(aa);
    return JSON.parse(e);
  } catch {
    return;
  }
}
function Nn(t) {
  return t.traceFlags === 1;
}
const hf = "BrowserTracing",
  Ef = {
    ...Nt,
    instrumentNavigation: !0,
    instrumentPageLoad: !0,
    markBackgroundSpan: !0,
    enableLongTask: !0,
    enableLongAnimationFrame: !0,
    enableInp: !0,
    enableElementTiming: !0,
    ignoreResourceSpans: [],
    ignorePerformanceApiSpans: [],
    detectRedirects: !0,
    linkPreviousTrace: "in-memory",
    consistentTraceSampling: !1,
    enableReportPageLoaded: !1,
    _experiments: {},
    ...sa,
  },
  Sf = (t = {}) => {
    const e = { name: void 0, source: void 0 },
      n = T.document,
      {
        enableInp: r,
        enableElementTiming: s,
        enableLongTask: a,
        enableLongAnimationFrame: o,
        _experiments: {
          enableInteractions: c,
          enableStandaloneClsSpans: i,
          enableStandaloneLcpSpans: u,
        },
        beforeStartSpan: f,
        idleTimeout: d,
        finalTimeout: l,
        childSpanTimeout: p,
        markBackgroundSpan: m,
        traceFetch: E,
        traceXHR: S,
        trackFetchStreamPerformance: R,
        shouldCreateSpanForRequest: N,
        enableHTTPTimings: B,
        ignoreResourceSpans: me,
        ignorePerformanceApiSpans: ae,
        instrumentPageLoad: oe,
        instrumentNavigation: y,
        detectRedirects: M,
        linkPreviousTrace: ge,
        consistentTraceSampling: xe,
        enableReportPageLoaded: ie,
        onRequestSpanStart: _e,
        onRequestSpanEnd: P,
      } = { ...Ef, ...t };
    let $, W, U;
    function Z(v, I, b = !0) {
      const D = I.op === "pageload",
        F = I.name,
        G = f ? f(I) : I,
        he = G.attributes || {};
      if ((F !== G.name && ((he[ne] = "custom"), (G.attributes = he)), !b)) {
        const ce = Gt();
        De({ ...G, startTime: ce }).end(ce);
        return;
      }
      (e.name = G.name), (e.source = he[ne]);
      const H = gs(G, {
        idleTimeout: d,
        finalTimeout: l,
        childSpanTimeout: p,
        disableAutoFinish: D,
        beforeSpanEnd: (ce) => {
          $ == null || $(),
            Iu(ce, {
              recordClsOnPageloadSpan: !i,
              recordLcpOnPageloadSpan: !u,
              ignoreResourceSpans: me,
              ignorePerformanceApiSpans: ae,
            }),
            qr(v, void 0);
          const He = L(),
            Ke = He.getPropagationContext();
          He.setPropagationContext({
            ...Ke,
            traceId: H.spanContext().traceId,
            sampled: qt(H),
            dsc: Ce(ce),
          }),
            D && (U = void 0);
        },
        trimIdleSpanEndTimestamp: !ie,
      });
      D && ie && (U = H), qr(v, H);
      function Fe() {
        n &&
          ["interactive", "complete"].includes(n.readyState) &&
          v.emit("idleSpanEnableAutoFinish", H);
      }
      D &&
        !ie &&
        n &&
        (n.addEventListener("readystatechange", () => {
          Fe();
        }),
        Fe());
    }
    return {
      name: hf,
      setup(v) {
        if (
          (ho(),
          ($ = hu({
            recordClsStandaloneSpans: i || !1,
            recordLcpStandaloneSpans: u || !1,
            client: v,
          })),
          r && Zu(),
          s && xu(),
          o &&
          x.PerformanceObserver &&
          PerformanceObserver.supportedEntryTypes &&
          PerformanceObserver.supportedEntryTypes.includes(
            "long-animation-frame"
          )
            ? Su()
            : a && Eu(),
          c && yu(),
          M && n)
        ) {
          const b = () => {
            W = q();
          };
          addEventListener("click", b, { capture: !0 }),
            addEventListener("keydown", b, { capture: !0, passive: !0 });
        }
        function I() {
          const b = ut(v);
          b &&
            !A(b).timestamp &&
            (se &&
              g.log(
                `[Tracing] Finishing current active span with op: ${A(b).op}`
              ),
            b.setAttribute(at, "cancelled"),
            b.end());
        }
        v.on("startNavigationSpan", (b, D) => {
          if (k() !== v) return;
          if (D != null && D.isRedirect) {
            se &&
              g.warn(
                "[Tracing] Detected redirect, navigation span will not be the root span, but a child span."
              ),
              Z(v, { op: "navigation.redirect", ...b }, !1);
            return;
          }
          (W = void 0),
            I(),
            Wt().setPropagationContext({
              traceId: Mt(),
              sampleRand: Math.random(),
              propagationSpanId: pe() ? void 0 : et(),
            });
          const F = L();
          F.setPropagationContext({
            traceId: Mt(),
            sampleRand: Math.random(),
            propagationSpanId: pe() ? void 0 : et(),
          }),
            F.setSDKProcessingMetadata({ normalizedRequest: void 0 }),
            Z(v, {
              op: "navigation",
              ...b,
              parentSpan: null,
              forceTransaction: !0,
            });
        }),
          v.on("startPageLoadSpan", (b, D = {}) => {
            if (k() !== v) return;
            I();
            const F = D.sentryTrace || Ur("sentry-trace"),
              G = D.baggage || Ur("baggage"),
              he = Wa(F, G),
              H = L();
            H.setPropagationContext(he),
              pe() || (H.getPropagationContext().propagationSpanId = et()),
              H.setSDKProcessingMetadata({ normalizedRequest: Bn() }),
              Z(v, { op: "pageload", ...b });
          }),
          v.on("endPageloadSpan", () => {
            ie && U && (U.setAttribute(at, "reportPageLoaded"), U.end());
          });
      },
      afterAllSetup(v) {
        let I = lt();
        if (
          (ge !== "off" &&
            pf(v, { linkPreviousTrace: ge, consistentTraceSampling: xe }),
          T.location)
        ) {
          if (oe) {
            const b = K();
            oa(v, {
              name: T.location.pathname,
              startTime: b ? b / 1e3 : void 0,
              attributes: { [ne]: "url", [O]: "auto.pageload.browser" },
            });
          }
          y &&
            Yn(({ to: b, from: D }) => {
              if (D === void 0 && (I == null ? void 0 : I.indexOf(b)) !== -1) {
                I = void 0;
                return;
              }
              I = void 0;
              const F = ks(b),
                G = ut(v),
                he = G && M && Tf(G, W);
              ia(
                v,
                {
                  name:
                    (F == null ? void 0 : F.pathname) || T.location.pathname,
                  attributes: { [ne]: "url", [O]: "auto.navigation.browser" },
                },
                { url: b, isRedirect: he }
              );
            });
        }
        m && df(),
          c && yf(v, d, l, p, e),
          r && td(),
          sf(v, {
            traceFetch: E,
            traceXHR: S,
            trackFetchStreamPerformance: R,
            tracePropagationTargets: v.getOptions().tracePropagationTargets,
            shouldCreateSpanForRequest: N,
            enableHTTPTimings: B,
            onRequestSpanStart: _e,
            onRequestSpanEnd: P,
          });
      },
    };
  };
function oa(t, e, n) {
  t.emit("startPageLoadSpan", e, n), L().setTransactionName(e.name);
  const r = ut(t);
  return r && t.emit("afterStartPageLoadSpan", r), r;
}
function ia(t, e, n) {
  const { url: r, isRedirect: s } = n || {};
  t.emit("beforeStartNavigationSpan", e, { isRedirect: s }),
    t.emit("startNavigationSpan", e, { isRedirect: s });
  const a = L();
  return (
    a.setTransactionName(e.name),
    r &&
      !s &&
      a.setSDKProcessingMetadata({ normalizedRequest: { ...Bn(), url: r } }),
    ut(t)
  );
}
function Ur(t) {
  const e = T.document,
    n = e == null ? void 0 : e.querySelector(`meta[name=${t}]`);
  return (n == null ? void 0 : n.getAttribute("content")) || void 0;
}
function yf(t, e, n, r, s) {
  const a = T.document;
  let o;
  const c = () => {
    const i = "ui.action.click",
      u = ut(t);
    if (u) {
      const f = A(u).op;
      if (["navigation", "pageload"].includes(f)) {
        se &&
          g.warn(
            `[Tracing] Did not create ${i} span because a pageload or navigation span is in progress.`
          );
        return;
      }
    }
    if (
      (o &&
        (o.setAttribute(at, "interactionInterrupted"), o.end(), (o = void 0)),
      !s.name)
    ) {
      se &&
        g.warn(
          `[Tracing] Did not create ${i} transaction because _latestRouteName is missing.`
        );
      return;
    }
    o = gs(
      { name: s.name, op: i, attributes: { [ne]: s.source || "url" } },
      { idleTimeout: e, finalTimeout: n, childSpanTimeout: r }
    );
  };
  a && addEventListener("click", c, { capture: !0 });
}
const ca = "_sentry_idleSpan";
function ut(t) {
  return t[ca];
}
function qr(t, e) {
  ot(t, ca, e);
}
const jr = 1.5;
function Tf(t, e) {
  const n = A(t),
    r = Gt(),
    s = n.start_timestamp;
  return !(r - s > jr || (e && r - e <= jr));
}
function bf(t) {
  const e = { ...t };
  return Hn(e, "svelte"), tf(e);
}
const ua = () => {
    const t = Ga;
    return {
      page: { subscribe: t.page.subscribe },
      navigating: { subscribe: t.navigating.subscribe },
      updated: t.updated,
    };
  },
  vf = {
    subscribe(t) {
      return ua().page.subscribe(t);
    },
  },
  If = {
    subscribe(t) {
      return ua().navigating.subscribe(t);
    },
  };
function Rf(t = {}) {
  const e = {
    ...Sf({ ...t, instrumentNavigation: !1, instrumentPageLoad: !1 }),
  };
  return {
    ...e,
    afterAllSetup: (n) => {
      e.afterAllSetup(n),
        t.instrumentPageLoad !== !1 && wf(n),
        t.instrumentNavigation !== !1 && Af(n);
    },
  };
}
function wf(t) {
  var r;
  const e = (r = T.location) == null ? void 0 : r.pathname,
    n = oa(t, {
      name: e,
      op: "pageload",
      attributes: { [O]: "auto.pageload.sveltekit", [ne]: "url" },
    });
  n &&
    vf.subscribe((s) => {
      var o;
      if (!s) return;
      const a = (o = s.route) == null ? void 0 : o.id;
      a &&
        (n.updateName(a),
        n.setAttribute(ne, "route"),
        L().setTransactionName(a));
    });
}
function Af(t) {
  let e;
  If.subscribe((n) => {
    var f;
    if (!n) {
      e && (e.end(), (e = void 0));
      return;
    }
    const r = n.from,
      s = n.to,
      a =
        (r == null ? void 0 : r.url.pathname) ||
        ((f = T.location) == null ? void 0 : f.pathname),
      o = s == null ? void 0 : s.url.pathname;
    if (a === o) return;
    const c = r == null ? void 0 : r.route.id,
      i = s == null ? void 0 : s.route.id;
    e && e.end();
    const u = {
      "sentry.sveltekit.navigation.type": n.type,
      "sentry.sveltekit.navigation.from": c || void 0,
      "sentry.sveltekit.navigation.to": i || void 0,
    };
    ia(t, {
      name: i || o || "unknown",
      op: "navigation",
      attributes: {
        [O]: "auto.navigation.sveltekit",
        [ne]: i ? "route" : "url",
        ...u,
      },
    }),
      (e = De({
        op: "ui.sveltekit.routing",
        name: "SvelteKit Route Change",
        attributes: { [O]: "auto.ui.sveltekit", ...u },
        onlyIfParent: !0,
      }));
  });
}
function Pf(t) {
  const e = { defaultIntegrations: kf(), ...t };
  Hn(e, "sveltekit", ["sveltekit", "svelte"]);
  const n = Nf(),
    r = bf(e);
  return n && Lf(n), r;
}
function kf(t) {
  return typeof __SENTRY_TRACING__ > "u" || __SENTRY_TRACING__
    ? [...kn(), Rf()]
    : kn();
}
function Nf() {
  const t = T,
    e = t.fetch;
  if (t._sentryFetchProxy && e) return (t.fetch = t._sentryFetchProxy), e;
}
function Lf(t) {
  const e = T;
  (e._sentryFetchProxy = e.fetch), (e.fetch = t);
}
function Cf({ error: t }) {
  zt(() => {
    console.error(t);
  });
}
function Of(t) {
  const e = Cf;
  return (n) => (
    Mf(n) ||
      rs(n.error, {
        mechanism: {
          type: "auto.function.sveltekit.handle_error",
          handled: !1,
        },
      }),
    e(n)
  );
}
function Mf(t) {
  const { status: e } = t;
  return e ? e >= 400 && e < 500 : !1;
}
Pf({
  dsn: "",
  tracesSampleRate: 1,
  enableLogs: !0,
  environment: "prod",
  replaysOnErrorSampleRate: 1,
});
const Df = Of(),
  Qf = {};
var xf = is(
    '<div id="svelte-announcer" aria-live="assertive" aria-atomic="true" style="position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px"><!></div>'
  ),
  Ff = is("<!> <!>", 1);
function Hf(t, e) {
  Ka(e, !0);
  let n = Qe(e, "components", 23, () => []),
    r = Qe(e, "data_0", 3, null),
    s = Qe(e, "data_1", 3, null),
    a = Qe(e, "data_2", 3, null),
    o = Qe(e, "data_3", 3, null);
  Za(() => e.stores.page.set(e.page)),
    Qa(() => {
      e.stores,
        e.page,
        e.constructors,
        n(),
        e.form,
        r(),
        s(),
        a(),
        o(),
        e.stores.page.notify();
    });
  let c = tn(!1),
    i = tn(!1),
    u = tn(null);
  lo(() => {
    const R = e.stores.page.subscribe(() => {
      z(c) &&
        (Pt(i, !0),
        eo().then(() => {
          Pt(u, document.title || "untitled page", !0);
        }));
    });
    return Pt(c, !0), R;
  });
  const f = Ae(() => e.constructors[3]);
  var d = Ff(),
    l = le(d);
  {
    var p = (R) => {
        const N = Ae(() => e.constructors[0]);
        var B = Ee(),
          me = le(B);
        Pe(
          me,
          () => z(N),
          (ae, oe) => {
            ke(
              oe(ae, {
                get data() {
                  return r();
                },
                get form() {
                  return e.form;
                },
                get params() {
                  return e.page.params;
                },
                children: (y, M) => {
                  var ge = Ee(),
                    xe = le(ge);
                  {
                    var ie = (P) => {
                        const $ = Ae(() => e.constructors[1]);
                        var W = Ee(),
                          U = le(W);
                        Pe(
                          U,
                          () => z($),
                          (Z, v) => {
                            ke(
                              v(Z, {
                                get data() {
                                  return s();
                                },
                                get form() {
                                  return e.form;
                                },
                                get params() {
                                  return e.page.params;
                                },
                                children: (I, b) => {
                                  var D = Ee(),
                                    F = le(D);
                                  {
                                    var G = (H) => {
                                        const Fe = Ae(() => e.constructors[2]);
                                        var ce = Ee(),
                                          He = le(ce);
                                        Pe(
                                          He,
                                          () => z(Fe),
                                          (Ke, Kt) => {
                                            ke(
                                              Kt(Ke, {
                                                get data() {
                                                  return a();
                                                },
                                                get form() {
                                                  return e.form;
                                                },
                                                get params() {
                                                  return e.page.params;
                                                },
                                                children: (ue, $f) => {
                                                  var Xn = Ee(),
                                                    fa = le(Xn);
                                                  Pe(
                                                    fa,
                                                    () => z(f),
                                                    (la, pa) => {
                                                      ke(
                                                        pa(la, {
                                                          get data() {
                                                            return o();
                                                          },
                                                          get form() {
                                                            return e.form;
                                                          },
                                                          get params() {
                                                            return e.page
                                                              .params;
                                                          },
                                                        }),
                                                        (St) => (n()[3] = St),
                                                        () => {
                                                          var St;
                                                          return (St = n()) ==
                                                            null
                                                            ? void 0
                                                            : St[3];
                                                        }
                                                      );
                                                    }
                                                  ),
                                                    Q(ue, Xn);
                                                },
                                                $$slots: { default: !0 },
                                              }),
                                              (ue) => (n()[2] = ue),
                                              () => {
                                                var ue;
                                                return (ue = n()) == null
                                                  ? void 0
                                                  : ue[2];
                                              }
                                            );
                                          }
                                        ),
                                          Q(H, ce);
                                      },
                                      he = (H) => {
                                        const Fe = Ae(() => e.constructors[2]);
                                        var ce = Ee(),
                                          He = le(ce);
                                        Pe(
                                          He,
                                          () => z(Fe),
                                          (Ke, Kt) => {
                                            ke(
                                              Kt(Ke, {
                                                get data() {
                                                  return a();
                                                },
                                                get form() {
                                                  return e.form;
                                                },
                                                get params() {
                                                  return e.page.params;
                                                },
                                              }),
                                              (ue) => (n()[2] = ue),
                                              () => {
                                                var ue;
                                                return (ue = n()) == null
                                                  ? void 0
                                                  : ue[2];
                                              }
                                            );
                                          }
                                        ),
                                          Q(H, ce);
                                      };
                                    Ze(F, (H) => {
                                      e.constructors[3] ? H(G) : H(he, !1);
                                    });
                                  }
                                  Q(I, D);
                                },
                                $$slots: { default: !0 },
                              }),
                              (I) => (n()[1] = I),
                              () => {
                                var I;
                                return (I = n()) == null ? void 0 : I[1];
                              }
                            );
                          }
                        ),
                          Q(P, W);
                      },
                      _e = (P) => {
                        const $ = Ae(() => e.constructors[1]);
                        var W = Ee(),
                          U = le(W);
                        Pe(
                          U,
                          () => z($),
                          (Z, v) => {
                            ke(
                              v(Z, {
                                get data() {
                                  return s();
                                },
                                get form() {
                                  return e.form;
                                },
                                get params() {
                                  return e.page.params;
                                },
                              }),
                              (I) => (n()[1] = I),
                              () => {
                                var I;
                                return (I = n()) == null ? void 0 : I[1];
                              }
                            );
                          }
                        ),
                          Q(P, W);
                      };
                    Ze(xe, (P) => {
                      e.constructors[2] ? P(ie) : P(_e, !1);
                    });
                  }
                  Q(y, ge);
                },
                $$slots: { default: !0 },
              }),
              (y) => (n()[0] = y),
              () => {
                var y;
                return (y = n()) == null ? void 0 : y[0];
              }
            );
          }
        ),
          Q(R, B);
      },
      m = (R) => {
        const N = Ae(() => e.constructors[0]);
        var B = Ee(),
          me = le(B);
        Pe(
          me,
          () => z(N),
          (ae, oe) => {
            ke(
              oe(ae, {
                get data() {
                  return r();
                },
                get form() {
                  return e.form;
                },
                get params() {
                  return e.page.params;
                },
              }),
              (y) => (n()[0] = y),
              () => {
                var y;
                return (y = n()) == null ? void 0 : y[0];
              }
            );
          }
        ),
          Q(R, B);
      };
    Ze(l, (R) => {
      e.constructors[1] ? R(p) : R(m, !1);
    });
  }
  var E = to(l, 2);
  {
    var S = (R) => {
      var N = xf(),
        B = ro(N);
      {
        var me = (ae) => {
          var oe = ao();
          oo(() => fo(oe, z(u))), Q(ae, oe);
        };
        Ze(B, (ae) => {
          z(i) && ae(me);
        });
      }
      so(N), Q(R, N);
    };
    Ze(E, (R) => {
      z(c) && R(S);
    });
  }
  Q(t, d), no();
}
const el = po(Hf),
  tl = [
    () =>
      w(
        () => import("../nodes/0.pLr2ZkeK.js"),
        __vite__mapDeps([
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/1.DQH1g9br.js"),
        __vite__mapDeps([19, 1, 17, 3, 4, 20, 21, 22, 2, 5, 23]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/2.pstZBWzB.js"),
        __vite__mapDeps([
          24, 1, 3, 4, 2, 25, 12, 26, 13, 27, 21, 22, 5, 23, 28, 11, 15, 29,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/3.DsVmlgHZ.js"),
        __vite__mapDeps([
          30, 1, 3, 4, 2, 25, 12, 26, 13, 27, 21, 22, 5, 23, 29,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/4.C7N6qwFu.js"),
        __vite__mapDeps([
          31, 1, 2, 3, 4, 11, 26, 13, 27, 12, 23, 22, 5, 21, 6, 7, 8, 9, 10, 32,
          15, 33, 14, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 29, 44, 25, 45,
          46, 47, 48, 17, 20, 28, 16, 49, 50, 51, 52, 53, 54, 55, 56, 57,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/5.CvWw6Hog.js"),
        __vite__mapDeps([58, 1, 17, 3, 28, 11, 13, 15]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/6.DYe1Nhol.js"),
        __vite__mapDeps([59, 1, 17, 3, 2, 4, 26, 20, 8, 23, 22, 5]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/7.vXfYB5CG.js"),
        __vite__mapDeps([
          60, 1, 3, 4, 11, 25, 12, 26, 13, 27, 35, 23, 2, 22, 5, 21, 7, 6, 8, 9,
          34, 15, 39, 33, 37, 54, 56, 36, 52, 44, 41, 61, 62, 63, 64, 43, 29,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/8.D41too8x.js"),
        __vite__mapDeps([65, 1, 2, 3, 4, 11, 12, 7, 6, 8, 9]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/9.gHzqB_fO.js"),
        __vite__mapDeps([
          66, 1, 2, 3, 4, 11, 12, 26, 13, 35, 23, 22, 5, 7, 6, 8, 9, 34, 15, 54,
          67, 61, 62, 68, 69, 42,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/10.qYJ5TBMT.js"),
        __vite__mapDeps([
          70, 1, 2, 3, 4, 11, 12, 26, 13, 35, 23, 22, 5, 7, 6, 8, 9, 39, 33, 54,
          15, 61, 62, 68, 71, 69,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/11.s_c5d7Pu.js"),
        __vite__mapDeps([72, 1, 17, 3, 26, 8, 22, 2, 4, 5]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/12.DaqvA-lP.js"),
        __vite__mapDeps([
          73, 1, 2, 3, 4, 11, 12, 26, 13, 35, 23, 22, 5, 7, 6, 8, 9, 39, 33, 54,
          15, 62, 68, 71, 69, 74, 63,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/13.D1SKYXg_.js"),
        __vite__mapDeps([
          75, 1, 2, 3, 4, 11, 12, 26, 13, 35, 23, 22, 5, 7, 6, 8, 9, 39, 33, 54,
          15, 62, 68, 71, 69, 74,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/14.CItkIPxr.js"),
        __vite__mapDeps([
          76, 1, 3, 4, 11, 25, 12, 26, 13, 35, 23, 2, 22, 5, 21, 7, 6, 8, 9, 38,
          27, 14, 15, 34, 39, 33, 40, 36, 41, 42, 43, 29, 48, 37, 77, 54, 56,
          78, 62, 68, 71, 79, 64,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/15.DFAdMRVC.js"),
        __vite__mapDeps([
          80, 1, 2, 3, 4, 11, 25, 12, 26, 13, 35, 21, 22, 5, 23, 7, 6, 8, 9, 39,
          33, 48, 15, 37, 77, 54, 78, 79, 81, 43,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/16.Bq0OAVIQ.js"),
        __vite__mapDeps([
          82, 1, 2, 3, 4, 11, 26, 23, 22, 5, 21, 7, 6, 8, 9, 49, 13, 15, 28, 50,
          83,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/17.DIqvAhdu.js"),
        __vite__mapDeps([
          84, 1, 2, 3, 4, 11, 25, 12, 26, 13, 27, 14, 23, 22, 5, 21, 7, 6, 8, 9,
          32, 39, 33, 45, 15, 48, 40, 37, 77, 54, 56, 67, 81, 43,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/18.Bgc5wtfX.js"),
        __vite__mapDeps([
          85, 1, 17, 3, 4, 26, 20, 28, 11, 13, 15, 54, 55, 8, 56,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/19.ofgcIKR2.js"),
        __vite__mapDeps([
          86, 1, 2, 3, 4, 11, 33, 26, 21, 22, 5, 23, 7, 6, 8, 9, 28, 13, 15, 53,
          83,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/20.DlIAN3i2.js"),
        __vite__mapDeps([
          87, 1, 3, 4, 11, 12, 13, 35, 14, 23, 2, 22, 5, 6, 7, 8, 9, 46, 15, 21,
          45, 39, 33, 47, 36, 52, 78, 43,
        ]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/21.DvhKcBis.js"),
        __vite__mapDeps([88, 1, 3, 4, 11, 12, 26, 13, 28, 15]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/22.BykEdy1m.js"),
        __vite__mapDeps([89, 1, 17, 3, 26, 28, 11, 13, 15, 90]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/23.BjtvDQqY.js"),
        __vite__mapDeps([91, 1, 17, 3, 26, 28, 11, 13, 15]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/24.HgwoLwLZ.js"),
        __vite__mapDeps([92, 1, 17, 3, 26, 28, 11, 13, 15]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/25.CcvpK7hL.js"),
        __vite__mapDeps([93, 1, 17, 3, 26, 28, 11, 13, 15]),
        import.meta.url
      ),
    () =>
      w(
        () => import("../nodes/26.Pg0i9C45.js"),
        __vite__mapDeps([
          94, 1, 2, 3, 4, 11, 33, 26, 23, 22, 5, 49, 13, 15, 6, 8, 28, 50, 83,
        ]),
        import.meta.url
      ),
  ],
  nl = [],
  rl = {
    "/": [4],
    "/404": [5],
    "/admin": [6, [2]],
    "/admin/alliances": [7, [2]],
    "/admin/ban-waves": [8, [2]],
    "/admin/dashboard": [9, [2]],
    "/admin/logs": [10, [2]],
    "/admin/mods": [11, [2, 3]],
    "/admin/mods/leaderboard-reports": [13, [2, 3]],
    "/admin/mods/leaderboard": [12, [2, 3]],
    "/admin/users": [14, [2]],
    "/appeal": [15],
    "/join": [16],
    "/moderation": [17],
    "/offline": [18],
    "/payment/success": [19],
    "/profile-picture": [20],
    "/terms/code-of-conduct": [21],
    "/terms/privacy": [22],
    "/terms/return": [23],
    "/terms/return/pt": [24],
    "/terms/terms-of-service": [25],
    "/twitch-migration": [26],
  },
  da = {
    handleError:
      Df ||
      (({ error: t }) => {
        console.error(t);
      }),
    init: void 0,
    reroute: () => {},
    transport: {},
  },
  Bf = Object.fromEntries(
    Object.entries(da.transport).map(([t, e]) => [t, e.decode])
  ),
  sl = Object.fromEntries(
    Object.entries(da.transport).map(([t, e]) => [t, e.encode])
  ),
  al = !1,
  ol = (t, e) => Bf[t](e);
export {
  ol as decode,
  Bf as decoders,
  rl as dictionary,
  sl as encoders,
  al as hash,
  da as hooks,
  Qf as matchers,
  tl as nodes,
  el as root,
  nl as server_loads,
};
